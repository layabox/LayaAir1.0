
(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var BaseTexture=laya.webgl.resource.BaseTexture,Browser=laya.utils.Browser,Buffer=laya.webgl.utils.Buffer;
	var BufferStateBase=laya.webgl.BufferStateBase,Byte=laya.utils.Byte,ClassUtils=laya.utils.ClassUtils,CommandEncoder=laya.layagl.CommandEncoder;
	var Component=laya.components.Component,Config=Laya.Config,Context=laya.resource.Context,Event=laya.events.Event;
	var EventDispatcher=laya.events.EventDispatcher,Handler=laya.utils.Handler,InlcudeFile=laya.webgl.utils.InlcudeFile;
	var LayaGL=laya.layagl.LayaGL,LayaGLRunner=laya.layagl.LayaGLRunner,Loader=laya.net.Loader,LoaderManager=laya.net.LoaderManager;
	var MathUtil=laya.maths.MathUtil,Node=laya.display.Node,Point=laya.maths.Point,Render=laya.renders.Render;
	var RenderTexture2D=laya.webgl.resource.RenderTexture2D,Resource=laya.resource.Resource,RunDriver=laya.utils.RunDriver;
	var Shader=laya.webgl.shader.Shader,ShaderCompile=laya.webgl.utils.ShaderCompile,ShaderNode=laya.webgl.utils.ShaderNode;
	var Sprite=laya.display.Sprite,SpriteConst=laya.display.SpriteConst,Stat=laya.utils.Stat,Submit=laya.webgl.submit.Submit;
	var SubmitKey=laya.webgl.submit.SubmitKey,Texture2D=laya.webgl.resource.Texture2D,Timer=laya.utils.Timer;
	var URL=laya.net.URL,WebGL=laya.webgl.WebGL,WebGLContext=laya.webgl.WebGLContext,WebGLContext2D=laya.webgl.canvas.WebGLContext2D;
Laya.interface('laya.d3.core.IClone');
Laya.interface('laya.d3.graphics.IVertex');
/**
*@private
*<code>RenderQuene</code> 类用于实现渲染队列。
*/
//class laya.d3.core.render.RenderQueue
var RenderQueue=(function(){
	function RenderQueue(isTransparent){
		/**@private [只读]*/
		//this.isTransparent=false;
		/**@private */
		//this.elements=null;
		/**@private */
		//this.lastTransparentRenderElement=null;
		/**@private */
		//this.lastTransparentBatched=false;
		(isTransparent===void 0)&& (isTransparent=false);
		this.isTransparent=isTransparent;
		this.elements=[];
	}

	__class(RenderQueue,'laya.d3.core.render.RenderQueue');
	var __proto=RenderQueue.prototype;
	/**
	*@private
	*/
	__proto._compare=function(left,right){
		var renderQueue=left.material.renderQueue-right.material.renderQueue;
		if (renderQueue===0){
			var sort=this.isTransparent ? right.render._distanceForSort-left.render._distanceForSort :left.render._distanceForSort-right.render._distanceForSort;
			return sort+left.render.sortingFudge-right.render.sortingFudge;
			}else {
			return renderQueue;
		}
	}

	/**
	*@private
	*/
	__proto._partitionRenderObject=function(left,right){
		var pivot=this.elements[Math.floor((right+left)/ 2)];
		while (left <=right){
			while (this._compare(this.elements[left],pivot)< 0)
			left++;
			while (this._compare(this.elements[right],pivot)> 0)
			right--;
			if (left < right){
				var temp=this.elements[left];
				this.elements[left]=this.elements[right];
				this.elements[right]=temp;
				left++;
				right--;
				}else if (left===right){
				left++;
				break ;
			}
		}
		return left;
	}

	/**
	*@private
	*/
	__proto._quickSort=function(left,right){
		if (this.elements.length > 1){
			var index=this._partitionRenderObject(left,right);
			var leftIndex=index-1;
			if (left < leftIndex)
				this._quickSort(left,leftIndex);
			if (index < right)
				this._quickSort(index,right);
		}
	}

	/**
	*@private
	*渲染队列。
	*@param state 渲染状态。
	*/
	__proto._render=function(context,isTarget,customShader,replacementTag){
		var lastStateRenderState,lastStateRender;
		var loopCount=Stat.loopCount;
		var scene=context.scene;
		var camera=context.camera;
		for (var i=0,n=this.elements.length;i < n;i++){
			var element=this.elements[i];
			var transform=element._transform;
			var render=element.render;
			var geometry=element._geometry;
			var material=element.material;
			context.renderElement=element;
			if (loopCount!==render._updateLoopCount){
				render._renderUpdate(context,transform);
				render._renderUpdateWithCamera(context,transform);
				render._updateLoopCount=loopCount;
				render._updateCamera=camera;
				}else if (camera!==render._updateCamera){
				render._renderUpdateWithCamera(context,transform);
				render._updateCamera=camera;
			}
			if (geometry._prepareRender(context)){
				var subShader=material._shader.getSubShaderAt(0);
				var renderStates=material._renderStates;
				var passes;
				if (customShader){
					if (replacementTag){
						var oriTag=subShader.getFlag(replacementTag);
						if (oriTag){
							var customSubShaders=customShader._subShaders;
							for (var k=0,p=customSubShaders.length;k < p;k++){
								var customSubShader=customSubShaders[k];
								if (oriTag===customSubShader.getFlag(replacementTag)){
									passes=customSubShader._passes;
									break ;
								}
							}
							if (!passes)
								continue ;
							}else {
							continue ;
						}
						}else {
						passes=customShader.getSubShaderAt(0)._passes;
					}
					}else {
					passes=subShader._passes;
				}
				for (var j=0,m=passes.length;j < m;j++){
					var shaderPass=context.shader=passes[j].withCompile((scene._defineDatas.value)& (~material._disablePublicDefineDatas.value),render._defineDatas.value,material._defineDatas.value);
					var switchShader=shaderPass.bind();
					var switchShaderLoop=(loopCount!==shaderPass._uploadLoopCount);
					var uploadScene=(shaderPass._uploadScene!==scene)|| switchShaderLoop;
					if (uploadScene || switchShader){
						shaderPass.uploadUniforms(shaderPass._sceneUniformParamsMap,scene._shaderValues,uploadScene);
						shaderPass._uploadScene=scene;
					};
					var switchCamera=shaderPass._uploadCamera!==camera;
					var uploadSprite3D=(switchCamera || shaderPass._uploadRender!==render)|| switchShaderLoop;
					if (uploadSprite3D || switchShader){
						shaderPass.uploadUniforms(shaderPass._spriteUniformParamsMap,render._shaderValues,uploadSprite3D);
						shaderPass._uploadRender=render;
					};
					var uploadCamera=switchCamera || switchShaderLoop;
					if (uploadCamera || switchShader){
						shaderPass.uploadUniforms(shaderPass._cameraUniformParamsMap,camera._shaderValues,uploadCamera);
						shaderPass._uploadCamera=camera;
					};
					var uploadMaterial=(shaderPass._uploadMaterial!==material)|| switchShaderLoop;
					if (uploadMaterial || switchShader){
						shaderPass.uploadUniforms(shaderPass._materialUniformParamsMap,material._shaderValues,uploadMaterial);
						shaderPass._uploadMaterial=material;
					};
					var renderState=renderStates[j];
					if (lastStateRenderState!==renderState){
						renderState._setRenderStateBlendDepth();
						renderState._setRenderStateFrontFace(isTarget,transform);
						lastStateRenderState=renderState;
						lastStateRender=render;
						}else {
						if (lastStateRender!==render){
							renderState._setRenderStateFrontFace(isTarget,transform);
							lastStateRender=render;
						}
					}
					if (customShader)
						WebGLContext.setBlend(LayaGL.instance,false);
					geometry._render(context);
					shaderPass._uploadLoopCount=loopCount;
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto.clear=function(){
		this.elements.length=0;
		this.lastTransparentRenderElement=null;
		this.lastTransparentBatched=false;
	}

	return RenderQueue;
})()


/**
*@private
*<code>VertexDeclaration</code> 类用于生成顶点声明。
*/
//class laya.d3.graphics.VertexDeclaration
var VertexDeclaration=(function(){
	function VertexDeclaration(vertexStride,vertexElements){
		/**@private */
		this._id=0;
		/**@private */
		this._vertexStride=0;
		/**@private */
		this._vertexElementsDic=null;
		/**@private */
		this._shaderValues=null;
		/**@private */
		this._defineDatas=null;
		/**@private [只读]*/
		this.vertexElements=null;
		this._id=++VertexDeclaration._uniqueIDCounter;
		this._defineDatas=new DefineDatas();
		this._vertexElementsDic={};
		this._vertexStride=vertexStride;
		this.vertexElements=vertexElements;
		var count=vertexElements.length;
		this._shaderValues=new ShaderData(null);
		for (var j=0;j < count;j++){
			var vertexElement=vertexElements[j];
			var name=vertexElement.elementUsage;
			this._vertexElementsDic[name]=vertexElement;
			var value=new Int32Array(5);
			var elmentInfo=VertexElementFormat.getElementInfos(vertexElement.elementFormat);
			value[0]=elmentInfo[0];
			value[1]=elmentInfo[1];
			value[2]=elmentInfo[2];
			value[3]=this._vertexStride;
			value[4]=vertexElement.offset;
			this._shaderValues.setAttribute(name,value);
		}
	}

	__class(VertexDeclaration,'laya.d3.graphics.VertexDeclaration');
	var __proto=VertexDeclaration.prototype;
	/**
	*@private
	*/
	__proto.getVertexElementByUsage=function(usage){
		return this._vertexElementsDic[usage];
	}

	/**
	*@private
	*/
	__proto.unBinding=function(){}
	/**
	*获取唯一标识ID(通常用于优化或识别)。
	*@return 唯一标识ID
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	/**
	*@private
	*/
	__getset(0,__proto,'vertexStride',function(){
		return this._vertexStride;
	});

	VertexDeclaration._uniqueIDCounter=1;
	return VertexDeclaration;
})()


/**
*@private
*<code>RenderElement</code> 类用于实现渲染元素。
*/
//class laya.d3.core.render.RenderElement
var RenderElement=(function(){
	function RenderElement(){
		/**@private */
		//this._transform=null;
		/**@private */
		//this._geometry=null;
		/**@private */
		//this.material=null;
		/**@private */
		//this.render=null;
		/**@private */
		//this.staticBatch=null;
	}

	__class(RenderElement,'laya.d3.core.render.RenderElement');
	var __proto=RenderElement.prototype;
	/**
	*@private
	*/
	__proto.setTransform=function(transform){
		this._transform=transform;
	}

	/**
	*@private
	*/
	__proto.setGeometry=function(geometry){
		this._geometry=geometry;
	}

	/**
	*@private
	*/
	__proto.addToOpaqueRenderQueue=function(context,queue){
		queue.elements.push(this);
	}

	/**
	*@private
	*/
	__proto.addToTransparentRenderQueue=function(context,queue){
		queue.elements.push(this);
		queue.lastTransparentBatched=false;
		queue.lastTransparentRenderElement=this;
	}

	/**
	*@private
	*/
	__proto.destroy=function(){
		this._transform=null;
		this._geometry=null;
		this.material=null;
		this.render=null;
	}

	return RenderElement;
})()


/**
*类用于八叉树节点。
*/
//class laya.d3.core.scene.OctreeNode
var OctreeNode=(function(){
	function OctreeNode(scene,depth){
		/**@private */
		this._exactBox=null;
		/**@private */
		this._relaxBox=null;
		/**@private */
		this._scene=null;
		/**@private */
		this._parent=null;
		/**@private */
		this._depth=0;
		this._boundingSphere=new BoundSphere(new Vector3(),0);
		this._corners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];
		this._boundingBoxCenter=new Vector3();
		this._children=__newvec(8);
		this._objects=[];
		this._scene=scene;
		this._depth=depth;
	}

	__class(OctreeNode,'laya.d3.core.scene.OctreeNode');
	var __proto=OctreeNode.prototype;
	/**
	*@private
	*/
	__proto.initRoot=function(center,treeSize){
		var min=new Vector3();
		var max=new Vector3();
		Vector3.scale(treeSize,-0.5,min);
		Vector3.scale(treeSize,0.5,max);
		Vector3.add(min,center,min);
		Vector3.add(max,center,max);
		this.exactBox=new BoundBox(min,max);
		this.relaxBox=new BoundBox(min,max);
	}

	/**
	*@private
	*/
	__proto.addTreeNode=function(render){
		if (CollisionUtils.boxContainsBox(this._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1)
			this.addNodeDown(render,0);
		else
		this.addObject(render);
	}

	/**
	*@private
	*/
	__proto.addChild=function(index){
		var child=this._children[index];
		if (child==null){
			child=new OctreeNode(this._scene,this._depth+1);
			this._children[index]=child;
			child._parent=this;
			Vector3.subtract(this._exactBox.max,this._exactBox.min,OctreeNode._tempSize);
			Vector3.multiply(OctreeNode._tempSize,OctreeNode._octreeSplit[index],OctreeNode._tempCenter);
			Vector3.add(this._exactBox.min,OctreeNode._tempCenter,OctreeNode._tempCenter);
			Vector3.scale(OctreeNode._tempSize,0.25,OctreeNode._tempSize);
			var min=new Vector3();
			var max=new Vector3();
			Vector3.subtract(OctreeNode._tempCenter,OctreeNode._tempSize,min);
			Vector3.add(OctreeNode._tempCenter,OctreeNode._tempSize,max);
			child.exactBox=new BoundBox(min,max);
			Vector3.scale(OctreeNode._tempSize,OctreeNode.relax,OctreeNode._tempSize);
			var relaxMin=new Vector3();
			var relaxMax=new Vector3();
			Vector3.subtract(OctreeNode._tempCenter,OctreeNode._tempSize,relaxMin);
			Vector3.add(OctreeNode._tempCenter,OctreeNode._tempSize,relaxMax);
			child.relaxBox=new BoundBox(relaxMin,relaxMax);
		}
		return child;
	}

	/**
	*@private
	*/
	__proto.addObject=function(object){
		object._treeNode=this;
		this._objects.push(object);
	}

	/**
	*@private
	*/
	__proto.removeObject=function(object){
		if (object._treeNode !=this){
			console.log("OctreeNode::removeObject error");
			return false;
		};
		var index=this._objects.indexOf(object);
		if (index!==-1){
			this._objects.splice(index,1);
			return true;
		}
		return false;
	}

	/**
	*@private
	*/
	__proto.clearObject=function(){
		this._objects.length=0;
	}

	/**
	*@private
	*/
	__proto.addNodeUp=function(render,depth){
		if (this._parent && (CollisionUtils.boxContainsBox(this._exactBox,render.boundingBox)!==/*laya.d3.math.ContainmentType.Contains*/1)){
			this._parent.addNodeUp(render,depth-1);
		}else
		this.addNodeDown(render,depth);
	}

	/**
	*@private
	*/
	__proto.addNodeDown=function(render,depth){
		if (depth < this._scene.treeLevel){
			var childIndex=this.inChildIndex(render.boundingBoxCenter);
			var child=this.addChild(childIndex);
			if (CollisionUtils.boxContainsBox(child._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1){
				child.addNodeDown(render,++depth);
			}else
			this.addObject(render);
			}else {
			this.addObject(render);
		}
	}

	/**
	*@private
	*/
	__proto.inChildIndex=function(objectCenter){
		var z=objectCenter.z < this._boundingBoxCenter.z ? 0 :1;
		var y=objectCenter.y < this._boundingBoxCenter.y ? 0 :1;
		var x=objectCenter.x < this._boundingBoxCenter.x ? 0 :1;
		return z *4+y *2+x;
	}

	/**
	*@private
	*/
	__proto.updateObject=function(render){
		if (CollisionUtils.boxContainsBox(this._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1){
			this.removeObject(render);
			render._treeNode=null;
			this.addNodeDown(render,this._depth);
			}else if (this._parent){
			this.removeObject(render);
			render._treeNode=null;
			this._parent.addNodeUp(render,this._depth-1);
		}
	}

	/**
	*@private
	*/
	__proto.cullingObjects=function(context,boundFrustum,camera,cameraPos,testVisible){
		var i=0,j=0,n=0,m=0;
		for (i=0,n=this._objects.length;i < n;i++){
			var render=this._objects[i];
			if (this._scene.isLayerVisible(render._owner.layer,camera)&& render._enable){
				if (testVisible){
					if (boundFrustum.containsBoundBox(render.boundingBox)===/*laya.d3.math.ContainmentType.Disjoint*/0)
						continue ;
				}
				render._distanceForSort=Vector3.distance(render.boundingSphere.center,cameraPos);
				var elements=render._renderElements;
				for (j=0,m=elements.length;j < m;j++){
					var element=elements[j];
					var renderQueue=this._scene._getRenderQueue(element.material.renderQueue);
					if (renderQueue.isTransparent)
						element.addToTransparentRenderQueue(context,renderQueue);
					else
					element.addToOpaqueRenderQueue(context,renderQueue);
				}
			}
		}
		for (i=0;i < 8;i++){
			var child=this._children[i];
			var testVisibleChild=testVisible;
			if (testVisible){
				var type=boundFrustum.containsBoundBox(child._relaxBox);
				if (type===/*laya.d3.math.ContainmentType.Disjoint*/0)
					continue ;
				testVisibleChild=(type===/*laya.d3.math.ContainmentType.Intersects*/2);
			}
			child.cullingObjects(context,boundFrustum,camera,cameraPos,testVisibleChild);
		}
	}

	/**
	*@private
	*/
	__proto.buildAllChild=function(depth){
		if (depth < this._scene.treeLevel){
			for (var i=0;i < 8;i++){
				var child=this.addChild(i);
				child.buildAllChild(depth+1);
			}
		}
	}

	/**
	*@private
	*/
	__proto._renderBoudingBox=function(line){}
	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'exactBox',function(){
		return this._exactBox;
		},function(value){
		this._exactBox=value;
		Vector3.add(value.min,value.max,this._boundingBoxCenter);
		Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'relaxBox',function(){
		return this._relaxBox;
		},function(value){
		this._relaxBox=value;
		value.getCorners(this._corners);
		BoundSphere.createfromPoints(this._corners,this._boundingSphere);
	});

	OctreeNode.CHILDNUM=8;
	OctreeNode.debugMode=false;
	OctreeNode.relax=1.15;
	__static(OctreeNode,
	['_tempVector0',function(){return this._tempVector0=new Vector3();},'_tempSize',function(){return this._tempSize=new Vector3();},'_tempCenter',function(){return this._tempCenter=new Vector3();},'_octreeSplit',function(){return this._octreeSplit=[new Vector3(0.250,0.250,0.250),new Vector3(0.750,0.250,0.250),new Vector3(0.250,0.750,0.250),new Vector3(0.750,0.750,0.250),new Vector3(0.250,0.250,0.750),new Vector3(0.750,0.250,0.750),new Vector3(0.250,0.750,0.750),new Vector3(0.750,0.750,0.750)];}
	]);
	return OctreeNode;
})()


/**
*<code>BoundSphere</code> 类用于创建包围球。
*/
//class laya.d3.math.BoundSphere
var BoundSphere=(function(){
	function BoundSphere(center,radius){
		/**包围球的中心。*/
		this.center=null;
		/**包围球的半径。*/
		this.radius=NaN;
		this.center=center;
		this.radius=radius;
	}

	__class(BoundSphere,'laya.d3.math.BoundSphere');
	var __proto=BoundSphere.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	__proto.toDefault=function(){
		this.center.toDefault();
		this.radius=0;
	}

	/**
	*判断射线是否与碰撞球交叉，并返回交叉距离。
	*@param ray 射线。
	*@return 距离交叉点的距离，-1表示不交叉。
	*/
	__proto.intersectsRayDistance=function(ray){
		return CollisionUtils.intersectsRayAndSphereRD(ray,this);
	}

	/**
	*判断射线是否与碰撞球交叉，并返回交叉点。
	*@param ray 射线。
	*@param outPoint 交叉点。
	*@return 距离交叉点的距离，-1表示不交叉。
	*/
	__proto.intersectsRayPoint=function(ray,outPoint){
		return CollisionUtils.intersectsRayAndSphereRP(ray,this,outPoint);
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		this.center.cloneTo(dest.center);
		dest.radius=this.radius;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor(new Vector3(),new Vector3());
		this.cloneTo(dest);
		return dest;
	}

	BoundSphere.createFromSubPoints=function(points,start,count,out){
		if (points==null){
			throw new Error("points");
		}
		if (start < 0 || start >=points.length){
			throw new Error("start"+start+"Must be in the range [0, "+(points.length-1)+"]");
		}
		if (count < 0 || (start+count)> points.length){
			throw new Error("count"+count+"Must be in the range <= "+points.length+"}");
		};
		var upperEnd=start+count;
		var center=BoundSphere._tempVector3;
		center.elements[0]=0;
		center.elements[1]=0;
		center.elements[2]=0;
		for (var i=start;i < upperEnd;++i){
			Vector3.add(points[i],center,center);
		};
		var outCenter=out.center;
		Vector3.scale(center,1 / count,outCenter);
		var radius=0.0;
		for (i=start;i < upperEnd;++i){
			var distance=Vector3.distanceSquared(outCenter,points[i]);
			if (distance > radius)
				radius=distance;
		}
		out.radius=Math.sqrt(radius);
	}

	BoundSphere.createfromPoints=function(points,out){
		if (points==null){
			throw new Error("points");
		}
		BoundSphere.createFromSubPoints(points,0,points.length,out);
	}

	__static(BoundSphere,
	['_tempVector3',function(){return this._tempVector3=new Vector3();}
	]);
	return BoundSphere;
})()


/**
*...
*@author ...
*/
//class laya.d3.loaders.MeshReader
var MeshReader=(function(){
	function MeshReader(){}
	__class(MeshReader,'laya.d3.loaders.MeshReader');
	MeshReader.read=function(data,mesh,subMeshes){
		var readData=new Byte(data);
		readData.pos=0;
		var version=readData.readUTFString();
		switch (version){
			case "LAYAMODEL:0301":
			case "LAYAMODEL:0400":
			case "LAYAMODEL:0401":
				LoadModelV04.parse(readData,version,mesh,subMeshes);
				break ;
			case "LAYAMODEL:05":
			case "LAYAMODEL:COMPRESSION_05":
				LoadModelV05.parse(readData,version,mesh,subMeshes);
				break ;
			default :
				throw new Error("MeshReader: unknown mesh version.");
			}
		mesh._setSubMeshes(subMeshes);
	}

	return MeshReader;
})()


/**
*<code>AnimationEvent</code> 类用于实现动画事件。
*/
//class laya.d3.animation.AnimationEvent
var AnimationEvent=(function(){
	function AnimationEvent(){
		/**事件触发时间。*/
		this.time=NaN;
		/**事件触发名称。*/
		this.eventName=null;
		/**事件触发参数。*/
		this.params=null;
	}

	__class(AnimationEvent,'laya.d3.animation.AnimationEvent');
	return AnimationEvent;
})()


/**
*<code>BaseShape</code> 类用于粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.BaseShape
var BaseShape=(function(){
	function BaseShape(){
		/**是否启用。*/
		this.enable=false;
		/**随机方向。*/
		this.randomDirection=false;
	}

	__class(BaseShape,'laya.d3.core.particleShuriKen.module.shape.BaseShape');
	var __proto=BaseShape.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**@private */
	__proto._getShapeBoundBox=function(boundBox){
		throw new Error("BaseShape: must override it.");
	}

	/**@private */
	__proto._getSpeedBoundBox=function(boundBox){
		throw new Error("BaseShape: must override it.");
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		throw new Error("BaseShape: must override it.");
	}

	/**
	*@private
	*/
	__proto._calculateProceduralBounds=function(boundBox,emitterPosScale,minMaxBounds){
		this._getShapeBoundBox(boundBox);
		var min=boundBox.min;
		var max=boundBox.max;
		Vector3.multiply(min,emitterPosScale,min);
		Vector3.multiply(max,emitterPosScale,max);
		var speedBounds=new BoundBox(new Vector3(),new Vector3());
		if (this.randomDirection){
			speedBounds.min=new Vector3(-1,-1,-1);
			speedBounds.max=new Vector3(1,1,1);
		}
		else{
			this._getSpeedBoundBox(speedBounds);
		};
		var maxSpeedBound=new BoundBox(new Vector3(),new Vector3());
		var maxSpeedMin=maxSpeedBound.min;
		var maxSpeedMax=maxSpeedBound.max;
		Vector3.scale(speedBounds.min,minMaxBounds.y,maxSpeedMin);
		Vector3.scale(speedBounds.max,minMaxBounds.y,maxSpeedMax);
		Vector3.add(boundBox.min,maxSpeedMin,maxSpeedMin);
		Vector3.add(boundBox.max,maxSpeedMax,maxSpeedMax);
		Vector3.min(boundBox.min,maxSpeedMin,boundBox.min);
		Vector3.max(boundBox.max,maxSpeedMin,boundBox.max);
		var minSpeedBound=new BoundBox(new Vector3(),new Vector3());
		var minSpeedMin=minSpeedBound.min;
		var minSpeedMax=minSpeedBound.max;
		Vector3.scale(speedBounds.min,minMaxBounds.x,minSpeedMin);
		Vector3.scale(speedBounds.max,minMaxBounds.x,minSpeedMax);
		Vector3.min(minSpeedBound.min,minSpeedMax,maxSpeedMin);
		Vector3.max(minSpeedBound.min,minSpeedMax,maxSpeedMax);
		Vector3.min(boundBox.min,maxSpeedMin,boundBox.min);
		Vector3.max(boundBox.max,maxSpeedMin,boundBox.max);
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destShape=destObject;
		destShape.enable=this.enable;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destShape=/*__JS__ */new this.constructor();
		this.cloneTo(destShape);
		return destShape;
	}

	return BaseShape;
})()


/**
*@private
*/
//class laya.d3.core.particleShuriKen.ShurikenParticleData
var ShurikenParticleData=(function(){
	function ShurikenParticleData(){}
	__class(ShurikenParticleData,'laya.d3.core.particleShuriKen.ShurikenParticleData');
	ShurikenParticleData._getStartLifetimeFromGradient=function(startLifeTimeGradient,emissionTime){
		for (var i=1,n=startLifeTimeGradient.gradientCount;i < n;i++){
			var key=startLifeTimeGradient.getKeyByIndex(i);
			if (key >=emissionTime){
				var lastKey=startLifeTimeGradient.getKeyByIndex(i-1);
				var age=(emissionTime-lastKey)/ (key-lastKey);
				return MathUtil.lerp(startLifeTimeGradient.getValueByIndex(i-1),startLifeTimeGradient.getValueByIndex(i),age)
			}
		}
		throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
	}

	ShurikenParticleData._randomInvertRoationArray=function(rotatonE,outE,randomizeRotationDirection,rand,randomSeeds){
		var randDic=NaN;
		if (rand){
			rand.seed=randomSeeds[6];
			randDic=rand.getFloat();
			randomSeeds[6]=rand.seed;
			}else {
			randDic=Math.random();
		}
		if (randDic < randomizeRotationDirection){
			outE[0]=-rotatonE[0];
			outE[1]=-rotatonE[1];
			outE[2]=-rotatonE[2];
			}else {
			outE[0]=rotatonE[0];
			outE[1]=rotatonE[1];
			outE[2]=rotatonE[2];
		}
	}

	ShurikenParticleData._randomInvertRoation=function(rotaton,randomizeRotationDirection,rand,randomSeeds){
		var randDic=NaN;
		if (rand){
			rand.seed=randomSeeds[6];
			randDic=rand.getFloat();
			randomSeeds[6]=rand.seed;
			}else {
			randDic=Math.random();
		}
		if (randDic < randomizeRotationDirection)
			rotaton=-rotaton;
		return rotaton;
	}

	ShurikenParticleData.create=function(particleSystem,particleRender,transform){
		var autoRandomSeed=particleSystem.autoRandomSeed;
		var rand=particleSystem._rand;
		var randomSeeds=particleSystem._randomSeeds;
		switch (particleSystem.startColorType){
			case 0:;
				var constantStartColorE=particleSystem.startColorConstant.elements;
				ShurikenParticleData.startColor[0]=constantStartColorE[0];
				ShurikenParticleData.startColor[1]=constantStartColorE[1];
				ShurikenParticleData.startColor[2]=constantStartColorE[2];
				ShurikenParticleData.startColor[3]=constantStartColorE[3];
				break ;
			case 2:
				if (autoRandomSeed){
					MathUtil.lerpVector4(particleSystem.startColorConstantMin.elements,particleSystem.startColorConstantMax.elements,Math.random(),ShurikenParticleData.startColor);
					}else {
					rand.seed=randomSeeds[3];
					MathUtil.lerpVector4(particleSystem.startColorConstantMin.elements,particleSystem.startColorConstantMax.elements,rand.getFloat(),ShurikenParticleData.startColor);
					randomSeeds[3]=rand.seed;
				}
				break ;
			};
		var colorOverLifetime=particleSystem.colorOverLifetime;
		if (colorOverLifetime && colorOverLifetime.enbale){
			var color=colorOverLifetime.color;
			switch (color.type){
				case 0:
					ShurikenParticleData.startColor[0]=ShurikenParticleData.startColor[0] *color.constant.x;
					ShurikenParticleData.startColor[1]=ShurikenParticleData.startColor[1] *color.constant.y;
					ShurikenParticleData.startColor[2]=ShurikenParticleData.startColor[2] *color.constant.z;
					ShurikenParticleData.startColor[3]=ShurikenParticleData.startColor[3] *color.constant.w;
					break ;
				case 2:;
					var colorRandom=NaN;
					if (autoRandomSeed){
						colorRandom=Math.random();
						}else {
						rand.seed=randomSeeds[10];
						colorRandom=rand.getFloat();
						randomSeeds[10]=rand.seed;
					};
					var minConstantColor=color.constantMin;
					var maxConstantColor=color.constantMax;
					ShurikenParticleData.startColor[0]=ShurikenParticleData.startColor[0] *MathUtil.lerp(minConstantColor.x,maxConstantColor.x,colorRandom);
					ShurikenParticleData.startColor[1]=ShurikenParticleData.startColor[1] *MathUtil.lerp(minConstantColor.y,maxConstantColor.y,colorRandom);
					ShurikenParticleData.startColor[2]=ShurikenParticleData.startColor[2] *MathUtil.lerp(minConstantColor.z,maxConstantColor.z,colorRandom);
					ShurikenParticleData.startColor[3]=ShurikenParticleData.startColor[3] *MathUtil.lerp(minConstantColor.w,maxConstantColor.w,colorRandom);
					break ;
				}
		};
		var particleSize=ShurikenParticleData.startSize;
		switch (particleSystem.startSizeType){
			case 0:
				if (particleSystem.threeDStartSize){
					var startSizeConstantSeparate=particleSystem.startSizeConstantSeparate;
					particleSize[0]=startSizeConstantSeparate.x;
					particleSize[1]=startSizeConstantSeparate.y;
					particleSize[2]=startSizeConstantSeparate.z;
					}else {
					particleSize[0]=particleSize[1]=particleSize[2]=particleSystem.startSizeConstant;
				}
				break ;
			case 2:
				if (particleSystem.threeDStartSize){
					var startSizeConstantMinSeparate=particleSystem.startSizeConstantMinSeparate;
					var startSizeConstantMaxSeparate=particleSystem.startSizeConstantMaxSeparate;
					if (autoRandomSeed){
						particleSize[0]=MathUtil.lerp(startSizeConstantMinSeparate.x,startSizeConstantMaxSeparate.x,Math.random());
						particleSize[1]=MathUtil.lerp(startSizeConstantMinSeparate.y,startSizeConstantMaxSeparate.y,Math.random());
						particleSize[2]=MathUtil.lerp(startSizeConstantMinSeparate.z,startSizeConstantMaxSeparate.z,Math.random());
						}else {
						rand.seed=randomSeeds[4];
						particleSize[0]=MathUtil.lerp(startSizeConstantMinSeparate.x,startSizeConstantMaxSeparate.x,rand.getFloat());
						particleSize[1]=MathUtil.lerp(startSizeConstantMinSeparate.y,startSizeConstantMaxSeparate.y,rand.getFloat());
						particleSize[2]=MathUtil.lerp(startSizeConstantMinSeparate.z,startSizeConstantMaxSeparate.z,rand.getFloat());
						randomSeeds[4]=rand.seed;
					}
					}else {
					if (autoRandomSeed){
						particleSize[0]=particleSize[1]=particleSize[2]=MathUtil.lerp(particleSystem.startSizeConstantMin,particleSystem.startSizeConstantMax,Math.random());
						}else {
						rand.seed=randomSeeds[4];
						particleSize[0]=particleSize[1]=particleSize[2]=MathUtil.lerp(particleSystem.startSizeConstantMin,particleSystem.startSizeConstantMax,rand.getFloat());
						randomSeeds[4]=rand.seed;
					}
				}
				break ;
			};
		var sizeOverLifetime=particleSystem.sizeOverLifetime;
		if (sizeOverLifetime && sizeOverLifetime.enbale && sizeOverLifetime.size.type===1){
			var size=sizeOverLifetime.size;
			if (size.separateAxes){
				if (autoRandomSeed){
					particleSize[0]=particleSize[0] *MathUtil.lerp(size.constantMinSeparate.x,size.constantMaxSeparate.x,Math.random());
					particleSize[1]=particleSize[1] *MathUtil.lerp(size.constantMinSeparate.y,size.constantMaxSeparate.y,Math.random());
					particleSize[2]=particleSize[2] *MathUtil.lerp(size.constantMinSeparate.z,size.constantMaxSeparate.z,Math.random());
					}else {
					rand.seed=randomSeeds[11];
					particleSize[0]=particleSize[0] *MathUtil.lerp(size.constantMinSeparate.x,size.constantMaxSeparate.x,rand.getFloat());
					particleSize[1]=particleSize[1] *MathUtil.lerp(size.constantMinSeparate.y,size.constantMaxSeparate.y,rand.getFloat());
					particleSize[2]=particleSize[2] *MathUtil.lerp(size.constantMinSeparate.z,size.constantMaxSeparate.z,rand.getFloat());
					randomSeeds[11]=rand.seed;
				}
				}else {
				var randomSize=NaN;
				if (autoRandomSeed){
					randomSize=MathUtil.lerp(size.constantMin,size.constantMax,Math.random());
					}else {
					rand.seed=randomSeeds[11];
					randomSize=MathUtil.lerp(size.constantMin,size.constantMax,rand.getFloat());
					randomSeeds[11]=rand.seed;
				}
				particleSize[0]=particleSize[0] *randomSize;
				particleSize[1]=particleSize[1] *randomSize;
				particleSize[2]=particleSize[2] *randomSize;
			}
		};
		var renderMode=particleRender.renderMode;
		if (renderMode!==1){
			switch (particleSystem.startRotationType){
				case 0:
					if (particleSystem.threeDStartRotation){
						var startRotationConstantSeparate=particleSystem.startRotationConstantSeparate;
						var randomRotationE=ShurikenParticleData._tempVector30.elements;
						ShurikenParticleData._randomInvertRoationArray(startRotationConstantSeparate.elements,randomRotationE,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
						ShurikenParticleData.startRotation[0]=randomRotationE[0];
						ShurikenParticleData.startRotation[1]=randomRotationE[1];
						if (renderMode!==4)
							ShurikenParticleData.startRotation[2]=-randomRotationE[2];
						else
						ShurikenParticleData.startRotation[2]=randomRotationE[2];
						}else {
						ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(particleSystem.startRotationConstant,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
						ShurikenParticleData.startRotation[1]=0;
						ShurikenParticleData.startRotation[2]=0;
					}
					break ;
				case 2:
					if (particleSystem.threeDStartRotation){
						var startRotationConstantMinSeparate=particleSystem.startRotationConstantMinSeparate;
						var startRotationConstantMaxSeparate=particleSystem.startRotationConstantMaxSeparate;
						var lerpRoationE=ShurikenParticleData._tempVector30.elements;
						if (autoRandomSeed){
							lerpRoationE[0]=MathUtil.lerp(startRotationConstantMinSeparate.x,startRotationConstantMaxSeparate.x,Math.random());
							lerpRoationE[1]=MathUtil.lerp(startRotationConstantMinSeparate.y,startRotationConstantMaxSeparate.y,Math.random());
							lerpRoationE[2]=MathUtil.lerp(startRotationConstantMinSeparate.z,startRotationConstantMaxSeparate.z,Math.random());
							}else {
							rand.seed=randomSeeds[5];
							lerpRoationE[0]=MathUtil.lerp(startRotationConstantMinSeparate.x,startRotationConstantMaxSeparate.x,rand.getFloat());
							lerpRoationE[1]=MathUtil.lerp(startRotationConstantMinSeparate.y,startRotationConstantMaxSeparate.y,rand.getFloat());
							lerpRoationE[2]=MathUtil.lerp(startRotationConstantMinSeparate.z,startRotationConstantMaxSeparate.z,rand.getFloat());
							randomSeeds[5]=rand.seed;
						}
						ShurikenParticleData._randomInvertRoationArray(lerpRoationE,lerpRoationE,particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
						ShurikenParticleData.startRotation[0]=lerpRoationE[0];
						ShurikenParticleData.startRotation[1]=lerpRoationE[1];
						if (renderMode!==4)
							ShurikenParticleData.startRotation[2]=-lerpRoationE[2];
						else
						ShurikenParticleData.startRotation[2]=lerpRoationE[2];
						}else {
						if (autoRandomSeed){
							ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(MathUtil.lerp(particleSystem.startRotationConstantMin,particleSystem.startRotationConstantMax,Math.random()),particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
							}else {
							rand.seed=randomSeeds[5];
							ShurikenParticleData.startRotation[0]=ShurikenParticleData._randomInvertRoation(MathUtil.lerp(particleSystem.startRotationConstantMin,particleSystem.startRotationConstantMax,rand.getFloat()),particleSystem.randomizeRotationDirection,autoRandomSeed ? null :rand,randomSeeds);
							randomSeeds[5]=rand.seed;
						}
					}
					break ;
				}
		}
		switch (particleSystem.startLifetimeType){
			case 0:
				ShurikenParticleData.startLifeTime=particleSystem.startLifetimeConstant;
				break ;
			case 1:
				ShurikenParticleData.startLifeTime=ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradient,particleSystem.emissionTime);
				break ;
			case 2:
				if (autoRandomSeed){
					ShurikenParticleData.startLifeTime=MathUtil.lerp(particleSystem.startLifetimeConstantMin,particleSystem.startLifetimeConstantMax,Math.random());
					}else {
					rand.seed=randomSeeds[7];
					ShurikenParticleData.startLifeTime=MathUtil.lerp(particleSystem.startLifetimeConstantMin,particleSystem.startLifetimeConstantMax,rand.getFloat());
					randomSeeds[7]=rand.seed;
				}
				break ;
			case 3:;
				var emissionTime=particleSystem.emissionTime;
				if (autoRandomSeed){
					ShurikenParticleData.startLifeTime=MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin,emissionTime),ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax,emissionTime),Math.random());
					}else {
					rand.seed=randomSeeds[7];
					ShurikenParticleData.startLifeTime=MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin,emissionTime),ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax,emissionTime),rand.getFloat());
					randomSeeds[7]=rand.seed;
				}
				break ;
			}
		switch (particleSystem.startSpeedType){
			case 0:
				ShurikenParticleData.startSpeed=particleSystem.startSpeedConstant;
				break ;
			case 2:
				if (autoRandomSeed){
					ShurikenParticleData.startSpeed=MathUtil.lerp(particleSystem.startSpeedConstantMin,particleSystem.startSpeedConstantMax,Math.random());
					}else {
					rand.seed=randomSeeds[8];
					ShurikenParticleData.startSpeed=MathUtil.lerp(particleSystem.startSpeedConstantMin,particleSystem.startSpeedConstantMax,rand.getFloat());
					randomSeeds[8]=rand.seed;
				}
				break ;
			};
		var textureSheetAnimation=particleSystem.textureSheetAnimation;
		var enableSheetAnimation=textureSheetAnimation && textureSheetAnimation.enable;
		if (enableSheetAnimation){
			var title=textureSheetAnimation.tiles;
			var titleX=title.x,titleY=title.y;
			var subU=1.0 / titleX,subV=1.0 / titleY;
			var startFrameCount=0;
			var startFrame=textureSheetAnimation.startFrame;
			switch (startFrame.type){
				case 0:
					startFrameCount=startFrame.constant;
					break ;
				case 1:
					if (autoRandomSeed){
						startFrameCount=MathUtil.lerp(startFrame.constantMin,startFrame.constantMax,Math.random());
						}else {
						rand.seed=randomSeeds[14];
						startFrameCount=MathUtil.lerp(startFrame.constantMin,startFrame.constantMax,rand.getFloat());
						randomSeeds[14]=rand.seed;
					}
					break ;
				};
			var frame=textureSheetAnimation.frame;
			switch (frame.type){
				case 0:
					startFrameCount+=frame.constant;
					break ;
				case 2:
					if (autoRandomSeed){
						startFrameCount+=MathUtil.lerp(frame.constantMin,frame.constantMax,Math.random());
						}else {
						rand.seed=randomSeeds[15];
						startFrameCount+=MathUtil.lerp(frame.constantMin,frame.constantMax,rand.getFloat());
						randomSeeds[15]=rand.seed;
					}
					break ;
				};
			var startRow=0;
			switch (textureSheetAnimation.type){
				case 0:
					startRow=Math.floor(startFrameCount / titleX);
					break ;
				case 1:
					if (textureSheetAnimation.randomRow){
						if (autoRandomSeed){
							startRow=Math.floor(Math.random()*titleY);
							}else {
							rand.seed=randomSeeds[13];
							startRow=Math.floor(rand.getFloat()*titleY);
							randomSeeds[13]=rand.seed;
						}
						}else {
						startRow=textureSheetAnimation.rowIndex;
					}
					break ;
				};
			var startCol=Math.floor(startFrameCount % titleX);
			ShurikenParticleData.startUVInfo=ShurikenParticleData.startUVInfo;
			ShurikenParticleData.startUVInfo[0]=subU;
			ShurikenParticleData.startUVInfo[1]=subV;
			ShurikenParticleData.startUVInfo[2]=startCol *subU;
			ShurikenParticleData.startUVInfo[3]=startRow *subV;
			}else {
			ShurikenParticleData.startUVInfo=ShurikenParticleData.startUVInfo;
			ShurikenParticleData.startUVInfo[0]=1.0;
			ShurikenParticleData.startUVInfo[1]=1.0;
			ShurikenParticleData.startUVInfo[2]=0.0;
			ShurikenParticleData.startUVInfo[3]=0.0;
		}
		switch (particleSystem.simulationSpace){
			case 0:;
				var positionE=transform.position.elements;
				ShurikenParticleData.simulationWorldPostion[0]=positionE[0];
				ShurikenParticleData.simulationWorldPostion[1]=positionE[1];
				ShurikenParticleData.simulationWorldPostion[2]=positionE[2];
				var rotationE=transform.rotation.elements;
				ShurikenParticleData.simulationWorldRotation[0]=rotationE[0];
				ShurikenParticleData.simulationWorldRotation[1]=rotationE[1];
				ShurikenParticleData.simulationWorldRotation[2]=rotationE[2];
				ShurikenParticleData.simulationWorldRotation[3]=rotationE[3];
				break ;
			case 1:
				break ;
			default :
				throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
				break ;
			}
	}

	ShurikenParticleData.startLifeTime=NaN;
	ShurikenParticleData.startSpeed=NaN;
	__static(ShurikenParticleData,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempQuaternion',function(){return this._tempQuaternion=new Quaternion();},'startColor',function(){return this.startColor=new Float32Array(4);},'startSize',function(){return this.startSize=new Float32Array(3);},'startRotation',function(){return this.startRotation=new Float32Array(3);},'startUVInfo',function(){return this.startUVInfo=new Float32Array(4);},'simulationWorldPostion',function(){return this.simulationWorldPostion=new Float32Array(3);},'simulationWorldRotation',function(){return this.simulationWorldRotation=new Float32Array(4);}
	]);
	return ShurikenParticleData;
})()


/**
*<code>ColliderShape</code> 类用于创建形状碰撞器的父类，该类为抽象类。
*/
//class laya.d3.physics.shape.ColliderShape
var ColliderShape=(function(){
	function ColliderShape(){
		/**@private */
		//this._nativeShape=null;
		/**@private */
		//this._type=0;
		/**@private */
		this._attatched=false;
		/**@private */
		this._indexInCompound=-1;
		/**@private */
		this._compoundParent=null;
		/**@private */
		this._attatchedCollisionObject=null;
		/**@private */
		this._referenceCount=0;
		this.needsCustomCollisionCallback=false;
		this._scale=new Vector3(1,1,1);
		this._centerMatrix=new Matrix4x4();
		this._localOffset=new Vector3(0,0,0);
		this._localRotation=new Quaternion(0,0,0,1);
	}

	__class(ColliderShape,'laya.d3.physics.shape.ColliderShape');
	var __proto=ColliderShape.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._setScale=function(value){
		if (this._compoundParent){
			this.updateLocalTransformations();
			}else {
			var valueE=value.elements;
			ColliderShape._nativeScale.setValue(valueE[0],valueE[1],valueE[2]);
			this._nativeShape.setLocalScaling(ColliderShape._nativeScale);
		}
	}

	/**
	*@private
	*/
	__proto._addReference=function(){
		this._referenceCount++;
	}

	/**
	*@private
	*/
	__proto._removeReference=function(){
		this._referenceCount--;
	}

	/**
	*更新本地偏移,如果修改LocalOffset或LocalRotation需要调用。
	*/
	__proto.updateLocalTransformations=function(){
		if (this._compoundParent){
			var offset=ColliderShape._tempVector30;
			Vector3.multiply(this.localOffset,this._scale,offset);
			ColliderShape._createAffineTransformation(offset.elements,this.localRotation.elements,this._centerMatrix.elements);
			}else {
			ColliderShape._createAffineTransformation(this.localOffset.elements,this.localRotation.elements,this._centerMatrix.elements);
		}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destColliderShape=destObject;
		this._localOffset.cloneTo(destColliderShape.localOffset);
		this._localRotation.cloneTo(destColliderShape.localRotation);
		destColliderShape.localOffset=destColliderShape.localOffset;
		destColliderShape.localRotation=destColliderShape.localRotation;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		return null;
	}

	/**
	*@private
	*/
	__proto.destroy=function(){
		if (this._nativeShape){
			Laya3D._physics3D.destroy(this._nativeShape);
			this._nativeShape=null;
		}
	}

	/**
	*获取碰撞类型。
	*@return 碰撞类型。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*设置Shape的本地偏移。
	*@param Shape的本地偏移。
	*/
	/**
	*获取Shape的本地偏移。
	*@return Shape的本地偏移。
	*/
	__getset(0,__proto,'localOffset',function(){
		return this._localOffset;
		},function(value){
		this._localOffset=value;
		if (this._compoundParent)
			this._compoundParent._updateChildTransform(this);
	});

	/**
	*设置Shape的本地旋转。
	*@param Shape的本地旋转。
	*/
	/**
	*获取Shape的本地旋转。
	*@return Shape的本地旋转。
	*/
	__getset(0,__proto,'localRotation',function(){
		return this._localRotation;
		},function(value){
		this._localRotation=value;
		if (this._compoundParent)
			this._compoundParent._updateChildTransform(this);
	});

	ColliderShape._creatShape=function(shapeData){
		var colliderShape;
		switch (shapeData.type){
			case "BoxColliderShape":;
				var sizeData=shapeData.size;
				colliderShape=sizeData ? new BoxColliderShape(sizeData[0],sizeData[1],sizeData[2]):new BoxColliderShape();
				break ;
			case "SphereColliderShape":
				colliderShape=new SphereColliderShape(shapeData.radius);
				break ;
			case "CapsuleColliderShape":
				colliderShape=new CapsuleColliderShape(shapeData.radius,shapeData.height,shapeData.orientation);
				break ;
			case "MeshColliderShape":;
				var meshCollider=new MeshColliderShape();
				shapeData.mesh && (meshCollider.mesh=Loader.getRes(shapeData.mesh));
				colliderShape=meshCollider;
				break ;
			case "ConeColliderShape":
				colliderShape=new ConeColliderShape(shapeData.radius,shapeData.height,shapeData.orientation);
				break ;
			case "CylinderColliderShape":
				colliderShape=new CylinderColliderShape(shapeData.radius,shapeData.height,shapeData.orientation);
				break ;
			default :
				throw "unknown shape type.";
			}
		if (shapeData.center){
			var localOffset=colliderShape.localOffset;
			localOffset.fromArray(shapeData.center);
			colliderShape.localOffset=localOffset;
		}
		return colliderShape;
	}

	ColliderShape._createAffineTransformation=function(trans,rot,outE){
		var x=rot[0],y=rot[1],z=rot[2],w=rot[3],x2=x+x,y2=y+y,z2=z+z;
		var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
		var wx=w *x2,wy=w *y2,wz=w *z2;
		outE[0]=(1-(yy+zz));
		outE[1]=(xy+wz);
		outE[2]=(xz-wy);
		outE[3]=0;
		outE[4]=(xy-wz);
		outE[5]=(1-(xx+zz));
		outE[6]=(yz+wx);
		outE[7]=0;
		outE[8]=(xz+wy);
		outE[9]=(yz-wx);
		outE[10]=(1-(xx+yy));
		outE[11]=0;
		outE[12]=trans[0];
		outE[13]=trans[1];
		outE[14]=trans[2];
		outE[15]=1;
	}

	ColliderShape.SHAPEORIENTATION_UPX=0;
	ColliderShape.SHAPEORIENTATION_UPY=1;
	ColliderShape.SHAPEORIENTATION_UPZ=2;
	ColliderShape.SHAPETYPES_BOX=0;
	ColliderShape.SHAPETYPES_SPHERE=1;
	ColliderShape.SHAPETYPES_CYLINDER=2;
	ColliderShape.SHAPETYPES_CAPSULE=3;
	ColliderShape.SHAPETYPES_CONVEXHULL=4;
	ColliderShape.SHAPETYPES_COMPOUND=5;
	ColliderShape.SHAPETYPES_STATICPLANE=6;
	ColliderShape.SHAPETYPES_CONE=7;
	__static(ColliderShape,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_nativeScale',function(){return this._nativeScale=new Laya3D._physics3D.btVector3(1,1,1);},'_nativeVector30',function(){return this._nativeVector30=new Laya3D._physics3D.btVector3(0,0,0);},'_nativQuaternion0',function(){return this._nativQuaternion0=new Laya3D._physics3D.btQuaternion(0,0,0,1);},'_nativeTransform0',function(){return this._nativeTransform0=new Laya3D._physics3D.btTransform();}
	]);
	return ColliderShape;
})()


/**
*...
*@author
*/
//class laya.d3.resource.TextureGenerator
var TextureGenerator=(function(){
	function TextureGenerator(){}
	__class(TextureGenerator,'laya.d3.resource.TextureGenerator');
	TextureGenerator.lightAttenTexture=function(x,y,maxX,maxY,index,data){
		var sqrRange=x / maxX;
		var atten=1.0 / (1.0+25.0 *sqrRange);
		if (sqrRange >=0.64){
			if (sqrRange > 1.0){
				atten=0;
				}else {
				atten *=1-(sqrRange-0.64)/ (1-0.64);
			}
		}
		data[index]=Math.floor(atten *255.0+0.5);
	}

	TextureGenerator.haloTexture=function(x,y,maxX,maxY,index,data){
		maxX >>=1;
		maxY >>=1;
		var xFac=(x-maxX)/ maxX;
		var yFac=(y-maxY)/ maxY;
		var sqrRange=xFac *xFac+yFac *yFac;
		if (sqrRange > 1.0){
			sqrRange=1.0;
		}
		data[index]=Math.floor((1.0-sqrRange)*255.0+0.5);
	}

	TextureGenerator._generateTexture2D=function(texture,textureWidth,textureHeight,func){
		var index=0;
		var size=0;
		switch (texture.format){
			case /*laya.webgl.resource.BaseTexture.FORMAT_R8G8B8*/0:
				size=3;
				break ;
			case /*laya.webgl.resource.BaseTexture.FORMAT_R8G8B8A8*/1:
				size=4;
				break ;
			case /*laya.webgl.resource.BaseTexture.FORMAT_ALPHA8*/2:
				size=1;
				break ;
			default :
				throw "GeneratedTexture._generateTexture: unkonw texture format.";
			};
		var data=new Uint8Array(textureWidth *textureHeight *size);
		for (var y=0;y < textureHeight;y++){
			for (var x=0;x < textureWidth;x++){
				func(x,y,textureWidth,textureHeight,index,data);
				index+=size;
			}
		}
		texture.setPixels(data);
	}

	return TextureGenerator;
})()


/**
*@private
*<code>FrustumCulling</code> 类用于裁剪。
*/
//class laya.d3.graphics.FrustumCulling
var FrustumCulling=(function(){
	/**
	*创建一个 <code>FrustumCulling</code> 实例。
	*/
	function FrustumCulling(){}
	__class(FrustumCulling,'laya.d3.graphics.FrustumCulling');
	FrustumCulling.__init__=function(){
		if (Render.isConchApp){
			FrustumCulling._cullingBufferLength=0;
			FrustumCulling._cullingBuffer=new Float32Array(4096);
		}
	}

	FrustumCulling.renderObjectCulling=function(camera,scene,context,renderList){
		var i=0,n=0,j=0,m=0;
		var opaqueQueue=scene._opaqueQueue;
		var transparentQueue=scene._transparentQueue;
		opaqueQueue.clear();
		transparentQueue.clear();
		var staticBatchManagers=StaticBatchManager._managers;
		for (i=0,n=staticBatchManagers.length;i < n;i++)
		staticBatchManagers[i]._clear();
		var dynamicBatchManagers=DynamicBatchManager._managers;
		for (i=0,n=dynamicBatchManagers.length;i < n;i++)
		dynamicBatchManagers[i]._clear();
		var validCount=renderList.length;
		var renders=renderList.elements;
		var boundFrustum=camera.boundFrustum;
		Stat.spriteCount+=validCount;
		var camPos=context.camera._transform.position;
		if (scene.treeRoot){
			scene.treeRoot.cullingObjects(context,boundFrustum,camera,camPos,true);
			}else {
			for (i=0;i < validCount;i++){
				var render=renders [i];
				if (scene.isLayerVisible(render._owner._layer,camera)&& render._enable && render._needRender(boundFrustum)){
					render._visible=true;
					render._distanceForSort=Vector3.distance(render.boundingSphere.center,camPos);
					var elements=render._renderElements;
					for (j=0,m=elements.length;j < m;j++){
						var element=elements[j];
						var renderQueue=scene._getRenderQueue(element.material.renderQueue);
						if (renderQueue.isTransparent)
							element.addToTransparentRenderQueue(context,renderQueue);
						else
						element.addToOpaqueRenderQueue(context,renderQueue);
					}
					}else {
					render._visible=false;
				}
			}
		};
		var count=opaqueQueue.elements.length;
		(count > 0)&& (opaqueQueue._quickSort(0,count-1));
		count=transparentQueue.elements.length;
		(count > 0)&& (transparentQueue._quickSort(0,count-1));
	}

	FrustumCulling.renderObjectCullingNative=function(camera,scene,context,renderList){
		var i=0,n=0,j=0,m=0;
		var opaqueQueue=scene._opaqueQueue;
		var transparentQueue=scene._transparentQueue;
		opaqueQueue.clear();
		transparentQueue.clear();
		var staticBatchManagers=StaticBatchManager._managers;
		for (i=0,n=staticBatchManagers.length;i < n;i++)
		staticBatchManagers[i]._clear();
		var dynamicBatchManagers=DynamicBatchManager._managers;
		for (i=0,n=dynamicBatchManagers.length;i < n;i++)
		dynamicBatchManagers[i]._clear();
		var validCount=renderList.length;
		var renders=renderList.elements;
		for (i=0;i < validCount;i++){
			(renders [i]).boundingSphere;
		};
		var boundFrustum=camera.boundFrustum;
		FrustumCulling.cullingNative(camera._boundFrustumBuffer,FrustumCulling._cullingBuffer,scene._cullingBufferIndices,validCount,scene._cullingBufferResult);
		Stat.spriteCount+=validCount;
		var camPos=context.camera._transform.position;
		for (i=0;i < validCount;i++){
			var render=renders [i];
			if (scene.isLayerVisible(render._owner._layer,camera)&& render._enable && scene._cullingBufferResult[i]){
				render._visible=true;
				render._distanceForSort=Vector3.distance(render.boundingSphere.center,camPos);
				var elements=render._renderElements;
				for (j=0,m=elements.length;j < m;j++){
					var element=elements[j];
					var renderQueue=scene._getRenderQueue(element.material.renderQueue);
					if (renderQueue.isTransparent)
						element.addToTransparentRenderQueue(context,renderQueue);
					else
					element.addToOpaqueRenderQueue(context,renderQueue);
				}
				}else {
				render._visible=false;
			}
		};
		var count=opaqueQueue.elements.length;
		(count > 0)&& (opaqueQueue._quickSort(0,count-1));
		count=transparentQueue.elements.length;
		(count > 0)&& (transparentQueue._quickSort(0,count-1));
	}

	FrustumCulling.cullingNative=function(boundFrustumBuffer,cullingBuffer,cullingBufferIndices,cullingCount,cullingBufferResult){
		return LayaGL.instance.culling(boundFrustumBuffer,cullingBuffer,cullingBufferIndices,cullingCount,cullingBufferResult);
	}

	FrustumCulling._cullingBufferLength=0;
	FrustumCulling._cullingBuffer=null;
	return FrustumCulling;
})()


/**
*创建一个 <code>MeshRenderStaticBatchOwner</code> 实例。
*/
//class laya.d3.graphics.MeshRenderStaticBatchOwner
var MeshRenderStaticBatchOwner=(function(){
	function MeshRenderStaticBatchOwner(owner){
		/**@private */
		//this._owner=null;
		/**@private */
		//this._batches=null;
		/**@private */
		//this._cacheBatchOwner=null;
		this._owner=owner;
		this._batches=[];
		this._cacheBatchOwner=[];
	}

	__class(MeshRenderStaticBatchOwner,'laya.d3.graphics.MeshRenderStaticBatchOwner');
	var __proto=MeshRenderStaticBatchOwner.prototype;
	/**
	*@private
	*/
	__proto._getBatchRender=function(context,lightMapIndex,receiveShadow){
		var lightRenders=this._cacheBatchOwner[lightMapIndex];
		(lightRenders)|| (lightRenders=this._cacheBatchOwner[lightMapIndex]=__newvec(2,null));
		var render=lightRenders[receiveShadow ? 1 :0];
		if (!render){
			render=new MeshRenderer(null);
			render.lightmapIndex=lightMapIndex;
			render.receiveShadow=receiveShadow;
			lightRenders[receiveShadow ? 1 :0]=render;
			render._defineDatas.add(MeshSprite3D.SHADERDEFINE_UV1);
		}
		return render;
	}

	return MeshRenderStaticBatchOwner;
})()


/**
*@private
*<code>GeometryElement</code> 类用于实现几何体元素,该类为抽象类。
*/
//class laya.d3.core.GeometryElement
var GeometryElement=(function(){
	function GeometryElement(){
		/**@private */
		//this._destroyed=false;
		this._destroyed=false;
	}

	__class(GeometryElement,'laya.d3.core.GeometryElement');
	var __proto=GeometryElement.prototype;
	Laya.imps(__proto,{"laya.resource.IDestroy":true})
	/**
	*获取几何体类型。
	*/
	__proto._getType=function(){
		throw "GeometryElement:must override it.";
	}

	/**
	*@private
	*@return 是否需要渲染。
	*/
	__proto._prepareRender=function(state){
		return true;
	}

	/**
	*@private
	*/
	__proto._render=function(state){
		throw "GeometryElement:must override it.";
	}

	/**
	*销毁。
	*/
	__proto.destroy=function(){
		if (this._destroyed)
			return;
		this._destroyed=true;
	}

	/**
	*获取是否销毁。
	*@return 是否销毁。
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	GeometryElement._typeCounter=0;
	return GeometryElement;
})()


/**
*<code>KeyFrame</code> 类用于创建关键帧实例。
*/
//class laya.d3.core.Keyframe
var Keyframe=(function(){
	function Keyframe(){
		/**时间。*/
		this.time=NaN;
	}

	__class(Keyframe,'laya.d3.core.Keyframe');
	var __proto=Keyframe.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destKeyFrame=destObject;
		destKeyFrame.time=this.time;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	return Keyframe;
})()


/**
*<code>AnimatorState</code> 类用于创建动作状态。
*/
//class laya.d3.component.AnimatorState
var AnimatorState=(function(){
	function AnimatorState(){
		/**@private */
		//this._clip=null;
		/**@private */
		//this._currentFrameIndices=null;
		/**@private */
		//this._scripts=null;
		/**名称。*/
		//this.name=null;
		/**动画播放速度,1.0为正常播放速度。*/
		this.speed=1.0;
		/**动作播放起始时间。*/
		this.clipStart=0.0;
		/**动作播放结束时间。*/
		this.clipEnd=1.0;
		this._nodeOwners=[];
	}

	__class(AnimatorState,'laya.d3.component.AnimatorState');
	var __proto=AnimatorState.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._resetFrameIndices=function(){
		for (var i=0,n=this._currentFrameIndices.length;i < n;i++)
		this._currentFrameIndices[i]=-1;
	}

	/**
	*添加脚本。
	*@param type 组件类型。
	*@return 脚本。
	*
	*/
	__proto.addScript=function(type){
		var script=new type();this._scripts=this._scripts|| [];
		this._scripts.push(script);
		return script;
	}

	/**
	*获取脚本。
	*@param type 组件类型。
	*@return 脚本。
	*
	*/
	__proto.getScript=function(type){
		if (this._scripts){
			for (var i=0,n=this._scripts.length;i < n;i++){
				var script=this._scripts[i];
				if (Laya.__typeof(script,type))
					return script;
			}
		}
		return null;
	}

	/**
	*获取脚本集合。
	*@param type 组件类型。
	*@return 脚本集合。
	*
	*/
	__proto.getScripts=function(type){
		var coms;
		if (this._scripts){
			for (var i=0,n=this._scripts.length;i < n;i++){
				var script=this._scripts[i];
				if (Laya.__typeof(script,type)){coms=coms|| [];
					coms.push(script);
				}
			}
		}
		return coms;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		dest.name=this.name;
		dest.speed=this.speed;
		dest.clipStart=this.clipStart;
		dest.clipEnd=this.clipEnd;
		dest.clip=this._clip;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*设置动作。
	*@param value 动作。
	*/
	/**
	*获取动作。
	*@return 动作
	*/
	__getset(0,__proto,'clip',function(){
		return this._clip;
		},function(value){
		this._clip=value;
		this._currentFrameIndices=new Int16Array(value._nodes.count);
		this._resetFrameIndices();
	});

	return AnimatorState;
})()


/**
*<code>SkyRenderer</code> 类用于实现天空渲染器。
*/
//class laya.d3.resource.models.SkyRenderer
var SkyRenderer=(function(){
	function SkyRenderer(){
		/**@private */
		this._material=null;
		this._mesh=SkyBox.instance;
	}

	__class(SkyRenderer,'laya.d3.resource.models.SkyRenderer');
	var __proto=SkyRenderer.prototype;
	/**
	*@private
	*是否可用。
	*/
	__proto._isAvailable=function(){
		return this._material && this._mesh;
	}

	/**
	*@private
	*/
	__proto._render=function(state){
		if (this._material && this._mesh){
			var gl=LayaGL.instance;
			var scene=state.scene;
			var camera=state.camera;
			WebGLContext.setCullFace(gl,false);
			WebGLContext.setDepthFunc(gl,/*laya.webgl.WebGLContext.LEQUAL*/0x0203);
			WebGLContext.setDepthMask(gl,false);
			var shader=state.shader=this._material._shader.getSubShaderAt(0)._passes[0].withCompile(0,0,this._material._defineDatas.value);
			var switchShader=shader.bind();
			var switchShaderLoop=(Stat.loopCount!==shader._uploadLoopCount);
			var uploadScene=(shader._uploadScene!==scene)|| switchShaderLoop;
			if (uploadScene || switchShader){
				shader.uploadUniforms(shader._sceneUniformParamsMap,scene._shaderValues,uploadScene);
				shader._uploadScene=scene;
			};
			var uploadCamera=(shader._uploadCamera!==camera)|| switchShaderLoop;
			if (uploadCamera || switchShader){
				shader.uploadUniforms(shader._cameraUniformParamsMap,camera._shaderValues,uploadCamera);
				shader._uploadCamera=camera;
			};
			var uploadMaterial=(shader._uploadMaterial!==this._material)|| switchShaderLoop;
			if (uploadMaterial || switchShader){
				shader.uploadUniforms(shader._materialUniformParamsMap,this._material._shaderValues,uploadMaterial);
				shader._uploadMaterial=this._material;
			}
			this._mesh._bufferState.bind();
			this._mesh._render(state);
			WebGLContext.setDepthFunc(gl,/*laya.webgl.WebGLContext.LESS*/0x0201);
			WebGLContext.setDepthMask(gl,true);
		}
	}

	/**
	*@private
	*/
	__proto.destroy=function(){
		if (this._material){
			this._material._removeReference();
			this._material=null;
		}
	}

	/**
	*设置材质。
	*@param 材质。
	*/
	/**
	*获取材质。
	*@return 材质。
	*/
	__getset(0,__proto,'material',function(){
		return this._material;
		},function(value){
		if (this._material!==value){
			(this._material)&& (this._material._removeReference());
			(value)&& (value._addReference());
			this._material=value;
		}
	});

	/**
	*设置网格。
	*@param 网格。
	*/
	/**
	*获取网格。
	*@return 网格。
	*/
	__getset(0,__proto,'mesh',function(){
		return this._mesh;
		},function(value){
		if (this._mesh!==value){
			this._mesh=value;
		}
	});

	return SkyRenderer;
})()


/**
*<code>PrimitiveMesh</code> 类用于创建简单网格。
*/
//class laya.d3.resource.models.PrimitiveMesh
var PrimitiveMesh=(function(){
	function PrimitiveMesh(){}
	__class(PrimitiveMesh,'laya.d3.resource.models.PrimitiveMesh');
	PrimitiveMesh._createMesh=function(vertexDeclaration,vertices,indices){
		var mesh=new Mesh();
		var subMesh=new SubMesh(mesh);
		var vertexBuffer=new VertexBuffer3D(vertices.length *4,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		vertexBuffer.vertexDeclaration=vertexDeclaration;
		vertexBuffer.setData(vertices);
		mesh._vertexBuffers.push(vertexBuffer);
		mesh._vertexCount+=vertexBuffer.vertexCount;
		var indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",indices.length,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		indexBuffer.setData(indices);
		mesh._indexBuffer=indexBuffer;
		var bufferState=subMesh._bufferState;
		bufferState.bind();
		bufferState.applyVertexBuffer(vertexBuffer);
		bufferState.applyIndexBuffer(indexBuffer);
		bufferState.unBind();
		subMesh._vertexBuffer=vertexBuffer;
		subMesh._indexBuffer=indexBuffer;
		subMesh._indexStart=0;
		subMesh._indexCount=indexBuffer.indexCount;
		var subIndexBufferStart=subMesh._subIndexBufferStart;
		var subIndexBufferCount=subMesh._subIndexBufferCount;
		var boneIndicesList=subMesh._boneIndicesList;
		subIndexBufferStart.length=1;
		subIndexBufferCount.length=1;
		boneIndicesList.length=1;
		subIndexBufferStart[0]=0;
		subIndexBufferCount[0]=indexBuffer.indexCount;
		var subMeshes=[];
		subMeshes.push(subMesh);
		mesh._setSubMeshes(subMeshes);
		var memorySize=vertexBuffer._byteLength+indexBuffer._byteLength;
		mesh._setCPUMemory(memorySize);
		mesh._setGPUMemory(memorySize);
		return mesh;
	}

	PrimitiveMesh.createBox=function(long,height,width){
		(long===void 0)&& (long=1);
		(height===void 0)&& (height=1);
		(width===void 0)&& (width=1);
		var vertexCount=24;
		var indexCount=36;
		var vertexDeclaration=VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
		var halfLong=long / 2;
		var halfHeight=height / 2;
		var halfWidth=width / 2;
		var vertices=new Float32Array([
		-halfLong,halfHeight,-halfWidth,0,1,0,0,0,halfLong,halfHeight,-halfWidth,0,1,0,1,0,halfLong,halfHeight,halfWidth,0,1,0,1,1,-halfLong,halfHeight,halfWidth,0,1,0,0,1,
		-halfLong,-halfHeight,-halfWidth,0,-1,0,0,1,halfLong,-halfHeight,-halfWidth,0,-1,0,1,1,halfLong,-halfHeight,halfWidth,0,-1,0,1,0,-halfLong,-halfHeight,halfWidth,0,-1,0,0,0,
		-halfLong,halfHeight,-halfWidth,-1,0,0,0,0,-halfLong,halfHeight,halfWidth,-1,0,0,1,0,-halfLong,-halfHeight,halfWidth,-1,0,0,1,1,-halfLong,-halfHeight,-halfWidth,-1,0,0,0,1,
		halfLong,halfHeight,-halfWidth,1,0,0,1,0,halfLong,halfHeight,halfWidth,1,0,0,0,0,halfLong,-halfHeight,halfWidth,1,0,0,0,1,halfLong,-halfHeight,-halfWidth,1,0,0,1,1,
		-halfLong,halfHeight,halfWidth,0,0,1,0,0,halfLong,halfHeight,halfWidth,0,0,1,1,0,halfLong,-halfHeight,halfWidth,0,0,1,1,1,-halfLong,-halfHeight,halfWidth,0,0,1,0,1,
		-halfLong,halfHeight,-halfWidth,0,0,-1,1,0,halfLong,halfHeight,-halfWidth,0,0,-1,0,0,halfLong,-halfHeight,-halfWidth,0,0,-1,0,1,-halfLong,-halfHeight,-halfWidth,0,0,-1,1,1]);
		var indices=new Uint16Array([
		0,1,2,2,3,0,
		4,7,6,6,5,4,
		8,9,10,10,11,8,
		12,15,14,14,13,12,
		16,17,18,18,19,16,
		20,23,22,22,21,20]);
		return PrimitiveMesh._createMesh(vertexDeclaration,vertices,indices);
	}

	PrimitiveMesh.createCapsule=function(radius,height,stacks,slices){
		(radius===void 0)&& (radius=0.5);
		(height===void 0)&& (height=2);
		(stacks===void 0)&& (stacks=16);
		(slices===void 0)&& (slices=32);
		var vertexCount=(stacks+1)*(slices+1)*2+(slices+1)*2;
		var indexCount=(3 *stacks *(slices+1))*2 *2+2 *slices *3;
		var vertexDeclaration=VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(vertexCount *vertexFloatStride);
		var indices=new Uint16Array(indexCount);
		var stackAngle=(Math.PI / 2.0)/ stacks;
		var sliceAngle=(Math.PI *2.0)/ slices;
		var hcHeight=height / 2-radius;
		var posX=0;
		var posY=0;
		var posZ=0;
		var vc=0;
		var ic=0;
		var verticeCount=0;
		var stack=0,slice=0;
		for (stack=0;stack <=stacks;stack++){
			for (slice=0;slice <=slices;slice++){
				posX=radius *Math.cos(stack *stackAngle)*Math.cos(slice *sliceAngle+Math.PI);
				posY=radius *Math.sin(stack *stackAngle);
				posZ=radius *Math.cos(stack *stackAngle)*Math.sin(slice *sliceAngle+Math.PI);
				vertices[vc++]=posX;
				vertices[vc++]=posY+hcHeight;
				vertices[vc++]=posZ;
				vertices[vc++]=posX;
				vertices[vc++]=posY;
				vertices[vc++]=posZ;
				vertices[vc++]=1-slice / slices;
				vertices[vc++]=(1-stack / stacks)*((Math.PI *radius / 2)/ (height+Math.PI *radius));
				if (stack < stacks){
					indices[ic++]=(stack *(slices+1))+slice+(slices+1);
					indices[ic++]=(stack *(slices+1))+slice;
					indices[ic++]=(stack *(slices+1))+slice+1;
					indices[ic++]=(stack *(slices+1))+slice+(slices);
					indices[ic++]=(stack *(slices+1))+slice;
					indices[ic++]=(stack *(slices+1))+slice+(slices+1);
				}
			}
		}
		verticeCount+=(stacks+1)*(slices+1);
		for (stack=0;stack <=stacks;stack++){
			for (slice=0;slice <=slices;slice++){
				posX=radius *Math.cos(stack *stackAngle)*Math.cos(slice *sliceAngle+Math.PI);
				posY=radius *Math.sin(-stack *stackAngle);
				posZ=radius *Math.cos(stack *stackAngle)*Math.sin(slice *sliceAngle+Math.PI);
				vertices[vc++]=posX;
				vertices[vc++]=posY-hcHeight;
				vertices[vc++]=posZ;
				vertices[vc++]=posX;
				vertices[vc++]=posY;
				vertices[vc++]=posZ;
				vertices[vc++]=1-slice / slices;
				vertices[vc++]=((stack / stacks)*(Math.PI *radius / 2)+(height+Math.PI *radius / 2))/ (height+Math.PI *radius);
				if (stack < stacks){
					indices[ic++]=verticeCount+(stack *(slices+1))+slice;
					indices[ic++]=verticeCount+(stack *(slices+1))+slice+(slices+1);
					indices[ic++]=verticeCount+(stack *(slices+1))+slice+1;
					indices[ic++]=verticeCount+(stack *(slices+1))+slice;
					indices[ic++]=verticeCount+(stack *(slices+1))+slice+(slices);
					indices[ic++]=verticeCount+(stack *(slices+1))+slice+(slices+1);
				}
			}
		}
		verticeCount+=(stacks+1)*(slices+1);
		for (slice=0;slice <=slices;slice++){
			posX=radius *Math.cos(slice *sliceAngle+Math.PI);
			posY=hcHeight;
			posZ=radius *Math.sin(slice *sliceAngle+Math.PI);
			vertices[vc++]=posX;
			vertices[vc+(slices+1)*8-1]=posX;
			vertices[vc++]=posY;
			vertices[vc+(slices+1)*8-1]=-posY;
			vertices[vc++]=posZ;
			vertices[vc+(slices+1)*8-1]=posZ;
			vertices[vc++]=posX;
			vertices[vc+(slices+1)*8-1]=posX;
			vertices[vc++]=0;
			vertices[vc+(slices+1)*8-1]=0;
			vertices[vc++]=posZ;
			vertices[vc+(slices+1)*8-1]=posZ;
			vertices[vc++]=1-slice *1 / slices;
			vertices[vc+(slices+1)*8-1]=1-slice *1 / slices;
			vertices[vc++]=(Math.PI *radius / 2)/ (height+Math.PI *radius);
			vertices[vc+(slices+1)*8-1]=(Math.PI *radius / 2+height)/ (height+Math.PI *radius);
		}
		for (slice=0;slice < slices;slice++){
			indices[ic++]=slice+verticeCount+(slices+1);
			indices[ic++]=slice+verticeCount+1;
			indices[ic++]=slice+verticeCount;
			indices[ic++]=slice+verticeCount+(slices+1);
			indices[ic++]=slice+verticeCount+(slices+1)+1;
			indices[ic++]=slice+verticeCount+1;
		}
		verticeCount+=2 *(slices+1);
		return PrimitiveMesh._createMesh(vertexDeclaration,vertices,indices);
	}

	PrimitiveMesh.createCone=function(radius,height,slices){
		(radius===void 0)&& (radius=0.5);
		(height===void 0)&& (height=1);
		(slices===void 0)&& (slices=32);
		var vertexCount=(slices+1+1)+(slices+1)*2;
		var indexCount=6 *slices+3 *slices;
		var vertexDeclaration=VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(vertexCount *vertexFloatStride);
		var indices=new Uint16Array(indexCount);
		var sliceAngle=(Math.PI *2.0)/ slices;
		var halfHeight=height / 2;
		var curAngle=0;
		var verticeCount=0;
		var posX=0;
		var posY=0;
		var posZ=0;
		var normal=new Vector3();
		var downV3=new Vector3(0,-1,0);
		var upPoint=new Vector3(0,halfHeight,0);
		var downPoint=new Vector3();
		var v3=new Vector3();
		var q4=new Quaternion();
		var rotateAxis=new Vector3();
		var rotateRadius=NaN;
		var vc=0;
		var ic=0;
		for (var rv=0;rv <=slices;rv++){
			curAngle=rv *sliceAngle;
			posX=Math.cos(curAngle+Math.PI)*radius;
			posY=halfHeight;
			posZ=Math.sin(curAngle+Math.PI)*radius;
			vertices[vc++]=0;
			vertices[vc+(slices+1)*8-1]=posX;
			vertices[vc++]=posY;
			vertices[vc+(slices+1)*8-1]=-posY;
			vertices[vc++]=0;
			vertices[vc+(slices+1)*8-1]=posZ;
			normal.x=posX;
			normal.y=0;
			normal.z=posZ;
			downPoint.x=posX;
			downPoint.y=-posY;
			downPoint.z=posZ;
			Vector3.subtract(downPoint,upPoint,v3);
			Vector3.normalize(v3,v3);
			rotateRadius=Math.acos(Vector3.dot(downV3,v3));
			Vector3.cross(downV3,v3,rotateAxis);
			Vector3.normalize(rotateAxis,rotateAxis);
			Quaternion.createFromAxisAngle(rotateAxis,rotateRadius,q4);
			Vector3.normalize(normal,normal);
			Vector3.transformQuat(normal,q4,normal);
			Vector3.normalize(normal,normal);
			vertices[vc++]=normal.x;
			vertices[vc+(slices+1)*8-1]=normal.x;
			vertices[vc++]=normal.y;
			vertices[vc+(slices+1)*8-1]=normal.y;
			vertices[vc++]=normal.z;
			vertices[vc+(slices+1)*8-1]=normal.z;
			vertices[vc++]=1-rv *1 / slices;
			vertices[vc+(slices+1)*8-1]=1-rv *1 / slices;
			vertices[vc++]=0;
			vertices[vc+(slices+1)*8-1]=1;
		}
		vc+=(slices+1)*8;
		for (var ri=0;ri < slices;ri++){
			indices[ic++]=ri+verticeCount+(slices+1);
			indices[ic++]=ri+verticeCount+1;
			indices[ic++]=ri+verticeCount;
			indices[ic++]=ri+verticeCount+(slices+1);
			indices[ic++]=ri+verticeCount+(slices+1)+1;
			indices[ic++]=ri+verticeCount+1;
		}
		verticeCount+=2 *(slices+1);
		for (var bv=0;bv <=slices;bv++){
			if (bv===0){
				vertices[vc++]=0;
				vertices[vc++]=-halfHeight;
				vertices[vc++]=0;
				vertices[vc++]=0;
				vertices[vc++]=-1;
				vertices[vc++]=0;
				vertices[vc++]=0.5;
				vertices[vc++]=0.5;
			}
			curAngle=bv *sliceAngle;
			posX=Math.cos(curAngle+Math.PI)*radius;
			posY=-halfHeight;
			posZ=Math.sin(curAngle+Math.PI)*radius;
			vertices[vc++]=posX;
			vertices[vc++]=posY;
			vertices[vc++]=posZ;
			vertices[vc++]=0;
			vertices[vc++]=-1;
			vertices[vc++]=0;
			vertices[vc++]=0.5+Math.cos(curAngle)*0.5;
			vertices[vc++]=0.5+Math.sin(curAngle)*0.5;
		}
		for (var bi=0;bi < slices;bi++){
			indices[ic++]=0+verticeCount;
			indices[ic++]=bi+2+verticeCount;
			indices[ic++]=bi+1+verticeCount;
		}
		verticeCount+=slices+1+1;
		return PrimitiveMesh._createMesh(vertexDeclaration,vertices,indices);
	}

	PrimitiveMesh.createCylinder=function(radius,height,slices){
		(radius===void 0)&& (radius=0.5);
		(height===void 0)&& (height=2);
		(slices===void 0)&& (slices=32);
		var vertexCount=(slices+1+1)+(slices+1)*2+(slices+1+1);
		var indexCount=3 *slices+6 *slices+3 *slices;
		var vertexDeclaration=VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(vertexCount *vertexFloatStride);
		var indices=new Uint16Array(indexCount);
		var sliceAngle=(Math.PI *2.0)/ slices;
		var halfHeight=height / 2;
		var curAngle=0;
		var verticeCount=0;
		var posX=0;
		var posY=0;
		var posZ=0;
		var vc=0;
		var ic=0;
		for (var tv=0;tv <=slices;tv++){
			if (tv===0){
				vertices[vc++]=0;
				vertices[vc++]=halfHeight;
				vertices[vc++]=0;
				vertices[vc++]=0;
				vertices[vc++]=1;
				vertices[vc++]=0;
				vertices[vc++]=0.5;
				vertices[vc++]=0.5;
			}
			curAngle=tv *sliceAngle;
			posX=Math.cos(curAngle)*radius;
			posY=halfHeight;
			posZ=Math.sin(curAngle)*radius;
			vertices[vc++]=posX;
			vertices[vc++]=posY;
			vertices[vc++]=posZ;
			vertices[vc++]=0;
			vertices[vc++]=1;
			vertices[vc++]=0;
			vertices[vc++]=0.5+Math.cos(curAngle)*0.5;
			vertices[vc++]=0.5+Math.sin(curAngle)*0.5;
		}
		for (var ti=0;ti < slices;ti++){
			indices[ic++]=0;
			indices[ic++]=ti+1;
			indices[ic++]=ti+2;
		}
		verticeCount+=slices+1+1;
		for (var rv=0;rv <=slices;rv++){
			curAngle=rv *sliceAngle;
			posX=Math.cos(curAngle+Math.PI)*radius;
			posY=halfHeight;
			posZ=Math.sin(curAngle+Math.PI)*radius;
			vertices[vc++]=posX;
			vertices[vc+(slices+1)*8-1]=posX;
			vertices[vc++]=posY;
			vertices[vc+(slices+1)*8-1]=-posY;
			vertices[vc++]=posZ;
			vertices[vc+(slices+1)*8-1]=posZ;
			vertices[vc++]=posX;
			vertices[vc+(slices+1)*8-1]=posX;
			vertices[vc++]=0;
			vertices[vc+(slices+1)*8-1]=0;
			vertices[vc++]=posZ;
			vertices[vc+(slices+1)*8-1]=posZ;
			vertices[vc++]=1-rv *1 / slices;
			vertices[vc+(slices+1)*8-1]=1-rv *1 / slices;
			vertices[vc++]=0;
			vertices[vc+(slices+1)*8-1]=1;
		}
		vc+=(slices+1)*8;
		for (var ri=0;ri < slices;ri++){
			indices[ic++]=ri+verticeCount+(slices+1);
			indices[ic++]=ri+verticeCount+1;
			indices[ic++]=ri+verticeCount;
			indices[ic++]=ri+verticeCount+(slices+1);
			indices[ic++]=ri+verticeCount+(slices+1)+1;
			indices[ic++]=ri+verticeCount+1;
		}
		verticeCount+=2 *(slices+1);
		for (var bv=0;bv <=slices;bv++){
			if (bv===0){
				vertices[vc++]=0;
				vertices[vc++]=-halfHeight;
				vertices[vc++]=0;
				vertices[vc++]=0;
				vertices[vc++]=-1;
				vertices[vc++]=0;
				vertices[vc++]=0.5;
				vertices[vc++]=0.5;
			}
			curAngle=bv *sliceAngle;
			posX=Math.cos(curAngle+Math.PI)*radius;
			posY=-halfHeight;
			posZ=Math.sin(curAngle+Math.PI)*radius;
			vertices[vc++]=posX;
			vertices[vc++]=posY;
			vertices[vc++]=posZ;
			vertices[vc++]=0;
			vertices[vc++]=-1;
			vertices[vc++]=0;
			vertices[vc++]=0.5+Math.cos(curAngle)*0.5;
			vertices[vc++]=0.5+Math.sin(curAngle)*0.5;
		}
		for (var bi=0;bi < slices;bi++){
			indices[ic++]=0+verticeCount;
			indices[ic++]=bi+2+verticeCount;
			indices[ic++]=bi+1+verticeCount;
		}
		verticeCount+=slices+1+1;
		return PrimitiveMesh._createMesh(vertexDeclaration,vertices,indices);
	}

	PrimitiveMesh.createPlane=function(long,width,stacks,slices){
		(long===void 0)&& (long=10);
		(width===void 0)&& (width=10);
		(stacks===void 0)&& (stacks=10);
		(slices===void 0)&& (slices=10);
		var vertexCount=(stacks+1)*(slices+1);
		var indexCount=stacks *slices *2 *3;
		var indices=new Uint16Array(indexCount);
		var vertexDeclaration=VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(vertexCount *vertexFloatStride);
		var halfLong=long / 2;
		var halfWidth=width / 2;
		var stacksLong=long / stacks;
		var slicesWidth=width / slices;
		var verticeCount=0;
		for (var i=0;i <=slices;i++){
			for (var j=0;j <=stacks;j++){
				vertices[verticeCount++]=j *stacksLong-halfLong;
				vertices[verticeCount++]=0;
				vertices[verticeCount++]=i *slicesWidth-halfWidth;
				vertices[verticeCount++]=0;
				vertices[verticeCount++]=1;
				vertices[verticeCount++]=0;
				vertices[verticeCount++]=j *1 / stacks;
				vertices[verticeCount++]=i *1 / slices;
			}
		};
		var indiceIndex=0;
		for (i=0;i < slices;i++){
			for (j=0;j < stacks;j++){
				indices[indiceIndex++]=(i+1)*(stacks+1)+j;
				indices[indiceIndex++]=i *(stacks+1)+j;
				indices[indiceIndex++]=(i+1)*(stacks+1)+j+1;
				indices[indiceIndex++]=i *(stacks+1)+j;
				indices[indiceIndex++]=i *(stacks+1)+j+1;
				indices[indiceIndex++]=(i+1)*(stacks+1)+j+1;
			}
		}
		return PrimitiveMesh._createMesh(vertexDeclaration,vertices,indices);
	}

	PrimitiveMesh.createQuad=function(long,width){
		(long===void 0)&& (long=1);
		(width===void 0)&& (width=1);
		var vertexCount=4;
		var indexCount=6;
		var vertexDeclaration=VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var halfLong=long / 2;
		var halfWidth=width / 2;
		var vertices=new Float32Array([
		-halfLong,halfWidth,0,0,0,1,0,0,halfLong,halfWidth,0,0,0,1,1,0,-halfLong,-halfWidth,0,0,0,1,0,1,halfLong,-halfWidth,0,0,0,1,1,1,]);
		var indices=new Uint16Array([
		0,1,2,3,2,1,]);
		return PrimitiveMesh._createMesh(vertexDeclaration,vertices,indices);
	}

	PrimitiveMesh.createSphere=function(radius,stacks,slices){
		(radius===void 0)&& (radius=0.5);
		(stacks===void 0)&& (stacks=32);
		(slices===void 0)&& (slices=32);
		var vertexCount=(stacks+1)*(slices+1);
		var indexCount=(3 *stacks *(slices+1))*2;
		var indices=new Uint16Array(indexCount);
		var vertexDeclaration=VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(vertexCount *vertexFloatStride);
		var stackAngle=Math.PI / stacks;
		var sliceAngle=(Math.PI *2.0)/ slices;
		var vertexIndex=0;
		vertexCount=0;
		indexCount=0;
		for (var stack=0;stack < (stacks+1);stack++){
			var r=Math.sin(stack *stackAngle);
			var y=Math.cos(stack *stackAngle);
			for (var slice=0;slice < (slices+1);slice++){
				var x=r *Math.sin(slice *sliceAngle+Math.PI *1 / 2);
				var z=r *Math.cos(slice *sliceAngle+Math.PI *1 / 2);
				vertices[vertexCount+0]=x *radius;
				vertices[vertexCount+1]=y *radius;
				vertices[vertexCount+2]=z *radius;
				vertices[vertexCount+3]=x;
				vertices[vertexCount+4]=y;
				vertices[vertexCount+5]=z;
				vertices[vertexCount+6]=slice / slices;
				vertices[vertexCount+7]=stack / stacks;
				vertexCount+=vertexFloatStride;
				if (stack !=(stacks-1)){
					indices[indexCount++]=vertexIndex+(slices+1);
					indices[indexCount++]=vertexIndex;
					indices[indexCount++]=vertexIndex+1;
					indices[indexCount++]=vertexIndex+(slices);
					indices[indexCount++]=vertexIndex;
					indices[indexCount++]=vertexIndex+(slices+1);
					vertexIndex++;
				}
			}
		}
		return PrimitiveMesh._createMesh(vertexDeclaration,vertices,indices);
	}

	return PrimitiveMesh;
})()


/**
*<code>BoundBox</code> 类用于创建包围盒。
*/
//class laya.d3.math.BoundBox
var BoundBox=(function(){
	function BoundBox(min,max){
		/**最小顶点。*/
		this.min=null;
		/**最大顶点。*/
		this.max=null;
		this.min=min;
		this.max=max;
	}

	__class(BoundBox,'laya.d3.math.BoundBox');
	var __proto=BoundBox.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*获取包围盒的8个角顶点。
	*@param corners 返回顶点的输出队列。
	*/
	__proto.getCorners=function(corners){
		corners.length=8;
		var mine=this.min.elements;
		var maxe=this.max.elements;
		var minX=mine[0];
		var minY=mine[1];
		var minZ=mine[2];
		var maxX=maxe[0];
		var maxY=maxe[1];
		var maxZ=maxe[2];
		corners[0]=new Vector3(minX,maxY,maxZ);
		corners[1]=new Vector3(maxX,maxY,maxZ);
		corners[2]=new Vector3(maxX,minY,maxZ);
		corners[3]=new Vector3(minX,minY,maxZ);
		corners[4]=new Vector3(minX,maxY,minZ);
		corners[5]=new Vector3(maxX,maxY,minZ);
		corners[6]=new Vector3(maxX,minY,minZ);
		corners[7]=new Vector3(minX,minY,minZ);
	}

	__proto.toDefault=function(){
		this.min.toDefault();
		this.max.toDefault();
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		this.min.cloneTo(dest.min);
		this.max.cloneTo(dest.max);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor(new Vector3(),new Vector3());
		this.cloneTo(dest);
		return dest;
	}

	BoundBox.createfromPoints=function(points,out){
		if (points==null)
			throw new Error("points");
		var min=out.min;
		var max=out.max;
		var minE=min.elements;
		minE[0]=Number.MAX_VALUE;
		minE[1]=Number.MAX_VALUE;
		minE[2]=Number.MAX_VALUE;
		var maxE=max.elements;
		maxE[0]=-Number.MAX_VALUE;
		maxE[1]=-Number.MAX_VALUE;
		maxE[2]=-Number.MAX_VALUE;
		for (var i=0,n=points.length;i < n;++i){
			Vector3.min(min,points[i],min);
			Vector3.max(max,points[i],max);
		}
	}

	BoundBox.merge=function(box1,box2,out){
		Vector3.min(box1.min,box2.min,out.min);
		Vector3.max(box1.max,box2.max,out.max);
	}

	return BoundBox;
})()


/**
*@private
*<code>shaderVariable</code> 类用于保存shader变量上传相关信息。
*/
//class laya.d3.shader.ShaderVariable
var ShaderVariable=(function(){
	function ShaderVariable(){
		/**@private */
		//this.name=null;
		/**@private */
		//this.type=0;
		/**@private */
		//this.location=0;
		/**@private */
		//this.isArray=false;
		/**@private */
		//this.textureID=0;
		/**@private */
		//this.dataOffset=0;
		/**@private */
		//this.caller=null;
		/**@private */
		//this.fun=null;
		/**@private */
		//this.uploadedValue=null;
		this.textureID=-1;
	}

	__class(ShaderVariable,'laya.d3.shader.ShaderVariable');
	return ShaderVariable;
})()


/**
*<code>TextMesh</code> 类用于创建文本网格。
*/
//class laya.d3.text.TextMesh
var TextMesh=(function(){
	function TextMesh(){
		/**@private */
		this._vertices=null;
		/**@private */
		this._vertexBuffer=null;
		/**@private */
		this._text=null;
		/**@private */
		this._fontSize=0;
		/**@private */
		this._color=null;
	}

	__class(TextMesh,'laya.d3.text.TextMesh');
	var __proto=TextMesh.prototype;
	/**
	*@private
	*/
	__proto._createVertexBuffer=function(charCount){}
	/**
	*@private
	*/
	__proto._resizeVertexBuffer=function(charCount){}
	/**
	*@private
	*/
	__proto._addChar=function(){}
	/**
	*设置文本。
	*@param value 文本。
	*/
	/**
	*获取文本。
	*@return 文本。
	*/
	__getset(0,__proto,'text',function(){
		return this._text;
		},function(value){
		this._text=value;
	});

	/**
	*设置字体储存。
	*@return 字体尺寸。
	*/
	/**
	*获取字体尺寸。
	*@param value 字体尺寸。
	*/
	__getset(0,__proto,'fontSize',function(){
		return this._fontSize;
		},function(value){
		this._fontSize=value;
	});

	/**
	*设置颜色。
	*@param 颜色。
	*/
	/**
	*获取颜色。
	*@return 颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._color;
		},function(value){
		this._color=value;
	});

	TextMesh._indexBuffer=null;
	return TextMesh;
})()


/**
*<code>GradientRotation</code> 类用于创建渐变角速度。
*/
//class laya.d3.core.particleShuriKen.module.GradientAngularVelocity
var GradientAngularVelocity=(function(){
	function GradientAngularVelocity(){
		/**@private */
		this._type=0;
		/**@private */
		this._separateAxes=false;
		/**@private */
		this._constant=NaN;
		/**@private */
		this._constantSeparate=null;
		/**@private */
		this._gradient=null;
		/**@private */
		this._gradientX=null;
		/**@private */
		this._gradientY=null;
		/**@private */
		this._gradientZ=null;
		/**@private */
		this._gradientW=null;
		/**@private */
		this._constantMin=NaN;
		/**@private */
		this._constantMax=NaN;
		/**@private */
		this._constantMinSeparate=null;
		/**@private */
		this._constantMaxSeparate=null;
		/**@private */
		this._gradientMin=null;
		/**@private */
		this._gradientMax=null;
		/**@private */
		this._gradientXMin=null;
		/**@private */
		this._gradientXMax=null;
		/**@private */
		this._gradientYMin=null;
		/**@private */
		this._gradientYMax=null;
		/**@private */
		this._gradientZMin=null;
		/**@private */
		this._gradientZMax=null;
		/**@private */
		this._gradientWMin=null;
		/**@private */
		this._gradientWMax=null;
	}

	__class(GradientAngularVelocity,'laya.d3.core.particleShuriKen.module.GradientAngularVelocity');
	var __proto=GradientAngularVelocity.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientAngularVelocity=destObject;
		destGradientAngularVelocity._type=this._type;
		destGradientAngularVelocity._separateAxes=this._separateAxes;
		destGradientAngularVelocity._constant=this._constant;
		this._constantSeparate.cloneTo(destGradientAngularVelocity._constantSeparate);
		this._gradient.cloneTo(destGradientAngularVelocity._gradient);
		this._gradientX.cloneTo(destGradientAngularVelocity._gradientX);
		this._gradientY.cloneTo(destGradientAngularVelocity._gradientY);
		this._gradientZ.cloneTo(destGradientAngularVelocity._gradientZ);
		destGradientAngularVelocity._constantMin=this._constantMin;
		destGradientAngularVelocity._constantMax=this._constantMax;
		this._constantMinSeparate.cloneTo(destGradientAngularVelocity._constantMinSeparate);
		this._constantMaxSeparate.cloneTo(destGradientAngularVelocity._constantMaxSeparate);
		this._gradientMin.cloneTo(destGradientAngularVelocity._gradientMin);
		this._gradientMax.cloneTo(destGradientAngularVelocity._gradientMax);
		this._gradientXMin.cloneTo(destGradientAngularVelocity._gradientXMin);
		this._gradientXMax.cloneTo(destGradientAngularVelocity._gradientXMax);
		this._gradientYMin.cloneTo(destGradientAngularVelocity._gradientYMin);
		this._gradientYMax.cloneTo(destGradientAngularVelocity._gradientYMax);
		this._gradientZMin.cloneTo(destGradientAngularVelocity._gradientZMin);
		this._gradientZMax.cloneTo(destGradientAngularVelocity._gradientZMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientAngularVelocity=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientAngularVelocity);
		return destGradientAngularVelocity;
	}

	/**
	*渐变角速度Z。
	*/
	__getset(0,__proto,'gradientZ',function(){
		return this._gradientZ;
	});

	/**
	*固定角速度。
	*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*渐变角速度。
	*/
	__getset(0,__proto,'gradient',function(){
		return this._gradient;
	});

	/**
	*是否分轴。
	*/
	__getset(0,__proto,'separateAxes',function(){
		return this._separateAxes;
	});

	/**
	*生命周期角速度类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*分轴固定角速度。
	*/
	__getset(0,__proto,'constantSeparate',function(){
		return this._constantSeparate;
	});

	/**
	*渐变角角速度X。
	*/
	__getset(0,__proto,'gradientX',function(){
		return this._gradientX;
	});

	/**
	*渐变角速度Y。
	*/
	__getset(0,__proto,'gradientY',function(){
		return this._gradientY;
	});

	/**
	*渐变角速度Z。
	*/
	__getset(0,__proto,'gradientW',function(){
		return this._gradientW;
	});

	/**
	*最小渐变角速度。
	*/
	__getset(0,__proto,'gradientMin',function(){
		return this._gradientMin;
	});

	/**
	*最小随机双固定角速度。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*最大渐变角速度。
	*/
	__getset(0,__proto,'gradientMax',function(){
		return this._gradientMax;
	});

	/**
	*最大随机双固定角速度。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	/**
	*最小渐变角速度Z。
	*/
	__getset(0,__proto,'gradientWMin',function(){
		return this._gradientWMin;
	});

	/**
	*最小分轴随机双固定角速度。
	*/
	__getset(0,__proto,'constantMinSeparate',function(){
		return this._constantMinSeparate;
	});

	/**
	*最大分轴随机双固定角速度。
	*/
	__getset(0,__proto,'constantMaxSeparate',function(){
		return this._constantMaxSeparate;
	});

	/**
	*最小渐变角速度X。
	*/
	__getset(0,__proto,'gradientXMin',function(){
		return this._gradientXMin;
	});

	/**
	*最大渐变角速度X。
	*/
	__getset(0,__proto,'gradientXMax',function(){
		return this._gradientXMax;
	});

	/**
	*最大渐变角速度Z。
	*/
	__getset(0,__proto,'gradientWMax',function(){
		return this._gradientWMax;
	});

	/**
	*最小渐变角速度Y。
	*/
	__getset(0,__proto,'gradientYMin',function(){
		return this._gradientYMin;
	});

	/**
	*最大渐变角速度Y。
	*/
	__getset(0,__proto,'gradientYMax',function(){
		return this._gradientYMax;
	});

	/**
	*最小渐变角速度Z。
	*/
	__getset(0,__proto,'gradientZMin',function(){
		return this._gradientZMin;
	});

	/**
	*最大渐变角速度Z。
	*/
	__getset(0,__proto,'gradientZMax',function(){
		return this._gradientZMax;
	});

	GradientAngularVelocity.createByConstant=function(constant){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=0;
		gradientAngularVelocity._separateAxes=false;
		gradientAngularVelocity._constant=constant;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByConstantSeparate=function(separateConstant){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=0;
		gradientAngularVelocity._separateAxes=true;
		gradientAngularVelocity._constantSeparate=separateConstant;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByGradient=function(gradient){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=1;
		gradientAngularVelocity._separateAxes=false;
		gradientAngularVelocity._gradient=gradient;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByGradientSeparate=function(gradientX,gradientY,gradientZ){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=1;
		gradientAngularVelocity._separateAxes=true;
		gradientAngularVelocity._gradientX=gradientX;
		gradientAngularVelocity._gradientY=gradientY;
		gradientAngularVelocity._gradientZ=gradientZ;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByRandomTwoConstant=function(constantMin,constantMax){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=2;
		gradientAngularVelocity._separateAxes=false;
		gradientAngularVelocity._constantMin=constantMin;
		gradientAngularVelocity._constantMax=constantMax;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByRandomTwoConstantSeparate=function(separateConstantMin,separateConstantMax){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=2;
		gradientAngularVelocity._separateAxes=true;
		gradientAngularVelocity._constantMinSeparate=separateConstantMin;
		gradientAngularVelocity._constantMaxSeparate=separateConstantMax;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByRandomTwoGradient=function(gradientMin,gradientMax){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=3;
		gradientAngularVelocity._separateAxes=false;
		gradientAngularVelocity._gradientMin=gradientMin;
		gradientAngularVelocity._gradientMax=gradientMax;
		return gradientAngularVelocity;
	}

	GradientAngularVelocity.createByRandomTwoGradientSeparate=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax,gradientWMin,gradientWMax){
		var gradientAngularVelocity=new GradientAngularVelocity();
		gradientAngularVelocity._type=3;
		gradientAngularVelocity._separateAxes=true;
		gradientAngularVelocity._gradientXMin=gradientXMin;
		gradientAngularVelocity._gradientXMax=gradientXMax;
		gradientAngularVelocity._gradientYMin=gradientYMin;
		gradientAngularVelocity._gradientYMax=gradientYMax;
		gradientAngularVelocity._gradientZMin=gradientZMin;
		gradientAngularVelocity._gradientZMax=gradientZMax;
		gradientAngularVelocity._gradientWMin=gradientWMin;
		gradientAngularVelocity._gradientWMax=gradientWMax;
		return gradientAngularVelocity;
	}

	return GradientAngularVelocity;
})()


/**
*@private
*<code>DynamicBatchManager</code> 类用于管理动态批处理。
*/
//class laya.d3.graphics.DynamicBatchManager
var DynamicBatchManager=(function(){
	function DynamicBatchManager(){
		/**@private */
		//this._batchRenderElementPool=null;
		/**@private */
		//this._batchRenderElementPoolIndex=0;
		this._batchRenderElementPool=[];
	}

	__class(DynamicBatchManager,'laya.d3.graphics.DynamicBatchManager');
	var __proto=DynamicBatchManager.prototype;
	/**
	*@private
	*/
	__proto._clear=function(){
		this._batchRenderElementPoolIndex=0;
	}

	/**
	*@private
	*/
	__proto._getBatchRenderElementFromPool=function(){
		throw "StaticBatch:must override this function.";
	}

	/**
	*@private
	*/
	__proto.dispose=function(){}
	DynamicBatchManager._registerManager=function(manager){
		DynamicBatchManager._managers.push(manager);
	}

	DynamicBatchManager._managers=[];
	return DynamicBatchManager;
})()


/**
*<code>HeightMap</code> 类用于实现高度图数据。
*/
//class laya.d3.core.HeightMap
var HeightMap=(function(){
	function HeightMap(width,height,minHeight,maxHeight){
		/**@private */
		this._datas=null;
		/**@private */
		this._w=0;
		/**@private */
		this._h=0;
		/**@private */
		this._minHeight=NaN;
		/**@private */
		this._maxHeight=NaN;
		this._datas=[];
		this._w=width;
		this._h=height;
		this._minHeight=minHeight;
		this._maxHeight=maxHeight;
	}

	__class(HeightMap,'laya.d3.core.HeightMap');
	var __proto=HeightMap.prototype;
	/**@private */
	__proto._inBounds=function(row,col){
		return row >=0 && row < this._h && col >=0 && col < this._w;
	}

	/**
	*获取高度。
	*@param row 列数。
	*@param col 行数。
	*@return 高度。
	*/
	__proto.getHeight=function(row,col){
		if (this._inBounds(row,col))
			return this._datas[row][col];
		else
		return NaN;
	}

	/**
	*获取宽度。
	*@return value 宽度。
	*/
	__getset(0,__proto,'width',function(){
		return this._w;
	});

	/**
	*获取高度。
	*@return value 高度。
	*/
	__getset(0,__proto,'height',function(){
		return this._h;
	});

	/**
	*最大高度。
	*@return value 最大高度。
	*/
	__getset(0,__proto,'maxHeight',function(){
		return this._maxHeight;
	});

	/**
	*最大高度。
	*@return value 最大高度。
	*/
	__getset(0,__proto,'minHeight',function(){
		return this._minHeight;
	});

	HeightMap.creatFromMesh=function(mesh,width,height,outCellSize){
		var vertices=[];
		var indexs=[];
		var submesheCount=mesh.subMeshCount;
		for (var i=0;i < submesheCount;i++){
			var subMesh=mesh._getSubMesh(i);
			var vertexBuffer=subMesh._vertexBuffer;
			var verts=vertexBuffer.getData();
			var subMeshVertices=[];
			for (var j=0;j < verts.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
				var position=new Vector3(verts[j+0],verts[j+1],verts[j+2]);
				subMeshVertices.push(position);
			}
			vertices.push(subMeshVertices);
			var ib=subMesh._indexBuffer;
			indexs.push(ib.getData());
		};
		var boundingBox=mesh.boundingBox;
		var minX=boundingBox.min.x;
		var minZ=boundingBox.min.z;
		var maxX=boundingBox.max.x;
		var maxZ=boundingBox.max.z;
		var minY=boundingBox.min.y;
		var maxY=boundingBox.max.y;
		var widthSize=maxX-minX;
		var heightSize=maxZ-minZ;
		var cellWidth=outCellSize.elements[0]=widthSize / (width-1);
		var cellHeight=outCellSize.elements[1]=heightSize / (height-1);
		var heightMap=new HeightMap(width,height,minY,maxY);
		var ray=HeightMap._tempRay;
		var rayDirE=ray.direction.elements;
		rayDirE[0]=0;
		rayDirE[1]=-1;
		rayDirE[2]=0;
		var heightOffset=0.1;
		var rayY=maxY+heightOffset;
		ray.origin.elements[1]=rayY;
		for (var h=0;h < height;h++){
			var posZ=minZ+h *cellHeight;
			heightMap._datas[h]=[];
			for (var w=0;w < width;w++){
				var posX=minX+w *cellWidth;
				var rayOriE=ray.origin.elements;
				rayOriE[0]=posX;
				rayOriE[2]=posZ;
				var closestIntersection=HeightMap._getPosition(ray,vertices,indexs);
				heightMap._datas[h][w]=(closestIntersection===Number.MAX_VALUE)? NaN :rayY-closestIntersection;
			}
		}
		return heightMap;
	}

	HeightMap.createFromImage=function(texture,minHeight,maxHeight){
		var textureWidth=texture.width;
		var textureHeight=texture.height;
		var heightMap=new HeightMap(textureWidth,textureHeight,minHeight,maxHeight);
		var compressionRatio=(maxHeight-minHeight)/ 254;
		var pixelsInfo=texture.getPixels();
		var index=0;
		for (var h=0;h <textureHeight;h++){
			var colDatas=heightMap._datas[h]=[];
			for (var w=0;w < textureWidth;w++){
				var r=pixelsInfo[index++];
				var g=pixelsInfo[index++];
				var b=pixelsInfo[index++];
				var a=pixelsInfo[index++];
				if (r==255 && g==255 && b==255 && a==255)
					colDatas[w]=NaN;
				else {
					colDatas[w]=(r+g+b)/ 3 *compressionRatio+minHeight;
				}
			}
		}
		return heightMap;
	}

	HeightMap._getPosition=function(ray,vertices,indexs){
		var closestIntersection=Number.MAX_VALUE;
		for (var i=0;i < vertices.length;i++){
			var subMeshVertices=vertices[i];
			var subMeshIndexes=indexs[i];
			for (var j=0;j < subMeshIndexes.length;j+=3){
				var vertex1=subMeshVertices[subMeshIndexes[j+0]];
				var vertex2=subMeshVertices[subMeshIndexes[j+1]];
				var vertex3=subMeshVertices[subMeshIndexes[j+2]];
				var intersection=Picker.rayIntersectsTriangle(ray,vertex1,vertex2,vertex3);
				if (!isNaN(intersection)&& intersection < closestIntersection){
					closestIntersection=intersection;
				}
			}
		}
		return closestIntersection;
	}

	__static(HeightMap,
	['_tempRay',function(){return this._tempRay=new Ray(new Vector3(),new Vector3());}
	]);
	return HeightMap;
})()


/**
*<code>BaseVector</code> 抽象类，类用于向量的父类。
*/
//class laya.d3.math.BaseVector
var BaseVector=(function(){
	function BaseVector(){
		/**[只读]向量元素集合。*/
		this.elements=null;
	}

	__class(BaseVector,'laya.d3.math.BaseVector');
	return BaseVector;
})()


/**
*<code>DefineDatas</code> 类用于创建宏定义数据。
*/
//class laya.d3.shader.DefineDatas
var DefineDatas=(function(){
	function DefineDatas(){
		/**@private [只读]*/
		//this.value=0;
		this.value=0;
	}

	__class(DefineDatas,'laya.d3.shader.DefineDatas');
	var __proto=DefineDatas.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加Shader宏定义。
	*@param value 宏定义。
	*/
	__proto.add=function(define){
		this.value |=define;
	}

	/**
	*移除Shader宏定义。
	*@param value 宏定义。
	*/
	__proto.remove=function(define){
		this.value &=~define;
	}

	/**
	*是否包含Shader宏定义。
	*@param value 宏定义。
	*/
	__proto.has=function(define){
		return (this.value & define)> 0;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destDefineData=destObject;
		destDefineData.value=this.value;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	return DefineDatas;
})()


/**
*...
*@author
*/
//class laya.d3.core.pixelLine.PixelLineVertex
var PixelLineVertex=(function(){
	function PixelLineVertex(){}
	__class(PixelLineVertex,'laya.d3.core.pixelLine.PixelLineVertex');
	var __proto=PixelLineVertex.prototype;
	__getset(0,__proto,'vertexDeclaration',function(){
		return PixelLineVertex._vertexDeclaration;
	});

	__getset(1,PixelLineVertex,'vertexDeclaration',function(){
		return PixelLineVertex._vertexDeclaration;
	});

	__static(PixelLineVertex,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(28,
		[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1)]);}
	]);
	return PixelLineVertex;
})()


/**
*<code>SizeOverLifetime</code> 类用于粒子的生命周期尺寸。
*/
//class laya.d3.core.particleShuriKen.module.SizeOverLifetime
var SizeOverLifetime=(function(){
	function SizeOverLifetime(size){
		/**@private */
		this._size=null;
		/**是否启用*/
		this.enbale=false;
		this._size=size;
	}

	__class(SizeOverLifetime,'laya.d3.core.particleShuriKen.module.SizeOverLifetime');
	var __proto=SizeOverLifetime.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destSizeOverLifetime=destObject;
		this._size.cloneTo(destSizeOverLifetime._size);
		destSizeOverLifetime.enbale=this.enbale;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destSize;
		switch (this._size.type){
			case 0:
				if (this._size.separateAxes)
					destSize=GradientSize.createByGradientSeparate(this._size.gradientX.clone(),this._size.gradientY.clone(),this._size.gradientZ.clone());
				else
				destSize=GradientSize.createByGradient(this._size.gradient.clone());
				break ;
			case 1:
				if (this._size.separateAxes)
					destSize=GradientSize.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(),this._size.constantMaxSeparate.clone());
				else
				destSize=GradientSize.createByRandomTwoConstant(this._size.constantMin,this._size.constantMax);
				break ;
			case 2:
				if (this._size.separateAxes)
					destSize=GradientSize.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(),this._size.gradientYMin.clone(),this._size.gradientZMin.clone(),this._size.gradientXMax.clone(),this._size.gradientYMax.clone(),this._size.gradientZMax.clone());
				else
				destSize=GradientSize.createByRandomTwoGradient(this._size.gradientMin.clone(),this._size.gradientMax.clone());
				break ;
			};
		var destSizeOverLifetime=/*__JS__ */new this.constructor(destSize);
		destSizeOverLifetime.enbale=this.enbale;
		return destSizeOverLifetime;
	}

	/**
	*获取尺寸。
	*/
	__getset(0,__proto,'size',function(){
		return this._size;
	});

	return SizeOverLifetime;
})()


/**
*<code>Picker</code> 类用于创建拾取。
*/
//class laya.d3.utils.Picker
var Picker=(function(){
	/**
	*创建一个 <code>Picker</code> 实例。
	*/
	function Picker(){}
	__class(Picker,'laya.d3.utils.Picker');
	Picker.calculateCursorRay=function(point,viewPort,projectionMatrix,viewMatrix,world,out){
		var x=point.elements[0];
		var y=point.elements[1];
		var nearSource=Picker._tempVector30;
		var nerSourceE=nearSource.elements;
		nerSourceE[0]=x;
		nerSourceE[1]=y;
		nerSourceE[2]=viewPort.minDepth;
		var farSource=Picker._tempVector31;
		var farSourceE=farSource.elements;
		farSourceE[0]=x;
		farSourceE[1]=y;
		farSourceE[2]=viewPort.maxDepth;
		var nearPoint=out.origin;
		var farPoint=Picker._tempVector32;
		viewPort.unprojectFromWVP(nearSource,projectionMatrix,viewMatrix,world,nearPoint);
		viewPort.unprojectFromWVP(farSource,projectionMatrix,viewMatrix,world,farPoint);
		var outDire=out.direction.elements;
		outDire[0]=farPoint.x-nearPoint.x;
		outDire[1]=farPoint.y-nearPoint.y;
		outDire[2]=farPoint.z-nearPoint.z;
		Vector3.normalize(out.direction,out.direction);
	}

	Picker.rayIntersectsTriangle=function(ray,vertex1,vertex2,vertex3){
		var result;
		var edge1=Picker._tempVector30,edge2=Picker._tempVector31;
		Vector3.subtract(vertex2,vertex1,edge1);
		Vector3.subtract(vertex3,vertex1,edge2);
		var directionCrossEdge2=Picker._tempVector32;
		Vector3.cross(ray.direction,edge2,directionCrossEdge2);
		var determinant;
		determinant=Vector3.dot(edge1,directionCrossEdge2);
		if (determinant >-Number.MIN_VALUE && determinant < Number.MIN_VALUE){
			result=Number.NaN;
			return result;
		};
		var inverseDeterminant=1.0 / determinant;
		var distanceVector=Picker._tempVector33;
		Vector3.subtract(ray.origin,vertex1,distanceVector);
		var triangleU;
		triangleU=Vector3.dot(distanceVector,directionCrossEdge2);
		triangleU *=inverseDeterminant;
		if (triangleU < 0 || triangleU > 1){
			result=Number.NaN;
			return result;
		};
		var distanceCrossEdge1=Picker._tempVector34;
		Vector3.cross(distanceVector,edge1,distanceCrossEdge1);
		var triangleV;
		triangleV=Vector3.dot(ray.direction,distanceCrossEdge1);
		triangleV *=inverseDeterminant;
		if (triangleV < 0 || triangleU+triangleV > 1){
			result=Number.NaN;
			return result;
		};
		var rayDistance;
		rayDistance=Vector3.dot(edge2,distanceCrossEdge1);
		rayDistance *=inverseDeterminant;
		if (rayDistance < 0){
			result=Number.NaN;
			return result;
		}
		result=rayDistance;
		return result;
	}

	__static(Picker,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempVector34',function(){return this._tempVector34=new Vector3();}
	]);
	return Picker;
})()


/**
*<code>PhysicsSettings</code> 类用于创建物理配置信息。
*/
//class laya.d3.physics.PhysicsSettings
var PhysicsSettings=(function(){
	function PhysicsSettings(){
		/**标志集合。*/
		this.flags=0;
		/**物理引擎在一帧中用于补偿减速的最大次数。*/
		this.maxSubSteps=1;
		/**物理模拟器帧的间隔时间。*/
		this.fixedTimeStep=1.0 / 60.0;
	}

	__class(PhysicsSettings,'laya.d3.physics.PhysicsSettings');
	return PhysicsSettings;
})()


/**
*<code>OrientedBoundBox</code> 类用于创建OBB包围盒。
*/
//class laya.d3.math.OrientedBoundBox
var OrientedBoundBox=(function(){
	function OrientedBoundBox(extents,transformation){
		/**每个轴长度的一半*/
		this.extents=null;
		/**这个矩阵表示包围盒的位置和缩放,它的平移向量表示该包围盒的中心*/
		this.transformation=null;
		this.extents=extents;
		this.transformation=transformation;
	}

	__class(OrientedBoundBox,'laya.d3.math.OrientedBoundBox');
	var __proto=OrientedBoundBox.prototype;
	/**
	*获取OBB包围盒的8个顶点。
	*@param corners 返回顶点的输出队列。
	*/
	__proto.getCorners=function(corners){
		var xve=OrientedBoundBox._tempV30.elements;
		var yve=OrientedBoundBox._tempV31.elements;
		var zve=OrientedBoundBox._tempV32.elements;
		var extentsE=this.extents.elements;
		xve[0]=extentsE[0];
		xve[1]=xve[2]=0;
		yve[1]=extentsE[1];
		yve[0]=yve[2]=0;
		zve[2]=extentsE[2];
		zve[0]=zve[1]=0;
		Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
		Vector3.TransformNormal(OrientedBoundBox._tempV32,this.transformation,OrientedBoundBox._tempV32);
		var center=OrientedBoundBox._tempV33;
		this.transformation.getTranslationVector(center);
		corners.length=8;
		Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[0]);
		Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[1]);
		Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[2]);
		Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[3]);
		Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[4]);
		Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[5]);
		Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[6]);
		Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
		Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[7]);
	}

	/**
	*变换该包围盒的矩阵信息。
	*@param mat 矩阵
	*/
	__proto.transform=function(mat){
		Matrix4x4.multiply(this.transformation,mat,this.transformation);
	}

	/**
	*缩放该包围盒
	*@param scaling 各轴的缩放比。
	*/
	__proto.scale=function(scaling){
		Vector3.multiply(this.extents,scaling,this.extents);
	}

	/**
	*平移该包围盒。
	*@param translation 平移参数
	*/
	__proto.translate=function(translation){
		this.transformation.getTranslationVector(OrientedBoundBox._tempV30);
		Vector3.add(OrientedBoundBox._tempV30,translation,OrientedBoundBox._tempV31);
		this.transformation.setTranslationVector(OrientedBoundBox._tempV31);
	}

	/**
	*该包围盒的尺寸。
	*@param out 输出
	*/
	__proto.Size=function(out){
		Vector3.scale(this.extents,2,out);
	}

	/**
	*该包围盒需要考虑的尺寸
	*@param out 输出
	*/
	__proto.getSize=function(out){
		var extentsE=this.extents.elements;
		OrientedBoundBox._tempV30.x=extentsE[0];
		OrientedBoundBox._tempV31.y=extentsE[1];
		OrientedBoundBox._tempV32.z=extentsE[2];
		Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV32);
		var oe=out.elements;
		oe[0]=Vector3.scalarLength(OrientedBoundBox._tempV30);
		oe[1]=Vector3.scalarLength(OrientedBoundBox._tempV31);
		oe[2]=Vector3.scalarLength(OrientedBoundBox._tempV32);
	}

	/**
	*该包围盒需要考虑尺寸的平方
	*@param out 输出
	*/
	__proto.getSizeSquared=function(out){
		var extentsE=this.extents.elements;
		OrientedBoundBox._tempV30.x=extentsE[0];
		OrientedBoundBox._tempV31.y=extentsE[1];
		OrientedBoundBox._tempV32.z=extentsE[2];
		Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
		Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV32);
		var oe=out.elements;
		oe[0]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV30);
		oe[1]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV31);
		oe[2]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV32);
	}

	/**
	*该包围盒的几何中心
	*/
	__proto.getCenter=function(center){
		this.transformation.getTranslationVector(center);
	}

	/**
	*该包围盒是否包含空间中一点
	*@param point 点
	*@return 返回位置关系
	*/
	__proto.containsPoint=function(point){
		var extentsE=this.extents.elements;
		var extentsEX=extentsE[0];
		var extentsEY=extentsE[1];
		var extentsEZ=extentsE[2];
		this.transformation.invert(OrientedBoundBox._tempM0);
		Vector3.transformCoordinate(point,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
		var _tempV30e=OrientedBoundBox._tempV30.elements;
		var _tempV30ex=Math.abs(_tempV30e[0]);
		var _tempV30ey=Math.abs(_tempV30e[1]);
		var _tempV30ez=Math.abs(_tempV30e[2]);
		if (MathUtils3D.nearEqual(_tempV30ex,extentsEX)&& MathUtils3D.nearEqual(_tempV30ey,extentsEY)&& MathUtils3D.nearEqual(_tempV30ez,extentsEZ))
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		if (_tempV30ex < extentsEX && _tempV30ey < extentsEY && _tempV30ez < extentsEZ)
			return /*laya.d3.math.ContainmentType.Contains*/1;
		else
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	/**
	*该包围盒是否包含空间中多点
	*@param point 点
	*@return 返回位置关系
	*/
	__proto.containsPoints=function(points){
		var extentse=this.extents.elements;
		var extentsex=extentse[0];
		var extentsey=extentse[1];
		var extentsez=extentse[2];
		this.transformation.invert(OrientedBoundBox._tempM0);
		var containsAll=true;
		var containsAny=false;
		for (var i=0;i < points.length;i++){
			Vector3.transformCoordinate(points[i],OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
			var _tempV30e=OrientedBoundBox._tempV30.elements;
			var _tempV30ex=Math.abs(_tempV30e[0]);
			var _tempV30ey=Math.abs(_tempV30e[1]);
			var _tempV30ez=Math.abs(_tempV30e[2]);
			if (MathUtils3D.nearEqual(_tempV30ex,extentsex)&& MathUtils3D.nearEqual(_tempV30ey,extentsey)&& MathUtils3D.nearEqual(_tempV30ez,extentsez))
				containsAny=true;
			if (_tempV30ex < extentsex && _tempV30ey < extentsey && _tempV30ez < extentsez)
				containsAny=true;
			else
			containsAll=false;
		}
		if (containsAll)
			return /*laya.d3.math.ContainmentType.Contains*/1;
		else if (containsAny)
		return /*laya.d3.math.ContainmentType.Intersects*/2;
		else
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	/**
	*该包围盒是否包含空间中一包围球
	*@param sphere 包围球
	*@param ignoreScale 是否考虑该包围盒的缩放
	*@return 返回位置关系
	*/
	__proto.containsSphere=function(sphere,ignoreScale){
		(ignoreScale===void 0)&& (ignoreScale=false);
		var extentsE=this.extents.elements;
		var extentsEX=extentsE[0];
		var extentsEY=extentsE[1];
		var extentsEZ=extentsE[2];
		var sphereR=sphere.radius;
		this.transformation.invert(OrientedBoundBox._tempM0);
		Vector3.transformCoordinate(sphere.center,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
		var locRadius=NaN;
		if (ignoreScale){
			locRadius=sphereR;
			}else {
			Vector3.scale(Vector3.UnitX,sphereR,OrientedBoundBox._tempV31);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0,OrientedBoundBox._tempV31);
			locRadius=Vector3.scalarLength(OrientedBoundBox._tempV31);
		}
		Vector3.scale(this.extents,-1,OrientedBoundBox._tempV32);
		Vector3.Clamp(OrientedBoundBox._tempV30,OrientedBoundBox._tempV32,this.extents,OrientedBoundBox._tempV33);
		var distance=Vector3.distanceSquared(OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
		if (distance > locRadius *locRadius)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		var tempV30e=OrientedBoundBox._tempV30.elements;
		var tempV30ex=tempV30e[0];
		var tempV30ey=tempV30e[1];
		var tempV30ez=tempV30e[2];
		var tempV32e=OrientedBoundBox._tempV32.elements;
		var tempV32ex=tempV32e[0];
		var tempV32ey=tempV32e[1];
		var tempV32ez=tempV32e[2];
		if ((((tempV32ex+locRadius <=tempV30ex)&& (tempV30ex <=extentsEX-locRadius))&& ((extentsEX-tempV32ex > locRadius)&& (tempV32ey+locRadius <=tempV30ey)))&& (((tempV30ey <=extentsEY-locRadius)&& (extentsEY-tempV32ey > locRadius))&& (((tempV32ez+locRadius <=tempV30ez)&& (tempV30ez <=extentsEZ-locRadius))&& (extentsEZ-tempV32ez > locRadius)))){
			return /*laya.d3.math.ContainmentType.Contains*/1;
		}
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	/**
	*For accuracy,The transformation matrix for both <see cref="OrientedBoundingBox"/> must not have any scaling applied to it.
	*Anyway,scaling using Scale method will keep this method accurate.
	*该包围盒是否包含空间中另一OBB包围盒
	*@param obb OBB包围盒
	*@return 返回位置关系
	*/
	__proto.containsOrientedBoundBox=function(obb){
		var i=0,k=0;
		obb.getCorners(OrientedBoundBox._corners);
		var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
		if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
			return cornersCheck;
		var sizeAe=this.extents.elements;
		obb.extents.cloneTo(OrientedBoundBox._tempV35);
		var sizeBe=OrientedBoundBox._tempV35.elements;
		OrientedBoundBox._getRows(this.transformation,OrientedBoundBox._rows1);
		OrientedBoundBox._getRows(obb.transformation,OrientedBoundBox._rows2);
		var extentA=NaN,extentB=NaN,separation=NaN,dotNumber=NaN;
		for (i=0;i < 4;i++){
			for (k=0;k < 4;k++){
				if (i==3 || k==3){
					OrientedBoundBox._tempM0.setElementByRowColumn(i,k,0);
					OrientedBoundBox._tempM1.setElementByRowColumn(i,k,0);
					}else {
					dotNumber=Vector3.dot(OrientedBoundBox._rows1[i],OrientedBoundBox._rows2[k]);
					OrientedBoundBox._tempM0.setElementByRowColumn(i,k,dotNumber);
					OrientedBoundBox._tempM1.setElementByRowColumn(i,k,Math.abs(dotNumber));
				}
			}
		}
		obb.getCenter(OrientedBoundBox._tempV34);
		this.getCenter(OrientedBoundBox._tempV36);
		Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV36,OrientedBoundBox._tempV30);
		var vsepAe=OrientedBoundBox._tempV31.elements;
		vsepAe[0]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[0]);
		vsepAe[1]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[1]);
		vsepAe[2]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[2]);
		var _tempV32e=OrientedBoundBox._tempV32.elements;
		var _tempV33e=OrientedBoundBox._tempV33.elements;
		for (i=0;i < 3;i++){
			_tempV32e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(i,0);
			_tempV32e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(i,1);
			_tempV32e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(i,2);
			extentA=sizeAe[i];
			extentB=Vector3.dot(OrientedBoundBox._tempV35,OrientedBoundBox._tempV32);
			separation=Math.abs(vsepAe[i]);
			if (separation > extentA+extentB)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}
		for (k=0;k < 3;k++){
			_tempV32e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(0,k);
			_tempV32e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(1,k);
			_tempV32e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(2,k);
			_tempV33e[0]=OrientedBoundBox._tempM0.getElementByRowColumn(0,k);
			_tempV33e[1]=OrientedBoundBox._tempM0.getElementByRowColumn(1,k);
			_tempV33e[2]=OrientedBoundBox._tempM0.getElementByRowColumn(2,k);
			extentA=Vector3.dot(this.extents,OrientedBoundBox._tempV32);
			extentB=sizeBe[k];
			separation=Math.abs(Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV33));
			if (separation > extentA+extentB)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}
		for (i=0;i < 3;i++){
			for (k=0;k < 3;k++){
				var i1=(i+1)% 3,i2=(i+2)% 3;
				var k1=(k+1)% 3,k2=(k+2)% 3;
				extentA=sizeAe[i1] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k)+sizeAe[i2] *OrientedBoundBox._tempM1.getElementByRowColumn(i1,k);
				extentB=sizeBe[k1] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k2)+sizeBe[k2] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k1);
				separation=Math.abs(vsepAe[i2] *OrientedBoundBox._tempM0.getElementByRowColumn(i1,k)-vsepAe[i1] *OrientedBoundBox._tempM0.getElementByRowColumn(i2,k));
				if (separation > extentA+extentB)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
			}
		}
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	/**
	*该包围盒是否包含空间中一条线
	*@param point1 点1
	*@param point2 点2
	*@return 返回位置关系
	*/
	__proto.containsLine=function(point1,point2){
		OrientedBoundBox._corners[0]=point1;
		OrientedBoundBox._corners[1]=point2;
		var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
		if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
			return cornersCheck;
		var extentsE=this.extents.elements;
		var extentsX=extentsE[0];
		var extentsY=extentsE[1];
		var extentsZ=extentsE[2];
		this.transformation.invert(OrientedBoundBox._tempM0);
		Vector3.transformCoordinate(point1,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
		Vector3.transformCoordinate(point2,OrientedBoundBox._tempM0,OrientedBoundBox._tempV31);
		Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
		Vector3.scale(OrientedBoundBox._tempV32,0.5,OrientedBoundBox._tempV32);
		Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV32,OrientedBoundBox._tempV33);
		var _tempV33e=OrientedBoundBox._tempV33.elements;
		var _tempV33X=_tempV33e[0];
		var _tempV33Y=_tempV33e[1];
		var _tempV33Z=_tempV33e[2];
		var _tempV34e=OrientedBoundBox._tempV34.elements;
		var _tempV34X=_tempV34e[0]=Math.abs(_tempV33e[0]);
		var _tempV34Y=_tempV34e[1]=Math.abs(_tempV33e[1]);
		var _tempV34Z=_tempV34e[2]=Math.abs(_tempV33e[2]);
		var _tempV32e=OrientedBoundBox._tempV32.elements;
		var _tempV32X=_tempV32e[0];
		var _tempV32Y=_tempV32e[1];
		var _tempV32Z=_tempV32e[2];
		if (Math.abs(_tempV32X)> extentsX+_tempV34X)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32Y)> extentsY+_tempV34Y)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32Z)> extentsZ+_tempV34Z)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32Y *_tempV33Z-_tempV32Z *_tempV33Y)> (extentsY *_tempV34Z+extentsZ *_tempV34Y))
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32X *_tempV33Z-_tempV32Z *_tempV33X)> (extentsX *_tempV34Z+extentsZ *_tempV34X))
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (Math.abs(_tempV32X *_tempV33Y-_tempV32Y *_tempV33X)> (extentsX *_tempV34Y+extentsY *_tempV34X))
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	/**
	*该包围盒是否包含空间中另一OBB包围盒
	*@param box 包围盒
	*@return 返回位置关系
	*/
	__proto.containsBoundBox=function(box){
		var i=0,k=0;
		var min=box.min;
		var max=box.max;
		box.getCorners(OrientedBoundBox._corners);
		var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
		if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
			return cornersCheck;
		Vector3.subtract(max,min,OrientedBoundBox._tempV30);
		Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
		Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV30);
		Vector3.subtract(max,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
		var sizeAe=this.extents.elements;
		var sizeBe=OrientedBoundBox._tempV31.elements;
		OrientedBoundBox._getRows(this.transformation,OrientedBoundBox._rows1);
		this.transformation.invert(OrientedBoundBox._tempM0);
		var extentA=NaN,extentB=NaN,separation=NaN,dotNumber=NaN;
		for (i=0;i < 3;i++){
			for (k=0;k < 3;k++){
				OrientedBoundBox._tempM1.setElementByRowColumn(i,k,Math.abs(OrientedBoundBox._tempM0.getElementByRowColumn(i,k)));
			}
		}
		this.getCenter(OrientedBoundBox._tempV35);
		Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV35,OrientedBoundBox._tempV32);
		var vsepAe=OrientedBoundBox._tempV31.elements;
		vsepAe[0]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[0]);
		vsepAe[1]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[1]);
		vsepAe[2]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[2]);
		var _tempV33e=OrientedBoundBox._tempV33.elements;
		var _tempV34e=OrientedBoundBox._tempV34.elements;
		for (i=0;i < 3;i++){
			_tempV33e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(i,0);
			_tempV33e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(i,1);
			_tempV33e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(i,2);
			extentA=sizeAe[i];
			extentB=Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			separation=Math.abs(vsepAe[i]);
			if (separation > extentA+extentB)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}
		for (k=0;k < 3;k++){
			_tempV33e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(0,k);
			_tempV33e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(1,k);
			_tempV33e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(2,k);
			_tempV34e[0]=OrientedBoundBox._tempM0.getElementByRowColumn(0,k);
			_tempV34e[1]=OrientedBoundBox._tempM0.getElementByRowColumn(1,k);
			_tempV34e[2]=OrientedBoundBox._tempM0.getElementByRowColumn(2,k);
			extentA=Vector3.dot(this.extents,OrientedBoundBox._tempV33);
			extentB=sizeBe[k];
			separation=Math.abs(Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV34));
			if (separation > extentA+extentB)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}
		for (i=0;i < 3;i++){
			for (k=0;k < 3;k++){
				var i1=(i+1)% 3,i2=(i+2)% 3;
				var k1=(k+1)% 3,k2=(k+2)% 3;
				extentA=sizeAe[i1] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k)+sizeAe[i2] *OrientedBoundBox._tempM1.getElementByRowColumn(i1,k);
				extentB=sizeBe[k1] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k2)+sizeBe[k2] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k1);
				separation=Math.abs(vsepAe[i2] *OrientedBoundBox._tempM0.getElementByRowColumn(i1,k)-vsepAe[i1] *OrientedBoundBox._tempM0.getElementByRowColumn(i2,k));
				if (separation > extentA+extentB)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
			}
		}
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	/**
	*该包围盒是否与空间中另一射线相交
	*@param ray
	*@param out
	*@return
	*/
	__proto.intersectsRay=function(ray,out){
		Vector3.scale(this.extents,-1,OrientedBoundBox._tempV30);
		this.transformation.invert(OrientedBoundBox._tempM0);
		Vector3.TransformNormal(ray.direction,OrientedBoundBox._tempM0,OrientedBoundBox._ray.direction);
		Vector3.transformCoordinate(ray.origin,OrientedBoundBox._tempM0,OrientedBoundBox._ray.origin);
		OrientedBoundBox._boxBound1.min=OrientedBoundBox._tempV30;
		OrientedBoundBox._boxBound1.max=this.extents;
		var intersects=CollisionUtils.intersectsRayAndBoxRP(OrientedBoundBox._ray,OrientedBoundBox._boxBound1,out);
		if (intersects!==-1)
			Vector3.transformCoordinate(out,this.transformation,out);
		return intersects;
	}

	__proto._getLocalCorners=function(corners){
		corners.length=8;
		var extentsE=this.extents.elements;
		OrientedBoundBox._tempV30.x=extentsE[0];
		OrientedBoundBox._tempV31.y=extentsE[1];
		OrientedBoundBox._tempV32.z=extentsE[2];
		Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
		Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[0]);
		Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
		Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[1]);
		Vector3.subtract(OrientedBoundBox._tempV31,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
		Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV30,corners[2]);
		Vector3.subtract(OrientedBoundBox._tempV31,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
		Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[3]);
		Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
		Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[4]);
		Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
		Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[5]);
		Vector3.scale(corners[0],-1,corners[6]);
		Vector3.subtract(OrientedBoundBox._tempV32,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
		Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV31,corners[7]);
	}

	/**
	*判断两个包围盒是否相等
	*@param obb obb包围盒
	*@return Boolean
	*/
	__proto.equals=function(obb){
		return this.extents==obb.extents && this.transformation==obb.transformation;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		this.extents.cloneTo(dest.extents);
		this.transformation.cloneTo(dest.transformation);
	}

	OrientedBoundBox.createByBoundBox=function(box,out){
		var min=box.min;
		var max=box.max;
		Vector3.subtract(max,min,OrientedBoundBox._tempV30);
		Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
		Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
		Vector3.subtract(max,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
		Matrix4x4.translation(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0);
		var extents=OrientedBoundBox._tempV32.clone();
		var transformation=OrientedBoundBox._tempM0.clone();
		out.extents=extents;
		out.transformation=transformation;
	}

	OrientedBoundBox.createByMinAndMaxVertex=function(min,max){
		Vector3.subtract(max,min,OrientedBoundBox._tempV30);
		Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
		Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
		Vector3.subtract(max,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
		Matrix4x4.translation(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0);
		var obb=new OrientedBoundBox(OrientedBoundBox._tempV32,OrientedBoundBox._tempM0);
		return obb;
	}

	OrientedBoundBox._getRows=function(mat,out){
		out.length=3;
		var mate=mat.elements;
		var row0e=out[0].elements;
		row0e[0]=mate[0];
		row0e[1]=mate[1];
		row0e[2]=mate[2];
		var row1e=out[1].elements;
		row1e[0]=mate[4];
		row1e[1]=mate[5];
		row1e[2]=mate[6];
		var row2e=out[2].elements;
		row2e[0]=mate[8];
		row2e[1]=mate[9];
		row2e[2]=mate[10];
	}

	OrientedBoundBox.getObbtoObbMatrix4x4=function(a,b,noMatrixScaleApplied,out){
		var at=a.transformation;
		var bt=b.transformation;
		if (noMatrixScaleApplied){
			OrientedBoundBox._getRows(at,OrientedBoundBox._rows1);
			OrientedBoundBox._getRows(bt,OrientedBoundBox._rows2);
			for (var i=0;i < 3;i++){
				for (var k=0;k < 3;k++){
					out.setElementByRowColumn(i,k,Vector3.dot(OrientedBoundBox._rows2[i],OrientedBoundBox._rows1[k]));
				}
			}
			b.getCenter(OrientedBoundBox._tempV30);
			a.getCenter(OrientedBoundBox._tempV31);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
			var AtoBMe=out.elements;
			AtoBMe[12]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[0]);
			AtoBMe[13]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[1]);
			AtoBMe[14]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[2]);
			AtoBMe[15]=1;
			}else {
			at.invert(OrientedBoundBox._tempM0);
			Matrix4x4.multiply(bt,OrientedBoundBox._tempM0,out);
		}
	}

	OrientedBoundBox.merge=function(a,b,noMatrixScaleApplied){
		var ae=a.extents;
		var at=a.transformation;
		OrientedBoundBox.getObbtoObbMatrix4x4(a,b,noMatrixScaleApplied,OrientedBoundBox._tempM0);
		b._getLocalCorners(OrientedBoundBox._corners);
		Vector3.transformCoordinate(OrientedBoundBox._corners[0],OrientedBoundBox._tempM0,OrientedBoundBox._corners[0]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[1],OrientedBoundBox._tempM0,OrientedBoundBox._corners[1]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[2],OrientedBoundBox._tempM0,OrientedBoundBox._corners[2]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[3],OrientedBoundBox._tempM0,OrientedBoundBox._corners[3]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[4],OrientedBoundBox._tempM0,OrientedBoundBox._corners[4]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[5],OrientedBoundBox._tempM0,OrientedBoundBox._corners[5]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[6],OrientedBoundBox._tempM0,OrientedBoundBox._corners[6]);
		Vector3.transformCoordinate(OrientedBoundBox._corners[7],OrientedBoundBox._tempM0,OrientedBoundBox._corners[7]);
		Vector3.scale(ae,-1,OrientedBoundBox._boxBound1.min);
		ae.cloneTo(OrientedBoundBox._boxBound1.max);
		BoundBox.createfromPoints(OrientedBoundBox._corners,OrientedBoundBox._boxBound2);
		BoundBox.merge(OrientedBoundBox._boxBound2,OrientedBoundBox._boxBound1,OrientedBoundBox._boxBound3);
		var box3Min=OrientedBoundBox._boxBound3.min;
		var box3Max=OrientedBoundBox._boxBound3.max;
		Vector3.subtract(box3Max,box3Min,OrientedBoundBox._tempV30);
		Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
		Vector3.add(box3Min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV32);
		Vector3.subtract(box3Max,OrientedBoundBox._tempV32,ae);
		Vector3.transformCoordinate(OrientedBoundBox._tempV32,at,OrientedBoundBox._tempV33);
	}

	__static(OrientedBoundBox,
	['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempM0',function(){return this._tempM0=new Matrix4x4();},'_tempM1',function(){return this._tempM1=new Matrix4x4();},'_corners',function(){return this._corners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];},'_rows1',function(){return this._rows1=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3()];},'_rows2',function(){return this._rows2=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3()];},'_ray',function(){return this._ray=new Ray(new Vector3(),new Vector3());},'_boxBound1',function(){return this._boxBound1=new BoundBox(new Vector3(),new Vector3());},'_boxBound2',function(){return this._boxBound2=new BoundBox(new Vector3(),new Vector3());},'_boxBound3',function(){return this._boxBound3=new BoundBox(new Vector3(),new Vector3());}
	]);
	return OrientedBoundBox;
})()


/**
*<code>SubShader</code> 类用于创建SubShader。
*/
//class laya.d3.shader.SubShader
var SubShader=(function(){
	function SubShader(attributeMap,uniformMap,spriteDefines,materialDefines){
		/**@private */
		this._attributeMap=null;
		/**@private */
		this._uniformMap=null;
		/**@private */
		this._publicDefines=null;
		/**@private */
		this._publicDefinesMap=null;
		/**@private */
		this._spriteDefines=null;
		/**@private */
		this._spriteDefinesMap=null;
		/**@private */
		this._materialDefines=null;
		/**@private */
		this._materialDefinesMap=null;
		/**@private */
		this._owner=null;
		/**@private */
		this._flags={};
		this._passes=[];
		this._publicDefines=[];
		this._publicDefinesMap={};
		this._spriteDefines=[];
		this._spriteDefinesMap={};
		this._materialDefines=[];
		this._materialDefinesMap={};
		this._addDefines(this._publicDefines,this._publicDefinesMap,Shader3D._globleDefines);
		(spriteDefines)&& (this._addDefines(this._spriteDefines,this._spriteDefinesMap,spriteDefines.defines));
		(materialDefines)&& (this._addDefines(this._materialDefines,this._materialDefinesMap,materialDefines.defines));
		this._attributeMap=attributeMap;
		this._uniformMap=uniformMap;
	}

	__class(SubShader,'laya.d3.shader.SubShader');
	var __proto=SubShader.prototype;
	/**
	*@private
	*/
	__proto._addDefines=function(defines,definesMap,supportDefines){
		for (var k in supportDefines){
			var name=supportDefines[k];
			var i=parseInt(k);
			defines[i]=name;
			definesMap[name]=i;
		}
	}

	/**
	*通过名称获取宏定义值。
	*@param name 名称。
	*@return 宏定义值。
	*/
	__proto.getMaterialDefineByName=function(name){
		return this._materialDefinesMap[name];
	}

	/**
	*添加标记。
	*@param key 标记键。
	*@param value 标记值。
	*/
	__proto.setFlag=function(key,value){
		if (value)
			this._flags[key]=value;
		else
		delete this._flags[key];
	}

	/**
	*获取标记值。
	*@return key 标记键。
	*/
	__proto.getFlag=function(key){
		return this._flags[key];
	}

	/**
	*@private
	*/
	__proto.addShaderPass=function(vs,ps){
		this._passes.push(new ShaderPass(this,vs,ps));
	}

	return SubShader;
})()


/**
*<code>Physics</code> 类用于简单物理检测。
*/
//class laya.d3.utils.Physics3DUtils
var Physics3DUtils=(function(){
	/**
	*创建一个 <code>Physics</code> 实例。
	*/
	function Physics3DUtils(){}
	__class(Physics3DUtils,'laya.d3.utils.Physics3DUtils');
	Physics3DUtils.setColliderCollision=function(collider1,collider2,collsion){}
	Physics3DUtils.getIColliderCollision=function(collider1,collider2){
		return false;
	}

	Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER=0x1;
	Physics3DUtils.COLLISIONFILTERGROUP_STATICFILTER=0x2;
	Physics3DUtils.COLLISIONFILTERGROUP_KINEMATICFILTER=0x4;
	Physics3DUtils.COLLISIONFILTERGROUP_DEBRISFILTER=0x8;
	Physics3DUtils.COLLISIONFILTERGROUP_SENSORTRIGGER=0x10;
	Physics3DUtils.COLLISIONFILTERGROUP_CHARACTERFILTER=0x20;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1=0x40;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2=0x80;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER3=0x100;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER4=0x200;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5=0x400;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER6=0x800;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER7=0x1000;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER8=0x2000;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER9=0x4000;
	Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER10=0x8000;
	Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER=-1;
	__static(Physics3DUtils,
	['gravity',function(){return this.gravity=new Vector3(0,-9.81,0);}
	]);
	return Physics3DUtils;
})()


/**
*<code>Input3D</code> 类用于实现3D输入。
*/
//class laya.d3.Input3D
var Input3D=(function(){
	function Input3D(){
		/**@private */
		this._scene=null;
		/**@private */
		this._eventList=[];
		/**@private */
		this._multiTouchEnabled=true;
		this._mouseTouch=new MouseTouch();
		this._touchPool=[];
		this._touches=new SimpleSingletonList();
	}

	__class(Input3D,'laya.d3.Input3D');
	var __proto=Input3D.prototype;
	/**
	*@private
	*/
	__proto.__init__=function(canvas,scene){
		this._scene=scene;
		var list=this._eventList;
		canvas.oncontextmenu=function (e){
			return false;
		}
		canvas.addEventListener('mousedown',function(e){
			e.preventDefault();
			list.push(e);
		});
		canvas.addEventListener('mouseup',function(e){
			e.preventDefault();
			list.push(e);
		},true);
		canvas.addEventListener('mousemove',function(e){
			e.preventDefault();
			list.push(e);
		},true);
		canvas.addEventListener("touchstart",function(e){
			e.preventDefault();
			list.push(e);
		});
		canvas.addEventListener("touchend",function(e){
			e.preventDefault();
			list.push(e);
		},true);
		canvas.addEventListener("touchmove",function(e){
			e.preventDefault();
			list.push(e);
		},true);
		canvas.addEventListener("touchcancel",function(e){
			list.push(e);
		},true);
	}

	/**
	*获取触摸点个数。
	*@return 触摸点个数。
	*/
	__proto.touchCount=function(){
		return this._touches.length;
	}

	/**
	*@private
	*/
	__proto._getTouch=function(touchID){
		var touch=this._touchPool[touchID];
		if (!touch){
			touch=new Touch();
			this._touchPool[touchID]=touch;
			touch._identifier=touchID;
		}
		return touch;
	}

	/**
	*@private
	*/
	__proto._mouseTouchDown=function(){
		var touch=this._mouseTouch;
		var sprite=touch.sprite;
		touch._pressedSprite=sprite;
		touch._pressedLoopCount=Stat.loopCount;
		if (sprite){
			var scripts=sprite._scripts;
			if (scripts){
				for (var i=0,n=scripts.length;i < n;i++)
				scripts[i].onMouseDown();
			}
		}
	}

	/**
	*@private
	*/
	__proto._mouseTouchUp=function(){
		var i=0,n=0;
		var touch=this._mouseTouch;
		var lastPressedSprite=touch._pressedSprite;
		touch._pressedSprite=null;
		touch._pressedLoopCount=-1;
		var sprite=touch.sprite;
		if (sprite){
			if (sprite===lastPressedSprite){
				var scripts=sprite._scripts;
				if (scripts){
					for (i=0,n=scripts.length;i < n;i++)
					scripts[i].onMouseClick();
				}
			}
		}
		if (lastPressedSprite){
			var lastScripts=lastPressedSprite._scripts;
			if (lastScripts){
				for (i=0,n=lastScripts.length;i < n;i++)
				lastScripts[i].onMouseUp();
			}
		}
	}

	/**
	*@private
	*/
	__proto._mouseTouchRayCast=function(cameras){
		var touchHitResult=Input3D._tempHitResult0;
		var touchPos=Input3D._tempVector20;
		var touchRay=Input3D._tempRay0;
		touchHitResult.succeeded=false;
		var x=this._mouseTouch.mousePositionX;
		var y=this._mouseTouch.mousePositionY;
		var touchPosE=touchPos.elements;
		touchPosE[0]=x;
		touchPosE[1]=y;
		for (var i=cameras.length-1;i >=0;i--){
			var camera=cameras [i];
			var viewport=camera.viewport;
			if (touchPos.x >=viewport.x && touchPos.y >=viewport.y && touchPos.x <=viewport.width && touchPos.y <=viewport.height){
				camera.viewportPointToRay(touchPos,touchRay);
				var sucess=this._scene._physicsSimulation.rayCast(touchRay,touchHitResult);
				if (sucess || (camera.clearFlag===/*laya.d3.core.BaseCamera.CLEARFLAG_SOLIDCOLOR*/0 || camera.clearFlag===/*laya.d3.core.BaseCamera.CLEARFLAG_SKY*/1))
					break ;
			}
		};
		var touch=this._mouseTouch;
		var lastSprite=touch.sprite;
		if (touchHitResult.succeeded){
			var touchSprite=touchHitResult.collider.owner;
			touch.sprite=touchSprite;
			var scripts=touchSprite._scripts;
			if (lastSprite!==touchSprite){
				if (scripts){
					for (var j=0,m=scripts.length;j < m;j++)
					scripts[j].onMouseEnter();
				}
			}
			}else {
			touch.sprite=null;
		}
		if (lastSprite && (lastSprite!==touchSprite)){
			var outScripts=lastSprite._scripts;
			if (outScripts){
				for (j=0,m=outScripts.length;j < m;j++)
				outScripts[j].onMouseOut();
			}
		}
	}

	/**
	*@private
	*@param flag 0:add、1:remove、2:change
	*/
	__proto._changeTouches=function(changedTouches,flag){
		var offsetX=0,offsetY=0;
		var lastCount=this._touches.length;
		for (var j=0,m=changedTouches.length;j < m;j++){
			var nativeTouch=changedTouches[j];
			var identifier=nativeTouch.identifier;
			if (!this._multiTouchEnabled && identifier!==0)
				continue ;
			var touch=this._getTouch(identifier);
			var posE=touch._position.elements;
			var mousePoint=Input3D._tempPoint;
			mousePoint.setTo(nativeTouch.pageX,nativeTouch.pageY);
			Laya.stage._canvasTransform.invertTransformPoint(mousePoint);
			var posX=mousePoint.x;
			var posY=mousePoint.y;
			switch (flag){
				case 0:
					this._touches.add(touch);
					offsetX+=posX;
					offsetY+=posY;
					break ;
				case 1:
					this._touches.remove(touch);
					offsetX-=posX;
					offsetY-=posY;
					break ;
				case 2:
					offsetX=posX-posE[0];
					offsetY=posY-posE[1];
					break ;
				}
			posE[0]=posX;
			posE[1]=posY;
		};
		var touchCount=this._touches.length;
		if (touchCount===0){
			this._mouseTouch.mousePositionX=0;
			this._mouseTouch.mousePositionY=0;
			}else {
			this._mouseTouch.mousePositionX=(this._mouseTouch.mousePositionX *lastCount+offsetX)/ touchCount;
			this._mouseTouch.mousePositionY=(this._mouseTouch.mousePositionY *lastCount+offsetY)/ touchCount;
		}
	}

	/**
	*@private
	*/
	__proto._update=function(){
		var i=0,n=0,j=0,m=0;
		n=this._eventList.length;
		var cameras=this._scene._cameraPool;
		if (n > 0){
			for (i=0;i < n;i++){
				var e=this._eventList[i];
				switch (e.type){
					case "mousedown":
						this._mouseTouchDown();
						break ;
					case "mouseup":
						this._mouseTouchUp();
						break ;
					case "mousemove":;
						var mousePoint=Input3D._tempPoint;
						mousePoint.setTo(e.pageX,e.pageY);
						Laya.stage._canvasTransform.invertTransformPoint(mousePoint);
						this._mouseTouch.mousePositionX=mousePoint.x;
						this._mouseTouch.mousePositionY=mousePoint.y;
						this._mouseTouchRayCast(cameras);
						break ;
					case "touchstart":;
						var lastLength=this._touches.length;
						this._changeTouches(e.changedTouches,0);
						this._mouseTouchRayCast(cameras);
						(lastLength===0)&& (this._mouseTouchDown());
						break ;
					case "touchend":
					case "touchcancel":
						this._changeTouches(e.changedTouches,1);
						(this._touches.length===0)&& (this._mouseTouchUp());
						break ;
					case "touchmove":
						this._changeTouches(e.changedTouches,2);
						this._mouseTouchRayCast(cameras);
						break ;
					default :
						throw "Input3D:unkonwn event type.";
					}
			}
			this._eventList.length=0;
		};
		var mouseTouch=this._mouseTouch;
		var pressedSprite=mouseTouch._pressedSprite;
		if (pressedSprite && (Stat.loopCount > mouseTouch._pressedLoopCount)){
			var pressedScripts=pressedSprite._scripts;
			if (pressedScripts){
				for (j=0,m=pressedScripts.length;j < m;j++)
				pressedScripts[j].onMouseDrag();
			}
		};
		var touchSprite=mouseTouch.sprite;
		if (touchSprite){
			var scripts=touchSprite._scripts;
			if (scripts){
				for (j=0,m=scripts.length;j < m;j++)
				scripts[j].onMouseOver();
			}
		}
	}

	/**
	*获取触摸点。
	*@param index 索引。
	*@return 触摸点。
	*/
	__proto.getTouch=function(index){
		if (index < this._touches.length){
			return this._touches.elements [index];
			}else {
			return null;
		}
	}

	/**
	*设置是否可以使用多点触摸。
	*@param 是否可以使用多点触摸。
	*/
	/**
	*获取是否可以使用多点触摸。
	*@return 是否可以使用多点触摸。
	*/
	__getset(0,__proto,'multiTouchEnabled',function(){
		return this._multiTouchEnabled;
		},function(value){
		this._multiTouchEnabled=value;
	});

	__static(Input3D,
	['_tempPoint',function(){return this._tempPoint=new Point();},'_tempVector20',function(){return this._tempVector20=new Vector2();},'_tempRay0',function(){return this._tempRay0=new Ray(new Vector3(),new Vector3());},'_tempHitResult0',function(){return this._tempHitResult0=new HitResult();}
	]);
	return Input3D;
})()


/**
*<code>Gradient</code> 类用于创建颜色渐变。
*/
//class laya.d3.core.Gradient
var Gradient=(function(){
	function Gradient(maxColorRGBKeyCount,maxColorAlphaKeyCount){
		/**@private */
		this._mode=0;
		/**@private */
		this._maxColorRGBKeysCount=0;
		/**@private */
		this._maxColorAlphaKeysCount=0;
		/**@private */
		this._colorRGBKeysCount=0;
		/**@private */
		this._colorAlphaKeysCount=0;
		/**@private */
		this._alphaElements=null;
		/**@private */
		this._rgbElements=null;
		this._maxColorRGBKeysCount=maxColorRGBKeyCount;
		this._maxColorAlphaKeysCount=maxColorAlphaKeyCount;
		this._rgbElements=new Float32Array(maxColorRGBKeyCount *4);
		this._alphaElements=new Float32Array(maxColorAlphaKeyCount *2);
	}

	__class(Gradient,'laya.d3.core.Gradient');
	var __proto=Gradient.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加颜色RGB帧。
	*@param key 生命周期，范围为0到1。
	*@param value RGB值。
	*/
	__proto.addColorRGB=function(key,value){
		if (this._colorRGBKeysCount < this._maxColorRGBKeysCount){
			var offset=this._colorRGBKeysCount *4;
			this._rgbElements[offset]=key;
			this._rgbElements[offset+1]=value.r;
			this._rgbElements[offset+2]=value.g;
			this._rgbElements[offset+3]=value.b;
			this._colorRGBKeysCount++;
			}else {
			console.warn("Gradient:warning:data count must lessEqual than "+this._maxColorRGBKeysCount);
		}
	}

	/**
	*增加颜色Alpha帧。
	*@param key 生命周期，范围为0到1。
	*@param value Alpha值。
	*/
	__proto.addColorAlpha=function(key,value){
		if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount){
			var offset=this._colorAlphaKeysCount *2;
			this._alphaElements[offset]=key;
			this._alphaElements[offset+1]=value;
			this._colorAlphaKeysCount++;
			}else {
			console.warn("Gradient:warning:data count must lessEqual than "+this._maxColorAlphaKeysCount);
		}
	}

	/**
	*更新颜色RGB帧。
	*@param index 索引。
	*@param key 生命周期，范围为0到1。
	*@param value RGB值。
	*/
	__proto.updateColorRGB=function(index,key,value){
		if (index < this._colorRGBKeysCount){
			var offset=index *4;
			this._rgbElements[offset]=key;
			this._rgbElements[offset+1]=value.r;
			this._rgbElements[offset+2]=value.g;
			this._rgbElements[offset+3]=value.b;
			}else {
			console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:"+this._colorRGBKeysCount);
		}
	}

	/**
	*更新颜色Alpha帧。
	*@param index 索引。
	*@param key 生命周期，范围为0到1。
	*@param value Alpha值。
	*/
	__proto.updateColorAlpha=function(index,key,value){
		if (index < this._colorAlphaKeysCount){
			var offset=index *2;
			this._alphaElements[offset]=key;
			this._alphaElements[offset+1]=value;
			}else {
			console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:"+this._colorAlphaKeysCount);
		}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientDataColor=destObject;
		var i=0,n=0;
		destGradientDataColor._colorAlphaKeysCount=this._colorAlphaKeysCount;
		var destAlphaElements=destGradientDataColor._alphaElements;
		destAlphaElements.length=this._alphaElements.length;
		for (i=0,n=this._alphaElements.length;i < n;i++)
		destAlphaElements[i]=this._alphaElements[i];
		destGradientDataColor._colorRGBKeysCount=this._colorRGBKeysCount;
		var destRGBElements=destGradientDataColor._rgbElements;
		destRGBElements.length=this._rgbElements.length;
		for (i=0,n=this._rgbElements.length;i < n;i++)
		destRGBElements[i]=this._rgbElements[i];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientDataColor=new Gradient(this._maxColorRGBKeysCount,this._maxColorAlphaKeysCount);
		this.cloneTo(destGradientDataColor);
		return destGradientDataColor;
	}

	/**
	*获取颜色RGB数量。
	*@return 颜色RGB数量。
	*/
	__getset(0,__proto,'colorRGBKeysCount',function(){
		return this._colorRGBKeysCount / 4;
	});

	/**
	*设置梯度模式。
	*@param value 梯度模式。
	*/
	/**
	*获取梯度模式。
	*@return 梯度模式。
	*/
	__getset(0,__proto,'mode',function(){
		return this._mode;
		},function(value){
		this._mode=value;
	});

	/**
	*获取颜色Alpha数量。
	*@return 颜色Alpha数量。
	*/
	__getset(0,__proto,'colorAlphaKeysCount',function(){
		return this._colorAlphaKeysCount / 2;
	});

	/**
	*获取最大颜色RGB帧数量。
	*@return 最大RGB帧数量。
	*/
	__getset(0,__proto,'maxColorRGBKeysCount',function(){
		return this._maxColorRGBKeysCount;
	});

	/**
	*获取最大颜色Alpha帧数量。
	*@return 最大Alpha帧数量。
	*/
	__getset(0,__proto,'maxColorAlphaKeysCount',function(){
		return this._maxColorAlphaKeysCount;
	});

	return Gradient;
})()


/**
*<code>SkyMesh</code> 类用于实现天空网格。
*/
//class laya.d3.resource.models.SkyMesh
var SkyMesh=(function(){
	function SkyMesh(){
		/**@private */
		this._vertexBuffer=null;
		/**@private */
		this._indexBuffer=null;
		/**@private */
		this._bufferState=null;
	}

	__class(SkyMesh,'laya.d3.resource.models.SkyMesh');
	var __proto=SkyMesh.prototype;
	/**
	*@private
	*/
	__proto._render=function(state){}
	return SkyMesh;
})()


/**
*<code>Collision</code> 类用于创建物理碰撞信息。
*/
//class laya.d3.physics.Collision
var Collision=(function(){
	function Collision(){
		/**@private */
		this._lastUpdateFrame=-2147483648;
		/**@private */
		this._updateFrame=-2147483648;
		/**@private */
		this._isTrigger=false;
		/**@private */
		//this._colliderA=null;
		/**@private */
		//this._colliderB=null;
		/**@private [只读]*/
		//this.other=null;
		this.contacts=[];
	}

	__class(Collision,'laya.d3.physics.Collision');
	var __proto=Collision.prototype;
	/**
	*@private
	*/
	__proto._setUpdateFrame=function(farme){
		this._lastUpdateFrame=this._updateFrame;
		this._updateFrame=farme;
	}

	return Collision;
})()


/**
*@private
*<code>KeyframeNodeOwner</code> 类用于保存帧节点的拥有者信息。
*/
//class laya.d3.component.KeyframeNodeOwner
var KeyframeNodeOwner=(function(){
	function KeyframeNodeOwner(){
		/**@private */
		this.indexInList=-1;
		/**@private */
		this.referenceCount=0;
		/**@private */
		this.updateMark=-1;
		/**@private */
		this.type=-1;
		/**@private */
		this.fullPath=null;
		/**@private */
		this.propertyOwner=null;
		/**@private */
		this.property=null;
		/**@private */
		this.defaultValue=null;
		/**@private */
		this.crossFixedValue=null;
	}

	__class(KeyframeNodeOwner,'laya.d3.component.KeyframeNodeOwner');
	var __proto=KeyframeNodeOwner.prototype;
	/**
	*@private
	*/
	__proto.saveCrossFixedValue=function(){
		var pro=this.propertyOwner;
		if (pro){
			switch (this.type){
				case 0:;
					var proPat=this.property;
					var m=proPat.length-1;
					for (var j=0;j < m;j++){
						pro=pro[proPat[j]];
						if (!pro)
							break ;
					}
					this.crossFixedValue=pro[proPat[m]];
					break ;
				case 1:;
					var locPosE=pro.localPosition.elements;
					this.crossFixedValue || (this.crossFixedValue=new Float32Array(3));
					this.crossFixedValue[0]=locPosE[0];
					this.crossFixedValue[1]=locPosE[1];
					this.crossFixedValue[2]=locPosE[2];
					break ;
				case 2:;
					var locRotE=pro.localRotation.elements;
					this.crossFixedValue || (this.crossFixedValue=new Float32Array(4));
					this.crossFixedValue[0]=locRotE[0];
					this.crossFixedValue[1]=locRotE[1];
					this.crossFixedValue[2]=locRotE[2];
					this.crossFixedValue[3]=locRotE[3];
					break ;
				case 3:;
					var locScaE=pro.localScale.elements;
					this.crossFixedValue || (this.crossFixedValue=new Float32Array(3));
					this.crossFixedValue[0]=locScaE[0];
					this.crossFixedValue[1]=locScaE[1];
					this.crossFixedValue[2]=locScaE[2];
					break ;
				case 4:;
					var locEulE=pro.localRotationEuler.elements;
					this.crossFixedValue || (this.crossFixedValue=new Float32Array(3));
					this.crossFixedValue[0]=locEulE[0];
					this.crossFixedValue[1]=locEulE[1];
					this.crossFixedValue[2]=locEulE[2];
					break ;
				default :
					throw "Animator:unknown type.";
				}
		}
	}

	return KeyframeNodeOwner;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.scene.SceneManager
var SceneManager=(function(){
	function SceneManager(){}
	__class(SceneManager,'laya.d3.core.scene.SceneManager');
	return SceneManager;
})()


/**
*<code>HitResult</code> 类用于实现射线检测或形状扫描的结果。
*/
//class laya.d3.physics.HitResult
var HitResult=(function(){
	function HitResult(){
		/**是否成功。 */
		this.succeeded=false;
		/**发生碰撞的碰撞组件。*/
		this.collider=null;
		/**碰撞分数。 */
		this.hitFraction=0;
		this.point=new Vector3();
		this.normal=new Vector3();
	}

	__class(HitResult,'laya.d3.physics.HitResult');
	return HitResult;
})()


/**
*<code>GradientDataInt</code> 类用于创建整形渐变。
*/
//class laya.d3.core.particleShuriKen.module.GradientDataInt
var GradientDataInt=(function(){
	function GradientDataInt(){
		/**@private */
		this._currentLength=0;
		/**@private 开发者禁止修改。*/
		this._elements=null;
		this._elements=new Float32Array(8);
	}

	__class(GradientDataInt,'laya.d3.core.particleShuriKen.module.GradientDataInt');
	var __proto=GradientDataInt.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加整形渐变。
	*@param key 生命周期，范围为0到1。
	*@param value 整形值。
	*/
	__proto.add=function(key,value){
		if (this._currentLength < 8){
			if ((this._currentLength===6)&& ((key!==1))){
				key=1;
				console.log("Warning:the forth key is  be force set to 1.");
			}
			this._elements[this._currentLength++]=key;
			this._elements[this._currentLength++]=value;
			}else {
			console.log("Warning:data count must lessEqual than 4");
		}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientDataInt=destObject;
		destGradientDataInt._currentLength=this._currentLength;
		var destElements=destGradientDataInt._elements;
		destElements.length=this._elements.length;
		for (var i=0,n=this._elements.length;i < n;i++){
			destElements[i]=this._elements[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientDataInt=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientDataInt);
		return destGradientDataInt;
	}

	/**整形渐变数量。*/
	__getset(0,__proto,'gradientCount',function(){
		return this._currentLength / 2;
	});

	return GradientDataInt;
})()


/**
*<code>VertexElement</code> 类用于创建顶点结构分配。
*/
//class laya.d3.graphics.VertexElement
var VertexElement=(function(){
	function VertexElement(offset,elementFormat,elementUsage){
		this.offset=0;
		this.elementFormat=null;
		this.elementUsage=0;
		this.offset=offset;
		this.elementFormat=elementFormat;
		this.elementUsage=elementUsage;
	}

	__class(VertexElement,'laya.d3.graphics.VertexElement');
	return VertexElement;
})()


/**
*<code>AnimatorControllerLayer</code> 类用于创建动画控制器层。
*/
//class laya.d3.component.AnimatorControllerLayer
var AnimatorControllerLayer=(function(){
	function AnimatorControllerLayer(name){
		/**@private 0:常规播放、1:动态融合播放、2:固定融合播放*/
		//this._playType=0;
		/**@private */
		//this._crossDuration=NaN;
		/**@private */
		//this._crossPlayState=null;
		/**@private */
		//this._crossMark=0;
		/**@private */
		//this._crossNodesOwnersCount=0;
		/**@private */
		//this._crossNodesOwners=null;
		/**@private */
		//this._crossNodesOwnersIndicesMap=null;
		/**@private */
		//this._srcCrossClipNodeIndices=null;
		/**@private */
		//this._destCrossClipNodeIndices=null;
		/**@private */
		//this._defaultState=null;
		/**@private */
		//this._currentPlayState=null;
		/**@private */
		this._statesMap={};
		/**@private */
		//this._states=null;
		/**@private */
		//this._playStateInfo=null;
		/**@private */
		//this._crossPlayStateInfo=null;
		/**层的名称。*/
		//this.name=null;
		/**名称。*/
		//this.blendingMode=0;
		/**权重。*/
		//this.defaultWeight=0;
		/**激活时是否自动播放*/
		this.playOnWake=true;
		this._playType=-1;
		this._crossMark=0;
		this._crossDuration=-1;
		this._crossNodesOwnersIndicesMap={};
		this._crossNodesOwnersCount=0;
		this._crossNodesOwners=[];
		this._defaultState=null;
		this._currentPlayState=null;
		this._states=[];
		this._playStateInfo=new AnimatorPlayState();
		this._crossPlayStateInfo=new AnimatorPlayState();
		this._srcCrossClipNodeIndices=[];
		this._destCrossClipNodeIndices=[];
		this.name=name;
		this.defaultWeight=1.0;
		this.blendingMode=laya.d3.component.AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
	}

	__class(AnimatorControllerLayer,'laya.d3.component.AnimatorControllerLayer');
	var __proto=AnimatorControllerLayer.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto.getAnimatorState=function(name){
		var state=this._statesMap[name];
		return state ? state :null;
	}

	/**
	*@private
	*/
	__proto.destroy=function(){
		this._statesMap=null;
		this._states=null;
		this._playStateInfo=null;
		this._crossPlayStateInfo=null;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		dest.name=this.name;
		dest.blendingMode=this.blendingMode;
		dest.defaultWeight=this.defaultWeight;
		dest.playOnWake=this.playOnWake;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	AnimatorControllerLayer.BLENDINGMODE_OVERRIDE=0;
	AnimatorControllerLayer.BLENDINGMODE_ADDTIVE=1;
	return AnimatorControllerLayer;
})()


/**
*<code>GradientDataNumber</code> 类用于创建浮点渐变。
*/
//class laya.d3.core.particleShuriKen.module.GradientDataNumber
var GradientDataNumber=(function(){
	function GradientDataNumber(){
		/**@private */
		this._currentLength=0;
		/**@private 开发者禁止修改。*/
		this._elements=null;
		this._elements=new Float32Array(8);
	}

	__class(GradientDataNumber,'laya.d3.core.particleShuriKen.module.GradientDataNumber');
	var __proto=GradientDataNumber.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加浮点渐变。
	*@param key 生命周期，范围为0到1。
	*@param value 浮点值。
	*/
	__proto.add=function(key,value){
		if (this._currentLength < 8){
			if ((this._currentLength===6)&& ((key!==1))){
				key=1;
				console.log("GradientDataNumber warning:the forth key is  be force set to 1.");
			}
			this._elements[this._currentLength++]=key;
			this._elements[this._currentLength++]=value;
			}else {
			console.log("GradientDataNumber warning:data count must lessEqual than 4");
		}
	}

	/**
	*通过索引获取键。
	*@param index 索引。
	*@return value 键。
	*/
	__proto.getKeyByIndex=function(index){
		return this._elements[index *2];
	}

	/**
	*通过索引获取值。
	*@param index 索引。
	*@return value 值。
	*/
	__proto.getValueByIndex=function(index){
		return this._elements[index *2+1];
	}

	/**
	*获取平均值。
	*/
	__proto.getAverageValue=function(){
		var total=0;
		for (var i=0,n=this._currentLength-2;i < n;i+=2){
			var subValue=this._elements[i+1];
			subValue+=this._elements[i+3];
			subValue=subValue *(this._elements[i+2]-this._elements[i]);
		}
		return total / 2;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientDataNumber=destObject;
		destGradientDataNumber._currentLength=this._currentLength;
		var destElements=destGradientDataNumber._elements;
		destElements.length=this._elements.length;
		for (var i=0,n=this._elements.length;i < n;i++)
		destElements[i]=this._elements[i];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientDataNumber=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientDataNumber);
		return destGradientDataNumber;
	}

	/**渐变浮点数量。*/
	__getset(0,__proto,'gradientCount',function(){
		return this._currentLength / 2;
	});

	return GradientDataNumber;
})()


/**
*<code>Emission</code> 类用于粒子发射器。
*/
//class laya.d3.core.particleShuriKen.module.Emission
var Emission=(function(){
	function Emission(){
		/**@private */
		this._destroyed=false;
		/**@private 粒子发射速率,每秒发射的个数。*/
		this._emissionRate=0;
		/**@private 粒子的爆裂,不允许修改。*/
		this._bursts=null;
		/**是否启用。*/
		this.enbale=false;
		this._destroyed=false;
		this.emissionRate=10;
		this._bursts=[];
	}

	__class(Emission,'laya.d3.core.particleShuriKen.module.Emission');
	var __proto=Emission.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true,"laya.resource.IDestroy":true})
	/**
	*@private
	*/
	__proto.destroy=function(){
		this._bursts=null;
		this._destroyed=true;
	}

	/**
	*获取粒子爆裂个数。
	*@return 粒子爆裂个数。
	*/
	__proto.getBurstsCount=function(){
		return this._bursts.length;
	}

	/**
	*通过索引获取粒子爆裂。
	*@param index 爆裂索引。
	*@return 粒子爆裂。
	*/
	__proto.getBurstByIndex=function(index){
		return this._bursts[index];
	}

	/**
	*增加粒子爆裂。
	*@param burst 爆裂。
	*/
	__proto.addBurst=function(burst){
		var burstsCount=this._bursts.length;
		if (burstsCount > 0)
			for (var i=0;i < burstsCount;i++){
			if (this._bursts[i].time > burst.time)
				this._bursts.splice(i,0,burst);
		}
		this._bursts.push(burst);
	}

	/**
	*移除粒子爆裂。
	*@param burst 爆裂。
	*/
	__proto.removeBurst=function(burst){
		var index=this._bursts.indexOf(burst);
		if (index!==-1){
			this._bursts.splice(index,1);
		}
	}

	/**
	*通过索引移除粒子爆裂。
	*@param index 爆裂索引。
	*/
	__proto.removeBurstByIndex=function(index){
		this._bursts.splice(index,1);
	}

	/**
	*清空粒子爆裂。
	*/
	__proto.clearBurst=function(){
		this._bursts.length=0;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destEmission=destObject;
		var destBursts=destEmission._bursts;
		destBursts.length=this._bursts.length;
		for (var i=0,n=this._bursts.length;i < n;i++){
			var destBurst=destBursts[i];
			if (destBurst)
				this._bursts[i].cloneTo(destBurst);
			else
			destBursts[i]=this._bursts[i].clone();
		}
		destEmission._emissionRate=this._emissionRate;
		destEmission.enbale=this.enbale;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destEmission=/*__JS__ */new this.constructor();
		this.cloneTo(destEmission);
		return destEmission;
	}

	/**
	*获取是否已销毁。
	*@return 是否已销毁。
	*/
	__getset(0,__proto,'destroyed',function(){
		return this._destroyed;
	});

	/**
	*设置粒子发射速率。
	*@param emissionRate 粒子发射速率 (个/秒)。
	*/
	/**
	*获取粒子发射速率。
	*@return 粒子发射速率 (个/秒)。
	*/
	__getset(0,__proto,'emissionRate',function(){
		return this._emissionRate;
		},function(value){
		if (value < 0)
			throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
		this._emissionRate=value;
	});

	return Emission;
})()


/**
*<code>Config3D</code> 类用于创建3D初始化配置。
*/
//class Config3D
var Config3D=(function(){
	function Config3D(){
		/**@private */
		this._defaultPhysicsMemory=16;
		/**@private */
		this._editerEnvironment=false;
		/**
		*是否开启抗锯齿。
		*/
		this.isAntialias=true;
		/**
		*设置画布是否透明。
		*/
		this.isAlpha=false;
		/**
		*设置画布是否预乘。
		*/
		this.premultipliedAlpha=true;
		/**
		*设置画布的是否开启模板缓冲。
		*/
		this.isStencil=true;
	}

	__class(Config3D,'Config3D');
	var __proto=Config3D.prototype;
	/**
	*设置默认物理功能初始化内存，单位为M。
	*@param value 默认物理功能初始化内存。
	*/
	/**
	*获取默认物理功能初始化内存，单位为M。
	*@return 默认物理功能初始化内存。
	*/
	__getset(0,__proto,'defaultPhysicsMemory',function(){
		return this._defaultPhysicsMemory;
		},function(value){
		if (value < 16)
			throw "defaultPhysicsMemory must large than 16M";
		this._defaultPhysicsMemory=value;
	});

	__static(Config3D,
	['_defaultConfig',function(){return this._defaultConfig=new Config3D();}
	]);
	return Config3D;
})()


/**
*<code>ContactPoint</code> 类用于创建物理碰撞信息。
*/
//class laya.d3.physics.ContactPoint
var ContactPoint=(function(){
	function ContactPoint(){
		/**@private */
		this._idCounter=0;
		/**@private */
		//this._id=0;
		/**碰撞器A。*/
		this.colliderA=null;
		/**碰撞器B。*/
		this.colliderB=null;
		/**距离。*/
		this.distance=0;
		this.normal=new Vector3();
		this.positionOnA=new Vector3();
		this.positionOnB=new Vector3();
		this._id=++this._idCounter;
	}

	__class(ContactPoint,'laya.d3.physics.ContactPoint');
	return ContactPoint;
})()


/**
*<code>AnimatorStateScript</code> 类用于动画状态脚本的父类,该类为抽象类,不允许实例。
*/
//class laya.d3.animation.AnimatorStateScript
var AnimatorStateScript=(function(){
	/**
	*创建一个新的 <code>AnimatorStateScript</code> 实例。
	*/
	function AnimatorStateScript(){}
	__class(AnimatorStateScript,'laya.d3.animation.AnimatorStateScript');
	var __proto=AnimatorStateScript.prototype;
	/**
	*动画状态开始时执行。
	*/
	__proto.onStateEnter=function(){}
	/**
	*动画状态更新时执行。
	*/
	__proto.onStateUpdate=function(){}
	/**
	*动画状态退出时执行。
	*/
	__proto.onStateExit=function(){}
	return AnimatorStateScript;
})()


/**
*<code>Quaternion</code> 类用于创建四元数。
*/
//class laya.d3.math.Quaternion
var Quaternion=(function(){
	function Quaternion(x,y,z,w,nativeElements){
		/**四元数元素数组*/
		//this.elements=null;
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(z===void 0)&& (z=0);
		(w===void 0)&& (w=1);
		var v;
		if (nativeElements){
			v=nativeElements;
			}else {
			v=new Float32Array(4);
		}
		v[0]=x;
		v[1]=y;
		v[2]=z;
		v[3]=w;
		this.elements=v;
	}

	__class(Quaternion,'laya.d3.math.Quaternion');
	var __proto=Quaternion.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*根据缩放值缩放四元数
	*@param scale 缩放值
	*@param out 输出四元数
	*/
	__proto.scaling=function(scaling,out){
		var e=out.elements;
		var f=this.elements;
		e[0]=f[0] *scaling;
		e[1]=f[1] *scaling;
		e[2]=f[2] *scaling;
		e[3]=f[3] *scaling;
	}

	/**
	*归一化四元数
	*@param out 输出四元数
	*/
	__proto.normalize=function(out){
		Quaternion._normalizeArray(this.elements,out.elements);
	}

	/**
	*计算四元数的长度
	*@return 长度
	*/
	__proto.length=function(){
		var f=this.elements;
		var x=f[0],y=f[1],z=f[2],w=f[3];
		return Math.sqrt(x *x+y *y+z *z+w *w);
	}

	/**
	*根据绕X轴的角度旋转四元数
	*@param rad 角度
	*@param out 输出四元数
	*/
	__proto.rotateX=function(rad,out){
		var e=out.elements;
		var f=this.elements;
		rad *=0.5;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3];
		var bx=Math.sin(rad),bw=Math.cos(rad);
		e[0]=ax *bw+aw *bx;
		e[1]=ay *bw+az *bx;
		e[2]=az *bw-ay *bx;
		e[3]=aw *bw-ax *bx;
	}

	/**
	*根据绕Y轴的制定角度旋转四元数
	*@param rad 角度
	*@param out 输出四元数
	*/
	__proto.rotateY=function(rad,out){
		var e=out.elements;
		var f=this.elements;
		rad *=0.5;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3],by=Math.sin(rad),bw=Math.cos(rad);
		e[0]=ax *bw-az *by;
		e[1]=ay *bw+aw *by;
		e[2]=az *bw+ax *by;
		e[3]=aw *bw-ay *by;
	}

	/**
	*根据绕Z轴的制定角度旋转四元数
	*@param rad 角度
	*@param out 输出四元数
	*/
	__proto.rotateZ=function(rad,out){
		var e=out.elements;
		var f=this.elements;
		rad *=0.5;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3],bz=Math.sin(rad),bw=Math.cos(rad);
		e[0]=ax *bw+ay *bz;
		e[1]=ay *bw-ax *bz;
		e[2]=az *bw+aw *bz;
		e[3]=aw *bw-az *bz;
	}

	/**
	*分解四元数到欧拉角（顺序为Yaw、Pitch、Roll），参考自http://xboxforums.create.msdn.com/forums/p/4574/23988.aspx#23988,问题绕X轴翻转超过±90度时有，会产生瞬间反转
	*@param quaternion 源四元数
	*@param out 欧拉角值
	*/
	__proto.getYawPitchRoll=function(out){
		Vector3.transformQuat(Vector3.ForwardRH,this,Quaternion.TEMPVector31);
		Vector3.transformQuat(Vector3.Up,this,Quaternion.TEMPVector32);
		var upe=Quaternion.TEMPVector32.elements;
		Quaternion.angleTo(Vector3.ZERO,Quaternion.TEMPVector31,Quaternion.TEMPVector33);
		var anglee=Quaternion.TEMPVector33.elements;
		if (anglee[0]==Math.PI / 2){
			anglee[1]=Quaternion.arcTanAngle(upe[2],upe[0]);
			anglee[2]=0;
			}else if (anglee[0]==-Math.PI / 2){
			anglee[1]=Quaternion.arcTanAngle(-upe[2],-upe[0]);
			anglee[2]=0;
			}else {
			Matrix4x4.createRotationY(-anglee[1],Quaternion.TEMPMatrix0);
			Matrix4x4.createRotationX(-anglee[0],Quaternion.TEMPMatrix1);
			Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix0,Quaternion.TEMPVector32);
			Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix1,Quaternion.TEMPVector32);
			anglee[2]=Quaternion.arcTanAngle(upe[1],-upe[0]);
		}
		if (anglee[1] <=-Math.PI)
			anglee[1]=Math.PI;
		if (anglee[2] <=-Math.PI)
			anglee[2]=Math.PI;
		if (anglee[1] >=Math.PI && anglee[2] >=Math.PI){
			anglee[1]=0;
			anglee[2]=0;
			anglee[0]=Math.PI-anglee[0];
		};
		var oe=out.elements;
		oe[0]=anglee[1];
		oe[1]=anglee[0];
		oe[2]=anglee[2];
	}

	/**
	*求四元数的逆
	*@param out 输出四元数
	*/
	__proto.invert=function(out){
		var e=out.elements;
		var f=this.elements;
		var a0=f[0],a1=f[1],a2=f[2],a3=f[3];
		var dot=a0 *a0+a1 *a1+a2 *a2+a3 *a3;
		var invDot=dot ? 1.0 / dot :0;
		e[0]=-a0 *invDot;
		e[1]=-a1 *invDot;
		e[2]=-a2 *invDot;
		e[3]=a3 *invDot;
	}

	/**
	*设置四元数为单位算数
	*@param out 输出四元数
	*/
	__proto.identity=function(){
		var e=this.elements;
		e[0]=0;
		e[1]=0;
		e[2]=0;
		e[3]=1;
	}

	/**
	*从Array数组拷贝值。
	*@param array 数组。
	*@param offset 数组偏移。
	*/
	__proto.fromArray=function(array,offset){
		(offset===void 0)&& (offset=0);
		this.elements[0]=array[offset+0];
		this.elements[1]=array[offset+1];
		this.elements[2]=array[offset+2];
		this.elements[3]=array[offset+3];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var i,s,d;
		s=this.elements;
		d=destObject.elements;
		if (s===d){
			return;
		}
		for (i=0;i < 4;++i){
			d[i]=s[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	__proto.equals=function(b){
		var ae=this.elements;
		var be=b.elements;
		return MathUtils3D.nearEqual(ae[0],be[0])&& MathUtils3D.nearEqual(ae[1],be[1])&& MathUtils3D.nearEqual(ae[2],be[2])&& MathUtils3D.nearEqual(ae[3],be[3]);
	}

	/**
	*计算长度的平方。
	*@return 长度的平方。
	*/
	__proto.lengthSquared=function(){
		var x=this.elements[0];
		var y=this.elements[1];
		var z=this.elements[2];
		var w=this.elements[3];
		return (x *x)+(y *y)+(z *z)+(w *w);
	}

	/**
	*获取四元数的x值
	*/
	__getset(0,__proto,'x',function(){
		return this.elements[0];
	});

	/**
	*获取四元数的y值
	*/
	__getset(0,__proto,'y',function(){
		return this.elements[1];
	});

	/**
	*获取四元数的z值
	*/
	__getset(0,__proto,'z',function(){
		return this.elements[2];
	});

	/**
	*获取四元数的w值
	*/
	__getset(0,__proto,'w',function(){
		return this.elements[3];
	});

	Quaternion._dotArray=function(l,r){
		return l[0] *r[0]+l[1] *r[1]+l[2] *r[2]+l[3] *r[3];
	}

	Quaternion._normalizeArray=function(f,o){
		var x=f[0],y=f[1],z=f[2],w=f[3];
		var len=x *x+y *y+z *z+w *w;
		if (len > 0){
			len=1 / Math.sqrt(len);
			o[0]=x *len;
			o[1]=y *len;
			o[2]=z *len;
			o[3]=w *len;
		}
	}

	Quaternion._lerpArray=function(l,r,amount,o){
		var inverse=1.0-amount;
		if (Quaternion._dotArray(l,r)>=0){
			o[0]=(inverse *l[0])+(amount *r[0]);
			o[1]=(inverse *l[1])+(amount *r[1]);
			o[2]=(inverse *l[2])+(amount *r[2]);
			o[3]=(inverse *l[3])+(amount *r[3]);
			}else {
			o[0]=(inverse *l[0])-(amount *r[0]);
			o[1]=(inverse *l[1])-(amount *r[1]);
			o[2]=(inverse *l[2])-(amount *r[2]);
			o[3]=(inverse *l[3])-(amount *r[3]);
		}
		Quaternion._normalizeArray(o,o);
	}

	Quaternion.createFromYawPitchRoll=function(yaw,pitch,roll,out){
		var halfRoll=roll *0.5;
		var halfPitch=pitch *0.5;
		var halfYaw=yaw *0.5;
		var sinRoll=Math.sin(halfRoll);
		var cosRoll=Math.cos(halfRoll);
		var sinPitch=Math.sin(halfPitch);
		var cosPitch=Math.cos(halfPitch);
		var sinYaw=Math.sin(halfYaw);
		var cosYaw=Math.cos(halfYaw);
		var oe=out.elements;
		oe[0]=(cosYaw *sinPitch *cosRoll)+(sinYaw *cosPitch *sinRoll);
		oe[1]=(sinYaw *cosPitch *cosRoll)-(cosYaw *sinPitch *sinRoll);
		oe[2]=(cosYaw *cosPitch *sinRoll)-(sinYaw *sinPitch *cosRoll);
		oe[3]=(cosYaw *cosPitch *cosRoll)+(sinYaw *sinPitch *sinRoll);
	}

	Quaternion.multiply=function(left,right,out){
		var le=left.elements;
		var re=right.elements;
		var oe=out.elements;
		var lx=le[0];
		var ly=le[1];
		var lz=le[2];
		var lw=le[3];
		var rx=re[0];
		var ry=re[1];
		var rz=re[2];
		var rw=re[3];
		var a=(ly *rz-lz *ry);
		var b=(lz *rx-lx *rz);
		var c=(lx *ry-ly *rx);
		var d=(lx *rx+ly *ry+lz *rz);
		oe[0]=(lx *rw+rx *lw)+a;
		oe[1]=(ly *rw+ry *lw)+b;
		oe[2]=(lz *rw+rz *lw)+c;
		oe[3]=lw *rw-d;
	}

	Quaternion.arcTanAngle=function(x,y){
		if (x==0){
			if (y==1)
				return Math.PI / 2;
			return-Math.PI / 2;
		}
		if (x > 0)
			return Math.atan(y / x);
		if (x < 0){
			if (y > 0)
				return Math.atan(y / x)+Math.PI;
			return Math.atan(y / x)-Math.PI;
		}
		return 0;
	}

	Quaternion.angleTo=function(from,location,angle){
		Vector3.subtract(location,from,Quaternion.TEMPVector30);
		Vector3.normalize(Quaternion.TEMPVector30,Quaternion.TEMPVector30);
		angle.elements[0]=Math.asin(Quaternion.TEMPVector30.y);
		angle.elements[1]=Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z,-Quaternion.TEMPVector30.x);
	}

	Quaternion.createFromAxisAngle=function(axis,rad,out){
		var e=out.elements;
		var f=axis.elements;
		rad=rad *0.5;
		var s=Math.sin(rad);
		e[0]=s *f[0];
		e[1]=s *f[1];
		e[2]=s *f[2];
		e[3]=Math.cos(rad);
	}

	Quaternion.createFromMatrix3x3=function(sou,out){
		var e=out.elements;
		var f=sou.elements;
		var fTrace=f[0]+f[4]+f[8];
		var fRoot;
		if (fTrace > 0.0){
			fRoot=Math.sqrt(fTrace+1.0);
			e[3]=0.5 *fRoot;
			fRoot=0.5 / fRoot;
			e[0]=(f[5]-f[7])*fRoot;
			e[1]=(f[6]-f[2])*fRoot;
			e[2]=(f[1]-f[3])*fRoot;
			}else {
			var i=0;
			if (f[4] > f[0])
				i=1;
			if (f[8] > f[i *3+i])
				i=2;
			var j=(i+1)% 3;
			var k=(i+2)% 3;
			fRoot=Math.sqrt(f[i *3+i]-f[j *3+j]-f[k *3+k]+1.0);
			e[i]=0.5 *fRoot;
			fRoot=0.5 / fRoot;
			e[3]=(f[j *3+k]-f[k *3+j])*fRoot;
			e[j]=(f[j *3+i]+f[i *3+j])*fRoot;
			e[k]=(f[k *3+i]+f[i *3+k])*fRoot;
		}
		return;
	}

	Quaternion.createFromMatrix4x4=function(mat,out){
		var me=mat.elements;
		var oe=out.elements;
		var sqrt;
		var half;
		var scale=me[0]+me[5]+me[10];
		if (scale > 0.0){
			sqrt=Math.sqrt(scale+1.0);
			oe[3]=sqrt *0.5;
			sqrt=0.5 / sqrt;
			oe[0]=(me[6]-me[9])*sqrt;
			oe[1]=(me[8]-me[2])*sqrt;
			oe[2]=(me[1]-me[4])*sqrt;
			}else if ((me[0] >=me[5])&& (me[0] >=me[10])){
			sqrt=Math.sqrt(1.0+me[0]-me[5]-me[10]);
			half=0.5 / sqrt;
			oe[0]=0.5 *sqrt;
			oe[1]=(me[1]+me[4])*half;
			oe[2]=(me[2]+me[8])*half;
			oe[3]=(me[6]-me[9])*half;
			}else if (me[5] > me[10]){
			sqrt=Math.sqrt(1.0+me[5]-me[0]-me[10]);
			half=0.5 / sqrt;
			oe[0]=(me[4]+me[1])*half;
			oe[1]=0.5 *sqrt;
			oe[2]=(me[9]+me[6])*half;
			oe[3]=(me[8]-me[2])*half;
			}else {
			sqrt=Math.sqrt(1.0+me[10]-me[0]-me[5]);
			half=0.5 / sqrt;
			oe[0]=(me[8]+me[2])*half;
			oe[1]=(me[9]+me[6])*half;
			oe[2]=0.5 *sqrt;
			oe[3]=(me[1]-me[4])*half;
		}
	}

	Quaternion.slerp=function(left,right,t,out){
		var a=left.elements;
		var b=right.elements;
		var oe=out.elements;
		var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];
		var omega,cosom,sinom,scale0,scale1;
		cosom=ax *bx+ay *by+az *bz+aw *bw;
		if (cosom < 0.0){
			cosom=-cosom;
			bx=-bx;
			by=-by;
			bz=-bz;
			bw=-bw;
		}
		if ((1.0-cosom)> 0.000001){
			omega=Math.acos(cosom);
			sinom=Math.sin(omega);
			scale0=Math.sin((1.0-t)*omega)/ sinom;
			scale1=Math.sin(t *omega)/ sinom;
			}else {
			scale0=1.0-t;
			scale1=t;
		}
		oe[0]=scale0 *ax+scale1 *bx;
		oe[1]=scale0 *ay+scale1 *by;
		oe[2]=scale0 *az+scale1 *bz;
		oe[3]=scale0 *aw+scale1 *bw;
		return oe;
	}

	Quaternion.lerp=function(left,right,amount,out){
		Quaternion._lerpArray(left.elements,right.elements,amount,out.elements);
	}

	Quaternion.add=function(left,right,out){
		var e=out.elements;
		var f=left.elements;
		var g=right.elements;
		e[0]=f[0]+g[0];
		e[1]=f[1]+g[1];
		e[2]=f[2]+g[2];
		e[3]=f[3]+g[3];
	}

	Quaternion.dot=function(left,right){
		return Quaternion._dotArray(left.elements,right.elements);
	}

	Quaternion.rotationLookAt=function(forward,up,out){
		Quaternion.lookAt(Vector3.ZERO,forward,up,out);
	}

	Quaternion.lookAt=function(eye,target,up,out){
		Matrix3x3.lookAt(eye,target,up,Quaternion._tempMatrix3x3);
		Quaternion.rotationMatrix(Quaternion._tempMatrix3x3,out);
	}

	Quaternion.invert=function(value,out){
		var vE=value.elements;
		var oE=out.elements;
		var lengthSq=value.lengthSquared();
		if (!MathUtils3D.isZero(lengthSq)){
			lengthSq=1.0 / lengthSq;
			oE[0]=-vE[0] *lengthSq;
			oE[1]=-vE[1] *lengthSq;
			oE[2]=-vE[2] *lengthSq;
			oE[3]=vE[3] *lengthSq;
		}
	}

	Quaternion.rotationMatrix=function(matrix3x3,out){
		var me=matrix3x3.elements;
		var m11=me[0];
		var m12=me[1];
		var m13=me[2];
		var m21=me[3];
		var m22=me[4];
		var m23=me[5];
		var m31=me[6];
		var m32=me[7];
		var m33=me[8];
		var oe=out.elements;
		var sqrt=NaN,half=NaN;
		var scale=m11+m22+m33;
		if (scale > 0){
			sqrt=Math.sqrt(scale+1);
			oe[3]=sqrt *0.5;
			sqrt=0.5 / sqrt;
			oe[0]=(m23-m32)*sqrt;
			oe[1]=(m31-m13)*sqrt;
			oe[2]=(m12-m21)*sqrt;
			}else if ((m11 >=m22)&& (m11 >=m33)){
			sqrt=Math.sqrt(1+m11-m22-m33);
			half=0.5 / sqrt;
			oe[0]=0.5 *sqrt;
			oe[1]=(m12+m21)*half;
			oe[2]=(m13+m31)*half;
			oe[3]=(m23-m32)*half;
			}else if (m22 > m33){
			sqrt=Math.sqrt(1+m22-m11-m33);
			half=0.5 / sqrt;
			oe[0]=(m21+m12)*half;
			oe[1]=0.5 *sqrt;
			oe[2]=(m32+m23)*half;
			oe[3]=(m31-m13)*half;
			}else {
			sqrt=Math.sqrt(1+m33-m11-m22);
			half=0.5 / sqrt;
			oe[0]=(m31+m13)*half;
			oe[1]=(m32+m23)*half;
			oe[2]=0.5 *sqrt;
			oe[3]=(m12-m21)*half;
		}
	}

	Quaternion.DEFAULT=new Quaternion();
	__static(Quaternion,
	['TEMPVector30',function(){return this.TEMPVector30=new Vector3();},'TEMPVector31',function(){return this.TEMPVector31=new Vector3();},'TEMPVector32',function(){return this.TEMPVector32=new Vector3();},'TEMPVector33',function(){return this.TEMPVector33=new Vector3();},'TEMPMatrix0',function(){return this.TEMPMatrix0=new Matrix4x4();},'TEMPMatrix1',function(){return this.TEMPMatrix1=new Matrix4x4();},'_tempMatrix3x3',function(){return this._tempMatrix3x3=new Matrix3x3();},'NAN',function(){return this.NAN=new Quaternion(NaN,NaN,NaN,NaN);}
	]);
	return Quaternion;
})()


//class laya.d3.utils.Size
var Size=(function(){
	function Size(width,height){
		this._width=0;
		this._height=0;
		this._width=width;
		this._height=height;
	}

	__class(Size,'laya.d3.utils.Size');
	var __proto=Size.prototype;
	__getset(0,__proto,'width',function(){
		if (this._width===-1)
			return RenderContext3D.clientWidth;
		return this._width;
	});

	__getset(0,__proto,'height',function(){
		if (this._height===-1)
			return RenderContext3D.clientHeight;
		return this._height;
	});

	__getset(1,Size,'fullScreen',function(){
		return new Size(-1,-1);
	});

	return Size;
})()


/**
*<code>Plane</code> 类用于创建平面。
*/
//class laya.d3.math.Plane
var Plane=(function(){
	function Plane(normal,d){
		/**平面的向量*/
		this.normal=null;
		/**平面到坐标系原点的距离*/
		this.distance=NaN;
		(d===void 0)&& (d=0);
		this.normal=normal;
		this.distance=d;
	}

	__class(Plane,'laya.d3.math.Plane');
	var __proto=Plane.prototype;
	/**
	*更改平面法线向量的系数，使之成单位长度。
	*/
	__proto.normalize=function(){
		var normalE=this.normal.elements;
		var normalEX=normalE[0];
		var normalEY=normalE[1];
		var normalEZ=normalE[2];
		var magnitude=1 / Math.sqrt(normalEX *normalEX+normalEY *normalEY+normalEZ *normalEZ);
		normalE[0]=normalEX *magnitude;
		normalE[1]=normalEY *magnitude;
		normalE[2]=normalEZ *magnitude;
		this.distance *=magnitude;
	}

	Plane.createPlaneBy3P=function(point1,point2,point3){
		var point1e=point1.elements;
		var point2e=point2.elements;
		var point3e=point3.elements;
		var x1=point2e[0]-point1e[0];
		var y1=point2e[1]-point1e[1];
		var z1=point2e[2]-point1e[2];
		var x2=point3e[0]-point1e[0];
		var y2=point3e[1]-point1e[1];
		var z2=point3e[2]-point1e[2];
		var yz=(y1 *z2)-(z1 *y2);
		var xz=(z1 *x2)-(x1 *z2);
		var xy=(x1 *y2)-(y1 *x2);
		var invPyth=1 / (Math.sqrt((yz *yz)+(xz *xz)+(xy *xy)));
		var x=yz *invPyth;
		var y=xz *invPyth;
		var z=xy *invPyth;
		var TEMPVec3e=Plane._TEMPVec3.elements;
		TEMPVec3e[0]=x;
		TEMPVec3e[1]=y;
		TEMPVec3e[2]=z;
		var d=-((x *point1e[0])+(y *point1e[1])+(z *point1e[2]));
		var plane=new Plane(Plane._TEMPVec3,d);
		return plane;
	}

	Plane.PlaneIntersectionType_Back=0;
	Plane.PlaneIntersectionType_Front=1;
	Plane.PlaneIntersectionType_Intersecting=2;
	__static(Plane,
	['_TEMPVec3',function(){return this._TEMPVec3=new Vector3();}
	]);
	return Plane;
})()


/**
*...
*@author ...
*/
//class laya.d3.physics.shape.HeightfieldColliderShape
var HeightfieldColliderShape=(function(){
	function HeightfieldColliderShape(){}
	__class(HeightfieldColliderShape,'laya.d3.physics.shape.HeightfieldColliderShape');
	return HeightfieldColliderShape;
})()


/**
*<code>Ray</code> 类用于创建射线。
*/
//class laya.d3.math.Ray
var Ray=(function(){
	function Ray(origin,direction){
		/**原点*/
		this.origin=null;
		/**方向*/
		this.direction=null;
		this.origin=origin;
		this.direction=direction;
	}

	__class(Ray,'laya.d3.math.Ray');
	return Ray;
})()


/**
*...
*@author ...
*/
//class laya.d3.graphics.Vertex.VertexShuriKenParticle
var VertexShuriKenParticle=(function(){
	function VertexShuriKenParticle(){}
	__class(VertexShuriKenParticle,'laya.d3.graphics.Vertex.VertexShuriKenParticle');
	VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0=0;
	VertexShuriKenParticle.PARTICLE_POSITION0=1;
	VertexShuriKenParticle.PARTICLE_COLOR0=2;
	VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0=3;
	VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME=4;
	VertexShuriKenParticle.PARTICLE_DIRECTIONTIME=5;
	VertexShuriKenParticle.PARTICLE_STARTCOLOR0=6;
	VertexShuriKenParticle.PARTICLE_ENDCOLOR0=7;
	VertexShuriKenParticle.PARTICLE_STARTSIZE=8;
	VertexShuriKenParticle.PARTICLE_STARTROTATION=9;
	VertexShuriKenParticle.PARTICLE_STARTSPEED=10;
	VertexShuriKenParticle.PARTICLE_RANDOM0=11;
	VertexShuriKenParticle.PARTICLE_RANDOM1=12;
	VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION=13;
	VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION=14;
	return VertexShuriKenParticle;
})()


/**
*<code>Collision</code> 类用于检测碰撞。
*/
//class laya.d3.math.CollisionUtils
var CollisionUtils=(function(){
	/**
	*创建一个 <code>Collision</code> 实例。
	*/
	function CollisionUtils(){}
	__class(CollisionUtils,'laya.d3.math.CollisionUtils');
	CollisionUtils.distancePlaneToPoint=function(plane,point){
		var dot=Vector3.dot(plane.normal,point);
		return dot-plane.distance;
	}

	CollisionUtils.distanceBoxToPoint=function(box,point){
		var boxMine=box.min.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMaxe=box.max.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		var pointe=point.elements;
		var pointeX=pointe[0];
		var pointeY=pointe[1];
		var pointeZ=pointe[2];
		var distance=0;
		if (pointeX < boxMineX)
			distance+=(boxMineX-pointeX)*(boxMineX-pointeX);
		if (pointeX > boxMaxeX)
			distance+=(boxMaxeX-pointeX)*(boxMaxeX-pointeX);
		if (pointeY < boxMineY)
			distance+=(boxMineY-pointeY)*(boxMineY-pointeY);
		if (pointeY > boxMaxeY)
			distance+=(boxMaxeY-pointeY)*(boxMaxeY-pointeY);
		if (pointeZ < boxMineZ)
			distance+=(boxMineZ-pointeZ)*(boxMineZ-pointeZ);
		if (pointeZ > boxMaxeZ)
			distance+=(boxMaxeZ-pointeZ)*(boxMaxeZ-pointeZ);
		return Math.sqrt(distance);
	}

	CollisionUtils.distanceBoxToBox=function(box1,box2){
		var box1Mine=box1.min.elements;
		var box1MineX=box1Mine[0];
		var box1MineY=box1Mine[1];
		var box1MineZ=box1Mine[2];
		var box1Maxe=box1.max.elements;
		var box1MaxeX=box1Maxe[0];
		var box1MaxeY=box1Maxe[1];
		var box1MaxeZ=box1Maxe[2];
		var box2Mine=box2.min.elements;
		var box2MineX=box2Mine[0];
		var box2MineY=box2Mine[1];
		var box2MineZ=box2Mine[2];
		var box2Maxe=box2.max.elements;
		var box2MaxeX=box2Maxe[0];
		var box2MaxeY=box2Maxe[1];
		var box2MaxeZ=box2Maxe[2];
		var distance=0;
		var delta=NaN;
		if (box1MineX > box2MaxeX){
			delta=box1MineX-box2MaxeX;
			distance+=delta *delta;
			}else if (box2MineX > box1MaxeX){
			delta=box2MineX-box1MaxeX;
			distance+=delta *delta;
		}
		if (box1MineY > box2MaxeY){
			delta=box1MineY-box2MaxeY;
			distance+=delta *delta;
			}else if (box2MineY > box1MaxeY){
			delta=box2MineY-box1MaxeY;
			distance+=delta *delta;
		}
		if (box1MineZ > box2MaxeZ){
			delta=box1MineZ-box2MaxeZ;
			distance+=delta *delta;
			}else if (box2MineZ > box1MaxeZ){
			delta=box2MineZ-box1MaxeZ;
			distance+=delta *delta;
		}
		return Math.sqrt(distance);
	}

	CollisionUtils.distanceSphereToPoint=function(sphere,point){
		var distance=Math.sqrt(Vector3.distanceSquared(sphere.center,point));
		distance-=sphere.radius;
		return Math.max(distance,0);
	}

	CollisionUtils.distanceSphereToSphere=function(sphere1,sphere2){
		var distance=Math.sqrt(Vector3.distanceSquared(sphere1.center,sphere2.center));
		distance-=sphere1.radius+sphere2.radius;
		return Math.max(distance,0);
	}

	CollisionUtils.intersectsRayAndTriangleRD=function(ray,vertex1,vertex2,vertex3,out){
		var rayO=ray.origin;
		var rayOe=rayO.elements;
		var rayOeX=rayOe[0];
		var rayOeY=rayOe[1];
		var rayOeZ=rayOe[2];
		var rayD=ray.direction;
		var rayDe=rayD.elements;
		var rayDeX=rayDe[0];
		var rayDeY=rayDe[1];
		var rayDeZ=rayDe[2];
		var v1e=vertex1.elements;
		var v1eX=v1e[0];
		var v1eY=v1e[1];
		var v1eZ=v1e[2];
		var v2e=vertex2.elements;
		var v2eX=v2e[0];
		var v2eY=v2e[1];
		var v2eZ=v2e[2];
		var v3e=vertex3.elements;
		var v3eX=v3e[0];
		var v3eY=v3e[1];
		var v3eZ=v3e[2];
		var _tempV30e=CollisionUtils._tempV30.elements;
		var _tempV30eX=_tempV30e[0];
		var _tempV30eY=_tempV30e[1];
		var _tempV30eZ=_tempV30e[2];
		_tempV30eX=v2eX-v1eX;
		_tempV30eY=v2eY-v1eY;
		_tempV30eZ=v2eZ-v1eZ;
		var _tempV31e=CollisionUtils._tempV31.elements;
		var _tempV31eX=_tempV31e[0];
		var _tempV31eY=_tempV31e[1];
		var _tempV31eZ=_tempV31e[2];
		_tempV31eX=v3eX-v1eX;
		_tempV31eY=v3eY-v1eY;
		_tempV31eZ=v3eZ-v1eZ;
		var _tempV32e=CollisionUtils._tempV32.elements;
		var _tempV32eX=_tempV32e[0];
		var _tempV32eY=_tempV32e[1];
		var _tempV32eZ=_tempV32e[2];
		_tempV32eX=(rayDeY *_tempV31eZ)-(rayDeZ *_tempV31eY);
		_tempV32eY=(rayDeZ *_tempV31eX)-(rayDeX *_tempV31eZ);
		_tempV32eZ=(rayDeX *_tempV31eY)-(rayDeY *_tempV31eX);
		var determinant=(_tempV30eX *_tempV32eX)+(_tempV30eY *_tempV32eY)+(_tempV30eZ *_tempV32eZ);
		if (MathUtils3D.isZero(determinant)){
			out=0;
			return false;
		};
		var inversedeterminant=1 / determinant;
		var _tempV33e=CollisionUtils._tempV33.elements;
		var _tempV33eX=_tempV33e[0];
		var _tempV33eY=_tempV33e[1];
		var _tempV33eZ=_tempV33e[2];
		_tempV33eX=rayOeX-v1eX;
		_tempV33eY=rayOeY-v1eY;
		_tempV33eZ=rayOeZ-v1eZ;
		var triangleU=(_tempV33eX *_tempV32eX)+(_tempV33eY *_tempV32eY)+(_tempV33eZ *_tempV32eZ);
		triangleU *=inversedeterminant;
		if (triangleU < 0 || triangleU > 1){
			out=0;
			return false;
		};
		var _tempV34e=CollisionUtils._tempV34.elements;
		var _tempV34eX=_tempV34e[0];
		var _tempV34eY=_tempV34e[1];
		var _tempV34eZ=_tempV34e[2];
		_tempV34eX=(_tempV33eY *_tempV30eZ)-(_tempV33eZ *_tempV30eY);
		_tempV34eY=(_tempV33eZ *_tempV30eX)-(_tempV33eX *_tempV30eZ);
		_tempV34eZ=(_tempV33eX *_tempV30eY)-(_tempV33eY *_tempV30eX);
		var triangleV=((rayDeX *_tempV34eX)+(rayDeY *_tempV34eY))+(rayDeZ *_tempV34eZ);
		triangleV *=inversedeterminant;
		if (triangleV < 0 || triangleU+triangleV > 1){
			out=0;
			return false;
		};
		var raydistance=(_tempV31eX *_tempV34eX)+(_tempV31eY *_tempV34eY)+(_tempV31eZ *_tempV34eZ);
		raydistance *=inversedeterminant;
		if (raydistance < 0){
			out=0;
			return false;
		}
		out=raydistance;
		return true;
	}

	CollisionUtils.intersectsRayAndTriangleRP=function(ray,vertex1,vertex2,vertex3,out){
		var distance=NaN;
		if (!CollisionUtils.intersectsRayAndTriangleRD(ray,vertex1,vertex2,vertex3,distance)){
			out=Vector3.ZERO;
			return false;
		}
		Vector3.scale(ray.direction,distance,CollisionUtils._tempV30);
		Vector3.add(ray.origin,CollisionUtils._tempV30,out);
		return true;
	}

	CollisionUtils.intersectsRayAndPoint=function(ray,point){
		Vector3.subtract(ray.origin,point,CollisionUtils._tempV30);
		var b=Vector3.dot(CollisionUtils._tempV30,ray.direction);
		var c=Vector3.dot(CollisionUtils._tempV30,CollisionUtils._tempV30)-MathUtils3D.zeroTolerance;
		if (c > 0 && b > 0)
			return false;
		var discriminant=b *b-c;
		if (discriminant < 0)
			return false;
		return true;
	}

	CollisionUtils.intersectsRayAndRay=function(ray1,ray2,out){
		var ray1o=ray1.origin;
		var ray1oe=ray1o.elements;
		var ray1oeX=ray1oe[0];
		var ray1oeY=ray1oe[1];
		var ray1oeZ=ray1oe[2];
		var ray1d=ray1.direction;
		var ray1de=ray1d.elements;
		var ray1deX=ray1de[0];
		var ray1deY=ray1de[1];
		var ray1deZ=ray1de[2];
		var ray2o=ray2.origin;
		var ray2oe=ray2o.elements;
		var ray2oeX=ray2oe[0];
		var ray2oeY=ray2oe[1];
		var ray2oeZ=ray2oe[2];
		var ray2d=ray2.direction;
		var ray2de=ray2d.elements;
		var ray2deX=ray2de[0];
		var ray2deY=ray2de[1];
		var ray2deZ=ray2de[2];
		Vector3.cross(ray1d,ray2d,CollisionUtils._tempV30);
		var tempV3e=CollisionUtils._tempV30.elements;
		var denominator=Vector3.scalarLength(CollisionUtils._tempV30);
		if (MathUtils3D.isZero(denominator)){
			if (MathUtils3D.nearEqual(ray2oeX,ray1oeX)&& MathUtils3D.nearEqual(ray2oeY,ray1oeY)&& MathUtils3D.nearEqual(ray2oeZ,ray1oeZ)){
				out=Vector3.ZERO;
				return true;
			}
		}
		denominator=denominator *denominator;
		var m11=ray2oeX-ray1oeX;
		var m12=ray2oeY-ray1oeY;
		var m13=ray2oeZ-ray1oeZ;
		var m21=ray2deX;
		var m22=ray2deY;
		var m23=ray2deZ;
		var m31=tempV3e[0];
		var m32=tempV3e[1];
		var m33=tempV3e[2];
		var dets=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
		m21=ray1deX;
		m22=ray1deY;
		m23=ray1deZ;
		var dett=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
		var s=dets / denominator;
		var t=dett / denominator;
		Vector3.scale(ray1d,s,CollisionUtils._tempV30);
		Vector3.scale(ray2d,s,CollisionUtils._tempV31);
		Vector3.add(ray1o,CollisionUtils._tempV30,CollisionUtils._tempV32);
		Vector3.add(ray2o,CollisionUtils._tempV31,CollisionUtils._tempV33);
		var point1e=CollisionUtils._tempV32.elements;
		var point2e=CollisionUtils._tempV33.elements;
		if (!MathUtils3D.nearEqual(point2e[0],point1e[0])|| !MathUtils3D.nearEqual(point2e[1],point1e[1])|| !MathUtils3D.nearEqual(point2e[2],point1e[2])){
			out=Vector3.ZERO;
			return false;
		}
		out=CollisionUtils._tempV32;
		return true;
	}

	CollisionUtils.intersectsPlaneAndTriangle=function(plane,vertex1,vertex2,vertex3){
		var test1=CollisionUtils.intersectsPlaneAndPoint(plane,vertex1);
		var test2=CollisionUtils.intersectsPlaneAndPoint(plane,vertex2);
		var test3=CollisionUtils.intersectsPlaneAndPoint(plane,vertex3);
		if (test1==Plane.PlaneIntersectionType_Front && test2==Plane.PlaneIntersectionType_Front && test3==Plane.PlaneIntersectionType_Front)
			return Plane.PlaneIntersectionType_Front;
		if (test1==Plane.PlaneIntersectionType_Back && test2==Plane.PlaneIntersectionType_Back && test3==Plane.PlaneIntersectionType_Back)
			return Plane.PlaneIntersectionType_Back;
		return Plane.PlaneIntersectionType_Intersecting;
	}

	CollisionUtils.intersectsRayAndPlaneRD=function(ray,plane,out){
		var planeNor=plane.normal;
		var direction=Vector3.dot(planeNor,ray.direction);
		if (MathUtils3D.isZero(direction)){
			out=0;
			return false;
		};
		var position=Vector3.dot(planeNor,ray.origin);
		out=(-plane.distance-position)/ direction;
		if (out < 0){
			out=0;
			return false;
		}
		return true;
	}

	CollisionUtils.intersectsRayAndPlaneRP=function(ray,plane,out){
		var distance=NaN;
		if (!CollisionUtils.intersectsRayAndPlaneRD(ray,plane,distance)){
			out=Vector3.ZERO;
			return false;
		}
		Vector3.scale(ray.direction,distance,CollisionUtils._tempV30);
		Vector3.add(ray.origin,CollisionUtils._tempV30,CollisionUtils._tempV31);
		out=CollisionUtils._tempV31;
		return true;
	}

	CollisionUtils.intersectsRayAndBoxRD=function(ray,box){
		var rayoe=ray.origin.elements;
		var rayoeX=rayoe[0];
		var rayoeY=rayoe[1];
		var rayoeZ=rayoe[2];
		var rayde=ray.direction.elements;
		var raydeX=rayde[0];
		var raydeY=rayde[1];
		var raydeZ=rayde[2];
		var boxMine=box.min.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMaxe=box.max.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		var out=0;
		var tmax=MathUtils3D.MaxValue;
		if (MathUtils3D.isZero(raydeX)){
			if (rayoeX < boxMineX || rayoeX > boxMaxeX){
				return-1;
			}
			}else {
			var inverse=1 / raydeX;
			var t1=(boxMineX-rayoeX)*inverse;
			var t2=(boxMaxeX-rayoeX)*inverse;
			if (t1 > t2){
				var temp=t1;
				t1=t2;
				t2=temp;
			}
			out=Math.max(t1,out);
			tmax=Math.min(t2,tmax);
			if (out > tmax){
				return-1;
			}
		}
		if (MathUtils3D.isZero(raydeY)){
			if (rayoeY < boxMineY || rayoeY > boxMaxeY){
				return-1;
			}
			}else {
			var inverse1=1 / raydeY;
			var t3=(boxMineY-rayoeY)*inverse1;
			var t4=(boxMaxeY-rayoeY)*inverse1;
			if (t3 > t4){
				var temp1=t3;
				t3=t4;
				t4=temp1;
			}
			out=Math.max(t3,out);
			tmax=Math.min(t4,tmax);
			if (out > tmax){
				return-1;
			}
		}
		if (MathUtils3D.isZero(raydeZ)){
			if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ){
				return-1;
			}
			}else {
			var inverse2=1 / raydeZ;
			var t5=(boxMineZ-rayoeZ)*inverse2;
			var t6=(boxMaxeZ-rayoeZ)*inverse2;
			if (t5 > t6){
				var temp2=t5;
				t5=t6;
				t6=temp2;
			}
			out=Math.max(t5,out);
			tmax=Math.min(t6,tmax);
			if (out > tmax){
				return-1;
			}
		}
		return out;
	}

	CollisionUtils.intersectsRayAndBoxRP=function(ray,box,out){
		var distance=CollisionUtils.intersectsRayAndBoxRD(ray,box);
		if (distance===-1){
			Vector3.ZERO.cloneTo(out);
			return distance;
		}
		Vector3.scale(ray.direction,distance,CollisionUtils._tempV30);
		Vector3.add(ray.origin,CollisionUtils._tempV30,CollisionUtils._tempV31);
		CollisionUtils._tempV31.cloneTo(out);
		return distance;
	}

	CollisionUtils.intersectsRayAndSphereRD=function(ray,sphere){
		var sphereR=sphere.radius;
		Vector3.subtract(ray.origin,sphere.center,CollisionUtils._tempV30);
		var b=Vector3.dot(CollisionUtils._tempV30,ray.direction);
		var c=Vector3.dot(CollisionUtils._tempV30,CollisionUtils._tempV30)-(sphereR *sphereR);
		if (c > 0 && b > 0){
			return-1;
		};
		var discriminant=b *b-c;
		if (discriminant < 0){
			return-1;
		};
		var distance=-b-Math.sqrt(discriminant);
		if (distance < 0)
			distance=0;
		return distance;
	}

	CollisionUtils.intersectsRayAndSphereRP=function(ray,sphere,out){
		var distance=CollisionUtils.intersectsRayAndSphereRD(ray,sphere);
		if (distance===-1){
			Vector3.ZERO.cloneTo(out);
			return distance;
		}
		Vector3.scale(ray.direction,distance,CollisionUtils._tempV30);
		Vector3.add(ray.origin,CollisionUtils._tempV30,CollisionUtils._tempV31);
		CollisionUtils._tempV31.cloneTo(out);
		return distance;
	}

	CollisionUtils.intersectsSphereAndTriangle=function(sphere,vertex1,vertex2,vertex3){
		var sphereC=sphere.center;
		var sphereR=sphere.radius;
		CollisionUtils.closestPointPointTriangle(sphereC,vertex1,vertex2,vertex3,CollisionUtils._tempV30);
		Vector3.subtract(CollisionUtils._tempV30,sphereC,CollisionUtils._tempV31);
		var dot=Vector3.dot(CollisionUtils._tempV31,CollisionUtils._tempV31);
		return dot <=sphereR *sphereR;
	}

	CollisionUtils.intersectsPlaneAndPoint=function(plane,point){
		var distance=Vector3.dot(plane.normal,point)+plane.distance;
		if (distance > 0)
			return Plane.PlaneIntersectionType_Front;
		if (distance < 0)
			return Plane.PlaneIntersectionType_Back;
		return Plane.PlaneIntersectionType_Intersecting;
	}

	CollisionUtils.intersectsPlaneAndPlane=function(plane1,plane2){
		Vector3.cross(plane1.normal,plane2.normal,CollisionUtils._tempV30);
		var denominator=Vector3.dot(CollisionUtils._tempV30,CollisionUtils._tempV30);
		if (MathUtils3D.isZero(denominator))
			return false;
		return true;
	}

	CollisionUtils.intersectsPlaneAndPlaneRL=function(plane1,plane2,line){
		var plane1nor=plane1.normal;
		var plane2nor=plane2.normal;
		Vector3.cross(plane1nor,plane2nor,CollisionUtils._tempV34);
		var denominator=Vector3.dot(CollisionUtils._tempV34,CollisionUtils._tempV34);
		if (MathUtils3D.isZero(denominator))
			return false;
		Vector3.scale(plane2nor,plane1.distance,CollisionUtils._tempV30);
		Vector3.scale(plane1nor,plane2.distance,CollisionUtils._tempV31);
		Vector3.subtract(CollisionUtils._tempV30,CollisionUtils._tempV31,CollisionUtils._tempV32);
		Vector3.cross(CollisionUtils._tempV32,CollisionUtils._tempV34,CollisionUtils._tempV33);
		Vector3.normalize(CollisionUtils._tempV34,CollisionUtils._tempV34);
		line=new Ray(CollisionUtils._tempV33,CollisionUtils._tempV34);
		return true;
	}

	CollisionUtils.intersectsPlaneAndBox=function(plane,box){
		var planeD=plane.distance;
		var planeNor=plane.normal;
		var planeNore=planeNor.elements;
		var planeNoreX=planeNore[0];
		var planeNoreY=planeNore[1];
		var planeNoreZ=planeNore[2];
		var boxMine=box.min.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMaxe=box.max.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		CollisionUtils._tempV30.elements[0]=(planeNoreX > 0)? boxMineX :boxMaxeX;
		CollisionUtils._tempV30.elements[1]=(planeNoreY > 0)? boxMineY :boxMaxeY;
		CollisionUtils._tempV30.elements[2]=(planeNoreZ > 0)? boxMineZ :boxMaxeZ;
		CollisionUtils._tempV31.elements[0]=(planeNoreX > 0)? boxMaxeX :boxMineX;
		CollisionUtils._tempV31.elements[1]=(planeNoreY > 0)? boxMaxeY :boxMineY;
		CollisionUtils._tempV31.elements[2]=(planeNoreZ > 0)? boxMaxeZ :boxMineZ;
		var distance=Vector3.dot(planeNor,CollisionUtils._tempV30);
		if (distance+planeD > 0)
			return Plane.PlaneIntersectionType_Front;
		distance=Vector3.dot(planeNor,CollisionUtils._tempV31);
		if (distance+planeD < 0)
			return Plane.PlaneIntersectionType_Back;
		return Plane.PlaneIntersectionType_Intersecting;
	}

	CollisionUtils.intersectsPlaneAndSphere=function(plane,sphere){
		var sphereR=sphere.radius;
		var distance=Vector3.dot(plane.normal,sphere.center)+plane.distance;
		if (distance > sphereR)
			return Plane.PlaneIntersectionType_Front;
		if (distance <-sphereR)
			return Plane.PlaneIntersectionType_Back;
		return Plane.PlaneIntersectionType_Intersecting;
	}

	CollisionUtils.intersectsBoxAndBox=function(box1,box2){
		var box1Mine=box1.min.elements;
		var box1Maxe=box1.max.elements;
		var box2Mine=box2.min.elements;
		var box2Maxe=box2.max.elements;
		if (box1Mine[0] > box2Maxe[0] || box2Mine[0] > box1Maxe[0])
			return false;
		if (box1Mine[1] > box2Maxe[1] || box2Mine[1] > box1Maxe[1])
			return false;
		if (box1Mine[2] > box2Maxe[2] || box2Mine[2] > box1Maxe[2])
			return false;
		return true;
	}

	CollisionUtils.intersectsBoxAndSphere=function(box,sphere){
		var sphereC=sphere.center;
		var sphereR=sphere.radius;
		Vector3.Clamp(sphereC,box.min,box.max,CollisionUtils._tempV30);
		var distance=Vector3.distanceSquared(sphereC,CollisionUtils._tempV30);
		return distance <=sphereR *sphereR;
	}

	CollisionUtils.intersectsSphereAndSphere=function(sphere1,sphere2){
		var radiisum=sphere1.radius+sphere2.radius;
		return Vector3.distanceSquared(sphere1.center,sphere2.center)<=radiisum *radiisum;
	}

	CollisionUtils.boxContainsPoint=function(box,point){
		var boxMine=box.min.elements;
		var boxMaxe=box.max.elements;
		var pointe=point.elements;
		if (boxMine[0] <=pointe[0] && boxMaxe[0] >=pointe[0] && boxMine[1] <=pointe[1] && boxMaxe[1] >=pointe[1] && boxMine[2] <=pointe[2] && boxMaxe[2] >=pointe[2])
			return /*laya.d3.math.ContainmentType.Contains*/1;
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	CollisionUtils.boxContainsBox=function(box1,box2){
		var box1Mine=box1.min.elements;
		var box1MineX=box1Mine[0];
		var box1MineY=box1Mine[1];
		var box1MineZ=box1Mine[2];
		var box1Maxe=box1.max.elements;
		var box1MaxeX=box1Maxe[0];
		var box1MaxeY=box1Maxe[1];
		var box1MaxeZ=box1Maxe[2];
		var box2Mine=box2.min.elements;
		var box2MineX=box2Mine[0];
		var box2MineY=box2Mine[1];
		var box2MineZ=box2Mine[2];
		var box2Maxe=box2.max.elements;
		var box2MaxeX=box2Maxe[0];
		var box2MaxeY=box2Maxe[1];
		var box2MaxeZ=box2Maxe[2];
		if (box1MaxeX < box2MineX || box1MineX > box2MaxeX)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (box1MaxeY < box2MineY || box1MineY > box2MaxeY)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (box1MaxeZ < box2MineZ || box1MineZ > box2MaxeZ)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (box1MineX <=box2MineX && box2MaxeX <=box2MaxeX && box1MineY <=box2MineY && box2MaxeY <=box1MaxeY && box1MineZ <=box2MineZ && box2MaxeZ <=box1MaxeZ){
			return /*laya.d3.math.ContainmentType.Contains*/1;
		}
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	CollisionUtils.boxContainsSphere=function(box,sphere){
		var boxMin=box.min;
		var boxMine=boxMin.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMax=box.max;
		var boxMaxe=boxMax.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		var sphereC=sphere.center;
		var sphereCe=sphereC.elements;
		var sphereCeX=sphereCe[0];
		var sphereCeY=sphereCe[1];
		var sphereCeZ=sphereCe[2];
		var sphereR=sphere.radius;
		Vector3.Clamp(sphereC,boxMin,boxMax,CollisionUtils._tempV30);
		var distance=Vector3.distanceSquared(sphereC,CollisionUtils._tempV30);
		if (distance > sphereR *sphereR)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if ((((boxMineX+sphereR <=sphereCeX)&& (sphereCeX <=boxMaxeX-sphereR))&& ((boxMaxeX-boxMineX > sphereR)&&
			(boxMineY+sphereR <=sphereCeY)))&& (((sphereCeY <=boxMaxeY-sphereR)&& (boxMaxeY-boxMineY > sphereR))&&
		(((boxMineZ+sphereR <=sphereCeZ)&& (sphereCeZ <=boxMaxeZ-sphereR))&& (boxMaxeZ-boxMineZ > sphereR))))
		return /*laya.d3.math.ContainmentType.Contains*/1;
		return /*laya.d3.math.ContainmentType.Intersects*/2;
	}

	CollisionUtils.sphereContainsPoint=function(sphere,point){
		if (Vector3.distanceSquared(point,sphere.center)<=sphere.radius *sphere.radius)
			return /*laya.d3.math.ContainmentType.Contains*/1;
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	CollisionUtils.sphereContainsTriangle=function(sphere,vertex1,vertex2,vertex3){
		var test1=CollisionUtils.sphereContainsPoint(sphere,vertex1);
		var test2=CollisionUtils.sphereContainsPoint(sphere,vertex2);
		var test3=CollisionUtils.sphereContainsPoint(sphere,vertex3);
		if (test1==/*laya.d3.math.ContainmentType.Contains*/1 && test2==/*laya.d3.math.ContainmentType.Contains*/1 && test3==/*laya.d3.math.ContainmentType.Contains*/1)
			return /*laya.d3.math.ContainmentType.Contains*/1;
		if (CollisionUtils.intersectsSphereAndTriangle(sphere,vertex1,vertex2,vertex3))
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		return /*laya.d3.math.ContainmentType.Disjoint*/0;
	}

	CollisionUtils.sphereContainsBox=function(sphere,box){
		var sphereC=sphere.center;
		var sphereCe=sphereC.elements;
		var sphereCeX=sphereCe[0];
		var sphereCeY=sphereCe[1];
		var sphereCeZ=sphereCe[2];
		var sphereR=sphere.radius;
		var boxMin=box.min;
		var boxMine=boxMin.elements;
		var boxMineX=boxMine[0];
		var boxMineY=boxMine[1];
		var boxMineZ=boxMine[2];
		var boxMax=box.max;
		var boxMaxe=boxMax.elements;
		var boxMaxeX=boxMaxe[0];
		var boxMaxeY=boxMaxe[1];
		var boxMaxeZ=boxMaxe[2];
		var _tempV30e=CollisionUtils._tempV30.elements;
		var _tempV30eX=_tempV30e[0];
		var _tempV30eY=_tempV30e[1];
		var _tempV30eZ=_tempV30e[2];
		if (!CollisionUtils.intersectsBoxAndSphere(box,sphere))
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		var radiusSquared=sphereR *sphereR;
		_tempV30eX=sphereCeX-boxMineX;
		_tempV30eY=sphereCeY-boxMaxeY;
		_tempV30eZ=sphereCeZ-boxMaxeZ;
		if (Vector3.scalarLengthSquared(CollisionUtils._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMaxeX;
		_tempV30eY=sphereCeY-boxMaxeY;
		_tempV30eZ=sphereCeZ-boxMaxeZ;
		if (Vector3.scalarLengthSquared(CollisionUtils._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMaxeX;
		_tempV30eY=sphereCeY-boxMineY;
		_tempV30eZ=sphereCeZ-boxMaxeZ;
		if (Vector3.scalarLengthSquared(CollisionUtils._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMineX;
		_tempV30eY=sphereCeY-boxMineY;
		_tempV30eZ=sphereCeZ-boxMaxeZ;
		if (Vector3.scalarLengthSquared(CollisionUtils._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMineX;
		_tempV30eY=sphereCeY-boxMaxeY;
		_tempV30eZ=sphereCeZ-boxMineZ;
		if (Vector3.scalarLengthSquared(CollisionUtils._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMaxeX;
		_tempV30eY=sphereCeY-boxMaxeY;
		_tempV30eZ=sphereCeZ-boxMineZ;
		if (Vector3.scalarLengthSquared(CollisionUtils._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMaxeX;
		_tempV30eY=sphereCeY-boxMineY;
		_tempV30eZ=sphereCeZ-boxMineZ;
		if (Vector3.scalarLengthSquared(CollisionUtils._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		_tempV30eX=sphereCeX-boxMineX;
		_tempV30eY=sphereCeY-boxMineY;
		_tempV30eZ=sphereCeZ-boxMineZ;
		if (Vector3.scalarLengthSquared(CollisionUtils._tempV30)> radiusSquared)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		return /*laya.d3.math.ContainmentType.Contains*/1;
	}

	CollisionUtils.sphereContainsSphere=function(sphere1,sphere2){
		var sphere1R=sphere1.radius;
		var sphere2R=sphere2.radius;
		var distance=Vector3.distance(sphere1.center,sphere2.center);
		if (sphere1R+sphere2R < distance)
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		if (sphere1R-sphere2R < distance)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		return /*laya.d3.math.ContainmentType.Contains*/1;
	}

	CollisionUtils.closestPointPointTriangle=function(point,vertex1,vertex2,vertex3,out){
		Vector3.subtract(vertex2,vertex1,CollisionUtils._tempV30);
		Vector3.subtract(vertex3,vertex1,CollisionUtils._tempV31);
		Vector3.subtract(point,vertex1,CollisionUtils._tempV32);
		Vector3.subtract(point,vertex2,CollisionUtils._tempV33);
		Vector3.subtract(point,vertex3,CollisionUtils._tempV34);
		var d1=Vector3.dot(CollisionUtils._tempV30,CollisionUtils._tempV32);
		var d2=Vector3.dot(CollisionUtils._tempV31,CollisionUtils._tempV32);
		var d3=Vector3.dot(CollisionUtils._tempV30,CollisionUtils._tempV33);
		var d4=Vector3.dot(CollisionUtils._tempV31,CollisionUtils._tempV33);
		var d5=Vector3.dot(CollisionUtils._tempV30,CollisionUtils._tempV34);
		var d6=Vector3.dot(CollisionUtils._tempV31,CollisionUtils._tempV34);
		if (d1 <=0 && d2 <=0){
			vertex1.cloneTo(out);
			return;
		}
		if (d3 >=0 && d4 <=d3){
			vertex2.cloneTo(out);
			return;
		};
		var vc=d1 *d4-d3 *d2;
		if (vc <=0 && d1 >=0 && d3 <=0){
			var v=d1 / (d1-d3);
			Vector3.scale(CollisionUtils._tempV30,v,out);
			Vector3.add(vertex1,out,out);
			return;
		}
		if (d6 >=0 && d5 <=d6){
			vertex3.cloneTo(out);
			return;
		};
		var vb=d5 *d2-d1 *d6;
		if (vb <=0 && d2 >=0 && d6 <=0){
			var w=d2 / (d2-d6);
			Vector3.scale(CollisionUtils._tempV31,w,out);
			Vector3.add(vertex1,out,out);
			return;
		};
		var va=d3 *d6-d5 *d4;
		if (va <=0 && (d4-d3)>=0 && (d5-d6)>=0){
			var w3=(d4-d3)/ ((d4-d3)+(d5-d6));
			Vector3.subtract(vertex3,vertex2,out);
			Vector3.scale(out,w3,out);
			Vector3.add(vertex2,out,out);
			return;
		};
		var denom=1 / (va+vb+vc);
		var v2=vb *denom;
		var w2=vc *denom;
		Vector3.scale(CollisionUtils._tempV30,v2,CollisionUtils._tempV35);
		Vector3.scale(CollisionUtils._tempV31,w2,CollisionUtils._tempV36);
		Vector3.add(CollisionUtils._tempV35,CollisionUtils._tempV36,out);
		Vector3.add(vertex1,out,out);
	}

	CollisionUtils.closestPointPlanePoint=function(plane,point,out){
		var planeN=plane.normal;
		var t=Vector3.dot(planeN,point)-plane.distance;
		Vector3.scale(planeN,t,CollisionUtils._tempV30);
		Vector3.subtract(point,CollisionUtils._tempV30,out);
	}

	CollisionUtils.closestPointBoxPoint=function(box,point,out){
		Vector3.max(point,box.min,CollisionUtils._tempV30);
		Vector3.min(CollisionUtils._tempV30,box.max,out);
	}

	CollisionUtils.closestPointSpherePoint=function(sphere,point,out){
		var sphereC=sphere.center;
		Vector3.subtract(point,sphereC,out);
		Vector3.normalize(out,out);
		Vector3.scale(out,sphere.radius,out);
		Vector3.add(out,sphereC,out);
	}

	CollisionUtils.closestPointSphereSphere=function(sphere1,sphere2,out){
		var sphere1C=sphere1.center;
		Vector3.subtract(sphere2.center,sphere1C,out);
		Vector3.normalize(out,out);
		Vector3.scale(out,sphere1.radius,out);
		Vector3.add(out,sphere1C,out);
	}

	__static(CollisionUtils,
	['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();}
	]);
	return CollisionUtils;
})()


/**
*<code>TrailFilter</code> 类用于创建拖尾过滤器。
*/
//class laya.d3.core.trail.TrailFilter
var TrailFilter=(function(){
	function TrailFilter(owner){
		/**@private */
		this._minVertexDistance=NaN;
		/**@private */
		this._widthMultiplier=NaN;
		/**@private */
		this._time=NaN;
		/**@private */
		this._widthCurve=null;
		/**@private */
		this._colorGradient=null;
		/**@private */
		this._textureMode=0;
		/**@private */
		this._trialGeometry=null;
		/**@private 拖尾总长度*/
		this._totalLength=0;
		this._owner=null;
		this._curtime=0;
		this._trailRenderElementIndex=0;
		this._lastPosition=new Vector3();
		this.alignment=0;
		this._owner=owner;
		this._initDefaultData();
		this.addRenderElement();
	}

	__class(TrailFilter,'laya.d3.core.trail.TrailFilter');
	var __proto=TrailFilter.prototype;
	/**
	*@private
	*/
	__proto.addRenderElement=function(){
		var render=this._owner._render;
		var elements=render._renderElements;
		var material=render.sharedMaterials [0];
		(material)|| (material=TrailMaterial.defaultMaterial);
		var element=new RenderElement();
		element.setTransform(this._owner._transform);
		element.render=render;
		element.material=material;
		this._trialGeometry=new TrailGeometry(this);
		element.setGeometry(this._trialGeometry);
		elements.push(element);
	}

	/**
	*@private
	*/
	__proto._update=function(state){
		var render=this._owner._render;
		this._curtime+=(state.scene).timer._delta / 1000;
		render._shaderValues.setNumber(TrailSprite3D.CURTIME,this._curtime);
		var curPos=this._owner.transform.position;
		var element=render._renderElements[0] ._geometry;
		element._updateDisappear();
		element._updateTrail(state.camera,this._lastPosition,curPos);
		element._updateVertexBufferUV();
		curPos.cloneTo(this._lastPosition);
	}

	/**
	*@private
	*/
	__proto._initDefaultData=function(){
		this.time=5.0;
		this.minVertexDistance=0.1;
		this.widthMultiplier=1;
		this.textureMode=/*laya.d3.core.TextureMode.Stretch*/0;
		var widthKeyFrames=[];
		var widthKeyFrame1=new FloatKeyframe();
		widthKeyFrame1.time=0;
		widthKeyFrame1.inTangent=0;
		widthKeyFrame1.outTangent=0;
		widthKeyFrame1.value=1;
		widthKeyFrames.push(widthKeyFrame1);
		var widthKeyFrame2=new FloatKeyframe();
		widthKeyFrame2.time=1;
		widthKeyFrame2.inTangent=0;
		widthKeyFrame2.outTangent=0;
		widthKeyFrame2.value=1;
		widthKeyFrames.push(widthKeyFrame2);
		this.widthCurve=widthKeyFrames;
		var gradient=new Gradient(2,2);
		gradient.mode=/*laya.d3.core.GradientMode.Blend*/0;
		gradient.addColorRGB(0,Color.WHITE);
		gradient.addColorRGB(1,Color.WHITE);
		gradient.addColorAlpha(0,1);
		gradient.addColorAlpha(1,1);
		this.colorGradient=gradient;
	}

	/**
	*@private
	*/
	__proto.destroy=function(){
		this._trialGeometry.destroy();
		this._trialGeometry=null;
		this._widthCurve=null;
		this._colorGradient=null;
	}

	/**
	*设置宽度倍数。
	*@param value 宽度倍数。
	*/
	/**
	*获取宽度倍数。
	*@return 宽度倍数。
	*/
	__getset(0,__proto,'widthMultiplier',function(){
		return this._widthMultiplier;
		},function(value){
		this._widthMultiplier=value;
	});

	/**
	*设置淡出时间。
	*@param value 淡出时间。
	*/
	/**
	*获取淡出时间。
	*@return 淡出时间。
	*/
	__getset(0,__proto,'time',function(){
		return this._time;
		},function(value){
		this._time=value;
		this._owner._render._shaderValues.setNumber(TrailSprite3D.LIFETIME,value);
	});

	/**
	*设置宽度曲线。
	*@param value 宽度曲线。
	*/
	/**
	*获取宽度曲线。
	*@return 宽度曲线。
	*/
	__getset(0,__proto,'widthCurve',function(){
		return this._widthCurve;
		},function(value){
		this._widthCurve=value;
		var widthCurveFloatArray=new Float32Array(value.length *4);
		var i=0,j=0,index=0;
		for (i=0,j=value.length;i < j;i++){
			widthCurveFloatArray[index++]=value[i].time;
			widthCurveFloatArray[index++]=value[i].inTangent;
			widthCurveFloatArray[index++]=value[i].outTangent;
			widthCurveFloatArray[index++]=value[i].value;
		}
		this._owner._render._shaderValues.setBuffer(TrailSprite3D.WIDTHCURVE,widthCurveFloatArray);
		this._owner._render._shaderValues.setInt(TrailSprite3D.WIDTHCURVEKEYLENGTH,value.length);
	});

	/**
	*设置新旧顶点之间最小距离。
	*@param value 新旧顶点之间最小距离。
	*/
	/**
	*获取新旧顶点之间最小距离。
	*@return 新旧顶点之间最小距离。
	*/
	__getset(0,__proto,'minVertexDistance',function(){
		return this._minVertexDistance;
		},function(value){
		this._minVertexDistance=value;
	});

	/**
	*设置颜色梯度。
	*@param value 颜色梯度。
	*/
	/**
	*获取颜色梯度。
	*@return 颜色梯度。
	*/
	__getset(0,__proto,'colorGradient',function(){
		return this._colorGradient;
		},function(value){
		this._colorGradient=value;
		this._owner._render._shaderValues.setBuffer(TrailSprite3D.GRADIENTCOLORKEY,value._rgbElements);
		this._owner._render._shaderValues.setBuffer(TrailSprite3D.GRADIENTALPHAKEY,value._alphaElements);
		if (value.mode==/*laya.d3.core.GradientMode.Blend*/0){
			this._owner._render._defineDatas.add(TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND);
			}else {
			this._owner._render._defineDatas.remove(TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND);
		}
	});

	/**
	*设置纹理模式。
	*@param value 纹理模式。
	*/
	/**
	*获取纹理模式。
	*@return 纹理模式。
	*/
	__getset(0,__proto,'textureMode',function(){
		return this._textureMode;
		},function(value){
		this._textureMode=value;
	});

	TrailFilter.ALIGNMENT_VIEW=0;
	TrailFilter.ALIGNMENT_TRANSFORM_Z=1;
	return TrailFilter;
})()


/**
*<code>StaticBatchManager</code> 类用于静态批处理管理的父类。
*/
//class laya.d3.graphics.StaticBatchManager
var StaticBatchManager=(function(){
	function StaticBatchManager(){
		/**@private */
		//this._batchRenderElementPool=null;
		/**@private */
		//this._batchRenderElementPoolIndex=0;
		/**@private */
		//this._initBatchSprites=null;
		/**@private */
		//this._staticBatches=null;
		this._initBatchSprites=[];
		this._staticBatches={};
		this._batchRenderElementPoolIndex=0;
		this._batchRenderElementPool=[];
	}

	__class(StaticBatchManager,'laya.d3.graphics.StaticBatchManager');
	var __proto=StaticBatchManager.prototype;
	/**
	*@private
	*/
	__proto._partition=function(items,left,right){
		var pivot=items[Math.floor((right+left)/ 2)];
		while (left <=right){
			while (this._compare(items[left],pivot)< 0)
			left++;
			while (this._compare(items[right],pivot)> 0)
			right--;
			if (left < right){
				var temp=items[left];
				items[left]=items[right];
				items[right]=temp;
				left++;
				right--;
				}else if (left===right){
				left++;
				break ;
			}
		}
		return left;
	}

	/**
	*@private
	*/
	__proto._quickSort=function(items,left,right){
		if (items.length > 1){
			var index=this._partition(items,left,right);
			var leftIndex=index-1;
			if (left < leftIndex)
				this._quickSort(items,left,leftIndex);
			if (index < right)
				this._quickSort(items,index,right);
		}
	}

	/**
	*@private
	*/
	__proto._compare=function(left,right){
		throw "StaticBatch:must override this function.";
	}

	/**
	*@private
	*/
	__proto._initStaticBatchs=function(rootSprite){
		throw "StaticBatch:must override this function.";
	}

	/**
	*@private
	*/
	__proto._getBatchRenderElementFromPool=function(){
		throw "StaticBatch:must override this function.";
	}

	/**
	*@private
	*/
	__proto._addBatchSprite=function(renderableSprite3D){
		this._initBatchSprites.push(renderableSprite3D);
	}

	/**
	*@private
	*/
	__proto._clear=function(){
		this._batchRenderElementPoolIndex=0;
	}

	/**
	*@private
	*/
	__proto._garbageCollection=function(){
		throw "StaticBatchManager: must override it.";
	}

	/**
	*@private
	*/
	__proto.dispose=function(){
		this._staticBatches=null;
	}

	StaticBatchManager._registerManager=function(manager){
		StaticBatchManager._managers.push(manager);
	}

	StaticBatchManager._addToStaticBatchQueue=function(sprite3D){
		if ((sprite3D instanceof laya.d3.core.RenderableSprite3D )&& sprite3D.isStatic)
			(sprite3D)._addToInitStaticBatchManager();
		for (var i=0,n=sprite3D.numChildren;i < n;i++)
		StaticBatchManager._addToStaticBatchQueue(sprite3D._children [i]);
	}

	StaticBatchManager.combine=function(staticBatchRoot,renderableSprite3Ds){
		var i=0,n=0;
		if (renderableSprite3Ds){
			for (i=0,n=renderableSprite3Ds.length;i < n;i++){
				var renderableSprite3D=renderableSprite3Ds[i];
				(renderableSprite3D.isStatic)&& (renderableSprite3D._addToInitStaticBatchManager());
			}
			}else {
			if (staticBatchRoot)
				StaticBatchManager._addToStaticBatchQueue(staticBatchRoot);
		}
		for (i=0,n=StaticBatchManager._managers.length;i < n;i++){
			var manager=StaticBatchManager._managers[i];
			manager._initStaticBatchs(staticBatchRoot);
		}
	}

	StaticBatchManager._managers=[];
	return StaticBatchManager;
})()


/**
*<code>RenderContext3D</code> 类用于实现渲染状态。
*/
//class laya.d3.core.render.RenderContext3D
var RenderContext3D=(function(){
	function RenderContext3D(){
		/**@private */
		//this._batchIndexStart=0;
		/**@private */
		//this._batchIndexEnd=0;
		/**@private */
		//this.viewMatrix=null;
		/**@private */
		//this.projectionMatrix=null;
		/**@private */
		//this.projectionViewMatrix=null;
		/**@private */
		//this.viewport=null;
		/**@private */
		//this.scene=null;
		/**@private */
		//this.camera=null;
		/**@private */
		//this.renderElement=null;
		/**@private */
		//this.shader=null;
	}

	__class(RenderContext3D,'laya.d3.core.render.RenderContext3D');
	RenderContext3D.clientWidth=0;
	RenderContext3D.clientHeight=0;
	__static(RenderContext3D,
	['_instance',function(){return this._instance=new RenderContext3D();}
	]);
	return RenderContext3D;
})()


/**
*<code>VertexTrail</code> 类用于创建拖尾顶点结构。
*/
//class laya.d3.core.trail.VertexTrail
var VertexTrail=(function(){
	function VertexTrail(){}
	__class(VertexTrail,'laya.d3.core.trail.VertexTrail');
	var __proto=VertexTrail.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexTrail._vertexDeclaration1;
	});

	__getset(1,VertexTrail,'vertexDeclaration1',function(){
		return VertexTrail._vertexDeclaration1;
	});

	__getset(1,VertexTrail,'vertexDeclaration2',function(){
		return VertexTrail._vertexDeclaration2;
	});

	VertexTrail.TRAIL_POSITION0=0;
	VertexTrail.TRAIL_OFFSETVECTOR=1;
	VertexTrail.TRAIL_TIME0=2;
	VertexTrail.TRAIL_TEXTURECOORDINATE0Y=3;
	VertexTrail.TRAIL_TEXTURECOORDINATE0X=4;
	__static(VertexTrail,
	['_vertexDeclaration1',function(){return this._vertexDeclaration1=new VertexDeclaration(32,
		[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*CLASS CONST:laya.d3.core.trail.VertexTrail.TRAIL_POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*CLASS CONST:laya.d3.core.trail.VertexTrail.TRAIL_OFFSETVECTOR*/1),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*CLASS CONST:laya.d3.core.trail.VertexTrail.TRAIL_TIME0*/2),
		new VertexElement(28,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*CLASS CONST:laya.d3.core.trail.VertexTrail.TRAIL_TEXTURECOORDINATE0Y*/3)]);},'_vertexDeclaration2',function(){return this._vertexDeclaration2=new VertexDeclaration(4,
		[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*CLASS CONST:laya.d3.core.trail.VertexTrail.TRAIL_TEXTURECOORDINATE0X*/4)]);}
	]);
	return VertexTrail;
})()


/**
*<code>GradientSize</code> 类用于创建渐变尺寸。
*/
//class laya.d3.core.particleShuriKen.module.GradientSize
var GradientSize=(function(){
	function GradientSize(){
		/**@private */
		this._type=0;
		/**@private */
		this._separateAxes=false;
		/**@private */
		this._gradient=null;
		/**@private */
		this._gradientX=null;
		/**@private */
		this._gradientY=null;
		/**@private */
		this._gradientZ=null;
		/**@private */
		this._constantMin=NaN;
		/**@private */
		this._constantMax=NaN;
		/**@private */
		this._constantMinSeparate=null;
		/**@private */
		this._constantMaxSeparate=null;
		/**@private */
		this._gradientMin=null;
		/**@private */
		this._gradientMax=null;
		/**@private */
		this._gradientXMin=null;
		/**@private */
		this._gradientXMax=null;
		/**@private */
		this._gradientYMin=null;
		/**@private */
		this._gradientYMax=null;
		/**@private */
		this._gradientZMin=null;
		/**@private */
		this._gradientZMax=null;
	}

	__class(GradientSize,'laya.d3.core.particleShuriKen.module.GradientSize');
	var __proto=GradientSize.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*获取最大尺寸。
	*/
	__proto.getMaxSizeInGradient=function(){
		var i=0,n=0;
		var maxSize=-Number.MAX_VALUE;
		switch (this._type){
			case 0:
				if (this._separateAxes){
					for (i=0,n=this._gradientX.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientX.getValueByIndex(i));
					for (i=0,n=this._gradientY.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientY.getValueByIndex(i));
					}else {
					for (i=0,n=this._gradient.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradient.getValueByIndex(i));
				}
				break ;
			case 1:
				if (this._separateAxes){
					maxSize=Math.max(this._constantMinSeparate.x,this._constantMaxSeparate.x);
					maxSize=Math.max(maxSize,this._constantMinSeparate.y);
					maxSize=Math.max(maxSize,this._constantMaxSeparate.y);
					}else {
					maxSize=Math.max(this._constantMin,this._constantMax);
				}
				break ;
			case 2:
				if (this._separateAxes){
					for (i=0,n=this._gradientXMin.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientXMin.getValueByIndex(i));
					for (i=0,n=this._gradientXMax.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientXMax.getValueByIndex(i));
					for (i=0,n=this._gradientYMin.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientYMin.getValueByIndex(i));
					for (i=0,n=this._gradientZMax.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientZMax.getValueByIndex(i));
					}else {
					for (i=0,n=this._gradientMin.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientMin.getValueByIndex(i));
					for (i=0,n=this._gradientMax.gradientCount;i < n;i++)
					maxSize=Math.max(maxSize,this._gradientMax.getValueByIndex(i));
				}
				break ;
			}
		return maxSize;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientSize=destObject;
		destGradientSize._type=this._type;
		destGradientSize._separateAxes=this._separateAxes;
		this._gradient.cloneTo(destGradientSize._gradient);
		this._gradientX.cloneTo(destGradientSize._gradientX);
		this._gradientY.cloneTo(destGradientSize._gradientY);
		this._gradientZ.cloneTo(destGradientSize._gradientZ);
		destGradientSize._constantMin=this._constantMin;
		destGradientSize._constantMax=this._constantMax;
		this._constantMinSeparate.cloneTo(destGradientSize._constantMinSeparate);
		this._constantMaxSeparate.cloneTo(destGradientSize._constantMaxSeparate);
		this._gradientMin.cloneTo(destGradientSize._gradientMin);
		this._gradientMax.cloneTo(destGradientSize._gradientMax);
		this._gradientXMin.cloneTo(destGradientSize._gradientXMin);
		this._gradientXMax.cloneTo(destGradientSize._gradientXMax);
		this._gradientYMin.cloneTo(destGradientSize._gradientYMin);
		this._gradientYMax.cloneTo(destGradientSize._gradientYMax);
		this._gradientZMin.cloneTo(destGradientSize._gradientZMin);
		this._gradientZMax.cloneTo(destGradientSize._gradientZMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientSize=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientSize);
		return destGradientSize;
	}

	/**
	*渐变尺寸Z。
	*/
	__getset(0,__proto,'gradientZ',function(){
		return this._gradientZ;
	});

	/**
	*渐变尺寸。
	*/
	__getset(0,__proto,'gradient',function(){
		return this._gradient;
	});

	/**
	*是否分轴。
	*/
	__getset(0,__proto,'separateAxes',function(){
		return this._separateAxes;
	});

	/**
	*生命周期尺寸类型，0曲线模式，1随机双常量模式，2随机双曲线模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*渐变最小尺寸。
	*/
	__getset(0,__proto,'gradientMin',function(){
		return this._gradientMin;
	});

	/**
	*最小随机双固定尺寸。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*渐变尺寸X。
	*/
	__getset(0,__proto,'gradientX',function(){
		return this._gradientX;
	});

	/**
	*渐变尺寸Y。
	*/
	__getset(0,__proto,'gradientY',function(){
		return this._gradientY;
	});

	/**
	*渐变最大尺寸。
	*/
	__getset(0,__proto,'gradientMax',function(){
		return this._gradientMax;
	});

	/**
	*最大随机双固定尺寸。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	/**
	*最小分轴随机双固定尺寸。
	*/
	__getset(0,__proto,'constantMinSeparate',function(){
		return this._constantMinSeparate;
	});

	/**
	*最小分轴随机双固定尺寸。
	*/
	__getset(0,__proto,'constantMaxSeparate',function(){
		return this._constantMaxSeparate;
	});

	/**
	*渐变最小尺寸X。
	*/
	__getset(0,__proto,'gradientXMin',function(){
		return this._gradientXMin;
	});

	/**
	*渐变最大尺寸X。
	*/
	__getset(0,__proto,'gradientXMax',function(){
		return this._gradientXMax;
	});

	/**
	*渐变最小尺寸Y。
	*/
	__getset(0,__proto,'gradientYMin',function(){
		return this._gradientYMin;
	});

	/**
	*渐变最大尺寸Y。
	*/
	__getset(0,__proto,'gradientYMax',function(){
		return this._gradientYMax;
	});

	/**
	*渐变最小尺寸Z。
	*/
	__getset(0,__proto,'gradientZMin',function(){
		return this._gradientZMin;
	});

	/**
	*渐变最大尺寸Z。
	*/
	__getset(0,__proto,'gradientZMax',function(){
		return this._gradientZMax;
	});

	GradientSize.createByGradient=function(gradient){
		var gradientSize=new GradientSize();
		gradientSize._type=0;
		gradientSize._separateAxes=false;
		gradientSize._gradient=gradient;
		return gradientSize;
	}

	GradientSize.createByGradientSeparate=function(gradientX,gradientY,gradientZ){
		var gradientSize=new GradientSize();
		gradientSize._type=0;
		gradientSize._separateAxes=true;
		gradientSize._gradientX=gradientX;
		gradientSize._gradientY=gradientY;
		gradientSize._gradientZ=gradientZ;
		return gradientSize;
	}

	GradientSize.createByRandomTwoConstant=function(constantMin,constantMax){
		var gradientSize=new GradientSize();
		gradientSize._type=1;
		gradientSize._separateAxes=false;
		gradientSize._constantMin=constantMin;
		gradientSize._constantMax=constantMax;
		return gradientSize;
	}

	GradientSize.createByRandomTwoConstantSeparate=function(constantMinSeparate,constantMaxSeparate){
		var gradientSize=new GradientSize();
		gradientSize._type=1;
		gradientSize._separateAxes=true;
		gradientSize._constantMinSeparate=constantMinSeparate;
		gradientSize._constantMaxSeparate=constantMaxSeparate;
		return gradientSize;
	}

	GradientSize.createByRandomTwoGradient=function(gradientMin,gradientMax){
		var gradientSize=new GradientSize();
		gradientSize._type=2;
		gradientSize._separateAxes=false;
		gradientSize._gradientMin=gradientMin;
		gradientSize._gradientMax=gradientMax;
		return gradientSize;
	}

	GradientSize.createByRandomTwoGradientSeparate=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
		var gradientSize=new GradientSize();
		gradientSize._type=2;
		gradientSize._separateAxes=true;
		gradientSize._gradientXMin=gradientXMin;
		gradientSize._gradientXMax=gradientXMax;
		gradientSize._gradientYMin=gradientYMin;
		gradientSize._gradientYMax=gradientYMax;
		gradientSize._gradientZMin=gradientZMin;
		gradientSize._gradientZMax=gradientZMax;
		return gradientSize;
	}

	return GradientSize;
})()


/**
*@private
*/
//class laya.d3.shader.ShaderDefines
var ShaderDefines=(function(){
	function ShaderDefines(superDefines){
		/**@private */
		this._counter=0;
		/**@private [只读]*/
		this.defines=null;
		if (superDefines){
			this._counter=superDefines._counter;
			this.defines=superDefines.defines.slice();
			}else {
			this._counter=0;
			this.defines=[];
		}
	}

	__class(ShaderDefines,'laya.d3.shader.ShaderDefines');
	var __proto=ShaderDefines.prototype;
	/**
	*@private
	*/
	__proto.registerDefine=function(name){
		var value=Math.pow(2,this._counter++);
		this.defines[value]=name;
		return value;
	}

	return ShaderDefines;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.TextureMode
var TextureMode=(function(){
	function TextureMode(){}
	__class(TextureMode,'laya.d3.core.TextureMode');
	TextureMode.Stretch=0;
	TextureMode.Tile=1;
	return TextureMode;
})()


/**
*<code>BoundFrustum</code> 类用于创建锥截体。
*/
//class laya.d3.math.BoundFrustum
var BoundFrustum=(function(){
	function BoundFrustum(matrix){
		/**4x4矩阵*/
		this._matrix=null;
		/**近平面*/
		this._near=null;
		/**远平面*/
		this._far=null;
		/**左平面*/
		this._left=null;
		/**右平面*/
		this._right=null;
		/**顶平面*/
		this._top=null;
		/**底平面*/
		this._bottom=null;
		this._matrix=matrix;
		this._near=new Plane(new Vector3());
		this._far=new Plane(new Vector3());
		this._left=new Plane(new Vector3());
		this._right=new Plane(new Vector3());
		this._top=new Plane(new Vector3());
		this._bottom=new Plane(new Vector3());
		BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
	}

	__class(BoundFrustum,'laya.d3.math.BoundFrustum');
	var __proto=BoundFrustum.prototype;
	/**
	*判断是否与其他锥截体相等。
	*@param other 锥截体。
	*/
	__proto.equalsBoundFrustum=function(other){
		return this._matrix.equalsOtherMatrix(other.matrix)
	}

	/**
	*判断是否与其他对象相等。
	*@param obj 对象。
	*/
	__proto.equalsObj=function(obj){
		if ((obj instanceof laya.d3.math.BoundFrustum )){
			var bf=obj;
			return this.equalsBoundFrustum(bf);
		}
		return false;
	}

	/**
	*获取锥截体的任意一平面。
	*0:近平面
	*1:远平面
	*2:左平面
	*3:右平面
	*4:顶平面
	*5:底平面
	*@param index 索引。
	*/
	__proto.getPlane=function(index){
		switch (index){
			case 0:
				return this._near;
			case 1:
				return this._far;
			case 2:
				return this._left;
			case 3:
				return this._right;
			case 4:
				return this._top;
			case 5:
				return this._bottom;
			default :
				return null;
			}
	}

	/**
	*锥截体的8个顶点。
	*@param corners 返回顶点的输出队列。
	*/
	__proto.getCorners=function(corners){
		BoundFrustum._get3PlaneInterPoint(this._near,this._bottom,this._right).cloneTo(corners[0]);
		BoundFrustum._get3PlaneInterPoint(this._near,this._top,this._right).cloneTo(corners[1]);
		BoundFrustum._get3PlaneInterPoint(this._near,this._top,this._left).cloneTo(corners[2]);
		BoundFrustum._get3PlaneInterPoint(this._near,this._bottom,this._left).cloneTo(corners[3]);
		BoundFrustum._get3PlaneInterPoint(this._far,this._bottom,this._right).cloneTo(corners[4]);
		BoundFrustum._get3PlaneInterPoint(this._far,this._top,this._right).cloneTo(corners[5]);
		BoundFrustum._get3PlaneInterPoint(this._far,this._top,this._left).cloneTo(corners[6]);
		BoundFrustum._get3PlaneInterPoint(this._far,this._bottom,this._left).cloneTo(corners[7]);
	}

	/**
	*与点的位置关系。返回-1,包涵;0,相交;1,不相交
	*@param point 点。
	*/
	__proto.containsPoint=function(point){
		var result=Plane.PlaneIntersectionType_Front;
		var planeResult=Plane.PlaneIntersectionType_Front;
		for (var i=0;i < 6;i++){
			switch (i){
				case 0:
					planeResult=CollisionUtils.intersectsPlaneAndPoint(this._near,point);
					break ;
				case 1:
					planeResult=CollisionUtils.intersectsPlaneAndPoint(this._far,point);
					break ;
				case 2:
					planeResult=CollisionUtils.intersectsPlaneAndPoint(this._left,point);
					break ;
				case 3:
					planeResult=CollisionUtils.intersectsPlaneAndPoint(this._right,point);
					break ;
				case 4:
					planeResult=CollisionUtils.intersectsPlaneAndPoint(this._top,point);
					break ;
				case 5:
					planeResult=CollisionUtils.intersectsPlaneAndPoint(this._bottom,point);
					break ;
				}
			switch (planeResult){
				case Plane.PlaneIntersectionType_Back:
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
				case Plane.PlaneIntersectionType_Intersecting:
					result=Plane.PlaneIntersectionType_Intersecting;
					break ;
				}
		}
		switch (result){
			case Plane.PlaneIntersectionType_Intersecting:
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			default :
				return /*laya.d3.math.ContainmentType.Contains*/1;
			}
	}

	/**
	*与包围盒的位置关系。返回-1,包涵;0,相交;1,不相交
	*@param box 包围盒。
	*/
	__proto.containsBoundBox=function(box){
		var p=BoundFrustum._tempV30,n=BoundFrustum._tempV31;
		var plane;
		var result=/*laya.d3.math.ContainmentType.Contains*/1;
		for (var i=0;i < 6;i++){
			plane=this.getPlane(i);
			this._getBoxToPlanePVertexNVertex(box,plane.normal,p,n);
			if (CollisionUtils.intersectsPlaneAndPoint(plane,p)===Plane.PlaneIntersectionType_Back)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (CollisionUtils.intersectsPlaneAndPoint(plane,n)===Plane.PlaneIntersectionType_Back)
				result=/*laya.d3.math.ContainmentType.Intersects*/2;
		}
		return result;
	}

	/**
	*与包围球的位置关系。返回-1,包涵;0,相交;1,不相交
	*@param sphere 包围球。
	*/
	__proto.containsBoundSphere=function(sphere){
		var result=Plane.PlaneIntersectionType_Front;
		var planeResult=Plane.PlaneIntersectionType_Front;
		for (var i=0;i < 6;i++){
			switch (i){
				case 0:
					planeResult=CollisionUtils.intersectsPlaneAndSphere(this._near,sphere);
					break ;
				case 1:
					planeResult=CollisionUtils.intersectsPlaneAndSphere(this._far,sphere);
					break ;
				case 2:
					planeResult=CollisionUtils.intersectsPlaneAndSphere(this._left,sphere);
					break ;
				case 3:
					planeResult=CollisionUtils.intersectsPlaneAndSphere(this._right,sphere);
					break ;
				case 4:
					planeResult=CollisionUtils.intersectsPlaneAndSphere(this._top,sphere);
					break ;
				case 5:
					planeResult=CollisionUtils.intersectsPlaneAndSphere(this._bottom,sphere);
					break ;
				}
			switch (planeResult){
				case Plane.PlaneIntersectionType_Back:
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
				case Plane.PlaneIntersectionType_Intersecting:
					result=Plane.PlaneIntersectionType_Intersecting;
					break ;
				}
		}
		switch (result){
			case Plane.PlaneIntersectionType_Intersecting:
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			default :
				return /*laya.d3.math.ContainmentType.Contains*/1;
			}
	}

	/**
	*@private
	*/
	__proto._getBoxToPlanePVertexNVertex=function(box,planeNormal,outP,outN){
		var boxMin=box.min;
		var boxMinE=boxMin.elements;
		var boxMax=box.max;
		var boxMaxE=boxMax.elements;
		var planeNorE=planeNormal.elements;
		var planeNorEX=planeNorE[0];
		var planeNorEY=planeNorE[1];
		var planeNorEZ=planeNorE[2];
		boxMin.cloneTo(outP);;
		var outPE=outP.elements;
		if (planeNorEX >=0)
			outPE[0]=boxMaxE[0];
		if (planeNorEY >=0)
			outPE[1]=boxMaxE[1];
		if (planeNorEZ >=0)
			outPE[2]=boxMaxE[2];
		boxMax.cloneTo(outN);
		var outNE=outN.elements;
		if (planeNorEX >=0)
			outNE[0]=boxMinE[0];
		if (planeNorEY >=0)
			outNE[1]=boxMinE[1];
		if (planeNorEZ >=0)
			outNE[2]=boxMinE[2];
	}

	/**
	*获取顶平面。
	*@return 顶平面。
	*/
	__getset(0,__proto,'top',function(){
		return this._top;
	});

	/**
	*设置描述矩阵。
	*@param matrix 描述矩阵。
	*/
	/**
	*获取描述矩阵。
	*@return 描述矩阵。
	*/
	__getset(0,__proto,'matrix',function(){
		return this._matrix;
		},function(matrix){
		this._matrix=matrix;
		BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
	});

	/**
	*获取近平面。
	*@return 近平面。
	*/
	__getset(0,__proto,'near',function(){
		return this._near;
	});

	/**
	*获取远平面。
	*@return 远平面。
	*/
	__getset(0,__proto,'far',function(){
		return this._far;
	});

	/**
	*获取左平面。
	*@return 左平面。
	*/
	__getset(0,__proto,'left',function(){
		return this._left;
	});

	/**
	*获取右平面。
	*@return 右平面。
	*/
	__getset(0,__proto,'right',function(){
		return this._right;
	});

	/**
	*获取底平面。
	*@return 底平面。
	*/
	__getset(0,__proto,'bottom',function(){
		return this._bottom;
	});

	BoundFrustum._getPlanesFromMatrix=function(m,np,fp,lp,rp,tp,bp){
		var matrixE=m.elements;
		var m11=matrixE[0];
		var m12=matrixE[1];
		var m13=matrixE[2];
		var m14=matrixE[3];
		var m21=matrixE[4];
		var m22=matrixE[5];
		var m23=matrixE[6];
		var m24=matrixE[7];
		var m31=matrixE[8];
		var m32=matrixE[9];
		var m33=matrixE[10];
		var m34=matrixE[11];
		var m41=matrixE[12];
		var m42=matrixE[13];
		var m43=matrixE[14];
		var m44=matrixE[15];
		var nearNorE=np.normal.elements;
		nearNorE[0]=m14+m13;
		nearNorE[1]=m24+m23;
		nearNorE[2]=m34+m33;
		np.distance=m44+m43;
		np.normalize();
		var farNorE=fp.normal.elements;
		farNorE[0]=m14-m13;
		farNorE[1]=m24-m23;
		farNorE[2]=m34-m33;
		fp.distance=m44-m43;
		fp.normalize();
		var leftNorE=lp.normal.elements;
		leftNorE[0]=m14+m11;
		leftNorE[1]=m24+m21;
		leftNorE[2]=m34+m31;
		lp.distance=m44+m41;
		lp.normalize();
		var rightNorE=rp.normal.elements;
		rightNorE[0]=m14-m11;
		rightNorE[1]=m24-m21;
		rightNorE[2]=m34-m31;
		rp.distance=m44-m41;
		rp.normalize();
		var topNorE=tp.normal.elements;
		topNorE[0]=m14-m12;
		topNorE[1]=m24-m22;
		topNorE[2]=m34-m32;
		tp.distance=m44-m42;
		tp.normalize();
		var bottomNorE=bp.normal.elements;
		bottomNorE[0]=m14+m12;
		bottomNorE[1]=m24+m22;
		bottomNorE[2]=m34+m32;
		bp.distance=m44+m42;
		bp.normalize();
	}

	BoundFrustum._get3PlaneInterPoint=function(p1,p2,p3){
		var p1Nor=p1.normal;
		var p2Nor=p2.normal;
		var p3Nor=p3.normal;
		Vector3.cross(p2Nor,p3Nor,BoundFrustum._tempV30);
		Vector3.cross(p3Nor,p1Nor,BoundFrustum._tempV31);
		Vector3.cross(p1Nor,p2Nor,BoundFrustum._tempV32);
		var a=Vector3.dot(p1Nor,BoundFrustum._tempV30);
		var b=Vector3.dot(p2Nor,BoundFrustum._tempV31);
		var c=Vector3.dot(p3Nor,BoundFrustum._tempV32);
		Vector3.scale(BoundFrustum._tempV30,-p1.distance / a,BoundFrustum._tempV33);
		Vector3.scale(BoundFrustum._tempV31,-p2.distance / b,BoundFrustum._tempV34);
		Vector3.scale(BoundFrustum._tempV32,-p3.distance / c,BoundFrustum._tempV35);
		Vector3.add(BoundFrustum._tempV33,BoundFrustum._tempV34,BoundFrustum._tempV36);
		Vector3.add(BoundFrustum._tempV35,BoundFrustum._tempV36,BoundFrustum._tempV37);
		var v=BoundFrustum._tempV37;
		return v;
	}

	__static(BoundFrustum,
	['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempV37',function(){return this._tempV37=new Vector3();}
	]);
	return BoundFrustum;
})()


/**
*<code>Color</code> 类用于创建颜色实例。
*/
//class laya.d3.math.Color
var Color=(function(){
	function Color(r,g,b,a){
		/**[只读]向量元素集合。*/
		this.elements=null;
		(r===void 0)&& (r=1);
		(g===void 0)&& (g=1);
		(b===void 0)&& (b=1);
		(a===void 0)&& (a=1);
		var v=this.elements=new Float32Array(4);
		v[0]=r;
		v[1]=g;
		v[2]=b;
		v[3]=a;
	}

	__class(Color,'laya.d3.math.Color');
	var __proto=Color.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destColor=destObject;
		var destE=destColor.elements;
		var s=this.elements;
		destE[0]=s[0];
		destE[1]=s[1];
		destE[2]=s[2];
		destE[3]=s[3];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*设置blue分量。
	*@param value blue分量。
	*/
	/**
	*获取blue分量。
	*@return blue分量。
	*/
	__getset(0,__proto,'b',function(){
		return this.elements[2];
		},function(value){
		this.elements[2]=value;
	});

	/**
	*设置red分量。
	*@param value red分量。
	*/
	/**
	*获取red分量。
	*@return red分量。
	*/
	__getset(0,__proto,'r',function(){
		return this.elements[0];
		},function(value){
		this.elements[0]=value;
	});

	/**
	*设置green分量。
	*@param value green分量。
	*/
	/**
	*获取green分量。
	*@return green分量。
	*/
	__getset(0,__proto,'g',function(){
		return this.elements[1];
		},function(value){
		this.elements[1]=value;
	});

	/**
	*设置alpha分量。
	*@param value alpha分量。
	*/
	/**
	*获取alpha分量。
	*@return alpha分量。
	*/
	__getset(0,__proto,'a',function(){
		return this.elements[3];
		},function(value){
		this.elements[3]=value;
	});

	__static(Color,
	['RED',function(){return this.RED=new Color(1,0,0,1);},'GREEN',function(){return this.GREEN=new Color(0,1,0,1);},'BLUE',function(){return this.BLUE=new Color(0,0,1,1);},'CYAN',function(){return this.CYAN=new Color(0,1,1,1);},'YELLOW',function(){return this.YELLOW=new Color(1,0.92,0.016,1);},'MAGENTA',function(){return this.MAGENTA=new Color(1,0,1,1);},'GRAY',function(){return this.GRAY=new Color(0.5,0.5,0.5,1);},'WHITE',function(){return this.WHITE=new Color(1,1,1,1);},'BLACK',function(){return this.BLACK=new Color(0,0,0,1);}
	]);
	return Color;
})()


/**
*<code>Burst</code> 类用于粒子的爆裂描述。
*/
//class laya.d3.core.particleShuriKen.module.Burst
var Burst=(function(){
	function Burst(time,minCount,maxCount){
		/**@private 爆裂时间,单位为秒。*/
		this._time=NaN;
		/**@private 爆裂的最小数量。*/
		this._minCount=0;
		/**@private 爆裂的最大数量。*/
		this._maxCount=0;
		this._time=time;
		this._minCount=minCount;
		this._maxCount=maxCount;
	}

	__class(Burst,'laya.d3.core.particleShuriKen.module.Burst');
	var __proto=Burst.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destBurst=destObject;
		destBurst._time=this._time
		destBurst._minCount=this._minCount;
		destBurst._maxCount=this._maxCount;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destBurst=/*__JS__ */new this.constructor();
		this.cloneTo(destBurst);
		return destBurst;
	}

	/**
	*获取爆裂时间,单位为秒。
	*@return 爆裂时间,单位为秒。
	*/
	__getset(0,__proto,'time',function(){
		return this._time;
	});

	/**
	*获取爆裂的最小数量。
	*@return 爆裂的最小数量。
	*/
	__getset(0,__proto,'minCount',function(){
		return this._minCount;
	});

	/**
	*获取爆裂的最大数量。
	*@return 爆裂的最大数量。
	*/
	__getset(0,__proto,'maxCount',function(){
		return this._maxCount;
	});

	return Burst;
})()


/**
*<code>DetailTextureInfo</code> 类用于描述地形细节纹理。
*/
//class laya.d3.terrain.unit.DetailTextureInfo
var DetailTextureInfo=(function(){
	function DetailTextureInfo(){
		this.diffuseTexture=null;
		this.normalTexture=null;
		this.scale=null;
		this.offset=null;
		;
	}

	__class(DetailTextureInfo,'laya.d3.terrain.unit.DetailTextureInfo');
	return DetailTextureInfo;
})()


/**
*<code>Utils3D</code> 类用于创建3D工具。
*/
//class laya.d3.utils.Utils3D
var Utils3D=(function(){
	function Utils3D(){}
	__class(Utils3D,'laya.d3.utils.Utils3D');
	Utils3D._convertToLayaVec3=function(bVector,out,inverseX){
		var outE=out.elements;
		outE[0]=inverseX ?-bVector.x():bVector.x();
		outE[1]=bVector.y();
		outE[2]=bVector.z();
	}

	Utils3D._convertToBulletVec3=function(lVector,out,inverseX){
		var lVectorE=lVector.elements;
		out.setValue(inverseX ?-lVectorE[0] :lVectorE[0],lVectorE[1],lVectorE[2]);
	}

	Utils3D._rotationTransformScaleSkinAnimation=function(tx,ty,tz,qx,qy,qz,qw,sx,sy,sz,outArray,outOffset){
		var re=Utils3D._tempArray16_0;
		var se=Utils3D._tempArray16_1;
		var tse=Utils3D._tempArray16_2;
		var x2=qx+qx;
		var y2=qy+qy;
		var z2=qz+qz;
		var xx=qx *x2;
		var yx=qy *x2;
		var yy=qy *y2;
		var zx=qz *x2;
		var zy=qz *y2;
		var zz=qz *z2;
		var wx=qw *x2;
		var wy=qw *y2;
		var wz=qw *z2;
		re[15]=1;
		re[0]=1-yy-zz;
		re[1]=yx+wz;
		re[2]=zx-wy;
		re[4]=yx-wz;
		re[5]=1-xx-zz;
		re[6]=zy+wx;
		re[8]=zx+wy;
		re[9]=zy-wx;
		re[10]=1-xx-yy;
		se[15]=1;
		se[0]=sx;
		se[5]=sy;
		se[10]=sz;
		var i,a,b,e,ai0,ai1,ai2,ai3;
		for (i=0;i < 4;i++){
			ai0=re[i];
			ai1=re[i+4];
			ai2=re[i+8];
			ai3=re[i+12];
			tse[i]=ai0;
			tse[i+4]=ai1;
			tse[i+8]=ai2;
			tse[i+12]=ai0 *tx+ai1 *ty+ai2 *tz+ai3;
		}
		for (i=0;i < 4;i++){
			ai0=tse[i];
			ai1=tse[i+4];
			ai2=tse[i+8];
			ai3=tse[i+12];
			outArray[i+outOffset]=ai0 *se[0]+ai1 *se[1]+ai2 *se[2]+ai3 *se[3];
			outArray[i+outOffset+4]=ai0 *se[4]+ai1 *se[5]+ai2 *se[6]+ai3 *se[7];
			outArray[i+outOffset+8]=ai0 *se[8]+ai1 *se[9]+ai2 *se[10]+ai3 *se[11];
			outArray[i+outOffset+12]=ai0 *se[12]+ai1 *se[13]+ai2 *se[14]+ai3 *se[15];
		}
	}

	Utils3D._createSceneByJsonForMaker=function(nodeData,outBatchSprites,initTool){
		var scene3d=Utils3D._createNodeByJsonForMaker(nodeData,outBatchSprites,initTool);
		Utils3D._addComponentByJsonForMaker(nodeData,outBatchSprites,initTool);
		return scene3d;
	}

	Utils3D._createNodeByJsonForMaker=function(nodeData,outBatchSprites,initTool){
		var node;
		switch (nodeData.type){
			case "Scene3D":
				node=new Scene3D();
				break ;
			case "Sprite3D":
				node=new Sprite3D();
				break ;
			case "MeshSprite3D":
				node=new MeshSprite3D();
				(outBatchSprites)&& (outBatchSprites.push(node));
				break ;
			case "SkinnedMeshSprite3D":
				node=new SkinnedMeshSprite3D();
				break ;
			case "ShuriKenParticle3D":
				node=new ShuriKenParticle3D();
				break ;
			case "Terrain":
				node=new Terrain();
				break ;
			case "Camera":
				node=new Camera();
				break ;
			case "DirectionLight":
				node=new DirectionLight();
				break ;
			case "PointLight":
				node=new PointLight();
				break ;
			case "SpotLight":
				node=new SpotLight();
				break ;
			case "TrailSprite3D":
				node=new TrailSprite3D();
				break ;
			default :;
				var clas=ClassUtils.getClass(nodeData.props.runtime);
				node=new clas();
				break ;
			};
		var childData=nodeData.child;
		if (childData){
			for (var i=0,n=childData.length;i < n;i++){
				var child=Utils3D._createNodeByJsonForMaker(childData[i],outBatchSprites,initTool);
				node.addChild(child);
			}
		};
		var compId=nodeData.compId;
		(node).compId=compId;
		node._parse(nodeData.props);
		if (initTool){
			initTool._idMap[compId]=node;
		}
		Utils3D._compIdToNode[compId]=node;
		var componentsData=nodeData.components;
		if (componentsData){
			for (var j=0,m=componentsData.length;j < m;j++){
				var data=componentsData[j];
				clas=Browser.window.Laya[data.type];
				if (!clas){
					clas=Browser.window;
					var clasPaths=data.type.split('.');
					clasPaths.forEach(function(cls){
						clas=clas[cls];
					});
				}
				if (typeof(clas)=='function'){
					var comp=new clas();
					if (initTool){
						initTool._idMap[data.compId]=comp;
						console.log(data.compId);
					}
					}else {
					console.warn("Utils3D:Unkown component type.");
				}
			}
		}
		return node;
	}

	Utils3D._addComponentByJsonForMaker=function(nodeData,outBatchSprites,initTool){
		var compId=nodeData.compId;
		var node=Utils3D._compIdToNode[compId];
		var childData=nodeData.child;
		if (childData){
			for (var i=0,n=childData.length;i < n;i++){
				var child=Utils3D._addComponentByJsonForMaker(childData[i],outBatchSprites,initTool);
			}
		};
		var componentsData=nodeData.components;
		if (componentsData){
			for (var j=0,m=componentsData.length;j < m;j++){
				var data=componentsData[j];
				clas=Browser.window.Laya[data.type];
				if (!clas){
					var clasPaths=data.type.split('.');
					var clas=Browser.window;
					clasPaths.forEach(function(cls){
						clas=clas[cls];
					});
				}
				if (typeof(clas)=='function'){
					var component=initTool._idMap[data.compId];
					node.addComponentIntance(component);
					component._parse(data);
					}else {
					console.warn("Utils3D:Unkown component type.");
				}
			}
		}
	}

	Utils3D._createNodeByJson=function(nodeData,outBatchSprites){
		var node;
		switch (nodeData.type){
			case "Scene3D":
				node=new Scene3D();
				break ;
			case "Sprite3D":
				node=new Sprite3D();
				break ;
			case "MeshSprite3D":
				node=new MeshSprite3D();
				(outBatchSprites)&& (outBatchSprites.push(node));
				break ;
			case "SkinnedMeshSprite3D":
				node=new SkinnedMeshSprite3D();
				break ;
			case "ShuriKenParticle3D":
				node=new ShuriKenParticle3D();
				break ;
			case "Terrain":
				node=new Terrain();
				break ;
			case "Camera":
				node=new Camera();
				break ;
			case "DirectionLight":
				node=new DirectionLight();
				break ;
			case "PointLight":
				node=new PointLight();
				break ;
			case "SpotLight":
				node=new SpotLight();
				break ;
			case "TrailSprite3D":
				node=new TrailSprite3D();
				break ;
			default :
				throw new Error("Utils3D:unidentified class type in (.lh) file.");
			};
		var childData=nodeData.child;
		if (childData){
			for (var i=0,n=childData.length;i < n;i++){
				var child=Utils3D._createNodeByJson(childData[i],outBatchSprites)
				node.addChild(child);
			}
		};
		var componentsData=nodeData.components;
		if (componentsData){
			for (var j=0,m=componentsData.length;j < m;j++){
				var data=componentsData[j];
				clas=Browser.window.Laya[data.type];
				if (!clas){
					var clasPaths=data.type.split('.');
					var clas=Browser.window;
					clasPaths.forEach(function(cls){
						clas=clas[cls];
					});
				}
				if (typeof(clas)=='function'){
					var component=node.addComponent(clas);
					component._parse(data);
					}else {
					console.warn("Unkown component type.");
				}
			}
		}
		node._parse(nodeData.props);
		return node;
	}

	Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxix=function(bones,curData,inverGlobalBindPose,outBonesDatas,outAnimationDatas,boneIndexToMesh){
		var offset=0;
		var matOffset=0;
		var i;
		var parentOffset;
		var boneLength=bones.length;
		for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
			laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],outBonesDatas,matOffset);
			if (i !=0){
				parentOffset=bones[i].parentIndex *16;
				laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
			}
		};
		var n=inverGlobalBindPose.length;
		for (i=0;i < n;i++){
			laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas,boneIndexToMesh[i] *16,inverGlobalBindPose[i],outAnimationDatas,i *16);
		}
	}

	Utils3D._computeAnimationDatasByArrayAndMatrixFast=function(inverGlobalBindPose,bonesDatas,outAnimationDatas,boneIndexToMesh){
		for (var i=0,n=inverGlobalBindPose.length;i < n;i++)
		laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas,boneIndexToMesh[i] *16,inverGlobalBindPose[i],outAnimationDatas,i *16);
	}

	Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxixOld=function(bones,curData,inverGlobalBindPose,outBonesDatas,outAnimationDatas){
		var offset=0;
		var matOffset=0;
		var i;
		var parentOffset;
		var boneLength=bones.length;
		for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
			laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+7],curData[offset+8],curData[offset+9],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+0],curData[offset+1],curData[offset+2],outBonesDatas,matOffset);
			if (i !=0){
				parentOffset=bones[i].parentIndex *16;
				laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
			}
		};
		var n=inverGlobalBindPose.length;
		for (i=0;i < n;i++){
			var arrayOffset=i *16;
			laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas,arrayOffset,inverGlobalBindPose[i],outAnimationDatas,arrayOffset);
		}
	}

	Utils3D._computeAnimationDatasByArrayAndMatrixFastOld=function(inverGlobalBindPose,bonesDatas,outAnimationDatas){
		var n=inverGlobalBindPose.length;
		for (var i=0;i < n;i++){
			var arrayOffset=i *16;
			laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas,arrayOffset,inverGlobalBindPose[i],outAnimationDatas,arrayOffset);
		}
	}

	Utils3D._computeRootAnimationData=function(bones,curData,animationDatas){
		for (var i=0,offset=0,matOffset=0,boneLength=bones.length;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++)
		laya.d3.utils.Utils3D.createAffineTransformationArray(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],animationDatas,matOffset);
	}

	Utils3D.transformVector3ArrayByQuat=function(sourceArray,sourceOffset,rotation,outArray,outOffset){
		var re=rotation.elements;
		var x=sourceArray[sourceOffset],y=sourceArray[sourceOffset+1],z=sourceArray[sourceOffset+2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
		outArray[outOffset]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
		outArray[outOffset+1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
		outArray[outOffset+2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
	}

	Utils3D.mulMatrixByArray=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
		var i,ai0,ai1,ai2,ai3;
		if (outArray===rightArray){
			rightArray=Utils3D._tempArray16_3;
			for (i=0;i < 16;++i){
				rightArray[i]=outArray[outOffset+i];
			}
			rightOffset=0;
		}
		for (i=0;i < 4;i++){
			ai0=leftArray[leftOffset+i];
			ai1=leftArray[leftOffset+i+4];
			ai2=leftArray[leftOffset+i+8];
			ai3=leftArray[leftOffset+i+12];
			outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
			outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
			outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
			outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
		}
	}

	Utils3D.mulMatrixByArrayFast=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
		var i,ai0,ai1,ai2,ai3;
		for (i=0;i < 4;i++){
			ai0=leftArray[leftOffset+i];
			ai1=leftArray[leftOffset+i+4];
			ai2=leftArray[leftOffset+i+8];
			ai3=leftArray[leftOffset+i+12];
			outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
			outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
			outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
			outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
		}
	}

	Utils3D.mulMatrixByArrayAndMatrixFast=function(leftArray,leftOffset,rightMatrix,outArray,outOffset){
		var i,ai0,ai1,ai2,ai3;
		var rightMatrixE=rightMatrix.elements;
		var m11=rightMatrixE[0],m12=rightMatrixE[1],m13=rightMatrixE[2],m14=rightMatrixE[3];
		var m21=rightMatrixE[4],m22=rightMatrixE[5],m23=rightMatrixE[6],m24=rightMatrixE[7];
		var m31=rightMatrixE[8],m32=rightMatrixE[9],m33=rightMatrixE[10],m34=rightMatrixE[11];
		var m41=rightMatrixE[12],m42=rightMatrixE[13],m43=rightMatrixE[14],m44=rightMatrixE[15];
		var ai0LeftOffset=leftOffset;
		var ai1LeftOffset=leftOffset+4;
		var ai2LeftOffset=leftOffset+8;
		var ai3LeftOffset=leftOffset+12;
		var ai0OutOffset=outOffset;
		var ai1OutOffset=outOffset+4;
		var ai2OutOffset=outOffset+8;
		var ai3OutOffset=outOffset+12;
		for (i=0;i < 4;i++){
			ai0=leftArray[ai0LeftOffset+i];
			ai1=leftArray[ai1LeftOffset+i];
			ai2=leftArray[ai2LeftOffset+i];
			ai3=leftArray[ai3LeftOffset+i];
			outArray[ai0OutOffset+i]=ai0 *m11+ai1 *m12+ai2 *m13+ai3 *m14;
			outArray[ai1OutOffset+i]=ai0 *m21+ai1 *m22+ai2 *m23+ai3 *m24;
			outArray[ai2OutOffset+i]=ai0 *m31+ai1 *m32+ai2 *m33+ai3 *m34;
			outArray[ai3OutOffset+i]=ai0 *m41+ai1 *m42+ai2 *m43+ai3 *m44;
		}
	}

	Utils3D.createAffineTransformationArray=function(tX,tY,tZ,rX,rY,rZ,rW,sX,sY,sZ,outArray,outOffset){
		var x2=rX+rX,y2=rY+rY,z2=rZ+rZ;
		var xx=rX *x2,xy=rX *y2,xz=rX *z2,yy=rY *y2,yz=rY *z2,zz=rZ *z2;
		var wx=rW *x2,wy=rW *y2,wz=rW *z2;
		outArray[outOffset+0]=(1-(yy+zz))*sX;
		outArray[outOffset+1]=(xy+wz)*sX;
		outArray[outOffset+2]=(xz-wy)*sX;
		outArray[outOffset+3]=0;
		outArray[outOffset+4]=(xy-wz)*sY;
		outArray[outOffset+5]=(1-(xx+zz))*sY;
		outArray[outOffset+6]=(yz+wx)*sY;
		outArray[outOffset+7]=0;
		outArray[outOffset+8]=(xz+wy)*sZ;
		outArray[outOffset+9]=(yz-wx)*sZ;
		outArray[outOffset+10]=(1-(xx+yy))*sZ;
		outArray[outOffset+11]=0;
		outArray[outOffset+12]=tX;
		outArray[outOffset+13]=tY;
		outArray[outOffset+14]=tZ;
		outArray[outOffset+15]=1;
	}

	Utils3D.transformVector3ArrayToVector3ArrayCoordinate=function(source,sourceOffset,transform,result,resultOffset){
		var coordinateX=source[sourceOffset+0];
		var coordinateY=source[sourceOffset+1];
		var coordinateZ=source[sourceOffset+2];
		var transformElem=transform.elements;
		var w=((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
		result[resultOffset]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12] / w;
		result[resultOffset+1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13] / w;
		result[resultOffset+2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14] / w;
	}

	Utils3D.transformLightingMapTexcoordArray=function(source,sourceOffset,lightingMapScaleOffset,result,resultOffset){
		var lightingMapScaleOffsetE=lightingMapScaleOffset.elements;
		result[resultOffset+0]=source[sourceOffset+0] *lightingMapScaleOffsetE[0]+lightingMapScaleOffsetE[2];
		result[resultOffset+1]=1.0-((1.0-source[sourceOffset+1])*lightingMapScaleOffsetE[1]+lightingMapScaleOffsetE[3]);
	}

	Utils3D.getURLVerion=function(url){
		var index=url.indexOf("?");
		return index >=0 ? url.substr(index):null;
	}

	Utils3D._quaternionCreateFromYawPitchRollArray=function(yaw,pitch,roll,out){
		var halfRoll=roll *0.5;
		var halfPitch=pitch *0.5;
		var halfYaw=yaw *0.5;
		var sinRoll=Math.sin(halfRoll);
		var cosRoll=Math.cos(halfRoll);
		var sinPitch=Math.sin(halfPitch);
		var cosPitch=Math.cos(halfPitch);
		var sinYaw=Math.sin(halfYaw);
		var cosYaw=Math.cos(halfYaw);
		out[0]=(cosYaw *sinPitch *cosRoll)+(sinYaw *cosPitch *sinRoll);
		out[1]=(sinYaw *cosPitch *cosRoll)-(cosYaw *sinPitch *sinRoll);
		out[2]=(cosYaw *cosPitch *sinRoll)-(sinYaw *sinPitch *cosRoll);
		out[3]=(cosYaw *cosPitch *cosRoll)+(sinYaw *sinPitch *sinRoll);
	}

	Utils3D._createAffineTransformationArray=function(trans,rot,scale,outE){
		var x=rot[0],y=rot[1],z=rot[2],w=rot[3],x2=x+x,y2=y+y,z2=z+z;
		var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
		var wx=w *x2,wy=w *y2,wz=w *z2,sx=scale[0],sy=scale[1],sz=scale[2];
		outE[0]=(1-(yy+zz))*sx;
		outE[1]=(xy+wz)*sx;
		outE[2]=(xz-wy)*sx;
		outE[3]=0;
		outE[4]=(xy-wz)*sy;
		outE[5]=(1-(xx+zz))*sy;
		outE[6]=(yz+wx)*sy;
		outE[7]=0;
		outE[8]=(xz+wy)*sz;
		outE[9]=(yz-wx)*sz;
		outE[10]=(1-(xx+yy))*sz;
		outE[11]=0;
		outE[12]=trans[0];
		outE[13]=trans[1];
		outE[14]=trans[2];
		outE[15]=1;
	}

	Utils3D._mulMatrixArray=function(leftMatrixE,rightMatrix,outArray,outOffset){
		var i,ai0,ai1,ai2,ai3;
		var rightMatrixE=rightMatrix.elements;
		var m11=rightMatrixE[0],m12=rightMatrixE[1],m13=rightMatrixE[2],m14=rightMatrixE[3];
		var m21=rightMatrixE[4],m22=rightMatrixE[5],m23=rightMatrixE[6],m24=rightMatrixE[7];
		var m31=rightMatrixE[8],m32=rightMatrixE[9],m33=rightMatrixE[10],m34=rightMatrixE[11];
		var m41=rightMatrixE[12],m42=rightMatrixE[13],m43=rightMatrixE[14],m44=rightMatrixE[15];
		var ai0OutOffset=outOffset;
		var ai1OutOffset=outOffset+4;
		var ai2OutOffset=outOffset+8;
		var ai3OutOffset=outOffset+12;
		for (i=0;i < 4;i++){
			ai0=leftMatrixE[i];
			ai1=leftMatrixE[i+4];
			ai2=leftMatrixE[i+8];
			ai3=leftMatrixE[i+12];
			outArray[ai0OutOffset+i]=ai0 *m11+ai1 *m12+ai2 *m13+ai3 *m14;
			outArray[ai1OutOffset+i]=ai0 *m21+ai1 *m22+ai2 *m23+ai3 *m24;
			outArray[ai2OutOffset+i]=ai0 *m31+ai1 *m32+ai2 *m33+ai3 *m34;
			outArray[ai3OutOffset+i]=ai0 *m41+ai1 *m42+ai2 *m43+ai3 *m44;
		}
	}

	Utils3D.getYawPitchRoll=function(quaternion,out){
		Utils3D.transformQuat(Vector3.ForwardRH,quaternion,Quaternion.TEMPVector31);
		Utils3D.transformQuat(Vector3.Up,quaternion,Quaternion.TEMPVector32);
		var upe=Quaternion.TEMPVector32.elements;
		Utils3D.angleTo(Vector3.ZERO,Quaternion.TEMPVector31,Quaternion.TEMPVector33);
		var anglee=Quaternion.TEMPVector33.elements;
		if (anglee[0]==Math.PI / 2){
			anglee[1]=Utils3D.arcTanAngle(upe[2],upe[0]);
			anglee[2]=0;
			}else if (anglee[0]==-Math.PI / 2){
			anglee[1]=Utils3D.arcTanAngle(-upe[2],-upe[0]);
			anglee[2]=0;
			}else {
			Matrix4x4.createRotationY(-anglee[1],Quaternion.TEMPMatrix0);
			Matrix4x4.createRotationX(-anglee[0],Quaternion.TEMPMatrix1);
			Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix0,Quaternion.TEMPVector32);
			Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix1,Quaternion.TEMPVector32);
			anglee[2]=Utils3D.arcTanAngle(upe[1],-upe[0]);
		}
		if (anglee[1] <=-Math.PI)
			anglee[1]=Math.PI;
		if (anglee[2] <=-Math.PI)
			anglee[2]=Math.PI;
		if (anglee[1] >=Math.PI && anglee[2] >=Math.PI){
			anglee[1]=0;
			anglee[2]=0;
			anglee[0]=Math.PI-anglee[0];
		}
		out[0]=anglee[1];
		out[1]=anglee[0];
		out[2]=anglee[2];
	}

	Utils3D.arcTanAngle=function(x,y){
		if (x==0){
			if (y==1)
				return Math.PI / 2;
			return-Math.PI / 2;
		}
		if (x > 0)
			return Math.atan(y / x);
		if (x < 0){
			if (y > 0)
				return Math.atan(y / x)+Math.PI;
			return Math.atan(y / x)-Math.PI;
		}
		return 0;
	}

	Utils3D.angleTo=function(from,location,angle){
		Vector3.subtract(location,from,Quaternion.TEMPVector30);
		Vector3.normalize(Quaternion.TEMPVector30,Quaternion.TEMPVector30);
		angle.elements[0]=Math.asin(Quaternion.TEMPVector30.y);
		angle.elements[1]=Utils3D.arcTanAngle(-Quaternion.TEMPVector30.z,-Quaternion.TEMPVector30.x);
	}

	Utils3D.transformQuat=function(source,rotation,out){
		var destination=out.elements;
		var se=source.elements;
		var re=rotation;
		var x=se[0],y=se[1],z=se[2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
		ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
		destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
		destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
		destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
	}

	Utils3D.quaterionNormalize=function(f,e){
		var x=f[0],y=f[1],z=f[2],w=f[3];
		var len=x *x+y *y+z *z+w *w;
		if (len > 0){
			len=1 / Math.sqrt(len);
			e[0]=x *len;
			e[1]=y *len;
			e[2]=z *len;
			e[3]=w *len;
		}
	}

	Utils3D.quaterionSlerp=function(left,right,t,out){
		var ax=left[0],ay=left[1],az=left[2],aw=left[3],bx=right[0],by=right[1],bz=right[2],bw=right[3];
		var omega,cosom,sinom,scale0,scale1;
		cosom=ax *bx+ay *by+az *bz+aw *bw;
		if (cosom < 0.0){
			cosom=-cosom;
			bx=-bx;
			by=-by;
			bz=-bz;
			bw=-bw;
		}
		if ((1.0-cosom)> 0.000001){
			omega=Math.acos(cosom);
			sinom=Math.sin(omega);
			scale0=Math.sin((1.0-t)*omega)/ sinom;
			scale1=Math.sin(t *omega)/ sinom;
			}else {
			scale0=1.0-t;
			scale1=t;
		}
		out[0]=scale0 *ax+scale1 *bx;
		out[1]=scale0 *ay+scale1 *by;
		out[2]=scale0 *az+scale1 *bz;
		out[3]=scale0 *aw+scale1 *bw;
	}

	Utils3D.quaternionMultiply=function(le,re,oe){
		var lx=le[0];
		var ly=le[1];
		var lz=le[2];
		var lw=le[3];
		var rx=re[0];
		var ry=re[1];
		var rz=re[2];
		var rw=re[3];
		var a=(ly *rz-lz *ry);
		var b=(lz *rx-lx *rz);
		var c=(lx *ry-ly *rx);
		var d=(lx *rx+ly *ry+lz *rz);
		oe[0]=(lx *rw+rx *lw)+a;
		oe[1]=(ly *rw+ry *lw)+b;
		oe[2]=(lz *rw+rz *lw)+c;
		oe[3]=lw *rw-d;
	}

	Utils3D.quaternionWeight=function(f,weight,e){
		e[0]=f[0] *weight;
		e[1]=f[1] *weight;
		e[2]=f[2] *weight;
		e[3]=f[3];
	}

	Utils3D.quaternionInvert=function(f,e){
		var a0=f[0],a1=f[1],a2=f[2],a3=f[3];
		var dot=a0 *a0+a1 *a1+a2 *a2+a3 *a3;
		var invDot=dot ? 1.0 / dot :0;
		e[0]=-a0 *invDot;
		e[1]=-a1 *invDot;
		e[2]=-a2 *invDot;
		e[3]=a3 *invDot;
	}

	Utils3D.quaternionConjugate=function(value,offset,result){
		result[0]=-value[offset];
		result[1]=-value[offset+1];
		result[2]=-value[offset+2];
		result[3]=value[offset+3];
	}

	Utils3D.scaleWeight=function(s,w,out){
		var sX=s[0],sY=s[1],sZ=s[2];
		out[0]=sX > 0 ? Math.pow(Math.abs(sX),w):-Math.pow(Math.abs(sX),w);
		out[1]=sY > 0 ? Math.pow(Math.abs(sY),w):-Math.pow(Math.abs(sY),w);
		out[2]=sZ > 0 ? Math.pow(Math.abs(sZ),w):-Math.pow(Math.abs(sZ),w);
	}

	Utils3D.scaleBlend=function(sa,sb,w,out){
		var saw=Utils3D._tempVector3Array0;
		var sbw=Utils3D._tempVector3Array1;
		Utils3D.scaleWeight(sa,1.0-w,saw);
		Utils3D.scaleWeight(sb,w,sbw);
		var sng=w > 0.5 ? sb :sa;
		out[0]=sng[0] > 0 ? Math.abs(saw[0] *sbw[0]):-Math.abs(saw[0] *sbw[0]);
		out[1]=sng[1] > 0 ? Math.abs(saw[1] *sbw[1]):-Math.abs(saw[1] *sbw[1]);
		out[2]=sng[2] > 0 ? Math.abs(saw[2] *sbw[2]):-Math.abs(saw[2] *sbw[2]);
	}

	Utils3D.matrix4x4MultiplyFFF=function(a,b,e){
		var i,ai0,ai1,ai2,ai3;
		if (e===b){
			b=new Float32Array(16);
			for (i=0;i < 16;++i){
				b[i]=e[i];
			}
		};
		var b0=b[0],b1=b[1],b2=b[2],b3=b[3];
		var b4=b[4],b5=b[5],b6=b[6],b7=b[7];
		var b8=b[8],b9=b[9],b10=b[10],b11=b[11];
		var b12=b[12],b13=b[13],b14=b[14],b15=b[15];
		for (i=0;i < 4;i++){
			ai0=a[i];
			ai1=a[i+4];
			ai2=a[i+8];
			ai3=a[i+12];
			e[i]=ai0 *b0+ai1 *b1+ai2 *b2+ai3 *b3;
			e[i+4]=ai0 *b4+ai1 *b5+ai2 *b6+ai3 *b7;
			e[i+8]=ai0 *b8+ai1 *b9+ai2 *b10+ai3 *b11;
			e[i+12]=ai0 *b12+ai1 *b13+ai2 *b14+ai3 *b15;
		}
	}

	Utils3D.matrix4x4MultiplyFFFForNative=function(a,b,e){
		LayaGL.instance.matrix4x4Multiply(a,b,e);
	}

	Utils3D.matrix4x4MultiplyMFM=function(left,right,out){
		Utils3D.matrix4x4MultiplyFFF(left.elements,right,out.elements);
	}

	Utils3D._buildTexture2D=function(width,height,format,colorFunc,mipmaps){
		(mipmaps===void 0)&& (mipmaps=false);
		var texture=new Texture2D(width,height,format,mipmaps,true);
		texture.anisoLevel=1;
		texture.filterMode=/*laya.webgl.resource.BaseTexture.FILTERMODE_POINT*/0;
		TextureGenerator._generateTexture2D(texture,width,height,colorFunc);
		return texture;
	}

	Utils3D._tempVector3Array0=new Float32Array(3);
	Utils3D._tempVector3Array1=new Float32Array(3);
	Utils3D._tempArray4_0=new Float32Array(4);
	Utils3D._tempArray16_0=new Float32Array(16);
	Utils3D._tempArray16_1=new Float32Array(16);
	Utils3D._tempArray16_2=new Float32Array(16);
	Utils3D._tempArray16_3=new Float32Array(16);
	__static(Utils3D,
	['_tempVector3_0',function(){return this._tempVector3_0=new Vector3();},'_tempVector3_1',function(){return this._tempVector3_1=new Vector3();},'_tempVector3_2',function(){return this._tempVector3_2=new Vector3();},'_tempVector3_3',function(){return this._tempVector3_3=new Vector3();},'_tempVector3_4',function(){return this._tempVector3_4=new Vector3();},'_tempVector3_5',function(){return this._tempVector3_5=new Vector3();},'_tempVector3_6',function(){return this._tempVector3_6=new Vector3();},'_compIdToNode',function(){return this._compIdToNode=new Object();}
	]);
	return Utils3D;
})()


/**
*<code>ContainmentType</code> 类用于定义空间物体位置关系。
*/
//class laya.d3.math.ContainmentType
var ContainmentType=(function(){
	function ContainmentType(){}
	__class(ContainmentType,'laya.d3.math.ContainmentType');
	ContainmentType.Disjoint=0;
	ContainmentType.Contains=1;
	ContainmentType.Intersects=2;
	return ContainmentType;
})()


/**
*@private
*<code>LoadModelV05</code> 类用于模型加载。
*/
//class laya.d3.loaders.LoadModelV05
var LoadModelV05=(function(){
	function LoadModelV05(){}
	__class(LoadModelV05,'laya.d3.loaders.LoadModelV05');
	LoadModelV05.parse=function(readData,version,mesh,subMeshes){
		LoadModelV05._mesh=mesh;
		LoadModelV05._subMeshes=subMeshes;
		LoadModelV05._version=version;
		LoadModelV05._readData=readData;
		LoadModelV05.READ_DATA();
		LoadModelV05.READ_BLOCK();
		LoadModelV05.READ_STRINGS();
		for (var i=0,n=LoadModelV05._BLOCK.count;i < n;i++){
			LoadModelV05._readData.pos=LoadModelV05._BLOCK.blockStarts[i];
			var index=LoadModelV05._readData.getUint16();
			var blockName=LoadModelV05._strings[index];
			var fn=LoadModelV05["READ_"+blockName];
			if (fn==null)
				throw new Error("model file err,no this function:"+index+" "+blockName);
			else
			fn.call();
		}
		LoadModelV05._mesh._bindPoseIndices=new Uint16Array(LoadModelV05._bindPoseIndices);
		LoadModelV05._bindPoseIndices.length=0;
		LoadModelV05._strings.length=0;
		LoadModelV05._readData=null;
		LoadModelV05._version=null;
		LoadModelV05._mesh=null;
		LoadModelV05._subMeshes=null;
	}

	LoadModelV05._readString=function(){
		return LoadModelV05._strings[LoadModelV05._readData.getUint16()];
	}

	LoadModelV05.READ_DATA=function(){
		LoadModelV05._DATA.offset=LoadModelV05._readData.getUint32();
		LoadModelV05._DATA.size=LoadModelV05._readData.getUint32();
	}

	LoadModelV05.READ_BLOCK=function(){
		var count=LoadModelV05._BLOCK.count=LoadModelV05._readData.getUint16();
		var blockStarts=LoadModelV05._BLOCK.blockStarts=[];
		var blockLengths=LoadModelV05._BLOCK.blockLengths=[];
		for (var i=0;i < count;i++){
			blockStarts.push(LoadModelV05._readData.getUint32());
			blockLengths.push(LoadModelV05._readData.getUint32());
		}
	}

	LoadModelV05.READ_STRINGS=function(){
		var offset=LoadModelV05._readData.getUint32();
		var count=LoadModelV05._readData.getUint16();
		var prePos=LoadModelV05._readData.pos;
		LoadModelV05._readData.pos=offset+LoadModelV05._DATA.offset;
		for (var i=0;i < count;i++)
		LoadModelV05._strings[i]=LoadModelV05._readData.readUTFString();
		LoadModelV05._readData.pos=prePos;
	}

	LoadModelV05.READ_MESH=function(){
		var i=0,n=0;
		var memorySize=0;
		var name=LoadModelV05._readString();
		var arrayBuffer=LoadModelV05._readData.__getBuffer();
		var vertexBufferCount=LoadModelV05._readData.getInt16();
		var offset=LoadModelV05._DATA.offset;
		for (i=0;i < vertexBufferCount;i++){
			var vbStart=offset+LoadModelV05._readData.getUint32();
			var vertexCount=LoadModelV05._readData.getUint32();
			var vertexFlag=LoadModelV05._readString();
			var vertexDeclaration=VertexMesh.getVertexDeclaration(vertexFlag,false);
			var vertexStride=vertexDeclaration.vertexStride;
			var vertexData=new ArrayBuffer(vertexStride *vertexCount);
			var floatData=new Float32Array(vertexData);
			var subVertexFlags=vertexFlag.split(",");
			var subVertexCount=subVertexFlags.length;
			switch (LoadModelV05._version){
				case "LAYAMODEL:05":
					floatData=new Float32Array(arrayBuffer.slice(vbStart,vbStart+vertexCount *vertexStride));
					break ;
				case "LAYAMODEL:COMPRESSION_05":;
					var lastPosition=LoadModelV05._readData.pos;
					floatData=new Float32Array(vertexData);
					var uint8Data=new Uint8Array(vertexData);
					LoadModelV05._readData.pos=vbStart;
					for (var j=0;j < vertexCount;j++){
						var subOffset=0;
						var verOffset=j *vertexStride;
						for (var k=0;k < subVertexCount;k++){
						switch (subVertexFlags[k]){
							case "POSITION":
								subOffset=verOffset / 4;
								floatData[subOffset]=HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
								floatData[subOffset+1]=HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
								floatData[subOffset+2]=HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
								verOffset+=12;
								break ;
							case "NORMAL":
								subOffset=verOffset / 4;
								floatData[subOffset]=LoadModelV05._readData.getUint8()/ 127.5-1;
								floatData[subOffset+1]=LoadModelV05._readData.getUint8()/ 127.5-1;
								floatData[subOffset+2]=LoadModelV05._readData.getUint8()/ 127.5-1;
								verOffset+=12;
								break ;
							case "COLOR":
								subOffset=verOffset / 4;
								floatData[subOffset]=LoadModelV05._readData.getUint8()/ 255;
								floatData[subOffset+1]=LoadModelV05._readData.getUint8()/ 255;
								floatData[subOffset+2]=LoadModelV05._readData.getUint8()/ 255;
								floatData[subOffset+3]=LoadModelV05._readData.getUint8()/ 255;
								verOffset+=16;
								break ;
							case "UV":
								subOffset=verOffset / 4;
								floatData[subOffset]=HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
								floatData[subOffset+1]=HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
								verOffset+=8;
								break ;
							case "UV1":
								subOffset=verOffset / 4;
								floatData[subOffset]=HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
								floatData[subOffset+1]=HalfFloatUtils.convertToNumber(LoadModelV05._readData.getUint16());
								verOffset+=8;
								break ;
							case "BLENDWEIGHT":
								subOffset=verOffset / 4;
								floatData[subOffset]=LoadModelV05._readData.getUint8()/ 255;
								floatData[subOffset+1]=LoadModelV05._readData.getUint8()/ 255;
								floatData[subOffset+2]=LoadModelV05._readData.getUint8()/ 255;
								floatData[subOffset+3]=LoadModelV05._readData.getUint8()/ 255;
								verOffset+=16;
								break ;
							case "BLENDINDICES":
								uint8Data[verOffset]=LoadModelV05._readData.getUint8();
								uint8Data[verOffset+1]=LoadModelV05._readData.getUint8();
								uint8Data[verOffset+2]=LoadModelV05._readData.getUint8();
								uint8Data[verOffset+3]=LoadModelV05._readData.getUint8();
								verOffset+=4;
								break ;
							case "TANGENT":
								subOffset=verOffset / 4;
								floatData[subOffset]=LoadModelV05._readData.getUint8()/ 127.5-1;
								floatData[subOffset+1]=LoadModelV05._readData.getUint8()/ 127.5-1;
								floatData[subOffset+2]=LoadModelV05._readData.getUint8()/ 127.5-1;
								floatData[subOffset+3]=LoadModelV05._readData.getUint8()/ 127.5-1;
								verOffset+=16;
								break ;
							}
					}
				}
				LoadModelV05._readData.pos=lastPosition;
				break ;
			};
			var vertexBuffer=new VertexBuffer3D(vertexData.byteLength,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			vertexBuffer.vertexDeclaration=vertexDeclaration;
			vertexBuffer.setData(floatData);
			LoadModelV05._mesh._vertexBuffers.push(vertexBuffer);
			LoadModelV05._mesh._vertexCount+=vertexBuffer.vertexCount;
			memorySize+=floatData.length *4;
		};
		var ibStart=offset+LoadModelV05._readData.getUint32();
		var ibLength=LoadModelV05._readData.getUint32();
		var ibDatas=new Uint16Array(arrayBuffer.slice(ibStart,ibStart+ibLength));
		var indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",ibLength / 2,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		indexBuffer.setData(ibDatas);
		LoadModelV05._mesh._indexBuffer=indexBuffer;
		memorySize+=indexBuffer.indexCount *2;
		LoadModelV05._mesh._setCPUMemory(memorySize);
		LoadModelV05._mesh._setGPUMemory(memorySize);
		var boneNames=LoadModelV05._mesh._boneNames=[];
		var boneCount=LoadModelV05._readData.getUint16();
		boneNames.length=boneCount;
		for (i=0;i < boneCount;i++)
		boneNames[i]=LoadModelV05._strings[LoadModelV05._readData.getUint16()];
		var bindPoseDataStart=LoadModelV05._readData.getUint32();
		var bindPoseDataLength=LoadModelV05._readData.getUint32();
		var bindPoseDatas=new Float32Array(arrayBuffer.slice(offset+bindPoseDataStart,offset+bindPoseDataStart+bindPoseDataLength));
		var bindPoseFloatCount=bindPoseDatas.length;
		var bindPoseCount=bindPoseFloatCount / 16;
		var bindPoseBuffer=LoadModelV05._mesh._inverseBindPosesBuffer=new ArrayBuffer(bindPoseFloatCount *4);
		LoadModelV05._mesh._inverseBindPoses=__newvec(bindPoseCount);
		for (i=0;i < bindPoseFloatCount;i+=16){
			var inverseGlobalBindPose=new Matrix4x4(bindPoseDatas[i+0],bindPoseDatas[i+1],bindPoseDatas[i+2],bindPoseDatas[i+3],bindPoseDatas[i+4],bindPoseDatas[i+5],bindPoseDatas[i+6],bindPoseDatas[i+7],bindPoseDatas[i+8],bindPoseDatas[i+9],bindPoseDatas[i+10],bindPoseDatas[i+11],bindPoseDatas[i+12],bindPoseDatas[i+13],bindPoseDatas[i+14],bindPoseDatas[i+15],new Float32Array(bindPoseBuffer,i *4,16));
			LoadModelV05._mesh._inverseBindPoses[i / 16]=inverseGlobalBindPose;
		}
		return true;
	}

	LoadModelV05.READ_SUBMESH=function(){
		var arrayBuffer=LoadModelV05._readData.__getBuffer();
		var submesh=new SubMesh(LoadModelV05._mesh);
		var vbIndex=LoadModelV05._readData.getInt16();
		var ibStart=LoadModelV05._readData.getUint32();
		var ibCount=LoadModelV05._readData.getUint32();
		var indexBuffer=LoadModelV05._mesh._indexBuffer;
		submesh._indexBuffer=indexBuffer;
		submesh._indexStart=ibStart;
		submesh._indexCount=ibCount;
		submesh._indices=new Uint16Array(indexBuffer.getData().buffer,ibStart *2,ibCount);
		var vertexBuffer=LoadModelV05._mesh._vertexBuffers[vbIndex];
		submesh._vertexBuffer=vertexBuffer;
		var bufferState=submesh._bufferState;
		bufferState.bind();
		bufferState.applyVertexBuffer(vertexBuffer);
		bufferState.applyIndexBuffer(indexBuffer);
		bufferState.unBind();
		var offset=LoadModelV05._DATA.offset;
		var subIndexBufferStart=submesh._subIndexBufferStart;
		var subIndexBufferCount=submesh._subIndexBufferCount;
		var boneIndicesList=submesh._boneIndicesList;
		var drawCount=LoadModelV05._readData.getUint16();
		subIndexBufferStart.length=drawCount;
		subIndexBufferCount.length=drawCount;
		boneIndicesList.length=drawCount;
		var pathMarks=LoadModelV05._mesh._skinDataPathMarks;
		var bindPoseIndices=LoadModelV05._bindPoseIndices;
		var subMeshIndex=LoadModelV05._subMeshes.length;
		for (var i=0;i < drawCount;i++){
			subIndexBufferStart[i]=LoadModelV05._readData.getUint32();
			subIndexBufferCount[i]=LoadModelV05._readData.getUint32();
			var boneDicofs=LoadModelV05._readData.getUint32();
			var boneDicCount=LoadModelV05._readData.getUint32();
			var boneIndices=boneIndicesList[i]=new Uint16Array(arrayBuffer.slice(offset+boneDicofs,offset+boneDicofs+boneDicCount));
			for (var j=0,m=boneIndices.length;j < m;j++){
				var index=boneIndices[j];
				var combineIndex=bindPoseIndices.indexOf(index);
				if (combineIndex===-1){
					boneIndices[j]=bindPoseIndices.length;
					bindPoseIndices.push(index);
					pathMarks.push([subMeshIndex,i,j]);
					}else {
					boneIndices[j]=combineIndex;
				}
			}
		}
		LoadModelV05._subMeshes.push(submesh);
		return true;
	}

	LoadModelV05._strings=[];
	LoadModelV05._readData=null;
	LoadModelV05._version=null;
	LoadModelV05._mesh=null;
	LoadModelV05._subMeshes=null;
	LoadModelV05._bindPoseIndices=[];
	__static(LoadModelV05,
	['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
	]);
	return LoadModelV05;
})()


/**
*<code>StartFrame</code> 类用于创建开始帧。
*/
//class laya.d3.core.particleShuriKen.module.StartFrame
var StartFrame=(function(){
	function StartFrame(){
		/**@private */
		this._type=0;
		/**@private */
		this._constant=NaN;
		/**@private */
		this._constantMin=NaN;
		/**@private */
		this._constantMax=NaN;
	}

	__class(StartFrame,'laya.d3.core.particleShuriKen.module.StartFrame');
	var __proto=StartFrame.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destStartFrame=destObject;
		destStartFrame._type=this._type;
		destStartFrame._constant=this._constant;
		destStartFrame._constantMin=this._constantMin;
		destStartFrame._constantMax=this._constantMax;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destStartFrame=/*__JS__ */new this.constructor();
		this.cloneTo(destStartFrame);
		return destStartFrame;
	}

	/**
	*固定帧。
	*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*开始帧类型,0常量模式，1随机双常量模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*最小固定帧。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*最大固定帧。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	StartFrame.createByConstant=function(constant){
		var rotationOverLifetime=new StartFrame();
		rotationOverLifetime._type=0;
		rotationOverLifetime._constant=constant;
		return rotationOverLifetime;
	}

	StartFrame.createByRandomTwoConstant=function(constantMin,constantMax){
		var rotationOverLifetime=new StartFrame();
		rotationOverLifetime._type=1;
		rotationOverLifetime._constantMin=constantMin;
		rotationOverLifetime._constantMax=constantMax;
		return rotationOverLifetime;
	}

	return StartFrame;
})()


/**
*@private
*<code>LoadModel</code> 类用于模型加载。
*/
//class laya.d3.loaders.LoadModelV04
var LoadModelV04=(function(){
	function LoadModelV04(){}
	__class(LoadModelV04,'laya.d3.loaders.LoadModelV04');
	LoadModelV04.parse=function(readData,version,mesh,subMeshes){
		LoadModelV04._mesh=mesh;
		LoadModelV04._subMeshes=subMeshes;
		LoadModelV04._version=version;
		LoadModelV04._readData=readData;
		LoadModelV04.READ_DATA();
		LoadModelV04.READ_BLOCK();
		LoadModelV04.READ_STRINGS();
		for (var i=0,n=LoadModelV04._BLOCK.count;i < n;i++){
			LoadModelV04._readData.pos=LoadModelV04._BLOCK.blockStarts[i];
			var index=LoadModelV04._readData.getUint16();
			var blockName=LoadModelV04._strings[index];
			var fn=LoadModelV04["READ_"+blockName];
			if (fn==null)
				throw new Error("model file err,no this function:"+index+" "+blockName);
			else
			fn.call();
		}
		LoadModelV04._mesh._bindPoseIndices=new Uint16Array(LoadModelV04._bindPoseIndices);
		LoadModelV04._bindPoseIndices.length=0;
		LoadModelV04._strings.length=0;
		LoadModelV04._readData=null;
		LoadModelV04._version=null;
		LoadModelV04._mesh=null;
		LoadModelV04._subMeshes=null;
	}

	LoadModelV04._readString=function(){
		return LoadModelV04._strings[LoadModelV04._readData.getUint16()];
	}

	LoadModelV04.READ_DATA=function(){
		LoadModelV04._DATA.offset=LoadModelV04._readData.getUint32();
		LoadModelV04._DATA.size=LoadModelV04._readData.getUint32();
	}

	LoadModelV04.READ_BLOCK=function(){
		var count=LoadModelV04._BLOCK.count=LoadModelV04._readData.getUint16();
		var blockStarts=LoadModelV04._BLOCK.blockStarts=[];
		var blockLengths=LoadModelV04._BLOCK.blockLengths=[];
		for (var i=0;i < count;i++){
			blockStarts.push(LoadModelV04._readData.getUint32());
			blockLengths.push(LoadModelV04._readData.getUint32());
		}
	}

	LoadModelV04.READ_STRINGS=function(){
		var offset=LoadModelV04._readData.getUint32();
		var count=LoadModelV04._readData.getUint16();
		var prePos=LoadModelV04._readData.pos;
		LoadModelV04._readData.pos=offset+LoadModelV04._DATA.offset;
		for (var i=0;i < count;i++)
		LoadModelV04._strings[i]=LoadModelV04._readData.readUTFString();
		LoadModelV04._readData.pos=prePos;
	}

	LoadModelV04.READ_MESH=function(){
		var name=LoadModelV04._readString();
		var arrayBuffer=LoadModelV04._readData.__getBuffer();
		var i=0,n=0;
		var memorySize=0;
		var vertexBufferCount=LoadModelV04._readData.getInt16();
		var offset=LoadModelV04._DATA.offset;
		for (i=0;i < vertexBufferCount;i++){
			var vbStart=offset+LoadModelV04._readData.getUint32();
			var vbLength=LoadModelV04._readData.getUint32();
			var vbDatas=new Float32Array(arrayBuffer.slice(vbStart,vbStart+vbLength));
			var bufferAttribute=LoadModelV04._readString();
			var vertexDeclaration;
			switch (LoadModelV04._version){
				case "LAYAMODEL:0301":
				case "LAYAMODEL:0400":
					vertexDeclaration=VertexMesh.getVertexDeclaration(bufferAttribute);
					break ;
				case "LAYAMODEL:0401":
					vertexDeclaration=VertexMesh.getVertexDeclaration(bufferAttribute,false);
					break ;
				default :
					throw new Error("LoadModelV03: unknown version.");
				}
			if (!vertexDeclaration)
				throw new Error("LoadModelV03: unknown vertexDeclaration.");
			var vertexBuffer=new VertexBuffer3D(vbDatas.length *4,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			vertexBuffer.vertexDeclaration=vertexDeclaration;
			vertexBuffer.setData(vbDatas);
			LoadModelV04._mesh._vertexBuffers.push(vertexBuffer);
			LoadModelV04._mesh._vertexCount+=vertexBuffer.vertexCount;
			memorySize+=vbDatas.length *4;
		};
		var ibStart=offset+LoadModelV04._readData.getUint32();
		var ibLength=LoadModelV04._readData.getUint32();
		var ibDatas=new Uint16Array(arrayBuffer.slice(ibStart,ibStart+ibLength));
		var indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",ibLength / 2,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
		indexBuffer.setData(ibDatas);
		LoadModelV04._mesh._indexBuffer=indexBuffer;
		memorySize+=indexBuffer.indexCount *2;
		LoadModelV04._mesh._setCPUMemory(memorySize);
		LoadModelV04._mesh._setGPUMemory(memorySize);
		var boneNames=LoadModelV04._mesh._boneNames=[];
		var boneCount=LoadModelV04._readData.getUint16();
		boneNames.length=boneCount;
		for (i=0;i < boneCount;i++)
		boneNames[i]=LoadModelV04._strings[LoadModelV04._readData.getUint16()];
		LoadModelV04._readData.pos+=8;
		var bindPoseDataStart=LoadModelV04._readData.getUint32();
		var bindPoseDataLength=LoadModelV04._readData.getUint32();
		var bindPoseDatas=new Float32Array(arrayBuffer.slice(offset+bindPoseDataStart,offset+bindPoseDataStart+bindPoseDataLength));
		var bindPoseFloatCount=bindPoseDatas.length;
		var bindPoseCount=bindPoseFloatCount / 16;
		var bindPoseBuffer=LoadModelV04._mesh._inverseBindPosesBuffer=new ArrayBuffer(bindPoseFloatCount *4);
		LoadModelV04._mesh._inverseBindPoses=__newvec(bindPoseCount);
		for (i=0;i < bindPoseFloatCount;i+=16){
			var inverseGlobalBindPose=new Matrix4x4(bindPoseDatas[i+0],bindPoseDatas[i+1],bindPoseDatas[i+2],bindPoseDatas[i+3],bindPoseDatas[i+4],bindPoseDatas[i+5],bindPoseDatas[i+6],bindPoseDatas[i+7],bindPoseDatas[i+8],bindPoseDatas[i+9],bindPoseDatas[i+10],bindPoseDatas[i+11],bindPoseDatas[i+12],bindPoseDatas[i+13],bindPoseDatas[i+14],bindPoseDatas[i+15],new Float32Array(bindPoseBuffer,i *4,16));
			LoadModelV04._mesh._inverseBindPoses[i / 16]=inverseGlobalBindPose;
		}
		return true;
	}

	LoadModelV04.READ_SUBMESH=function(){
		var arrayBuffer=LoadModelV04._readData.__getBuffer();
		var submesh=new SubMesh(LoadModelV04._mesh);
		var vbIndex=LoadModelV04._readData.getInt16();
		LoadModelV04._readData.getUint32();
		LoadModelV04._readData.getUint32();
		var ibStart=LoadModelV04._readData.getUint32();
		var ibCount=LoadModelV04._readData.getUint32();
		var indexBuffer=LoadModelV04._mesh._indexBuffer;
		submesh._indexBuffer=indexBuffer;
		submesh._indexStart=ibStart;
		submesh._indexCount=ibCount;
		submesh._indices=new Uint16Array(indexBuffer.getData().buffer,ibStart *2,ibCount);
		var vertexBuffer=LoadModelV04._mesh._vertexBuffers[vbIndex];
		submesh._vertexBuffer=vertexBuffer;
		var bufferState=submesh._bufferState;
		bufferState.bind();
		bufferState.applyVertexBuffer(vertexBuffer);
		bufferState.applyIndexBuffer(indexBuffer);
		bufferState.unBind();
		var offset=LoadModelV04._DATA.offset;
		var subIndexBufferStart=submesh._subIndexBufferStart;
		var subIndexBufferCount=submesh._subIndexBufferCount;
		var boneIndicesList=submesh._boneIndicesList;
		var drawCount=LoadModelV04._readData.getUint16();
		subIndexBufferStart.length=drawCount;
		subIndexBufferCount.length=drawCount;
		boneIndicesList.length=drawCount;
		var pathMarks=LoadModelV04._mesh._skinDataPathMarks;
		var bindPoseIndices=LoadModelV04._bindPoseIndices;
		var subMeshIndex=LoadModelV04._subMeshes.length;
		for (var i=0;i < drawCount;i++){
			subIndexBufferStart[i]=LoadModelV04._readData.getUint32();
			subIndexBufferCount[i]=LoadModelV04._readData.getUint32();
			var boneDicofs=LoadModelV04._readData.getUint32();
			var boneDicCount=LoadModelV04._readData.getUint32();
			var boneIndices=boneIndicesList[i]=new Uint16Array(arrayBuffer.slice(offset+boneDicofs,offset+boneDicofs+boneDicCount));
			for (var j=0,m=boneIndices.length;j < m;j++){
				var index=boneIndices[j];
				var combineIndex=bindPoseIndices.indexOf(index);
				if (combineIndex===-1){
					boneIndices[j]=bindPoseIndices.length;
					bindPoseIndices.push(index);
					pathMarks.push([subMeshIndex,i,j]);
					}else {
					boneIndices[j]=combineIndex;
				}
			}
		}
		LoadModelV04._subMeshes.push(submesh);
		return true;
	}

	LoadModelV04._strings=[];
	LoadModelV04._readData=null;
	LoadModelV04._version=null;
	LoadModelV04._mesh=null;
	LoadModelV04._subMeshes=null;
	LoadModelV04._bindPoseIndices=[];
	__static(LoadModelV04,
	['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
	]);
	return LoadModelV04;
})()


/**
*<code>Touch</code> 类用于实现触摸描述。
*/
//class laya.d3.Touch
var Touch=(function(){
	function Touch(){
		/**@private [实现IListPool接口]*/
		this._indexInList=-1;
		/**@private */
		this._identifier=-1;
		this._position=new Vector2();
	}

	__class(Touch,'laya.d3.Touch');
	var __proto=Touch.prototype;
	Laya.imps(__proto,{"laya.resource.ISingletonElement":true})
	/**
	*@private [实现ISingletonElement接口]
	*/
	__proto._getIndexInList=function(){
		return this._indexInList;
	}

	/**
	*@private [实现ISingletonElement接口]
	*/
	__proto._setIndexInList=function(index){
		this._indexInList=index;
	}

	/**
	*获取唯一识别ID。
	*@return 唯一识别ID。
	*/
	__getset(0,__proto,'identifier',function(){
		return this._identifier;
	});

	/**
	*获取触摸点的像素坐标。
	*@return 触摸点的像素坐标 [只读]。
	*/
	__getset(0,__proto,'position',function(){
		return this._position;
	});

	return Touch;
})()


/**
*<code>FrameOverTime</code> 类用于创建时间帧。
*/
//class laya.d3.core.particleShuriKen.module.FrameOverTime
var FrameOverTime=(function(){
	function FrameOverTime(){
		/**@private */
		this._type=0;
		/**@private */
		this._constant=0;
		/**@private */
		this._overTime=null;
		/**@private */
		this._constantMin=0;
		/**@private */
		this._constantMax=0;
		/**@private */
		this._overTimeMin=null;
		/**@private */
		this._overTimeMax=null;
	}

	__class(FrameOverTime,'laya.d3.core.particleShuriKen.module.FrameOverTime');
	var __proto=FrameOverTime.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destFrameOverTime=destObject;
		destFrameOverTime._type=this._type;
		destFrameOverTime._constant=this._constant;
		this._overTime.cloneTo(destFrameOverTime._overTime);
		destFrameOverTime._constantMin=this._constantMin;
		destFrameOverTime._constantMax=this._constantMax;
		this._overTimeMin.cloneTo(destFrameOverTime._overTimeMin);
		this._overTimeMax.cloneTo(destFrameOverTime._overTimeMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destFrameOverTime=/*__JS__ */new this.constructor();
		this.cloneTo(destFrameOverTime);
		return destFrameOverTime;
	}

	/**
	*时间帧。
	*/
	__getset(0,__proto,'frameOverTimeData',function(){
		return this._overTime;
	});

	/**
	*固定帧。
	*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*生命周期旋转类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*最小时间帧。
	*/
	__getset(0,__proto,'frameOverTimeDataMin',function(){
		return this._overTimeMin;
	});

	/**
	*最小固定帧。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*最大时间帧。
	*/
	__getset(0,__proto,'frameOverTimeDataMax',function(){
		return this._overTimeMax;
	});

	/**
	*最大固定帧。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	FrameOverTime.createByConstant=function(constant){
		var rotationOverLifetime=new FrameOverTime();
		rotationOverLifetime._type=0;
		rotationOverLifetime._constant=constant;
		return rotationOverLifetime;
	}

	FrameOverTime.createByOverTime=function(overTime){
		var rotationOverLifetime=new FrameOverTime();
		rotationOverLifetime._type=1;
		rotationOverLifetime._overTime=overTime;
		return rotationOverLifetime;
	}

	FrameOverTime.createByRandomTwoConstant=function(constantMin,constantMax){
		var rotationOverLifetime=new FrameOverTime();
		rotationOverLifetime._type=2;
		rotationOverLifetime._constantMin=constantMin;
		rotationOverLifetime._constantMax=constantMax;
		return rotationOverLifetime;
	}

	FrameOverTime.createByRandomTwoOverTime=function(gradientFrameMin,gradientFrameMax){
		var rotationOverLifetime=new FrameOverTime();
		rotationOverLifetime._type=3;
		rotationOverLifetime._overTimeMin=gradientFrameMin;
		rotationOverLifetime._overTimeMax=gradientFrameMax;
		return rotationOverLifetime;
	}

	return FrameOverTime;
})()


/**
*...
*@author ...
*/
//class laya.d3.graphics.Vertex.VertexMesh
var VertexMesh=(function(){
	function VertexMesh(){}
	__class(VertexMesh,'laya.d3.graphics.Vertex.VertexMesh');
	VertexMesh.getVertexDeclaration=function(vertexFlag,compatible){
		(compatible===void 0)&& (compatible=true);
		var verDec=VertexMesh._vertexDeclarationMap[vertexFlag];
		if (!verDec){
			var subFlags=vertexFlag.split(",");
			var offset=0;
			var elements=[];
			for (var i=0,n=subFlags.length;i < n;i++){
				var element;
				switch (subFlags[i]){
					case "POSITION":
						element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0);
						offset+=12;
						break ;
					case "NORMAL":
						element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_NORMAL0*/3);
						offset+=12;
						break ;
					case "COLOR":
						element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1);
						offset+=16;
						break ;
					case "UV":
						element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2);
						offset+=8;
						break ;
					case "UV1":
						element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE1*/8);
						offset+=8;
						break ;
					case "BLENDWEIGHT":
						element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDWEIGHT0*/7);
						offset+=16;
						break ;
					case "BLENDINDICES":
						if (compatible){
							element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDINDICES0*/6);
							offset+=16;
							}else {
							element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Byte4*/"byte4",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDINDICES0*/6);
							offset+=4;
						}
						break ;
					case "TANGENT":
						element=new VertexElement(offset,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*CLASS CONST:laya.d3.graphics.Vertex.VertexMesh.MESH_TANGENT0*/5);
						offset+=16;
						break ;
					default :
						throw "VertexMesh: unknown vertex flag.";
					}
				elements.push(element);
			}
			verDec=new VertexDeclaration(offset,elements);
			VertexMesh._vertexDeclarationMap[vertexFlag]=verDec;
		}
		return verDec;
	}

	VertexMesh.MESH_POSITION0=0;
	VertexMesh.MESH_COLOR0=1;
	VertexMesh.MESH_TEXTURECOORDINATE0=2;
	VertexMesh.MESH_NORMAL0=3;
	VertexMesh.MESH_TANGENT0=5;
	VertexMesh.MESH_BLENDINDICES0=6;
	VertexMesh.MESH_BLENDWEIGHT0=7;
	VertexMesh.MESH_TEXTURECOORDINATE1=8;
	VertexMesh._vertexDeclarationMap={};
	return VertexMesh;
})()


/**
*<code>RotationOverLifetime</code> 类用于粒子的生命周期旋转。
*/
//class laya.d3.core.particleShuriKen.module.RotationOverLifetime
var RotationOverLifetime=(function(){
	function RotationOverLifetime(angularVelocity){
		/**@private */
		this._angularVelocity=null;
		/**是否启用*/
		this.enbale=false;
		this._angularVelocity=angularVelocity;
	}

	__class(RotationOverLifetime,'laya.d3.core.particleShuriKen.module.RotationOverLifetime');
	var __proto=RotationOverLifetime.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destRotationOverLifetime=destObject;
		this._angularVelocity.cloneTo(destRotationOverLifetime._angularVelocity);
		destRotationOverLifetime.enbale=this.enbale;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destAngularVelocity;
		switch (this._angularVelocity.type){
			case 0:
				if (this._angularVelocity.separateAxes)
					destAngularVelocity=GradientAngularVelocity.createByConstantSeparate(this._angularVelocity.constantSeparate.clone());
				else
				destAngularVelocity=GradientAngularVelocity.createByConstant(this._angularVelocity.constant);
				break ;
			case 1:
				if (this._angularVelocity.separateAxes)
					destAngularVelocity=GradientAngularVelocity.createByGradientSeparate(this._angularVelocity.gradientX.clone(),this._angularVelocity.gradientY.clone(),this._angularVelocity.gradientZ.clone());
				else
				destAngularVelocity=GradientAngularVelocity.createByGradient(this._angularVelocity.gradient.clone());
				break ;
			case 2:
				if (this._angularVelocity.separateAxes)
					destAngularVelocity=GradientAngularVelocity.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(),this._angularVelocity.constantMaxSeparate.clone());
				else
				destAngularVelocity=GradientAngularVelocity.createByRandomTwoConstant(this._angularVelocity.constantMin,this._angularVelocity.constantMax);
				break ;
			case 3:
				if (this._angularVelocity.separateAxes)
					destAngularVelocity=GradientAngularVelocity.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(),this._angularVelocity.gradientYMin.clone(),this._angularVelocity.gradientZMin.clone(),this._angularVelocity.gradientWMin.clone(),this._angularVelocity.gradientXMax.clone(),this._angularVelocity.gradientYMax.clone(),this._angularVelocity.gradientZMax.clone(),this._angularVelocity.gradientWMax.clone());
				else
				destAngularVelocity=GradientAngularVelocity.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(),this._angularVelocity.gradientMax.clone());
				break ;
			};
		var destRotationOverLifetime=/*__JS__ */new this.constructor(destAngularVelocity);
		destRotationOverLifetime.enbale=this.enbale;
		return destRotationOverLifetime;
	}

	/**
	*获取角速度。
	*/
	__getset(0,__proto,'angularVelocity',function(){
		return this._angularVelocity;
	});

	return RotationOverLifetime;
})()


/**
*<code>VertexPositionTerrain</code> 类用于创建位置、法线、纹理1、纹理2顶点结构。
*/
//class laya.d3.graphics.Vertex.VertexPositionTerrain
var VertexPositionTerrain=(function(){
	function VertexPositionTerrain(position,normal,textureCoord0,textureCoord1){
		this._position=null;
		this._normal=null;
		this._textureCoord0=null;
		this._textureCoord1=null;
		this._position=position;
		this._normal=normal;
		this._textureCoord0=textureCoord0;
		this._textureCoord1=textureCoord1;
	}

	__class(VertexPositionTerrain,'laya.d3.graphics.Vertex.VertexPositionTerrain');
	var __proto=VertexPositionTerrain.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'normal',function(){
		return this._normal;
	});

	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoord0',function(){
		return this._textureCoord0;
	});

	__getset(0,__proto,'textureCoord1',function(){
		return this._textureCoord1;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionTerrain._vertexDeclaration;
	});

	__getset(1,VertexPositionTerrain,'vertexDeclaration',function(){
		return VertexPositionTerrain._vertexDeclaration;
	});

	VertexPositionTerrain.TERRAIN_POSITION0=0;
	VertexPositionTerrain.TERRAIN_NORMAL0=1;
	VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0=2;
	VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1=3;
	__static(VertexPositionTerrain,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*CLASS CONST:laya.d3.graphics.Vertex.VertexPositionTerrain.TERRAIN_POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*CLASS CONST:laya.d3.graphics.Vertex.VertexPositionTerrain.TERRAIN_NORMAL0*/1),
		new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*CLASS CONST:laya.d3.graphics.Vertex.VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0*/2),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*CLASS CONST:laya.d3.graphics.Vertex.VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1*/3)]);}
	]);
	return VertexPositionTerrain;
})()


/**
*<code>AnimatorPlayState</code> 类用于创建动画播放状态信息。
*/
//class laya.d3.component.AnimatorPlayState
var AnimatorPlayState=(function(){
	function AnimatorPlayState(){
		/**@private */
		//this._finish=false;
		/**@private */
		//this._startPlayTime=NaN;
		/**@private */
		//this._lastElapsedTime=NaN;
		/**@private */
		//this._elapsedTime=NaN;
		/**@private */
		//this._normalizedTime=NaN;
		/**@private */
		//this._normalizedPlayTime=NaN;
		/**@private */
		//this._duration=NaN;
		/**@private */
		//this._playEventIndex=0;
	}

	__class(AnimatorPlayState,'laya.d3.component.AnimatorPlayState');
	var __proto=AnimatorPlayState.prototype;
	/**
	*@private
	*/
	__proto._resetPlayState=function(startTime){
		this._finish=false;
		this._startPlayTime=startTime;
		this._elapsedTime=startTime;
		this._playEventIndex=0.0;
	}

	/**
	*@private
	*/
	__proto._cloneTo=function(dest){
		dest._finish=this._finish;
		dest._startPlayTime=this._startPlayTime;
		dest._elapsedTime=this._elapsedTime;
		dest._playEventIndex=this._playEventIndex;
	}

	/**
	*获取播放状态的归一化时间,整数为循环次数，小数为单次播放时间。
	*/
	__getset(0,__proto,'normalizedTime',function(){
		return this._normalizedTime;
	});

	/**
	*获取当前动画的持续时间，以秒为单位。
	*/
	__getset(0,__proto,'duration',function(){
		return this._duration;
	});

	return AnimatorPlayState;
})()


/**
*<code>Shader3D</code> 类用于创建Shader3D。
*/
//class laya.d3.shader.Shader3D
var Shader3D=(function(){
	function Shader3D(name){
		/**@private */
		//this._name=null;
		this._subShaders=[];
		this._name=name;
	}

	__class(Shader3D,'laya.d3.shader.Shader3D');
	var __proto=Shader3D.prototype;
	/**
	*添加子着色器。
	*@param 子着色器。
	*/
	__proto.addSubShader=function(subShader){
		this._subShaders.push(subShader);
		subShader._owner=this;
	}

	/**
	*在特定索引获取子着色器。
	*@param index 索引。
	*@return 子着色器。
	*/
	__proto.getSubShaderAt=function(index){
		return this._subShaders[index];
	}

	Shader3D.propertyNameToID=function(name){
		if (Shader3D._propertyNameMap[name]!=null){
			return Shader3D._propertyNameMap[name];
			}else {
			var id=Shader3D._propertyNameCounter++;
			Shader3D._propertyNameMap[name]=id;
			return id;
		}
	}

	Shader3D.addInclude=function(fileName,txt){
		ShaderCompile.addInclude(fileName,txt);
	}

	Shader3D.registerPublicDefine=function(name){
		var value=Math.pow(2,Shader3D._publicCounter++);
		Shader3D._globleDefines[value]=name;
		return value;
	}

	Shader3D.compileShader=function(name,subShaderIndex,passIndex,publicDefine,spriteDefine,materialDefine){
		var shader=laya.d3.shader.Shader3D.find(name);
		if (shader){
			var subShader=shader.getSubShaderAt(subShaderIndex);
			if (subShader){
				var pass=subShader._passes[passIndex];
				if (pass){
					if (WebGL.shaderHighPrecision)
						pass.withCompile(publicDefine,spriteDefine,materialDefine);
					else
					pass.withCompile(publicDefine-laya.d3.shader.Shader3D.SHADERDEFINE_HIGHPRECISION,spriteDefine,materialDefine);
					}else {
					console.warn("Shader3D: unknown passIndex.");
				}
				}else {
				console.warn("Shader3D: unknown subShaderIndex.");
			}
			}else {
			console.warn("Shader3D: unknown shader name.");
		}
	}

	Shader3D.add=function(name){
		return laya.d3.shader.Shader3D._preCompileShader[name]=new Shader3D(name);
	}

	Shader3D.find=function(name){
		return laya.d3.shader.Shader3D._preCompileShader[name];
	}

	Shader3D.PERIOD_CUSTOM=0;
	Shader3D.PERIOD_MATERIAL=1;
	Shader3D.PERIOD_SPRITE=2;
	Shader3D.PERIOD_CAMERA=3;
	Shader3D.PERIOD_SCENE=4;
	Shader3D.SHADERDEFINE_HIGHPRECISION=0;
	Shader3D._propertyNameCounter=0;
	Shader3D._propertyNameMap={};
	Shader3D._publicCounter=0;
	Shader3D._globleDefines=[];
	Shader3D._preCompileShader={};
	Shader3D.debugMode=false;
	return Shader3D;
})()


/**
*<code>SingletonList</code> 类用于实现单例队列。
*/
//class laya.d3.component.SingletonList
var SingletonList=(function(){
	function SingletonList(){
		/**@private [只读]*/
		this.length=0;
		this.elements=[];
	}

	__class(SingletonList,'laya.d3.component.SingletonList');
	var __proto=SingletonList.prototype;
	/**
	*@private
	*/
	__proto._add=function(element){
		if (this.length===this.elements.length)
			this.elements.push(element);
		else
		this.elements[this.length]=element;
	}

	return SingletonList;
})()


/**
*<code>DetailTextureInfo</code> 类用于描述地形细节纹理。
*/
//class laya.d3.terrain.unit.ChunkInfo
var ChunkInfo=(function(){
	function ChunkInfo(){
		this.alphaMap=null;
		this.detailID=null;
		this.normalMap=null;
		;
	}

	__class(ChunkInfo,'laya.d3.terrain.unit.ChunkInfo');
	return ChunkInfo;
})()


/**
*<code>GradientColor</code> 类用于创建渐变颜色。
*/
//class laya.d3.core.particleShuriKen.module.GradientColor
var GradientColor=(function(){
	function GradientColor(){
		/**@private */
		this._type=0;
		/**@private */
		this._constant=null;
		/**@private */
		this._constantMin=null;
		/**@private */
		this._constantMax=null;
		/**@private */
		this._gradient=null;
		/**@private */
		this._gradientMin=null;
		/**@private */
		this._gradientMax=null;
	}

	__class(GradientColor,'laya.d3.core.particleShuriKen.module.GradientColor');
	var __proto=GradientColor.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientColor=destObject;
		destGradientColor._type=this._type;
		this._constant.cloneTo(destGradientColor._constant);
		this._constantMin.cloneTo(destGradientColor._constantMin);
		this._constantMax.cloneTo(destGradientColor._constantMax);
		this._gradient.cloneTo(destGradientColor._gradient);
		this._gradientMin.cloneTo(destGradientColor._gradientMin);
		this._gradientMax.cloneTo(destGradientColor._gradientMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientColor=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientColor);
		return destGradientColor;
	}

	/**
	*渐变颜色。
	*/
	__getset(0,__proto,'gradient',function(){
		return this._gradient;
	});

	/**
	*固定颜色。
	*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*生命周期颜色类型,0为固定颜色模式,1渐变模式,2为随机双固定颜色模式,3随机双渐变模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*最小渐变颜色。
	*/
	__getset(0,__proto,'gradientMin',function(){
		return this._gradientMin;
	});

	/**
	*最小固定颜色。
	*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*最大渐变颜色。
	*/
	__getset(0,__proto,'gradientMax',function(){
		return this._gradientMax;
	});

	/**
	*最大固定颜色。
	*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	GradientColor.createByConstant=function(constant){
		var gradientColor=new GradientColor();
		gradientColor._type=0;
		gradientColor._constant=constant;
		return gradientColor;
	}

	GradientColor.createByGradient=function(gradient){
		var gradientColor=new GradientColor();
		gradientColor._type=1;
		gradientColor._gradient=gradient;
		return gradientColor;
	}

	GradientColor.createByRandomTwoConstant=function(minConstant,maxConstant){
		var gradientColor=new GradientColor();
		gradientColor._type=2;
		gradientColor._constantMin=minConstant;
		gradientColor._constantMax=maxConstant;
		return gradientColor;
	}

	GradientColor.createByRandomTwoGradient=function(minGradient,maxGradient){
		var gradientColor=new GradientColor();
		gradientColor._type=3;
		gradientColor._gradientMin=minGradient;
		gradientColor._gradientMax=maxGradient;
		return gradientColor;
	}

	return GradientColor;
})()


/**
*<code>Simulation</code> 类用于创建物理模拟器。
*/
//class laya.d3.physics.PhysicsSimulation
var PhysicsSimulation=(function(){
	function PhysicsSimulation(configuration,flags){
		/**@private */
		this._nativeDiscreteDynamicsWorld=null;
		/**@private */
		this._nativeCollisionWorld=null;
		/**@private */
		this._nativeDispatcher=null;
		/**@private */
		this._nativeCollisionConfiguration=null;
		/**@private */
		this._nativeBroadphase=null;
		/**@private */
		this._nativeSolverInfo=null;
		/**@private */
		this._nativeDispatchInfo=null;
		/**@private */
		this._nativeClosestRayResultCallback=null;
		/**@private */
		this._nativeAllHitsRayResultCallback=null;
		/**@private */
		this._nativeClosestConvexResultCallback=null;
		/**@private */
		this._nativeAllConvexResultCallback=null;
		/**@private */
		this._updatedRigidbodies=0;
		/**物理引擎在一帧中用于补偿减速的最大次数：模拟器每帧允许的最大模拟次数，如果引擎运行缓慢,可能需要增加该次数，否则模拟器会丢失“时间",引擎间隔时间小于maxSubSteps*fixedTimeStep非常重要。*/
		this.maxSubSteps=1;
		/**物理模拟器帧的间隔时间:通过减少fixedTimeStep可增加模拟精度，默认是1.0 / 60.0。*/
		this.fixedTimeStep=1.0 / 60.0;
		this._gravity=new Vector3(0,-10,0);
		this._nativeVector3Zero=new Laya3D._physics3D.btVector3(0,0,0);
		this._nativeDefaultQuaternion=new Laya3D._physics3D.btQuaternion(0,0,0,-1);
		this._collisionsUtils=new CollisionTool();
		this._previousFrameCollisions=[];
		this._currentFrameCollisions=[];
		this._physicsUpdateList=new PhysicsUpdateList();
		this._characters=[];
		(flags===void 0)&& (flags=0);
		this.maxSubSteps=configuration.maxSubSteps;
		this.fixedTimeStep=configuration.fixedTimeStep;
		var physics3D=Laya3D._physics3D;
		this._nativeCollisionConfiguration=new physics3D.btDefaultCollisionConfiguration();
		this._nativeDispatcher=new physics3D.btCollisionDispatcher(this._nativeCollisionConfiguration);
		this._nativeBroadphase=new physics3D.btDbvtBroadphase();
		this._nativeBroadphase.getOverlappingPairCache().setInternalGhostPairCallback(new physics3D.btGhostPairCallback());
		var conFlags=configuration.flags;
		if (conFlags & 0x1){
			this._nativeCollisionWorld=new physics3D.btCollisionWorld(this._nativeDispatcher,this._nativeBroadphase,this._nativeCollisionConfiguration);
			}else if (conFlags & 0x2){
			throw "PhysicsSimulation:SoftBody processing is not yet available";
			}else {
			var solver=new physics3D.btSequentialImpulseConstraintSolver();
			this._nativeDiscreteDynamicsWorld=new physics3D.btDiscreteDynamicsWorld(this._nativeDispatcher,this._nativeBroadphase,solver,this._nativeCollisionConfiguration);
			this._nativeCollisionWorld=this._nativeDiscreteDynamicsWorld;
		}
		if (this._nativeDiscreteDynamicsWorld){
			this._nativeSolverInfo=this._nativeDiscreteDynamicsWorld.getSolverInfo();
			this._nativeDispatchInfo=this._nativeDiscreteDynamicsWorld.getDispatchInfo();
		}
		this._nativeClosestRayResultCallback=new physics3D.ClosestRayResultCallback(this._nativeVector3Zero,this._nativeVector3Zero);
		this._nativeAllHitsRayResultCallback=new physics3D.AllHitsRayResultCallback(this._nativeVector3Zero,this._nativeVector3Zero);
		this._nativeClosestConvexResultCallback=new physics3D.ClosestConvexResultCallback(this._nativeVector3Zero,this._nativeVector3Zero);
		this._nativeAllConvexResultCallback=new physics3D.AllConvexResultCallback(this._nativeVector3Zero,this._nativeVector3Zero);
		physics3D._btGImpactCollisionAlgorithm_RegisterAlgorithm(this._nativeDispatcher.a);
	}

	__class(PhysicsSimulation,'laya.d3.physics.PhysicsSimulation');
	var __proto=PhysicsSimulation.prototype;
	/**
	*@private
	*/
	__proto._simulate=function(deltaTime){
		this._updatedRigidbodies=0;
		if (this._nativeDiscreteDynamicsWorld)
			this._nativeDiscreteDynamicsWorld.stepSimulation(deltaTime,this.maxSubSteps,this.fixedTimeStep);
		else
		this._nativeCollisionWorld.PerformDiscreteCollisionDetection();
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		var physics3D=Laya3D._physics3D;
		if (this._nativeDiscreteDynamicsWorld){
			physics3D.destroy(this._nativeDiscreteDynamicsWorld);
			this._nativeDiscreteDynamicsWorld=null;
			}else {
			physics3D.destroy(this._nativeCollisionWorld);
			this._nativeCollisionWorld=null;
		}
		physics3D.destroy(this._nativeBroadphase);
		this._nativeBroadphase=null;
		physics3D.destroy(this._nativeDispatcher);
		this._nativeDispatcher=null;
		physics3D.destroy(this._nativeCollisionConfiguration);
		this._nativeCollisionConfiguration=null;
	}

	/**
	*@private
	*/
	__proto._addPhysicsCollider=function(component,group,mask){
		this._nativeCollisionWorld.addCollisionObject(component._nativeColliderObject,group,mask);
	}

	/**
	*@private
	*/
	__proto._removePhysicsCollider=function(component){
		this._nativeCollisionWorld.removeCollisionObject(component._nativeColliderObject);
	}

	/**
	*@private
	*/
	__proto._addRigidBody=function(rigidBody,group,mask){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._nativeCollisionWorld.addRigidBody(rigidBody._nativeColliderObject,group,mask);
	}

	/**
	*@private
	*/
	__proto._removeRigidBody=function(rigidBody){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._nativeCollisionWorld.removeRigidBody(rigidBody._nativeColliderObject);
	}

	/**
	*@private
	*/
	__proto._addCharacter=function(character,group,mask){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._nativeCollisionWorld.addCollisionObject(character._nativeColliderObject,group,mask);
		this._nativeCollisionWorld.addAction(character._nativeKinematicCharacter);
	}

	/**
	*@private
	*/
	__proto._removeCharacter=function(character){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._nativeCollisionWorld.removeCollisionObject(character._nativeColliderObject);
		this._nativeCollisionWorld.removeAction(character._nativeKinematicCharacter);
	}

	/**
	*射线检测第一个碰撞物体。
	*@param from 起始位置。
	*@param to 结束位置。
	*@param out 碰撞结果。
	*@param collisonGroup 射线所属碰撞组。
	*@param collisionMask 与射线可产生碰撞的组。
	*@return 是否成功。
	*/
	__proto.raycastFromTo=function(from,to,out,collisonGroup,collisionMask){
		(collisonGroup===void 0)&& (collisonGroup=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		(collisionMask===void 0)&& (collisionMask=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		var rayResultCall=this._nativeClosestRayResultCallback;
		var rayFrom=PhysicsSimulation._nativeTempVector30;
		var rayTo=PhysicsSimulation._nativeTempVector31;
		var fromE=from.elements;
		var toE=to.elements;
		rayFrom.setValue(-fromE[0],fromE[1],fromE[2]);
		rayTo.setValue(-toE[0],toE[1],toE[2]);
		rayResultCall.set_m_rayFromWorld(rayFrom);
		rayResultCall.set_m_rayToWorld(rayTo);
		rayResultCall.set_m_collisionFilterGroup(collisonGroup);
		rayResultCall.set_m_collisionFilterMask(collisionMask);
		rayResultCall.set_m_collisionObject(null);
		rayResultCall.set_m_closestHitFraction(1);
		this._nativeCollisionWorld.rayTest(rayFrom,rayTo,rayResultCall);
		if (rayResultCall.hasHit()){
			if (out){
				out.succeeded=true;
				out.collider=PhysicsComponent._physicObjectsMap[rayResultCall.get_m_collisionObject().getUserIndex()];
				out.hitFraction=rayResultCall.get_m_closestHitFraction();
				var nativePoint=rayResultCall.get_m_hitPointWorld();
				var pointE=out.point.elements;
				pointE[0]=-nativePoint.x();
				pointE[1]=nativePoint.y();
				pointE[2]=nativePoint.z();
				var nativeNormal=rayResultCall.get_m_hitNormalWorld();
				var normalE=out.normal.elements;
				normalE[0]=-nativeNormal.x();
				normalE[1]=nativeNormal.y();
				normalE[2]=nativeNormal.z();
			}
			return true;
			}else {
			if (out)
				out.succeeded=false;
			return false;
		}
	}

	/**
	*射线检测所有碰撞的物体。
	*@param from 起始位置。
	*@param to 结束位置。
	*@param out 碰撞结果[数组元素会被回收]。
	*@param collisonGroup 射线所属碰撞组。
	*@param collisionMask 与射线可产生碰撞的组。
	*@return 是否成功。
	*/
	__proto.raycastAllFromTo=function(from,to,out,collisonGroup,collisionMask){
		(collisonGroup===void 0)&& (collisonGroup=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		(collisionMask===void 0)&& (collisionMask=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		var rayResultCall=this._nativeAllHitsRayResultCallback;
		var rayFrom=PhysicsSimulation._nativeTempVector30;
		var rayTo=PhysicsSimulation._nativeTempVector31;
		out.length=0;
		var fromE=from.elements;
		var toE=to.elements;
		rayFrom.setValue(-fromE[0],fromE[1],fromE[2]);
		rayTo.setValue(-toE[0],toE[1],toE[2]);
		rayResultCall.set_m_rayFromWorld(rayFrom);
		rayResultCall.set_m_rayToWorld(rayTo);
		rayResultCall.set_m_collisionFilterGroup(collisonGroup);
		rayResultCall.set_m_collisionFilterMask(collisionMask);
		var collisionObjects=rayResultCall.get_m_collisionObjects();
		var nativePoints=rayResultCall.get_m_hitPointWorld();
		var nativeNormals=rayResultCall.get_m_hitNormalWorld();
		var nativeFractions=rayResultCall.get_m_hitFractions();
		collisionObjects.clear();
		nativePoints.clear();
		nativeNormals.clear();
		nativeFractions.clear();
		this._nativeCollisionWorld.rayTest(rayFrom,rayTo,rayResultCall);
		var count=collisionObjects.size();
		if (count > 0){
			this._collisionsUtils.recoverAllHitResultsPool();
			for (var i=0;i < count;i++){
				var hitResult=this._collisionsUtils.getHitResult();
				out.push(hitResult);
				hitResult.succeeded=true;
				hitResult.collider=PhysicsComponent._physicObjectsMap[collisionObjects.at(i).getUserIndex()];
				hitResult.hitFraction=nativeFractions.at(i);
				var nativePoint=nativePoints.at(i);
				var pointE=hitResult.point.elements;
				pointE[0]=-nativePoint.x();
				pointE[1]=nativePoint.y();
				pointE[2]=nativePoint.z();
				var nativeNormal=nativeNormals.at(i);
				var normalE=hitResult.normal.elements;
				normalE[0]=-nativeNormal.x();
				normalE[1]=nativeNormal.y();
				normalE[2]=nativeNormal.z();
			}
			return true;
			}else {
			return false;
		}
	}

	/**
	*射线检测第一个碰撞物体。
	*@param ray 射线
	*@param outHitInfo 与该射线发生碰撞的第一个碰撞器的碰撞信息
	*@param distance 射线长度,默认为最大值
	*@param collisonGroup 射线所属碰撞组。
	*@param collisionMask 与射线可产生碰撞的组。
	*@return 是否检测成功。
	*/
	__proto.rayCast=function(ray,outHitResult,distance,collisonGroup,collisionMask){
		(distance===void 0)&& (distance=2147483647);
		(collisonGroup===void 0)&& (collisonGroup=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		(collisionMask===void 0)&& (collisionMask=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		var from=ray.origin;
		var to=PhysicsSimulation._tempVector30;
		Vector3.normalize(ray.direction,to);
		Vector3.scale(to,distance,to);
		Vector3.add(from,to,to);
		return this.raycastFromTo(from,to,outHitResult,collisonGroup,collisionMask);
	}

	/**
	*射线检测所有碰撞的物体。
	*@param ray 射线
	*@param out 碰撞结果[数组元素会被回收]。
	*@param distance 射线长度,默认为最大值
	*@param collisonGroup 射线所属碰撞组。
	*@param collisionMask 与射线可产生碰撞的组。
	*@return 是否检测成功。
	*/
	__proto.rayCastAll=function(ray,out,distance,collisonGroup,collisionMask){
		(distance===void 0)&& (distance=2147483647);
		(collisonGroup===void 0)&& (collisonGroup=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		(collisionMask===void 0)&& (collisionMask=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		var from=ray.origin;
		var to=PhysicsSimulation._tempVector30;
		Vector3.normalize(ray.direction,to);
		Vector3.scale(to,distance,to);
		Vector3.add(from,to,to);
		return this.raycastAllFromTo(from,to,out,collisonGroup,collisionMask);
	}

	/**
	*形状检测第一个碰撞的物体。
	*@param shape 形状。
	*@param fromPosition 世界空间起始位置。
	*@param toPosition 世界空间结束位置。
	*@param out 碰撞结果。
	*@param fromRotation 起始旋转。
	*@param toRotation 结束旋转。
	*@param collisonGroup 射线所属碰撞组。
	*@param collisionMask 与射线可产生碰撞的组。
	*@return 是否成功。
	*/
	__proto.shapeCast=function(shape,fromPosition,toPosition,out,fromRotation,toRotation,collisonGroup,collisionMask,allowedCcdPenetration){
		(collisonGroup===void 0)&& (collisonGroup=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		(collisionMask===void 0)&& (collisionMask=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		(allowedCcdPenetration===void 0)&& (allowedCcdPenetration=0.0);
		var convexResultCall=this._nativeClosestConvexResultCallback;
		var convexPosFrom=PhysicsSimulation._nativeTempVector30;
		var convexPosTo=PhysicsSimulation._nativeTempVector31;
		var convexRotFrom=PhysicsSimulation._nativeTempVector30;
		var convexRotTo=PhysicsSimulation._nativeTempVector31;
		var convexTransform=PhysicsSimulation._nativeTempTransform0;
		var convexTransTo=PhysicsSimulation._nativeTempTransform1;
		var sweepShape=shape._nativeShape;
		var fromPositionE=fromPosition.elements;
		var toPositionE=toPosition.elements;
		convexPosFrom.setValue(-fromPositionE[0],fromPositionE[1],fromPositionE[2]);
		convexPosTo.setValue(-toPositionE[0],toPositionE[1],toPositionE[2]);
		convexResultCall.set_m_collisionFilterGroup(collisonGroup);
		convexResultCall.set_m_collisionFilterMask(collisionMask);
		convexTransform.setOrigin(convexPosFrom);
		convexTransTo.setOrigin(convexPosTo);
		if (fromRotation){
			var fromRotationE=fromRotation.elements;
			convexRotFrom.setValue(-fromRotationE[0],fromRotationE[1],fromRotationE[2],-fromRotationE[3]);
			convexTransform.setRotation(convexRotFrom);
			}else {
			convexTransform.setRotation(this._nativeDefaultQuaternion);
		}
		if (toRotation){
			var toRotationE=toRotation.elements;
			convexRotTo.setValue(-toRotationE[0],toRotationE[1],toRotationE[2],-toRotationE[2]);
			convexTransTo.setRotation(convexRotTo);
			}else {
			convexTransTo.setRotation(this._nativeDefaultQuaternion);
		}
		convexResultCall.set_m_hitCollisionObject(null);
		convexResultCall.set_m_closestHitFraction(1);
		this._nativeCollisionWorld.convexSweepTest(sweepShape,convexTransform,convexTransTo,convexResultCall,allowedCcdPenetration);
		if (convexResultCall.hasHit()){
			if (out){
				out.succeeded=true;
				out.collider=PhysicsComponent._physicObjectsMap[convexResultCall.get_m_hitCollisionObject().getUserIndex()];
				out.hitFraction=convexResultCall.get_m_closestHitFraction();
				var nativePoint=convexResultCall.get_m_hitPointWorld();
				var nativeNormal=convexResultCall.get_m_hitNormalWorld();
				var pointE=out.point.elements;
				var normalE=out.normal.elements;
				pointE[0]=-nativePoint.x();
				pointE[1]=nativePoint.y();
				pointE[2]=nativePoint.z();
				normalE[0]=-nativeNormal.x();
				normalE[1]=nativeNormal.y();
				normalE[2]=nativeNormal.z();
			}
			return true;
			}else {
			if (out)
				out.succeeded=false;
			return false;
		}
	}

	/**
	*形状检测所有碰撞的物体。
	*@param shape 形状。
	*@param fromPosition 世界空间起始位置。
	*@param toPosition 世界空间结束位置。
	*@param out 碰撞结果[数组元素会被回收]。
	*@param fromRotation 起始旋转。
	*@param toRotation 结束旋转。
	*@param collisonGroup 射线所属碰撞组。
	*@param collisionMask 与射线可产生碰撞的组。
	*@return 是否成功。
	*/
	__proto.shapeCastAll=function(shape,fromPosition,toPosition,out,fromRotation,toRotation,collisonGroup,collisionMask,allowedCcdPenetration){
		(collisonGroup===void 0)&& (collisonGroup=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		(collisionMask===void 0)&& (collisionMask=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		(allowedCcdPenetration===void 0)&& (allowedCcdPenetration=0.0);
		var convexResultCall=this._nativeAllConvexResultCallback;
		var convexPosFrom=PhysicsSimulation._nativeTempVector30;
		var convexPosTo=PhysicsSimulation._nativeTempVector31;
		var convexRotFrom=PhysicsSimulation._nativeTempVector30;
		var convexRotTo=PhysicsSimulation._nativeTempVector31;
		var convexTransform=PhysicsSimulation._nativeTempTransform0;
		var convexTransTo=PhysicsSimulation._nativeTempTransform1;
		var sweepShape=shape._nativeShape;
		out.length=0;
		var fromPositionE=fromPosition.elements;
		var toPositionE=toPosition.elements;
		convexPosFrom.setValue(-fromPositionE[0],fromPositionE[1],fromPositionE[2]);
		convexPosTo.setValue(-toPositionE[0],toPositionE[1],toPositionE[2]);
		convexResultCall.set_m_collisionFilterGroup(collisonGroup);
		convexResultCall.set_m_collisionFilterMask(collisionMask);
		convexTransform.setOrigin(convexPosFrom);
		convexTransTo.setOrigin(convexPosTo);
		if (fromRotation){
			var fromRotationE=fromRotation.elements;
			convexRotFrom.setValue(-fromRotationE[0],fromRotationE[1],fromRotationE[2],-fromRotationE[3]);
			convexTransform.setRotation(convexRotFrom);
			}else {
			convexTransform.setRotation(this._nativeDefaultQuaternion);
		}
		if (toRotation){
			var toRotationE=toRotation.elements;
			convexRotTo.setValue(-toRotationE[0],toRotationE[1],toRotationE[2],-toRotationE[2]);
			convexTransTo.setRotation(convexRotTo);
			}else {
			convexTransTo.setRotation(this._nativeDefaultQuaternion);
		};
		var collisionObjects=convexResultCall.get_m_collisionObjects();
		collisionObjects.clear();
		this._nativeCollisionWorld.convexSweepTest(sweepShape,convexTransform,convexTransTo,convexResultCall,allowedCcdPenetration);
		var count=collisionObjects.size();
		if (count > 0){
			var nativePoints=convexResultCall.get_m_hitPointWorld();
			var nativeNormals=convexResultCall.get_m_hitNormalWorld();
			var nativeFractions=convexResultCall.get_m_hitFractions();
			for (var i=0;i < count;i++){
				var hitResult=this._collisionsUtils.getHitResult();
				out.push(hitResult);
				hitResult.succeeded=true;
				hitResult.collider=PhysicsComponent._physicObjectsMap[collisionObjects.at(i).getUserIndex()];
				hitResult.hitFraction=nativeFractions.at(i);
				var nativePoint=nativePoints.at(i);
				var pointE=hitResult.point.elements;
				pointE[0]=-nativePoint.x();
				pointE[1]=nativePoint.y();
				pointE[2]=nativePoint.z();
				var nativeNormal=nativeNormals.at(i);
				var normalE=hitResult.normal.elements;
				normalE[0]=-nativeNormal.x();
				normalE[1]=nativeNormal.y();
				normalE[2]=nativeNormal.z();
			}
			return true;
			}else {
			return false;
		}
	}

	/**
	*添加刚体运动的约束条件。
	*@param constraint 约束。
	*@param disableCollisionsBetweenLinkedBodies 是否禁用
	*/
	__proto.addConstraint=function(constraint,disableCollisionsBetweenLinkedBodies){
		(disableCollisionsBetweenLinkedBodies===void 0)&& (disableCollisionsBetweenLinkedBodies=false);
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._nativeDiscreteDynamicsWorld.addConstraint(constraint._nativeConstraint,disableCollisionsBetweenLinkedBodies);
		constraint._simulation=this;
	}

	/**
	*移除刚体运动的约束条件。
	*/
	__proto.removeConstraint=function(constraint){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._nativeDiscreteDynamicsWorld.removeConstraint(constraint._nativeConstraint);
	}

	/**
	*@private
	*/
	__proto._updatePhysicsTransformFromRender=function(){
		var elements=this._physicsUpdateList.elements;
		for (var i=0,n=this._physicsUpdateList.length;i < n;i++){
			var physicCollider=elements[i];
			physicCollider._derivePhysicsTransformation(false);
			physicCollider._inPhysicUpdateListIndex=-1;
		}
		this._physicsUpdateList.length=0;
	}

	/**
	*@private
	*/
	__proto._updateCharacters=function(){
		for (var i=0,n=this._characters.length;i < n;i++){
			var character=this._characters[i];
			character._updateTransformComponent(character._nativeColliderObject.getWorldTransform());
		}
	}

	/**
	*@private
	*/
	__proto._updateCollisions=function(){
		this._collisionsUtils.recoverAllContactPointsPool();
		var previous=this._currentFrameCollisions;
		this._currentFrameCollisions=this._previousFrameCollisions;
		this._currentFrameCollisions.length=0;
		this._previousFrameCollisions=previous;
		var loopCount=Stat.loopCount;
		var numManifolds=this._nativeDispatcher.getNumManifolds();
		for (var i=0;i < numManifolds;i++){
			var contactManifold=this._nativeDispatcher.getManifoldByIndexInternal(i);
			var componentA=PhysicsComponent._physicObjectsMap[contactManifold.getBody0().getUserIndex()];
			var componentB=PhysicsComponent._physicObjectsMap[contactManifold.getBody1().getUserIndex()];
			var collision=null;
			var isFirstCollision=false;
			var contacts=null;
			var isTrigger=componentA.isTrigger || componentB.isTrigger;
			if (isTrigger && ((componentA.owner)._needProcessTriggers || (componentB.owner)._needProcessTriggers)){
				var numContacts=contactManifold.getNumContacts();
				for (var j=0;j < numContacts;j++){
					var pt=contactManifold.getContactPoint(j);
					var distance=pt.getDistance();
					if (distance <=0){
						collision=this._collisionsUtils.getCollision(componentA,componentB);
						contacts=collision.contacts;
						isFirstCollision=collision._updateFrame!==loopCount;
						if (isFirstCollision){
							collision._isTrigger=true;
							contacts.length=0;
						}
						break ;
					}
				}
				}else if ((componentA.owner)._needProcessCollisions || (componentB.owner)._needProcessCollisions){
				if (componentA._enableProcessCollisions || componentB._enableProcessCollisions){
					numContacts=contactManifold.getNumContacts();
					for (j=0;j < numContacts;j++){
						pt=contactManifold.getContactPoint(j);
						distance=pt.getDistance();
						if (distance <=0){
							var contactPoint=this._collisionsUtils.getContactPoints();
							contactPoint.colliderA=componentA;
							contactPoint.colliderB=componentB;
							contactPoint.distance=distance;
							var nativeNormal=pt.get_m_normalWorldOnB();
							var normalE=contactPoint.normal.elements;
							normalE[0]=-nativeNormal.x();
							normalE[1]=nativeNormal.y();
							normalE[2]=nativeNormal.z();
							var nativePostionA=pt.get_m_positionWorldOnA();
							var positionOnAE=contactPoint.positionOnA.elements;
							positionOnAE[0]=-nativePostionA.x();
							positionOnAE[1]=nativePostionA.y();
							positionOnAE[2]=nativePostionA.z();
							var nativePostionB=pt.get_m_positionWorldOnB();
							var positionOnBE=contactPoint.positionOnB.elements;
							positionOnBE[0]=-nativePostionB.x();
							positionOnBE[1]=nativePostionB.y();
							positionOnBE[2]=nativePostionB.z();
							if (!collision){
								collision=this._collisionsUtils.getCollision(componentA,componentB);
								contacts=collision.contacts;
								isFirstCollision=collision._updateFrame!==loopCount;
								if (isFirstCollision){
									collision._isTrigger=false;
									contacts.length=0;
								}
							}
							contacts.push(contactPoint);
						}
					}
				}
			}
			if (collision && isFirstCollision){
				this._currentFrameCollisions.push(collision);
				collision._setUpdateFrame(loopCount);
			}
		}
	}

	/**
	*@private
	*/
	__proto._eventScripts=function(){
		var loopCount=Stat.loopCount;
		for (var i=0,n=this._currentFrameCollisions.length;i < n;i++){
			var curFrameCol=this._currentFrameCollisions[i];
			var colliderA=curFrameCol._colliderA;
			var colliderB=curFrameCol._colliderB;
			if (colliderA.destroyed || colliderB.destroyed)
				continue ;
			if (loopCount-curFrameCol._lastUpdateFrame===1){
				var ownerA=colliderA.owner;
				var scriptsA=ownerA._scripts;
				if (scriptsA){
					if (curFrameCol._isTrigger){
						if (ownerA._needProcessTriggers){
							for (var j=0,m=scriptsA.length;j < m;j++)
							scriptsA[j].onTriggerStay(colliderB);
						}
						}else {
						if (ownerA._needProcessCollisions){
							for (j=0,m=scriptsA.length;j < m;j++){
								curFrameCol.other=colliderB;
								scriptsA[j].onCollisionStay(curFrameCol);
							}
						}
					}
				};
				var ownerB=colliderB.owner;
				var scriptsB=ownerB._scripts;
				if (scriptsB){
					if (curFrameCol._isTrigger){
						if (ownerB._needProcessTriggers){
							for (j=0,m=scriptsB.length;j < m;j++)
							scriptsB[j].onTriggerStay(colliderA);
						}
						}else {
						if (ownerB._needProcessCollisions){
							for (j=0,m=scriptsB.length;j < m;j++){
								curFrameCol.other=colliderA;
								scriptsB[j].onCollisionStay(curFrameCol);
							}
						}
					}
				}
				}else {
				ownerA=colliderA.owner;
				scriptsA=ownerA._scripts;
				if (scriptsA){
					if (curFrameCol._isTrigger){
						if (ownerA._needProcessTriggers){
							for (j=0,m=scriptsA.length;j < m;j++)
							scriptsA[j].onTriggerEnter(colliderB);
						}
						}else {
						if (ownerA._needProcessCollisions){
							for (j=0,m=scriptsA.length;j < m;j++){
								curFrameCol.other=colliderB;
								scriptsA[j].onCollisionEnter(curFrameCol);
							}
						}
					}
				}
				ownerB=colliderB.owner;
				scriptsB=ownerB._scripts;
				if (scriptsB){
					if (curFrameCol._isTrigger){
						if (ownerB._needProcessTriggers){
							for (j=0,m=scriptsB.length;j < m;j++)
							scriptsB[j].onTriggerEnter(colliderA);
						}
						}else {
						if (ownerB._needProcessCollisions){
							for (j=0,m=scriptsB.length;j < m;j++){
								curFrameCol.other=colliderA;
								scriptsB[j].onCollisionEnter(curFrameCol);
							}
						}
					}
				}
			}
		}
		for (i=0,n=this._previousFrameCollisions.length;i < n;i++){
			var preFrameCol=this._previousFrameCollisions[i];
			var preColliderA=preFrameCol._colliderA;
			var preColliderB=preFrameCol._colliderB;
			if (preColliderA.destroyed || preColliderB.destroyed)
				continue ;
			if (loopCount-preFrameCol._updateFrame===1){
				this._collisionsUtils.recoverCollision(preFrameCol);
				ownerA=preColliderA.owner;
				scriptsA=ownerA._scripts;
				if (scriptsA){
					if (preFrameCol._isTrigger){
						if (ownerA._needProcessTriggers){
							for (j=0,m=scriptsA.length;j < m;j++)
							scriptsA[j].onTriggerExit(preColliderB);
						}
						}else {
						if (ownerA._needProcessCollisions){
							for (j=0,m=scriptsA.length;j < m;j++){
								preFrameCol.other=preColliderB;
								scriptsA[j].onCollisionExit(preFrameCol);
							}
						}
					}
				}
				ownerB=preColliderB.owner;
				scriptsB=ownerB._scripts;
				if (scriptsB){
					if (preFrameCol._isTrigger){
						if (ownerB._needProcessTriggers){
							for (j=0,m=scriptsB.length;j < m;j++)
							scriptsB[j].onTriggerExit(preColliderA);
						}
						}else {
						if (ownerB._needProcessCollisions){
							for (j=0,m=scriptsB.length;j < m;j++){
								preFrameCol.other=preColliderA;
								scriptsB[j].onCollisionExit(preFrameCol);
							}
						}
					}
				}
			}
		}
	}

	/**
	*清除力。
	*/
	__proto.clearForces=function(){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._nativeDiscreteDynamicsWorld.clearForces();
	}

	/**
	*设置重力。
	*/
	/**
	*获取重力。
	*/
	__getset(0,__proto,'gravity',function(){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
		return this._gravity;
		},function(value){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._gravity=value;
		var gravityE=value.elements;
		var nativeGravity=PhysicsSimulation._nativeTempVector30;
		nativeGravity.setValue(-gravityE[0],gravityE[1],gravityE[2]);
		this._nativeDiscreteDynamicsWorld.setGravity(nativeGravity);
	});

	/**
	*设置是否进行连续碰撞检测。
	*@param value 是否进行连续碰撞检测。
	*/
	/**
	*获取是否进行连续碰撞检测。
	*@return 是否进行连续碰撞检测。
	*/
	__getset(0,__proto,'continuousCollisionDetection',function(){
		return this._nativeDispatchInfo.get_m_useContinuous();
		},function(value){
		this._nativeDispatchInfo.set_m_useContinuous(value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'speculativeContactRestitution',function(){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
		return this._nativeDiscreteDynamicsWorld.getApplySpeculativeContactRestitution();
		},function(value){
		if (!this._nativeDiscreteDynamicsWorld)
			throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
		this._nativeDiscreteDynamicsWorld.setApplySpeculativeContactRestitution(value);
	});

	PhysicsSimulation.createConstraint=function(){}
	PhysicsSimulation.PHYSICSENGINEFLAGS_NONE=0x0;
	PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY=0x1;
	PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT=0x2;
	PhysicsSimulation.PHYSICSENGINEFLAGS_MULTITHREADED=0x4;
	PhysicsSimulation.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE=0x8;
	PhysicsSimulation.SOLVERMODE_RANDMIZE_ORDER=1;
	PhysicsSimulation.SOLVERMODE_FRICTION_SEPARATE=2;
	PhysicsSimulation.SOLVERMODE_USE_WARMSTARTING=4;
	PhysicsSimulation.SOLVERMODE_USE_2_FRICTION_DIRECTIONS=16;
	PhysicsSimulation.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING=32;
	PhysicsSimulation.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION=64;
	PhysicsSimulation.SOLVERMODE_CACHE_FRIENDLY=128;
	PhysicsSimulation.SOLVERMODE_SIMD=256;
	PhysicsSimulation.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS=512;
	PhysicsSimulation.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS=1024;
	PhysicsSimulation.disableSimulation=false;
	__static(PhysicsSimulation,
	['_nativeTempVector30',function(){return this._nativeTempVector30=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeTempVector31',function(){return this._nativeTempVector31=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeTempQuaternion0',function(){return this._nativeTempQuaternion0=new Laya3D._physics3D.btQuaternion(0,0,0,1);},'_nativeTempQuaternion1',function(){return this._nativeTempQuaternion1=new Laya3D._physics3D.btQuaternion(0,0,0,1);},'_nativeTempTransform0',function(){return this._nativeTempTransform0=new Laya3D._physics3D.btTransform();},'_nativeTempTransform1',function(){return this._nativeTempTransform1=new Laya3D._physics3D.btTransform();},'_tempVector30',function(){return this._tempVector30=new Vector3();}
	]);
	return PhysicsSimulation;
})()


/**
*...
*@author ...
*/
//class laya.d3.shadowMap.ParallelSplitShadowMap
var ParallelSplitShadowMap=(function(){
	function ParallelSplitShadowMap(){
		/**@private */
		//this.lastNearPlane=NaN;
		/**@private */
		//this.lastFieldOfView=NaN;
		/**@private */
		//this.lastAspectRatio=NaN;
		/**@private */
		this._currentPSSM=-1;
		/**@private */
		this._shadowMapCount=3;
		/**@private */
		this._maxDistance=200.0;
		/**@private */
		this._ratioOfDistance=1.0 / this._shadowMapCount;
		/**@private */
		this._statesDirty=true;
		/**@private */
		//this.cameras=null;
		/**@private */
		this._shadowMapTextureSize=1024;
		/**@private */
		this._scene=null;
		/**@private */
		this._PCFType=0;
		/**@private */
		this._shaderValueLightVP=null;
		/**@private */
		//this._shaderValueVPs=null;
		this._spiltDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._globalParallelLightDir=new Vector3(0,-1,0);
		this._boundingSphere=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._boundingBox=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._frustumPos=new Array((/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1)*4);
		this._uniformDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._logDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._dimension=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
		this._tempLookAt3=new Vector3();
		this._tempLookAt4=new Vector4();
		this._tempValue=new Vector4();
		this._tempPos=new Vector3();
		this._tempLightUp=new Vector3();
		this._tempMin=new Vector4();
		this._tempMax=new Vector4();
		this._tempMatrix44=new Matrix4x4;
		this._splitFrustumCulling=new BoundFrustum(Matrix4x4.DEFAULT);
		this._tempScaleMatrix44=new Matrix4x4();
		this._shadowPCFOffset=new Vector2(1.0 / 1024.0,1.0 / 1024.0);
		this._shaderValueDistance=new Vector4();
		this.cameras=[];
		this._shaderValueVPs=[];
		var i=0;
		for (i=0;i < this._spiltDistance.length;i++){
			this._spiltDistance[i]=0.0;
		}
		for (i=0;i < this._dimension.length;i++){
			this._dimension[i]=new Vector2();
		}
		for (i=0;i < this._frustumPos.length;i++){
			this._frustumPos[i]=new Vector3();
		}
		for (i=0;i < this._boundingBox.length;i++){
			this._boundingBox[i]=new BoundBox(new Vector3(),new Vector3());
		}
		for (i=0;i < this._boundingSphere.length;i++){
			this._boundingSphere[i]=new BoundSphere(new Vector3(),0.0);
		}
		Matrix4x4.createScaling(new Vector3(0.5,0.5,1.0),this._tempScaleMatrix44);
		this._tempScaleMatrix44.elements[12]=0.5;
		this._tempScaleMatrix44.elements[13]=0.5;
	}

	__class(ParallelSplitShadowMap,'laya.d3.shadowMap.ParallelSplitShadowMap');
	var __proto=ParallelSplitShadowMap.prototype;
	__proto.setInfo=function(scene,maxDistance,globalParallelDir,shadowMapTextureSize,numberOfPSSM,PCFType){
		if (numberOfPSSM > /*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3){
			this._shadowMapCount=/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3;
		}
		this._scene=scene;
		this._maxDistance=maxDistance;
		this.shadowMapCount=numberOfPSSM;
		this._globalParallelLightDir=globalParallelDir;
		this._ratioOfDistance=1.0 / this._shadowMapCount;
		for (var i=0;i < this._spiltDistance.length;i++){
			this._spiltDistance[i]=0.0;
		}
		this._shadowMapTextureSize=shadowMapTextureSize;
		this._shadowPCFOffset.x=1.0 / this._shadowMapTextureSize;
		this._shadowPCFOffset.y=1.0 / this._shadowMapTextureSize;
		this.setPCFType(PCFType);
		this._statesDirty=true;
	}

	__proto.setPCFType=function(PCFtype){
		this._PCFType=PCFtype;
		var defineData=this._scene._defineDatas;
		switch (this._PCFType){
			case 0:
				defineData.add(Scene3D.SHADERDEFINE_SHADOW_PCF_NO);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF1);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF2);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF3);
				break ;
			case 1:
				defineData.add(Scene3D.SHADERDEFINE_SHADOW_PCF1);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF_NO);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF2);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF3);
				break ;
			case 2:
				defineData.add(Scene3D.SHADERDEFINE_SHADOW_PCF2);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF_NO);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF1);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF3);
				break ;
			case 3:
				defineData.add(Scene3D.SHADERDEFINE_SHADOW_PCF3);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF_NO);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF1);
				defineData.remove(Scene3D.SHADERDEFINE_SHADOW_PCF2);
				break ;
			}
	}

	__proto.getPCFType=function(){
		return this._PCFType;
	}

	__proto.setFarDistance=function(value){
		if (this._maxDistance !=value){
			this._maxDistance=value;
			this._statesDirty=true;
		}
	}

	__proto.getFarDistance=function(){
		return this._maxDistance;
	}

	/**
	*@private
	*/
	__proto._beginSampler=function(index,sceneCamera){
		if (index < 0 || index > this._shadowMapCount)
			throw new Error("ParallelSplitShadowMap: beginSample invalid index");
		this._currentPSSM=index;
		this._update(sceneCamera);
	}

	/**
	*@private
	*/
	__proto.endSampler=function(sceneCamera){
		this._currentPSSM=-1;
	}

	/**
	*@private
	*/
	__proto._calcAllLightCameraInfo=function(sceneCamera){
		if (this._shadowMapCount===1){
			this._beginSampler(0,sceneCamera);
			this.endSampler(sceneCamera);
			}else {
			for (var i=0,n=this._shadowMapCount+1;i < n;i++){
				this._beginSampler(i,sceneCamera);
				this.endSampler(sceneCamera);
			}
		}
	}

	/**
	*@private
	*/
	__proto._recalculate=function(nearPlane,fieldOfView,aspectRatio){
		this._calcSplitDistance(nearPlane);
		this._calcBoundingBox(fieldOfView,aspectRatio);
		this._rebuildRenderInfo();
	}

	/**
	*@private
	*/
	__proto._update=function(sceneCamera){
		var nearPlane=sceneCamera.nearPlane;
		var fieldOfView=sceneCamera.fieldOfView;
		var aspectRatio=(sceneCamera).aspectRatio;
		if (this._statesDirty || this.lastNearPlane!==nearPlane || this.lastFieldOfView!==fieldOfView || this.lastAspectRatio!==aspectRatio){
			this._recalculate(nearPlane,fieldOfView,aspectRatio);
			this._uploadShaderValue();
			this._statesDirty=false;
			this.lastNearPlane=nearPlane;
			this.lastFieldOfView=fieldOfView;
			this.lastAspectRatio=aspectRatio;
		}
		this._calcLightViewProject(sceneCamera);
	}

	/**
	*@private
	*/
	__proto._uploadShaderValue=function(){
		var defDatas=this._scene._defineDatas;
		switch (this._shadowMapCount){
			case 1:
				defDatas.add(Scene3D.SHADERDEFINE_SHADOW_PSSM1);
				defDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM2);
				defDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM3);
				break ;
			case 2:
				defDatas.add(Scene3D.SHADERDEFINE_SHADOW_PSSM2);
				defDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM1);
				defDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM3);
				break ;
			case 3:
				defDatas.add(Scene3D.SHADERDEFINE_SHADOW_PSSM3);
				defDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM1);
				defDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM2);
				break ;
			};
		var sceneSV=this._scene._shaderValues;
		sceneSV.setVector(Scene3D.SHADOWDISTANCE,this._shaderValueDistance);
		sceneSV.setBuffer(Scene3D.SHADOWLIGHTVIEWPROJECT,this._shaderValueLightVP);
		sceneSV.setVector(Scene3D.SHADOWMAPPCFOFFSET,this._shadowPCFOffset);
		switch (this._shadowMapCount){
			case 3:
				sceneSV.setTexture(Scene3D.SHADOWMAPTEXTURE1,this.cameras[1].renderTarget);
				sceneSV.setTexture(Scene3D.SHADOWMAPTEXTURE2,this.cameras[2].renderTarget)
				sceneSV.setTexture(Scene3D.SHADOWMAPTEXTURE3,this.cameras[3].renderTarget);
				break ;
			case 2:
				sceneSV.setTexture(Scene3D.SHADOWMAPTEXTURE1,this.cameras[1].renderTarget);
				sceneSV.setTexture(Scene3D.SHADOWMAPTEXTURE2,this.cameras[2].renderTarget);
				break ;
			case 1:
				sceneSV.setTexture(Scene3D.SHADOWMAPTEXTURE1,this.cameras[1].renderTarget);
				break ;
			}
	}

	/**
	*@private
	*/
	__proto._calcSplitDistance=function(nearPlane){
		var far=this._maxDistance;
		var invNumberOfPSSM=1.0 / this._shadowMapCount;
		var i=0;
		for (i=0;i <=this._shadowMapCount;i++){
			this._uniformDistance[i]=nearPlane+(far-nearPlane)*i *invNumberOfPSSM;
		};
		var farDivNear=far / nearPlane;
		for (i=0;i <=this._shadowMapCount;i++){
			var n=Math.pow(farDivNear,i *invNumberOfPSSM);
			this._logDistance[i]=nearPlane *n;
		}
		for (i=0;i <=this._shadowMapCount;i++){
			this._spiltDistance[i]=this._uniformDistance[i] *this._ratioOfDistance+this._logDistance[i] *(1.0-this._ratioOfDistance);
		}
		this._shaderValueDistance.x=this._spiltDistance[1];
		this._shaderValueDistance.y=this._spiltDistance[2];
		this._shaderValueDistance.z=this._spiltDistance[3];
		this._shaderValueDistance.w=this._spiltDistance[4];
	}

	/**
	*@private
	*/
	__proto._calcBoundingBox=function(fieldOfView,aspectRatio){
		var fov=3.1415926 *fieldOfView / 180.0;
		var halfTanValue=Math.tan(fov / 2.0);
		var height=NaN;
		var width=NaN;
		var distance=NaN;
		var i=0;
		for (i=0;i <=this._shadowMapCount;i++){
			distance=this._spiltDistance[i];
			height=distance *halfTanValue;
			width=height *aspectRatio;
			var temp=this._frustumPos[i *4+0].elements;
			temp[0]=-width;
			temp[1]=-height;
			temp[2]=-distance;
			temp=this._frustumPos[i *4+1].elements;
			temp[0]=width;
			temp[1]=-height;
			temp[2]=-distance;
			temp=this._frustumPos[i *4+2].elements;
			temp[0]=-width;
			temp[1]=height;
			temp[2]=-distance;
			temp=this._frustumPos[i *4+3].elements;
			temp[0]=width;
			temp[1]=height;
			temp[2]=-distance;
			temp=this._dimension[i].elements;
			temp[0]=width;
			temp[1]=height;
		};
		var d;
		var min;
		var max;
		var center;
		for (i=1;i <=this._shadowMapCount;i++){
			d=this._dimension[i].elements;
			min=this._boundingBox[i].min.elements;
			min[0]=-d[0];
			min[1]=-d[1];
			min[2]=-this._spiltDistance[i];
			max=this._boundingBox[i].max.elements;
			max[0]=d[0];
			max[1]=d[1];
			max[2]=-this._spiltDistance[i-1];
			center=this._boundingSphere[i].center.elements;
			center[0]=(min[0]+max[0])*0.5;
			center[1]=(min[1]+max[1])*0.5;
			center[2]=(min[2]+max[2])*0.5;
			this._boundingSphere[i].radius=Math.sqrt(Math.pow(max[0]-min[0],2)+Math.pow(max[1]-min[1],2)+Math.pow(max[2]-min[2],2))*0.5;
		}
		min=this._boundingBox[0].min.elements;
		d=this._dimension[this._shadowMapCount].elements;
		min[0]=-d[0];
		min[1]=-d[1];
		min[2]=-this._spiltDistance[this._shadowMapCount];
		max=this._boundingBox[0].max.elements;
		max[0]=d[0];
		max[1]=d[1];
		max[2]=-this._spiltDistance[0];
		center=this._boundingSphere[0].center.elements;
		center[0]=(min[0]+max[0])*0.5;
		center[1]=(min[1]+max[1])*0.5;
		center[2]=(min[2]+max[2])*0.5;
		this._boundingSphere[0].radius=Math.sqrt(Math.pow(max[0]-min[0],2)+Math.pow(max[1]-min[1],2)+Math.pow(max[2]-min[2],2))*0.5;
	}

	__proto.calcSplitFrustum=function(sceneCamera){
		if (this._currentPSSM > 0){
			Matrix4x4.createPerspective(3.1416 *sceneCamera.fieldOfView / 180.0,(sceneCamera).aspectRatio,this._spiltDistance[this._currentPSSM-1],this._spiltDistance[this._currentPSSM],this._tempMatrix44);
			}else {
			Matrix4x4.createPerspective(3.1416 *sceneCamera.fieldOfView / 180.0,(sceneCamera).aspectRatio,this._spiltDistance[0],this._spiltDistance[this._shadowMapCount],this._tempMatrix44);
		}
		Matrix4x4.multiply(this._tempMatrix44,(sceneCamera).viewMatrix,this._tempMatrix44);
		this._splitFrustumCulling.matrix=this._tempMatrix44;
	}

	/**
	*@private
	*/
	__proto._rebuildRenderInfo=function(){
		var nNum=this._shadowMapCount+1;
		var i=0;
		this.cameras.length=nNum;
		for (i=0;i < nNum;i++){
			if (!this.cameras[i]){
				var camera=new Camera();
				camera.name="lightCamera"+i;
				camera.clearColor=new Vector4(1.0,1.0,1.0,1.0);
				this.cameras[i]=camera;
			};
			var shadowMap=this.cameras[i].renderTarget;
			if (shadowMap==null || shadowMap.width !=this._shadowMapTextureSize || shadowMap.height !=this._shadowMapTextureSize){
				(shadowMap)&& (shadowMap.destroy());
				shadowMap=new RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,/*laya.webgl.resource.BaseTexture.FORMAT_R8G8B8A8*/1,/*laya.webgl.resource.BaseTexture.FORMAT_DEPTH_16*/0);
				shadowMap.filterMode=/*laya.webgl.resource.BaseTexture.FILTERMODE_POINT*/0;
				this.cameras[i].renderTarget=shadowMap;
			}
		}
	}

	/**
	*@private
	*/
	__proto._calcLightViewProject=function(sceneCamera){
		var boundSphere=this._boundingSphere[this._currentPSSM];
		var cameraMatViewInv=sceneCamera.transform.worldMatrix;
		var radius=boundSphere.radius;
		boundSphere.center.cloneTo(this._tempLookAt3);
		Vector3.transformV3ToV4(this._tempLookAt3,cameraMatViewInv,this._tempLookAt4);
		var lookAt3Element=this._tempLookAt3.elements;
		var lookAt4Element=this._tempLookAt4.elements;
		lookAt3Element[0]=lookAt4Element[0];
		lookAt3Element[1]=lookAt4Element[1];
		lookAt3Element[2]=lookAt4Element[2];
		var lightUpElement=this._tempLightUp.elements;
		sceneCamera.transform.worldMatrix.getForward(ParallelSplitShadowMap._tempVector30);
		var sceneCameraDir=ParallelSplitShadowMap._tempVector30.elements;
		lightUpElement[0]=sceneCameraDir[0];
		lightUpElement[1]=1.0;
		lightUpElement[2]=sceneCameraDir[2];
		Vector3.normalize(this._tempLightUp,this._tempLightUp);
		Vector3.scale(this._globalParallelLightDir,boundSphere.radius *4,this._tempPos);
		Vector3.subtract(this._tempLookAt3,this._tempPos,this._tempPos);
		var curLightCamera=this.cameras[this._currentPSSM];
		curLightCamera.transform.position=this._tempPos;
		curLightCamera.transform.lookAt(this._tempLookAt3,this._tempLightUp,false);
		var tempMaxElements=this._tempMax.elements;
		var tempMinElements=this._tempMin.elements;
		tempMaxElements[0]=tempMaxElements[1]=tempMaxElements[2]=-100000.0;
		tempMaxElements[3]=1.0;
		tempMinElements[0]=tempMinElements[1]=tempMinElements[2]=100000.0;
		tempMinElements[3]=1.0;
		Matrix4x4.multiply(curLightCamera.viewMatrix,cameraMatViewInv,this._tempMatrix44);
		var tempValueElement=this._tempValue.elements;
		var corners=[];
		corners.length=8;
		this._boundingBox[this._currentPSSM].getCorners(corners);
		for (var i=0;i < 8;i++){
			var frustumPosElements=corners[i].elements;
			tempValueElement[0]=frustumPosElements[0];
			tempValueElement[1]=frustumPosElements[1];
			tempValueElement[2]=frustumPosElements[2];
			tempValueElement[3]=1.0;
			Vector4.transformByM4x4(this._tempValue,this._tempMatrix44,this._tempValue);
			tempMinElements[0]=(tempValueElement[0] < tempMinElements[0])? tempValueElement[0] :tempMinElements[0];
			tempMinElements[1]=(tempValueElement[1] < tempMinElements[1])? tempValueElement[1] :tempMinElements[1];
			tempMinElements[2]=(tempValueElement[2] < tempMinElements[2])? tempValueElement[2] :tempMinElements[2];
			tempMaxElements[0]=(tempValueElement[0] > tempMaxElements[0])? tempValueElement[0] :tempMaxElements[0];
			tempMaxElements[1]=(tempValueElement[1] > tempMaxElements[1])? tempValueElement[1] :tempMaxElements[1];
			tempMaxElements[2]=(tempValueElement[2] > tempMaxElements[2])? tempValueElement[2] :tempMaxElements[2];
		}
		Vector4.add(this._tempMax,this._tempMin,this._tempValue);
		tempValueElement[0] *=0.5;
		tempValueElement[1] *=0.5;
		tempValueElement[2] *=0.5;
		tempValueElement[3]=1;
		Vector4.transformByM4x4(this._tempValue,curLightCamera.transform.worldMatrix,this._tempValue);
		var distance=Math.abs(-this._tempMax.z);
		var farPlane=distance > this._maxDistance ? distance :this._maxDistance;
		Vector3.scale(this._globalParallelLightDir,farPlane,this._tempPos);
		var tempPosElement=this._tempPos.elements;
		tempPosElement[0]=tempValueElement[0]-tempPosElement[0];
		tempPosElement[1]=tempValueElement[1]-tempPosElement[1];
		tempPosElement[2]=tempValueElement[2]-tempPosElement[2];
		curLightCamera.transform.position=this._tempPos;
		curLightCamera.transform.lookAt(this._tempLookAt3,this._tempLightUp,false);
		Matrix4x4.createOrthoOffCenterRH(tempMinElements[0],tempMaxElements[0],tempMinElements[1],tempMaxElements[1],1.0,farPlane+0.5 *(tempMaxElements[2]-tempMinElements[2]),curLightCamera.projectionMatrix);
		var projectView=curLightCamera.projectionViewMatrix;
		ParallelSplitShadowMap.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44,projectView,this._shaderValueVPs[this._currentPSSM]);
		this._scene._shaderValues.setBuffer(Scene3D.SHADOWLIGHTVIEWPROJECT,this._shaderValueLightVP);
	}

	__proto.setShadowMapTextureSize=function(size){
		if (size!==this._shadowMapTextureSize){
			this._shadowMapTextureSize=size;
			this._shadowPCFOffset.x=1 / this._shadowMapTextureSize;
			this._shadowPCFOffset.y=1 / this._shadowMapTextureSize;
			this._statesDirty=true;
		}
	}

	__proto.disposeAllRenderTarget=function(){
		for (var i=0,n=this._shadowMapCount+1;i < n;i++){
			if (this.cameras[i].renderTarget){
				this.cameras[i].renderTarget.destroy();
				this.cameras[i].renderTarget=null;
			}
		}
	}

	__getset(0,__proto,'shadowMapCount',function(){
		return this._shadowMapCount;
		},function(value){
		value=value > 0 ? value :1;
		value=value <=3 ? value :3;
		if (this._shadowMapCount !=value){
			this._shadowMapCount=value;
			this._ratioOfDistance=1.0 / this._shadowMapCount;
			this._statesDirty=true;
			this._shaderValueLightVP=new Float32Array(value *16);
			this._shaderValueVPs.length=value;
			for (var i=0;i < value;i++)
			this._shaderValueVPs[i]=new Float32Array(this._shaderValueLightVP.buffer,i *64);
		}
	});

	ParallelSplitShadowMap.multiplyMatrixOutFloat32Array=function(left,right,out){
		var i,a,b,ai0,ai1,ai2,ai3;
		a=left.elements;
		b=right.elements;
		for (i=0;i < 4;i++){
			ai0=a[i];
			ai1=a[i+4];
			ai2=a[i+8];
			ai3=a[i+12];
			out[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
			out[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
			out[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
			out[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
		}
	}

	ParallelSplitShadowMap.MAX_PSSM_COUNT=3;
	__static(ParallelSplitShadowMap,
	['_tempVector30',function(){return this._tempVector30=new Vector3();}
	]);
	return ParallelSplitShadowMap;
})()


/**
*<code>ColorOverLifetime</code> 类用于粒子的生命周期颜色。
*/
//class laya.d3.core.particleShuriKen.module.ColorOverLifetime
var ColorOverLifetime=(function(){
	function ColorOverLifetime(color){
		/**@private */
		this._color=null;
		/**是否启用。*/
		this.enbale=false;
		this._color=color;
	}

	__class(ColorOverLifetime,'laya.d3.core.particleShuriKen.module.ColorOverLifetime');
	var __proto=ColorOverLifetime.prototype;
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destColorOverLifetime=destObject;
		this._color.cloneTo(destColorOverLifetime._color);
		destColorOverLifetime.enbale=this.enbale;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destColor;
		switch (this._color.type){
			case 0:
				destColor=GradientColor.createByConstant(this._color.constant.clone());
				break ;
			case 1:
				destColor=GradientColor.createByGradient(this._color.gradient.clone());
				break ;
			case 2:
				destColor=GradientColor.createByRandomTwoConstant(this._color.constantMin.clone(),this._color.constantMax.clone());
				break ;
			case 3:
				destColor=GradientColor.createByRandomTwoGradient(this._color.gradientMin.clone(),this._color.gradientMax.clone());
				break ;
			};
		var destColorOverLifetime=/*__JS__ */new this.constructor(destColor);
		destColorOverLifetime.enbale=this.enbale;
		return destColorOverLifetime;
	}

	/**
	*获取颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._color;
	});

	return ColorOverLifetime;
})()


/**
*@private
*/
//class laya.d3.animation.KeyframeNode
var KeyframeNode=(function(){
	function KeyframeNode(){
		/**@private */
		this._indexInList=0;
		/**@private */
		this.type=0;
		/**@private */
		this.fullPath=null;
		/**@private */
		this.propertyOwner=null;
		/**@private */
		this.data=null;
		this._ownerPath=[];
		this._propertys=[];
		this._keyFrames=[];
	}

	__class(KeyframeNode,'laya.d3.animation.KeyframeNode');
	var __proto=KeyframeNode.prototype;
	/**
	*@private
	*/
	__proto._setOwnerPathCount=function(value){
		this._ownerPath.length=value;
	}

	/**
	*@private
	*/
	__proto._setOwnerPathByIndex=function(index,value){
		this._ownerPath[index]=value;
	}

	/**
	*@private
	*/
	__proto._joinOwnerPath=function(sep){
		return this._ownerPath.join(sep);
	}

	/**
	*@private
	*/
	__proto._setPropertyCount=function(value){
		this._propertys.length=value;
	}

	/**
	*@private
	*/
	__proto._setPropertyByIndex=function(index,value){
		this._propertys[index]=value;
	}

	/**
	*@private
	*/
	__proto._joinProperty=function(sep){
		return this._propertys.join(sep);
	}

	/**
	*@private
	*/
	__proto._setKeyframeCount=function(value){
		this._keyFrames.length=value;
	}

	/**
	*@private
	*/
	__proto._setKeyframeByIndex=function(index,value){
		this._keyFrames[index]=value;
	}

	/**
	*通过索引获取精灵路径。
	*@param index 索引。
	*/
	__proto.getOwnerPathByIndex=function(index){
		return this._ownerPath[index];
	}

	/**
	*通过索引获取属性路径。
	*@param index 索引。
	*/
	__proto.getPropertyByIndex=function(index){
		return this._propertys[index];
	}

	/**
	*通过索引获取帧。
	*@param index 索引。
	*/
	__proto.getKeyframeByIndex=function(index){
		return this._keyFrames[index];
	}

	/**
	*获取精灵路径个数。
	*@return 精灵路径个数。
	*/
	__getset(0,__proto,'ownerPathCount',function(){
		return this._ownerPath.length;
	});

	/**
	*获取属性路径个数。
	*@return 数量路径个数。
	*/
	__getset(0,__proto,'propertyCount',function(){
		return this._propertys.length;
	});

	/**
	*获取帧个数。
	*帧个数。
	*/
	__getset(0,__proto,'keyFramesCount',function(){
		return this._keyFrames.length;
	});

	return KeyframeNode;
})()


/**
*<code>Matrix3x3</code> 类用于创建3x3矩阵。
*/
//class laya.d3.math.Matrix3x3
var Matrix3x3=(function(){
	function Matrix3x3(){
		/**矩阵元素数组*/
		//this.elements=null;
		var e=this.elements=new Float32Array(9);
		e[0]=1;
		e[1]=0;
		e[2]=0;
		e[3]=0;
		e[4]=1;
		e[5]=0;
		e[6]=0;
		e[7]=0;
		e[8]=1;
	}

	__class(Matrix3x3,'laya.d3.math.Matrix3x3');
	var __proto=Matrix3x3.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*计算3x3矩阵的行列式
	*@return 矩阵的行列式
	*/
	__proto.determinant=function(){
		var f=this.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		return a00 *(a22 *a11-a12 *a21)+a01 *(-a22 *a10+a12 *a20)+a02 *(a21 *a10-a11 *a20);
	}

	/**
	*通过一个二维向量转换3x3矩阵
	*@param tra 转换向量
	*@param out 输出矩阵
	*/
	__proto.translate=function(trans,out){
		var e=out.elements;
		var f=this.elements;
		var g=trans.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		var x=g[0],y=g[1];
		e[0]=a00;
		e[1]=a01;
		e[2]=a02;
		e[3]=a10;
		e[4]=a11;
		e[5]=a12;
		e[6]=x *a00+y *a10+a20;
		e[7]=x *a01+y *a11+a21;
		e[8]=x *a02+y *a12+a22;
	}

	/**
	*根据指定角度旋转3x3矩阵
	*@param rad 旋转角度
	*@param out 输出矩阵
	*/
	__proto.rotate=function(rad,out){
		var e=out.elements;
		var f=this.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		var s=Math.sin(rad);
		var c=Math.cos(rad);
		e[0]=c *a00+s *a10;
		e[1]=c *a01+s *a11;
		e[2]=c *a02+s *a12;
		e[3]=c *a10-s *a00;
		e[4]=c *a11-s *a01;
		e[5]=c *a12-s *a02;
		e[6]=a20;
		e[7]=a21;
		e[8]=a22;
	}

	/**
	*根据制定缩放3x3矩阵
	*@param scale 缩放值
	*@param out 输出矩阵
	*/
	__proto.scale=function(scale,out){
		var e=out.elements;
		var f=this.elements;
		var g=scale.elements;
		var x=g[0],y=g[1];
		e[0]=x *f[0];
		e[1]=x *f[1];
		e[2]=x *f[2];
		e[3]=y *f[3];
		e[4]=y *f[4];
		e[5]=y *f[5];
		e[6]=f[6];
		e[7]=f[7];
		e[8]=f[8];
	}

	/**
	*计算3x3矩阵的逆矩阵
	*@param out 输出的逆矩阵
	*/
	__proto.invert=function(out){
		var e=out.elements;
		var f=this.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		var b01=a22 *a11-a12 *a21;
		var b11=-a22 *a10+a12 *a20;
		var b21=a21 *a10-a11 *a20;
		var det=a00 *b01+a01 *b11+a02 *b21;
		if (!det){
			out=null;
		}
		det=1.0 / det;
		e[0]=b01 *det;
		e[1]=(-a22 *a01+a02 *a21)*det;
		e[2]=(a12 *a01-a02 *a11)*det;
		e[3]=b11 *det;
		e[4]=(a22 *a00-a02 *a20)*det;
		e[5]=(-a12 *a00+a02 *a10)*det;
		e[6]=b21 *det;
		e[7]=(-a21 *a00+a01 *a20)*det;
		e[8]=(a11 *a00-a01 *a10)*det;
	}

	/**
	*计算3x3矩阵的转置矩阵
	*@param out 输出矩阵
	*/
	__proto.transpose=function(out){
		var e=out.elements;
		var f=this.elements;
		if (out===this){
			var a01=f[1],a02=f[2],a12=f[5];
			e[1]=f[3];
			e[2]=f[6];
			e[3]=a01;
			e[5]=f[7];
			e[6]=a02;
			e[7]=a12;
			}else {
			e[0]=f[0];
			e[1]=f[3];
			e[2]=f[6];
			e[3]=f[1];
			e[4]=f[4];
			e[5]=f[7];
			e[6]=f[2];
			e[7]=f[5];
			e[8]=f[8];
		}
	}

	/**设置已有的矩阵为单位矩阵*/
	__proto.identity=function(){
		var e=this.elements;
		e[0]=1;
		e[1]=0;
		e[2]=0;
		e[3]=0;
		e[4]=1;
		e[5]=0;
		e[6]=0;
		e[7]=0;
		e[8]=1;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var i,s,d;
		s=this.elements;
		d=destObject.elements;
		if (s===d){
			return;
		}
		for (i=0;i < 9;++i){
			d[i]=s[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	Matrix3x3.createFromTranslation=function(trans,out){
		var e=out.elements;
		var g=trans.elements;
		out[0]=1;
		out[1]=0;
		out[2]=0;
		out[3]=0;
		out[4]=1;
		out[5]=0;
		out[6]=g[0];
		out[7]=g[1];
		out[8]=1;
	}

	Matrix3x3.createFromRotation=function(rad,out){
		var e=out.elements;
		var s=Math.sin(rad),c=Math.cos(rad);
		e[0]=c;
		e[1]=s;
		e[2]=0;
		e[3]=-s;
		e[4]=c;
		e[5]=0;
		e[6]=0;
		e[7]=0;
		e[8]=1;
	}

	Matrix3x3.createFromScaling=function(scale,out){
		var e=out.elements;
		var g=scale.elements;
		e[0]=g[0];
		e[1]=0;
		e[2]=0;
		e[3]=0;
		e[4]=g[1];
		e[5]=0;
		e[6]=0;
		e[7]=0;
		e[8]=1;
	}

	Matrix3x3.createFromMatrix4x4=function(sou,out){
		out[0]=sou[0];
		out[1]=sou[1];
		out[2]=sou[2];
		out[3]=sou[4];
		out[4]=sou[5];
		out[5]=sou[6];
		out[6]=sou[8];
		out[7]=sou[9];
		out[8]=sou[10];
	}

	Matrix3x3.multiply=function(left,right,out){
		var e=out.elements;
		var f=left.elements;
		var g=right.elements;
		var a00=f[0],a01=f[1],a02=f[2];
		var a10=f[3],a11=f[4],a12=f[5];
		var a20=f[6],a21=f[7],a22=f[8];
		var b00=g[0],b01=g[1],b02=g[2];
		var b10=g[3],b11=g[4],b12=g[5];
		var b20=g[6],b21=g[7],b22=g[8];
		e[0]=b00 *a00+b01 *a10+b02 *a20;
		e[1]=b00 *a01+b01 *a11+b02 *a21;
		e[2]=b00 *a02+b01 *a12+b02 *a22;
		e[3]=b10 *a00+b11 *a10+b12 *a20;
		e[4]=b10 *a01+b11 *a11+b12 *a21;
		e[5]=b10 *a02+b11 *a12+b12 *a22;
		e[6]=b20 *a00+b21 *a10+b22 *a20;
		e[7]=b20 *a01+b21 *a11+b22 *a21;
		e[8]=b20 *a02+b21 *a12+b22 *a22;
	}

	Matrix3x3.lookAt=function(eye,target,up,out){
		Vector3.subtract(eye,target,Matrix3x3._tempV30);
		Vector3.normalize(Matrix3x3._tempV30,Matrix3x3._tempV30);
		Vector3.cross(up,Matrix3x3._tempV30,Matrix3x3._tempV31);
		Vector3.normalize(Matrix3x3._tempV31,Matrix3x3._tempV31);
		Vector3.cross(Matrix3x3._tempV30,Matrix3x3._tempV31,Matrix3x3._tempV32);
		var v0e=Matrix3x3._tempV30.elements;
		var v1e=Matrix3x3._tempV31.elements;
		var v2e=Matrix3x3._tempV32.elements;
		var me=out.elements;
		me[0]=v1e[0];
		me[3]=v1e[1];
		me[6]=v1e[2];
		me[1]=v2e[0];
		me[4]=v2e[1];
		me[7]=v2e[2];
		me[2]=v0e[0];
		me[5]=v0e[1];
		me[8]=v0e[2];
	}

	Matrix3x3.DEFAULT=new Matrix3x3();
	__static(Matrix3x3,
	['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();}
	]);
	return Matrix3x3;
})()


/**
*<code>VertexPositionNormalTexture</code> 类用于创建位置、纹理顶点结构。
*/
//class laya.d3.graphics.Vertex.VertexPositionTexture0
var VertexPositionTexture0=(function(){
	function VertexPositionTexture0(position,textureCoordinate0){
		this._position=null;
		this._textureCoordinate0=null;
		this._position=position;
		this._textureCoordinate0=textureCoordinate0;
	}

	__class(VertexPositionTexture0,'laya.d3.graphics.Vertex.VertexPositionTexture0');
	var __proto=VertexPositionTexture0.prototype;
	Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
	__getset(0,__proto,'position',function(){
		return this._position;
	});

	__getset(0,__proto,'textureCoordinate0',function(){
		return this._textureCoordinate0;
	});

	__getset(0,__proto,'vertexDeclaration',function(){
		return VertexPositionTexture0._vertexDeclaration;
	});

	__getset(1,VertexPositionTexture0,'vertexDeclaration',function(){
		return VertexPositionTexture0._vertexDeclaration;
	});

	__static(VertexPositionTexture0,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(20,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2)]);}
	]);
	return VertexPositionTexture0;
})()


/**
*@private
*/
//class laya.d3.animation.AnimationClipParser03
var AnimationClipParser03=(function(){
	function AnimationClipParser03(){}
	__class(AnimationClipParser03,'laya.d3.animation.AnimationClipParser03');
	AnimationClipParser03.READ_DATA=function(){
		AnimationClipParser03._DATA.offset=AnimationClipParser03._reader.getUint32();
		AnimationClipParser03._DATA.size=AnimationClipParser03._reader.getUint32();
	}

	AnimationClipParser03.READ_BLOCK=function(){
		var count=AnimationClipParser03._BLOCK.count=AnimationClipParser03._reader.getUint16();
		var blockStarts=AnimationClipParser03._BLOCK.blockStarts=[];
		var blockLengths=AnimationClipParser03._BLOCK.blockLengths=[];
		for (var i=0;i < count;i++){
			blockStarts.push(AnimationClipParser03._reader.getUint32());
			blockLengths.push(AnimationClipParser03._reader.getUint32());
		}
	}

	AnimationClipParser03.READ_STRINGS=function(){
		var offset=AnimationClipParser03._reader.getUint32();
		var count=AnimationClipParser03._reader.getUint16();
		var prePos=AnimationClipParser03._reader.pos;
		AnimationClipParser03._reader.pos=offset+AnimationClipParser03._DATA.offset;
		for (var i=0;i < count;i++)
		AnimationClipParser03._strings[i]=AnimationClipParser03._reader.readUTFString();
		AnimationClipParser03._reader.pos=prePos;
	}

	AnimationClipParser03.parse=function(clip,reader){
		AnimationClipParser03._animationClip=clip;
		AnimationClipParser03._reader=reader;
		var arrayBuffer=reader.__getBuffer();
		AnimationClipParser03.READ_DATA();
		AnimationClipParser03.READ_BLOCK();
		AnimationClipParser03.READ_STRINGS();
		for (var i=0,n=AnimationClipParser03._BLOCK.count;i < n;i++){
			var index=reader.getUint16();
			var blockName=AnimationClipParser03._strings[index];
			var fn=AnimationClipParser03["READ_"+blockName];
			if (fn==null)
				throw new Error("model file err,no this function:"+index+" "+blockName);
			else
			fn.call();
		}
	}

	AnimationClipParser03.READ_ANIMATIONS=function(){
		var i=0,j=0;
		var node;
		var reader=AnimationClipParser03._reader;
		var buffer=reader.__getBuffer();
		var startTimeTypes=[];
		var startTimeTypeCount=reader.getUint16();
		startTimeTypes.length=startTimeTypeCount;
		for (i=0;i < startTimeTypeCount;i++)
		startTimeTypes[i]=reader.getFloat32();
		var clip=AnimationClipParser03._animationClip;
		clip.name=AnimationClipParser03._strings[reader.getUint16()];
		var clipDur=clip._duration=reader.getFloat32();
		clip.islooping=!!reader.getByte();
		clip._frameRate=reader.getInt16();
		var nodeCount=reader.getInt16();
		var nodes=clip._nodes;
		nodes.count=nodeCount;
		var nodesMap=clip._nodesMap={};
		var nodesDic=clip._nodesDic={};
		for (i=0;i < nodeCount;i++){
			node=new KeyframeNode();
			nodes.setNodeByIndex(i,node);
			node._indexInList=i;
			var type=node.type=reader.getUint8();
			var pathLength=reader.getUint16();
			node._setOwnerPathCount(pathLength);
			for (j=0;j < pathLength;j++)
			node._setOwnerPathByIndex(j,AnimationClipParser03._strings[reader.getUint16()]);
			var nodePath=node._joinOwnerPath("/");
			var mapArray=nodesMap[nodePath];
			(mapArray)|| (nodesMap[nodePath]=mapArray=[]);
			mapArray.push(node);
			node.propertyOwner=AnimationClipParser03._strings[reader.getUint16()];
			var propertyLength=reader.getUint16();
			node._setPropertyCount(propertyLength);
			for (j=0;j < propertyLength;j++)
			node._setPropertyByIndex(j,AnimationClipParser03._strings[reader.getUint16()]);
			var fullPath=nodePath+"."+node.propertyOwner+"."+node._joinProperty(".");
			nodesDic[fullPath]=node;
			node.fullPath=fullPath;
			var keyframeCount=reader.getUint16();
			node._setKeyframeCount(keyframeCount);
			var startTime=NaN;
			switch (type){
				case 0:
					break ;
				case 1:
				case 3:
				case 4:
					node.data=new Float32Array(3);
					break ;
				case 2:
					node.data=new Float32Array(4);
					break ;
				default :
					throw "AnimationClipParser03:unknown type.";
				}
			for (j=0;j < keyframeCount;j++){
				switch (type){
					case 0:;
						var floatKeyframe=new FloatKeyframe();
						node._setKeyframeByIndex(j,floatKeyframe);
						startTime=floatKeyframe.time=startTimeTypes[reader.getUint16()];
						floatKeyframe.inTangent=reader.getFloat32();
						floatKeyframe.outTangent=reader.getFloat32();
						floatKeyframe.value=reader.getFloat32();
						break ;
					case 1:
					case 3:
					case 4:;
						var floatArrayKeyframe=new FloatArrayKeyframe();
						node._setKeyframeByIndex(j,floatArrayKeyframe);
						startTime=floatArrayKeyframe.time=startTimeTypes[reader.getUint16()];
						var data=floatArrayKeyframe.data=new Float32Array(3 *3);
						for (var k=0;k < 3;k++)
						data[k]=reader.getFloat32();
						for (k=0;k < 3;k++)
						data[3+k]=reader.getFloat32();
						for (k=0;k < 3;k++)
						data[6+k]=reader.getFloat32();
						break ;
					case 2:
						floatArrayKeyframe=new FloatArrayKeyframe();
						node._setKeyframeByIndex(j,floatArrayKeyframe);
						startTime=floatArrayKeyframe.time=startTimeTypes[reader.getUint16()];
						data=floatArrayKeyframe.data=new Float32Array(3 *4);
						for (k=0;k < 4;k++)
						data[k]=reader.getFloat32();
						for (k=0;k < 4;k++)
						data[4+k]=reader.getFloat32();
						for (k=0;k < 4;k++)
						data[8+k]=reader.getFloat32();
						break ;
					default :
						throw "AnimationClipParser03:unknown type.";
					}
			}
		};
		var eventCount=reader.getUint16();
		for (i=0;i < eventCount;i++){
			var event=new AnimationEvent();
			event.time=reader.getFloat32();
			event.eventName=AnimationClipParser03._strings[reader.getUint16()];
			var params;
			var paramCount=reader.getUint16();
			(paramCount > 0)&& (event.params=params=[]);
			for (j=0;j < paramCount;j++){
				var eventType=reader.getByte();
				switch (eventType){
					case 0:
						params.push(!!reader.getByte());
						break ;
					case 1:
						params.push(reader.getInt32());
						break ;
					case 2:
						params.push(reader.getFloat32());
						break ;
					case 3:
						params.push(AnimationClipParser03._strings[reader.getUint16()]);
						break ;
					default :
						throw new Error("unknown type.");
					}
			}
			clip.addEvent(event);
		}
	}

	AnimationClipParser03._animationClip=null;
	AnimationClipParser03._reader=null;
	AnimationClipParser03._strings=[];
	__static(AnimationClipParser03,
	['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
	]);
	return AnimationClipParser03;
})()


/**
*<code>TerrainLeaf</code> Terrain的叶子节点
*/
//class laya.d3.terrain.TerrainLeaf
var TerrainLeaf=(function(){
	function TerrainLeaf(){
		this._boundingSphere=null;
		this._boundingBox=null;
		this._sizeOfY=null;
		this._currentLODLevel=0;
		this._lastDistanceToEye=NaN;
		this._originalBoundingSphere=null;
		this._originalBoundingBox=null;
		this._originalBoundingBoxCorners=null;
		this._bUseStrip=false;
		this._gridSize=NaN;
		this._beginGridX=0;
		//针对整个大地形的偏移
		this._beginGridZ=0;
		//针对整个大地形的偏移
		this._LODError=null;
		TerrainLeaf.__init__();
		this._currentLODLevel=0;
	}

	__class(TerrainLeaf,'laya.d3.terrain.TerrainLeaf');
	var __proto=TerrainLeaf.prototype;
	__proto.calcVertextNorml=function(x,z,terrainHeightData,heighDataWidth,heightDataHeight,normal){
		var dZ=0,dX=0;
		dX=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dX+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dZ=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x-1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		dZ+=TerrainLeaf.getHeightFromTerrainHeightData(x+1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
		normal.x=-dX;
		normal.y=6;
		normal.z=-dZ;
		Vector3.normalize(normal,normal);
	}

	__proto.calcVertextNormlUV=function(x,z,terrainWidth,terrainHeight,normal){
		normal.x=x / terrainWidth;
		normal.y=z / terrainHeight;
		normal.z=z / terrainHeight;
	}

	__proto.calcVertextBuffer=function(offsetChunkX,offsetChunkZ,beginX,beginZ,girdSize,vertextBuffer,offset,strideSize,terrainHeightData,heighDataWidth,heightDataHeight,cameraCoordinateInverse){
		if (cameraCoordinateInverse==true && !TerrainLeaf.__ADAPT_MATRIX__){
			TerrainLeaf.__ADAPT_MATRIX__=new Matrix4x4();
			var mat=new Matrix4x4();
			Matrix4x4.createRotationY(Math.PI,TerrainLeaf.__ADAPT_MATRIX__);
			Matrix4x4.createTranslate(new Vector3(0,0,(heightDataHeight-1)*girdSize),mat);
			Matrix4x4.multiply(mat,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__ADAPT_MATRIX__);
			TerrainLeaf.__ADAPT_MATRIX_INV__=new Matrix4x4();
			TerrainLeaf.__ADAPT_MATRIX__.invert(TerrainLeaf.__ADAPT_MATRIX_INV__);
		}
		this._gridSize=girdSize;
		this._beginGridX=offsetChunkX *TerrainLeaf.CHUNK_GRID_NUM+beginX;
		this._beginGridZ=offsetChunkZ *TerrainLeaf.CHUNK_GRID_NUM+beginZ;
		var nNum=offset *strideSize;
		var minY=2147483647;
		var maxY=-2147483648;
		var normal=new Vector3();
		for (var i=0,s=TerrainLeaf.LEAF_GRID_NUM+1;i < s;i++){
			for (var j=0,s1=TerrainLeaf.LEAF_GRID_NUM+1;j < s1;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+i)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=terrainHeightData[(this._beginGridZ+i)*(heighDataWidth)+(this._beginGridX+j)];
				minY=TerrainLeaf.__VECTOR3__.y < minY ? TerrainLeaf.__VECTOR3__.y :minY;
				maxY=TerrainLeaf.__VECTOR3__.y > maxY ? TerrainLeaf.__VECTOR3__.y :maxY;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				this.calcVertextNormlUV(this._beginGridX+j,this._beginGridZ+i,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+i)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=this._beginGridX+j;
				nNum++;
				vertextBuffer[nNum]=this._beginGridZ+i;
				nNum++;
			}
		}
		this._sizeOfY=new Vector2(minY-1,maxY+1);
		this.calcLODErrors(terrainHeightData,heighDataWidth,heightDataHeight);
		this.calcOriginalBoudingBoxAndSphere();
	}

	__proto.calcSkirtVertextBuffer=function(offsetChunkX,offsetChunkZ,beginX,beginZ,girdSize,vertextBuffer,offset,strideSize,terrainHeightData,heighDataWidth,heightDataHeight){
		this._gridSize=girdSize;
		this._beginGridX=offsetChunkX *TerrainLeaf.CHUNK_GRID_NUM+beginX;
		this._beginGridZ=offsetChunkZ *TerrainLeaf.CHUNK_GRID_NUM+beginZ;
		var nNum=offset *strideSize;
		var i=0,j=0,s=TerrainLeaf.LEAF_GRID_NUM+1;
		var normal=new Vector3();
		var hZIndex=0;
		var hXIndex=0;
		var h=0;
		var zh=0;
		var xh=0;
		for (i=0;i < 2;i++){
			for (j=0;j < s;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=(i==1 ? terrainHeightData[this._beginGridZ *heighDataWidth+(this._beginGridX+j)] :-this._gridSize);
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+0)*this._gridSize;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				if (i==0){
					hZIndex=(this._beginGridZ-1);
					}else {
					hZIndex=this._beginGridZ;
				}
				this.calcVertextNormlUV(this._beginGridX+j,hZIndex,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+0)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=this._beginGridX+j;
				nNum++;
				vertextBuffer[nNum]=hZIndex;
				nNum++;
			}
		}
		for (i=0;i < 2;i++){
			for (j=0;j < s;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+j)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=(i==0 ? terrainHeightData[(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*(heighDataWidth)+(this._beginGridX+j)] :-this._gridSize);
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				if (i==0){
					hZIndex=this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM;
					}else {
					hZIndex=(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM+1);
				}
				this.calcVertextNormlUV(this._beginGridX+j,hZIndex,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+TerrainLeaf.LEAF_GRID_NUM)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=this._beginGridX+j;
				nNum++;
				vertextBuffer[nNum]=hZIndex;
				nNum++;
			}
		}
		for (i=0;i < 2;i++){
			for (j=0;j < s;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+0)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=(i==0 ? terrainHeightData[(this._beginGridZ+j)*(heighDataWidth)+(this._beginGridX+0)] :-this._gridSize);
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+j)*this._gridSize;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				if (i==0){
					hXIndex=this._beginGridX;
					}else {
					hXIndex=(this._beginGridX-1);
				}
				this.calcVertextNormlUV(hXIndex,this._beginGridZ+j,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+0)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=hXIndex;
				nNum++;
				vertextBuffer[nNum]=this._beginGridZ+j;
				nNum++;
			}
		}
		for (i=0;i < 2;i++){
			for (j=0;j < s;j++){
				TerrainLeaf.__VECTOR3__.x=(this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize;
				TerrainLeaf.__VECTOR3__.y=(i==1 ? terrainHeightData[(this._beginGridZ+j)*(heighDataWidth)+(this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)] :-this._gridSize);
				TerrainLeaf.__VECTOR3__.z=(this._beginGridZ+j)*this._gridSize;
				if (TerrainLeaf.__ADAPT_MATRIX__){
					Vector3.transformV3ToV3(TerrainLeaf.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX__,TerrainLeaf.__VECTOR3__);
				}
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.x;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.y;
				nNum++;
				vertextBuffer[nNum]=TerrainLeaf.__VECTOR3__.z;
				nNum++;
				if (i==0){
					hXIndex=this._beginGridX+TerrainLeaf.LEAF_GRID_NUM+1;
					}else {
					hXIndex=this._beginGridX+TerrainLeaf.LEAF_GRID_NUM;
				}
				this.calcVertextNormlUV(hXIndex,this._beginGridZ+j,heighDataWidth,heightDataHeight,normal);
				vertextBuffer[nNum]=normal.x;
				nNum++;
				vertextBuffer[nNum]=normal.y;
				nNum++;
				vertextBuffer[nNum]=normal.z;
				nNum++;
				vertextBuffer[nNum]=(beginX+TerrainLeaf.LEAF_GRID_NUM)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=(beginZ+j)/ TerrainLeaf.CHUNK_GRID_NUM;
				nNum++;
				vertextBuffer[nNum]=hXIndex;
				nNum++;
				vertextBuffer[nNum]=this._beginGridZ+j;
				nNum++;
			}
		}
	}

	__proto.calcOriginalBoudingBoxAndSphere=function(){
		var min=new Vector3(this._beginGridX *this._gridSize,this._sizeOfY.x,this._beginGridZ *this._gridSize);
		var max=new Vector3((this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize,this._sizeOfY.y,(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize);
		if (TerrainLeaf.__ADAPT_MATRIX__){
			Vector3.transformV3ToV3(min,TerrainLeaf.__ADAPT_MATRIX__,min);
			Vector3.transformV3ToV3(max,TerrainLeaf.__ADAPT_MATRIX__,max);
		}
		this._originalBoundingBox=new BoundBox(min,max);
		var size=new Vector3();
		Vector3.subtract(max,min,size);
		Vector3.scale(size,0.5,size);
		var center=new Vector3();
		Vector3.add(min,size,center);
		this._originalBoundingSphere=new BoundSphere(center,Vector3.scalarLength(size));
		this._originalBoundingBoxCorners=__newvec(8,null);
		this._originalBoundingBox.getCorners(this._originalBoundingBoxCorners);
		this._boundingBox=new BoundBox(new Vector3(-0.5,-0.5,-0.5),new Vector3(0.5,0.5,0.5));
		this._boundingSphere=new BoundSphere(new Vector3(0,0,0),1);
	}

	__proto.calcLeafBoudingBox=function(worldMatrix){
		for (var i=0;i < 8;i++){
			Vector3.transformCoordinate(this._originalBoundingBoxCorners[i],worldMatrix,BaseRender._tempBoundBoxCorners[i]);
		}
		BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
	}

	__proto.calcLeafBoudingSphere=function(worldMatrix,maxScale){
		Vector3.transformCoordinate(this._originalBoundingSphere.center,worldMatrix,this._boundingSphere.center);
		this._boundingSphere.radius=this._originalBoundingSphere.radius *maxScale;
	}

	__proto.calcLODErrors=function(terrainHeightData,heighDataWidth,heightDataHeight){
		this._LODError=new Float32Array(TerrainLeaf._maxLODLevel+1);
		var step=1;
		for (var i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
			var maxError=0;
			for (var y=0,n1=TerrainLeaf.LEAF_GRID_NUM;y < n1;y+=step){
				for (var x=0,n2=TerrainLeaf.LEAF_GRID_NUM;x < n2;x+=step){
					var z00=terrainHeightData[(this._beginGridZ+y)*heighDataWidth+(this._beginGridX+x)];
					var z10=terrainHeightData[(this._beginGridZ+y)*heighDataWidth+(this._beginGridX+x)+step];
					var z01=terrainHeightData[(this._beginGridZ+y+step)*heighDataWidth+(this._beginGridX+x)];
					var z11=terrainHeightData[(this._beginGridZ+y+step)*heighDataWidth+(this._beginGridX+x)+step];
					for (var j=0;j < step;j++){
						var ys=j / step;
						for (var k=0;k < step;k++){
							var xs=k / step;
							var z=terrainHeightData[(this._beginGridZ+y+j)*heighDataWidth+(this._beginGridX+x)+k];
							var iz=(xs+ys <=1)? (z00+(z10-z00)*xs+(z01-z00)*ys):(z11+(z01-z11)*(1-xs)+(z10-z11)*(1-ys));
							var error=Math.abs(iz-z);
							maxError=Math.max(maxError,error);
						}
					}
				}
			}
			step *=2;
			this._LODError[i]=maxError;
		}
	}

	__proto.determineLod=function(eyePos,perspectiveFactor,tolerance,tolerAndPerspectiveChanged){
		var nDistanceToEye=Vector3.distance(eyePos,this._boundingSphere.center);
		var n=TerrainLeaf._maxLODLevel;
		if (!tolerAndPerspectiveChanged){
			if (this._lastDistanceToEye==nDistanceToEye){
				return this._currentLODLevel;
				}else if (this._lastDistanceToEye > nDistanceToEye){
				n=this._currentLODLevel;
			}
		}
		for (var i=n;i >=1;i--){
			if (Terrain.LOD_DISTANCE_FACTOR *this._LODError[i] / nDistanceToEye *perspectiveFactor < tolerance){
				this._currentLODLevel=i;
				break ;
			}
		}
		this._lastDistanceToEye=nDistanceToEye;
		return this._currentLODLevel;
	}

	TerrainLeaf.__init__=function(){
		if (!TerrainLeaf._bInit){
			var nLeafNum=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
			TerrainLeaf._planeLODIndex=__newvec(nLeafNum);
			var i=0,j=0,k=0,n=0,n1=0,nOffset=0;
			var nOriginIndexArray=null,nTempIndex=null;
			for (i=0;i < nLeafNum;i++){
				TerrainLeaf._planeLODIndex[i]=new Array(TerrainLeaf._maxLODLevel+1);
			}
			for (i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
				TerrainLeaf._planeLODIndex[0][i]=TerrainLeaf.calcPlaneLODIndex(i);
			}
			for (i=1;i < nLeafNum;i++){
				nOffset=i *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT;
				for (j=0,n1=TerrainLeaf._maxLODLevel+1;j < n1;j++){
					nOriginIndexArray=TerrainLeaf._planeLODIndex[0][j];
					nTempIndex=new Uint16Array(nOriginIndexArray.length);
					for (k=0;k < nOriginIndexArray.length;k++){
						nTempIndex[k]=nOriginIndexArray[k]+nOffset;
					}
					TerrainLeaf._planeLODIndex[i][j]=nTempIndex;
				}
			}
			TerrainLeaf._skirtLODIndex=__newvec(nLeafNum);
			for (i=0;i < nLeafNum;i++){
				TerrainLeaf._skirtLODIndex[i]=new Array(TerrainLeaf._maxLODLevel+1);
			}
			for (i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
				TerrainLeaf._skirtLODIndex[0][i]=TerrainLeaf.calcSkirtLODIndex(i);
			}
			for (i=1;i < nLeafNum;i++){
				nOffset=i *TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;
				for (j=0,n1=TerrainLeaf._maxLODLevel+1;j < n1;j++){
					nOriginIndexArray=TerrainLeaf._skirtLODIndex[0][j];
					nTempIndex=new Uint16Array(nOriginIndexArray.length);
					for (k=0;k < nOriginIndexArray.length;k++){
						nTempIndex[k]=nOriginIndexArray[k]+nOffset;
					}
					TerrainLeaf._skirtLODIndex[i][j]=nTempIndex;
				}
			}
			TerrainLeaf._bInit=true;
		}
	}

	TerrainLeaf.getPlaneLODIndex=function(leafIndex,LODLevel){
		return TerrainLeaf._planeLODIndex[leafIndex][LODLevel];
	}

	TerrainLeaf.getSkirtLODIndex=function(leafIndex,LODLevel){
		return TerrainLeaf._skirtLODIndex[leafIndex][LODLevel];
	}

	TerrainLeaf.calcPlaneLODIndex=function(level){
		if (level > TerrainLeaf._maxLODLevel)level=TerrainLeaf._maxLODLevel;
		var nGridNumAddOne=TerrainLeaf.LEAF_GRID_NUM+1;
		var nNum=0;
		var indexBuffer=null;
		var nLODGridNum=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2,level);
		indexBuffer=new Uint16Array(nLODGridNum *nLODGridNum *6);
		var nGridSpace=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / nLODGridNum;
		for (var i=0;i < TerrainLeaf.LEAF_GRID_NUM;i+=nGridSpace){
			for (var j=0;j < TerrainLeaf.LEAF_GRID_NUM;j+=nGridSpace){
				indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j;
				nNum++;
				indexBuffer[nNum]=i *nGridNumAddOne+j;
				nNum++;
				indexBuffer[nNum]=i *nGridNumAddOne+j+nGridSpace;
				nNum++;
				indexBuffer[nNum]=i *nGridNumAddOne+j+nGridSpace;
				nNum++;
				indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j+nGridSpace;
				nNum++;
				indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j;
				nNum++;
			}
		}
		return indexBuffer;
	}

	TerrainLeaf.calcSkirtLODIndex=function(level){
		if (level > TerrainLeaf._maxLODLevel)level=TerrainLeaf._maxLODLevel;
		var nSkirtIndexOffset=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT;
		var nGridNumAddOne=TerrainLeaf.LEAF_GRID_NUM+1;
		var nNum=0;
		var indexBuffer=null;
		var nLODGridNum=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2,level);
		indexBuffer=new Uint16Array(nLODGridNum *4 *6);
		var nGridSpace=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / nLODGridNum;
		for (var j=0;j < 4;j++){
			for (var i=0;i < TerrainLeaf.LEAF_GRID_NUM;i+=nGridSpace){
				indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+i;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+i+nGridSpace;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+i+nGridSpace;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i+nGridSpace;
				nNum++;
				indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i;
				nNum++;
			}
			nSkirtIndexOffset+=nGridNumAddOne *2;
		}
		return indexBuffer;
	}

	TerrainLeaf.getHeightFromTerrainHeightData=function(x,z,terrainHeightData,heighDataWidth,heightDataHeight){
		x=x < 0 ? 0 :x;
		x=(x >=heighDataWidth)? heighDataWidth-1 :x;
		z=z < 0 ? 0 :z;
		z=(z >=heightDataHeight)? heightDataHeight-1 :z;
		return terrainHeightData[z *heighDataWidth+x];
	}

	TerrainLeaf.CHUNK_GRID_NUM=64;
	TerrainLeaf.LEAF_GRID_NUM=32;
	TerrainLeaf.__ADAPT_MATRIX__=null;
	TerrainLeaf.__ADAPT_MATRIX_INV__=null;
	TerrainLeaf._planeLODIndex=null;
	TerrainLeaf._skirtLODIndex=null;
	TerrainLeaf._bInit=false;
	__static(TerrainLeaf,
	['LEAF_PLANE_VERTEXT_COUNT',function(){return this.LEAF_PLANE_VERTEXT_COUNT=(TerrainLeaf.LEAF_GRID_NUM+1)*(TerrainLeaf.LEAF_GRID_NUM+1);},'LEAF_SKIRT_VERTEXT_COUNT',function(){return this.LEAF_SKIRT_VERTEXT_COUNT=(TerrainLeaf.LEAF_GRID_NUM+1)*2 *4;},'LEAF_VERTEXT_COUNT',function(){return this.LEAF_VERTEXT_COUNT=TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT+TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;},'LEAF_PLANE_MAX_INDEX_COUNT',function(){return this.LEAF_PLANE_MAX_INDEX_COUNT=TerrainLeaf.LEAF_GRID_NUM *TerrainLeaf.LEAF_GRID_NUM *6;},'LEAF_SKIRT_MAX_INDEX_COUNT',function(){return this.LEAF_SKIRT_MAX_INDEX_COUNT=TerrainLeaf.LEAF_GRID_NUM *4 *6;},'LEAF_MAX_INDEX_COUNT',function(){return this.LEAF_MAX_INDEX_COUNT=TerrainLeaf.LEAF_PLANE_MAX_INDEX_COUNT+TerrainLeaf.LEAF_SKIRT_MAX_INDEX_COUNT;},'__VECTOR3__',function(){return this.__VECTOR3__=new Vector3();},'_maxLODLevel',function(){return this._maxLODLevel=/*__JS__ */Math.log2(TerrainLeaf.LEAF_GRID_NUM);}
	]);
	return TerrainLeaf;
})()


/**
*<code>PixelLineData</code> 类用于表示线数据。
*/
//class laya.d3.core.pixelLine.PixelLineData
var PixelLineData=(function(){
	function PixelLineData(){
		this.startPosition=new Vector3();
		this.endPosition=new Vector3();
		this.startColor=new Color();
		this.endColor=new Color();
	}

	__class(PixelLineData,'laya.d3.core.pixelLine.PixelLineData');
	var __proto=PixelLineData.prototype;
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		this.startPosition.cloneTo(destObject.startPosition);
		this.endPosition.cloneTo(destObject.endPosition);
		this.startColor.cloneTo(destObject.startColor);
		this.endColor.cloneTo(destObject.endColor);
	}

	return PixelLineData;
})()


/**
*<code>Matrix4x4</code> 类用于创建4x4矩阵。
*/
//class laya.d3.math.Matrix4x4
var Matrix4x4=(function(){
	function Matrix4x4(m11,m12,m13,m14,m21,m22,m23,m24,m31,m32,m33,m34,m41,m42,m43,m44,elements){
		/**矩阵元素数组*/
		//this.elements=null;
		(m11===void 0)&& (m11=1);
		(m12===void 0)&& (m12=0);
		(m13===void 0)&& (m13=0);
		(m14===void 0)&& (m14=0);
		(m21===void 0)&& (m21=0);
		(m22===void 0)&& (m22=1);
		(m23===void 0)&& (m23=0);
		(m24===void 0)&& (m24=0);
		(m31===void 0)&& (m31=0);
		(m32===void 0)&& (m32=0);
		(m33===void 0)&& (m33=1);
		(m34===void 0)&& (m34=0);
		(m41===void 0)&& (m41=0);
		(m42===void 0)&& (m42=0);
		(m43===void 0)&& (m43=0);
		(m44===void 0)&& (m44=1);
		var e=elements ? this.elements=elements :this.elements=new Float32Array(16);
		e[0]=m11;
		e[1]=m12;
		e[2]=m13;
		e[3]=m14;
		e[4]=m21;
		e[5]=m22;
		e[6]=m23;
		e[7]=m24;
		e[8]=m31;
		e[9]=m32;
		e[10]=m33;
		e[11]=m34;
		e[12]=m41;
		e[13]=m42;
		e[14]=m43;
		e[15]=m44;
	}

	__class(Matrix4x4,'laya.d3.math.Matrix4x4');
	var __proto=Matrix4x4.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	__proto.setRotation=function(rotation){
		var rotationE=rotation.elements;
		var rotationX=rotationE[0];
		var rotationY=rotationE[1];
		var rotationZ=rotationE[2];
		var rotationW=rotationE[3];
		var xx=rotationX *rotationX;
		var yy=rotationY *rotationY;
		var zz=rotationZ *rotationZ;
		var xy=rotationX *rotationY;
		var zw=rotationZ *rotationW;
		var zx=rotationZ *rotationX;
		var yw=rotationY *rotationW;
		var yz=rotationY *rotationZ;
		var xw=rotationX *rotationW;
		var e=this.elements;
		e[0]=1.0-(2.0 *(yy+zz));
		e[1]=2.0 *(xy+zw);
		e[2]=2.0 *(zx-yw);
		e[4]=2.0 *(xy-zw);
		e[5]=1.0-(2.0 *(zz+xx));
		e[6]=2.0 *(yz+xw);
		e[8]=2.0 *(zx+yw);
		e[9]=2.0 *(yz-xw);
		e[10]=1.0-(2.0 *(yy+xx));
	}

	__proto.setPosition=function(position){
		var positione=position.elements;
		var e=this.elements;
		e[12]=positione[0];
		e[13]=positione[1];
		e[14]=positione[2];
	}

	__proto.getElementByRowColumn=function(row,column){
		if (row < 0 || row > 3)
			throw new Error("row","Rows and columns for matrices run from 0 to 3, inclusive.");
		if (column < 0 || column > 3)
			throw new Error("column","Rows and columns for matrices run from 0 to 3, inclusive.");
		return this.elements[(row *4)+column];
	}

	__proto.setElementByRowColumn=function(row,column,value){
		if (row < 0 || row > 3)
			throw new Error("row","Rows and columns for matrices run from 0 to 3, inclusive.");
		if (column < 0 || column > 3)
			throw new Error("column","Rows and columns for matrices run from 0 to 3, inclusive.");
		this.elements[(row *4)+column]=value;
	}

	/**
	*判断两个4x4矩阵的值是否相等。
	*@param other 4x4矩阵
	*/
	__proto.equalsOtherMatrix=function(other){
		var e=this.elements;
		var oe=other.elements;
		return (MathUtils3D.nearEqual(e[0],oe[0])&& MathUtils3D.nearEqual(e[1],oe[1])&& MathUtils3D.nearEqual(e[2],oe[2])&& MathUtils3D.nearEqual(e[3],oe[3])&& MathUtils3D.nearEqual(e[4],oe[4])&& MathUtils3D.nearEqual(e[5],oe[5])&& MathUtils3D.nearEqual(e[6],oe[6])&& MathUtils3D.nearEqual(e[7],oe[7])&& MathUtils3D.nearEqual(e[8],oe[8])&& MathUtils3D.nearEqual(e[9],oe[9])&& MathUtils3D.nearEqual(e[10],oe[10])&& MathUtils3D.nearEqual(e[11],oe[11])&& MathUtils3D.nearEqual(e[12],oe[12])&& MathUtils3D.nearEqual(e[13],oe[13])&& MathUtils3D.nearEqual(e[14],oe[14])&& MathUtils3D.nearEqual(e[15],oe[15]));
	}

	/**
	*分解矩阵为平移向量、旋转四元数、缩放向量。
	*@param translation 平移向量。
	*@param rotation 旋转四元数。
	*@param scale 缩放向量。
	*@return 是否分解成功。
	*/
	__proto.decomposeTransRotScale=function(translation,rotation,scale){
		var rotationMatrix=Matrix4x4._tempMatrix4x4;
		if (this.decomposeTransRotMatScale(translation,rotationMatrix,scale)){
			Quaternion.createFromMatrix4x4(rotationMatrix,rotation);
			return true;
			}else {
			rotation.identity();
			return false;
		}
	}

	/**
	*分解矩阵为平移向量、旋转矩阵、缩放向量。
	*@param translation 平移向量。
	*@param rotationMatrix 旋转矩阵。
	*@param scale 缩放向量。
	*@return 是否分解成功。
	*/
	__proto.decomposeTransRotMatScale=function(translation,rotationMatrix,scale){
		var e=this.elements;
		var te=translation.elements;
		var re=rotationMatrix.elements;
		var se=scale.elements;
		te[0]=e[12];
		te[1]=e[13];
		te[2]=e[14];
		var m11=e[0],m12=e[1],m13=e[2];
		var m21=e[4],m22=e[5],m23=e[6];
		var m31=e[8],m32=e[9],m33=e[10];
		var sX=se[0]=Math.sqrt((m11 *m11)+(m12 *m12)+(m13 *m13));
		var sY=se[1]=Math.sqrt((m21 *m21)+(m22 *m22)+(m23 *m23));
		var sZ=se[2]=Math.sqrt((m31 *m31)+(m32 *m32)+(m33 *m33));
		if (MathUtils3D.isZero(sX)|| MathUtils3D.isZero(sY)|| MathUtils3D.isZero(sZ)){
			re[1]=re[2]=re[3]=re[4]=re[6]=re[7]=re[8]=re[9]=re[11]=re[12]=re[13]=re[14]=0;
			re[0]=re[5]=re[10]=re[15]=1;
			return false;
		};
		var at=Matrix4x4._tempVector0;
		var atE=at.elements;
		atE[0]=m31 / sZ;
		atE[1]=m32 / sZ;
		atE[2]=m33 / sZ;
		var tempRight=Matrix4x4._tempVector1;
		var tempRightE=tempRight.elements;
		tempRightE[0]=m11 / sX;
		tempRightE[1]=m12 / sX;
		tempRightE[2]=m13 / sX;
		var up=Matrix4x4._tempVector2;
		Vector3.cross(at,tempRight,up);
		var right=Matrix4x4._tempVector1;
		Vector3.cross(up,at,right);
		re[3]=re[7]=re[11]=re[12]=re[13]=re[14]=0;
		re[15]=1;
		re[0]=right.x;
		re[1]=right.y;
		re[2]=right.z;
		re[4]=up.x;
		re[5]=up.y;
		re[6]=up.z;
		re[8]=at.x;
		re[9]=at.y;
		re[10]=at.z;
		((re[0] *m11+re[1] *m12+re[2] *m13)< 0.0)&& (se[0]=-sX);
		((re[4] *m21+re[5] *m22+re[6] *m23)< 0.0)&& (se[1]=-sY);
		((re[8] *m31+re[9] *m32+re[10] *m33)< 0.0)&& (se[2]=-sZ);
		return true;
	}

	/**
	*分解旋转矩阵的旋转为YawPitchRoll欧拉角。
	*@param out float yaw
	*@param out float pitch
	*@param out float roll
	*@return
	*/
	__proto.decomposeYawPitchRoll=function(yawPitchRoll){
		var yawPitchRollE=yawPitchRoll.elements;
		var pitch=Math.asin(-this.elements[9]);
		yawPitchRollE[1]=pitch;
		var test=Math.cos(pitch);
		if (test > MathUtils3D.zeroTolerance){
			yawPitchRollE[2]=Math.atan2(this.elements[1],this.elements[5]);
			yawPitchRollE[0]=Math.atan2(this.elements[8],this.elements[10]);
			}else {
			yawPitchRollE[2]=Math.atan2(-this.elements[4],this.elements[0]);
			yawPitchRollE[0]=0.0;
		}
	}

	/**归一化矩阵 */
	__proto.normalize=function(){
		var v=this.elements;
		var c=v[0],d=v[1],e=v[2],g=Math.sqrt(c *c+d *d+e *e);
		if (g){
			if (g==1)
				return;
			}else {
			v[0]=0;
			v[1]=0;
			v[2]=0;
			return;
		}
		g=1 / g;
		v[0]=c *g;
		v[1]=d *g;
		v[2]=e *g;
	}

	/**计算矩阵的转置矩阵*/
	__proto.transpose=function(){
		var e,t;
		e=this.elements;
		t=e[1];
		e[1]=e[4];
		e[4]=t;
		t=e[2];
		e[2]=e[8];
		e[8]=t;
		t=e[3];
		e[3]=e[12];
		e[12]=t;
		t=e[6];
		e[6]=e[9];
		e[9]=t;
		t=e[7];
		e[7]=e[13];
		e[13]=t;
		t=e[11];
		e[11]=e[14];
		e[14]=t;
		return this;
	}

	/**
	*计算一个矩阵的逆矩阵
	*@param out 输出矩阵
	*/
	__proto.invert=function(out){
		var ae=this.elements;
		var oe=out.elements;
		var a00=ae[0],a01=ae[1],a02=ae[2],a03=ae[3],a10=ae[4],a11=ae[5],a12=ae[6],a13=ae[7],a20=ae[8],a21=ae[9],a22=ae[10],a23=ae[11],a30=ae[12],a31=ae[13],a32=ae[14],a33=ae[15],
		b00=a00 *a11-a01 *a10,b01=a00 *a12-a02 *a10,b02=a00 *a13-a03 *a10,b03=a01 *a12-a02 *a11,b04=a01 *a13-a03 *a11,b05=a02 *a13-a03 *a12,b06=a20 *a31-a21 *a30,b07=a20 *a32-a22 *a30,b08=a20 *a33-a23 *a30,b09=a21 *a32-a22 *a31,b10=a21 *a33-a23 *a31,b11=a22 *a33-a23 *a32,
		det=b00 *b11-b01 *b10+b02 *b09+b03 *b08-b04 *b07+b05 *b06;
		if (Math.abs(det)===0.0){
			return;
		}
		det=1.0 / det;
		oe[0]=(a11 *b11-a12 *b10+a13 *b09)*det;
		oe[1]=(a02 *b10-a01 *b11-a03 *b09)*det;
		oe[2]=(a31 *b05-a32 *b04+a33 *b03)*det;
		oe[3]=(a22 *b04-a21 *b05-a23 *b03)*det;
		oe[4]=(a12 *b08-a10 *b11-a13 *b07)*det;
		oe[5]=(a00 *b11-a02 *b08+a03 *b07)*det;
		oe[6]=(a32 *b02-a30 *b05-a33 *b01)*det;
		oe[7]=(a20 *b05-a22 *b02+a23 *b01)*det;
		oe[8]=(a10 *b10-a11 *b08+a13 *b06)*det;
		oe[9]=(a01 *b08-a00 *b10-a03 *b06)*det;
		oe[10]=(a30 *b04-a31 *b02+a33 *b00)*det;
		oe[11]=(a21 *b02-a20 *b04-a23 *b00)*det;
		oe[12]=(a11 *b07-a10 *b09-a12 *b06)*det;
		oe[13]=(a00 *b09-a01 *b07+a02 *b06)*det;
		oe[14]=(a31 *b01-a30 *b03-a32 *b00)*det;
		oe[15]=(a20 *b03-a21 *b01+a22 *b00)*det;
	}

	/**设置矩阵为单位矩阵*/
	__proto.identity=function(){
		var e=this.elements;
		e[1]=e[2]=e[3]=e[4]=e[6]=e[7]=e[8]=e[9]=e[11]=e[12]=e[13]=e[14]=0;
		e[0]=e[5]=e[10]=e[15]=1;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var i,s,d;
		s=this.elements;
		d=destObject.elements;
		if (s===d){
			return;
		}
		for (i=0;i < 16;++i){
			d[i]=s[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*获取平移向量。
	*@param out 平移向量。
	*/
	__proto.getTranslationVector=function(out){
		var me=this.elements;
		var te=out.elements;
		te[0]=me[12];
		te[1]=me[13];
		te[2]=me[14];
	}

	/**
	*设置平移向量。
	*@param translate 平移向量。
	*/
	__proto.setTranslationVector=function(translate){
		var me=this.elements;
		var ve=translate.elements;
		me[12]=ve[0];
		me[13]=ve[1];
		me[14]=ve[2];
	}

	/**
	*获取前向量。
	*@param out 前向量。
	*/
	__proto.getForward=function(out){
		var me=this.elements;
		var te=out.elements;
		te[0]=-me[8];
		te[1]=-me[9];
		te[2]=-me[10];
	}

	/**
	*设置前向量。
	*@param forward 前向量。
	*/
	__proto.setForward=function(forward){
		var me=this.elements;
		var ve=forward.elements;
		me[8]=-ve[0];
		me[9]=-ve[1];
		me[10]=-ve[2];
	}

	Matrix4x4.createRotationX=function(rad,out){
		var oe=out.elements;
		var s=Math.sin(rad),c=Math.cos(rad);
		oe[1]=oe[2]=oe[3]=oe[4]=oe[7]=oe[8]=oe[11]=oe[12]=oe[13]=oe[14]=0;
		oe[0]=oe[15]=1;
		oe[5]=oe[10]=c;
		oe[6]=s;
		oe[9]=-s;
	}

	Matrix4x4.createRotationY=function(rad,out){
		var oe=out.elements;
		var s=Math.sin(rad),c=Math.cos(rad);
		oe[1]=oe[3]=oe[4]=oe[6]=oe[7]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
		oe[5]=oe[15]=1;
		oe[0]=oe[10]=c;
		oe[2]=-s;
		oe[8]=s;
	}

	Matrix4x4.createRotationZ=function(rad,out){
		var oe=out.elements;
		var s=Math.sin(rad),c=Math.cos(rad);
		oe[2]=oe[3]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
		oe[10]=oe[15]=1;
		oe[0]=oe[5]=c;
		oe[1]=s;
		oe[4]=-s;
	}

	Matrix4x4.createRotationYawPitchRoll=function(yaw,pitch,roll,result){
		Quaternion.createFromYawPitchRoll(yaw,pitch,roll,Matrix4x4._tempQuaternion);
		Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion,result);
	}

	Matrix4x4.createRotationAxis=function(axis,angle,result){
		var axisE=axis.elements;
		var x=axisE[0];
		var y=axisE[1];
		var z=axisE[2];
		var cos=Math.cos(angle);
		var sin=Math.sin(angle);
		var xx=x *x;
		var yy=y *y;
		var zz=z *z;
		var xy=x *y;
		var xz=x *z;
		var yz=y *z;
		var resultE=result.elements;
		resultE[3]=resultE[7]=resultE[11]=resultE[12]=resultE[13]=resultE[14]=0;
		resultE[15]=1.0;
		resultE[0]=xx+(cos *(1.0-xx));
		resultE[1]=(xy-(cos *xy))+(sin *z);
		resultE[2]=(xz-(cos *xz))-(sin *y);
		resultE[4]=(xy-(cos *xy))-(sin *z);
		resultE[5]=yy+(cos *(1.0-yy));
		resultE[6]=(yz-(cos *yz))+(sin *x);
		resultE[8]=(xz-(cos *xz))+(sin *y);
		resultE[9]=(yz-(cos *yz))-(sin *x);
		resultE[10]=zz+(cos *(1.0-zz));
	}

	Matrix4x4.createRotationQuaternion=function(rotation,result){
		var rotationE=rotation.elements;
		var resultE=result.elements;
		var rotationX=rotationE[0];
		var rotationY=rotationE[1];
		var rotationZ=rotationE[2];
		var rotationW=rotationE[3];
		var xx=rotationX *rotationX;
		var yy=rotationY *rotationY;
		var zz=rotationZ *rotationZ;
		var xy=rotationX *rotationY;
		var zw=rotationZ *rotationW;
		var zx=rotationZ *rotationX;
		var yw=rotationY *rotationW;
		var yz=rotationY *rotationZ;
		var xw=rotationX *rotationW;
		resultE[3]=resultE[7]=resultE[11]=resultE[12]=resultE[13]=resultE[14]=0;
		resultE[15]=1.0;
		resultE[0]=1.0-(2.0 *(yy+zz));
		resultE[1]=2.0 *(xy+zw);
		resultE[2]=2.0 *(zx-yw);
		resultE[4]=2.0 *(xy-zw);
		resultE[5]=1.0-(2.0 *(zz+xx));
		resultE[6]=2.0 *(yz+xw);
		resultE[8]=2.0 *(zx+yw);
		resultE[9]=2.0 *(yz-xw);
		resultE[10]=1.0-(2.0 *(yy+xx));
	}

	Matrix4x4.createTranslate=function(trans,out){
		var te=trans.elements;
		var oe=out.elements;
		oe[4]=oe[8]=oe[1]=oe[9]=oe[2]=oe[6]=oe[3]=oe[7]=oe[11]=0;
		oe[0]=oe[5]=oe[10]=oe[15]=1;
		oe[12]=te[0];
		oe[13]=te[1];
		oe[14]=te[2];
	}

	Matrix4x4.createScaling=function(scale,out){
		var se=scale.elements;
		var oe=out.elements;
		oe[0]=se[0];
		oe[5]=se[1];
		oe[10]=se[2];
		oe[1]=oe[4]=oe[8]=oe[12]=oe[9]=oe[13]=oe[2]=oe[6]=oe[14]=oe[3]=oe[7]=oe[11]=0;
		oe[15]=1;
	}

	Matrix4x4.multiply=function(left,right,out){
		var i,e,a,b,ai0,ai1,ai2,ai3;
		e=out.elements;
		a=left.elements;
		b=right.elements;
		if (e===b){
			b=new Float32Array(16);
			for (i=0;i < 16;++i){
				b[i]=e[i];
			}
		};
		var b0=b[0],b1=b[1],b2=b[2],b3=b[3];
		var b4=b[4],b5=b[5],b6=b[6],b7=b[7];
		var b8=b[8],b9=b[9],b10=b[10],b11=b[11];
		var b12=b[12],b13=b[13],b14=b[14],b15=b[15];
		for (i=0;i < 4;i++){
			ai0=a[i];
			ai1=a[i+4];
			ai2=a[i+8];
			ai3=a[i+12];
			e[i]=ai0 *b0+ai1 *b1+ai2 *b2+ai3 *b3;
			e[i+4]=ai0 *b4+ai1 *b5+ai2 *b6+ai3 *b7;
			e[i+8]=ai0 *b8+ai1 *b9+ai2 *b10+ai3 *b11;
			e[i+12]=ai0 *b12+ai1 *b13+ai2 *b14+ai3 *b15;
		}
	}

	Matrix4x4.multiplyForNative=function(left,right,out){
		LayaGL.instance.matrix4x4Multiply(left.elements,right.elements,out.elements);
	}

	Matrix4x4.createFromQuaternion=function(rotation,out){
		var e=out.elements;
		var q=rotation.elements;
		var x=q[0],y=q[1],z=q[2],w=q[3];
		var x2=x+x;
		var y2=y+y;
		var z2=z+z;
		var xx=x *x2;
		var yx=y *x2;
		var yy=y *y2;
		var zx=z *x2;
		var zy=z *y2;
		var zz=z *z2;
		var wx=w *x2;
		var wy=w *y2;
		var wz=w *z2;
		e[0]=1-yy-zz;
		e[1]=yx+wz;
		e[2]=zx-wy;
		e[3]=0;
		e[4]=yx-wz;
		e[5]=1-xx-zz;
		e[6]=zy+wx;
		e[7]=0;
		e[8]=zx+wy;
		e[9]=zy-wx;
		e[10]=1-xx-yy;
		e[11]=0;
		e[12]=0;
		e[13]=0;
		e[14]=0;
		e[15]=1;
	}

	Matrix4x4.createAffineTransformation=function(trans,rot,scale,out){
		var te=trans.elements;
		var re=rot.elements;
		var se=scale.elements;
		var oe=out.elements;
		var x=re[0],y=re[1],z=re[2],w=re[3],x2=x+x,y2=y+y,z2=z+z;
		var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
		var wx=w *x2,wy=w *y2,wz=w *z2,sx=se[0],sy=se[1],sz=se[2];
		oe[0]=(1-(yy+zz))*sx;
		oe[1]=(xy+wz)*sx;
		oe[2]=(xz-wy)*sx;
		oe[3]=0;
		oe[4]=(xy-wz)*sy;
		oe[5]=(1-(xx+zz))*sy;
		oe[6]=(yz+wx)*sy;
		oe[7]=0;
		oe[8]=(xz+wy)*sz;
		oe[9]=(yz-wx)*sz;
		oe[10]=(1-(xx+yy))*sz;
		oe[11]=0;
		oe[12]=te[0];
		oe[13]=te[1];
		oe[14]=te[2];
		oe[15]=1;
	}

	Matrix4x4.createLookAt=function(eye,target,up,out){
		var oE=out.elements;
		var xaxis=Matrix4x4._tempVector0;
		var yaxis=Matrix4x4._tempVector1;
		var zaxis=Matrix4x4._tempVector2;
		Vector3.subtract(eye,target,zaxis);
		Vector3.normalize(zaxis,zaxis);
		Vector3.cross(up,zaxis,xaxis);
		Vector3.normalize(xaxis,xaxis);
		Vector3.cross(zaxis,xaxis,yaxis);
		out.identity();
		oE[0]=xaxis.x;
		oE[4]=xaxis.y;
		oE[8]=xaxis.z;
		oE[1]=yaxis.x;
		oE[5]=yaxis.y;
		oE[9]=yaxis.z;
		oE[2]=zaxis.x;
		oE[6]=zaxis.y;
		oE[10]=zaxis.z;
		oE[12]=-Vector3.dot(xaxis,eye);
		oE[13]=-Vector3.dot(yaxis,eye);
		oE[14]=-Vector3.dot(zaxis,eye);
	}

	Matrix4x4.createPerspective=function(fov,aspect,near,far,out){
		var oe=out.elements;
		var f=1.0 / Math.tan(fov / 2),nf=1 / (near-far);
		oe[0]=f / aspect;
		oe[5]=f;
		oe[10]=(far+near)*nf;
		oe[11]=-1;
		oe[14]=(2 *far *near)*nf;
		oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[12]=oe[13]=oe[15]=0;
	}

	Matrix4x4.createOrthoOffCenterRH=function(left,right,bottom,top,near,far,out){
		var oe=out.elements;
		var lr=1 / (left-right);
		var bt=1 / (bottom-top);
		var nf=1 / (near-far);
		oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=0;
		oe[15]=1;
		oe[0]=-2 *lr;
		oe[5]=-2 *bt;
		oe[10]=2 *nf;
		oe[12]=(left+right)*lr;
		oe[13]=(top+bottom)*bt;
		oe[14]=(far+near)*nf;
	}

	Matrix4x4.billboard=function(objectPosition,cameraPosition,cameraRight,cameraUp,cameraForward,mat){
		Vector3.subtract(objectPosition,cameraPosition,Matrix4x4._tempVector0);
		var lengthSq=Vector3.scalarLengthSquared(Matrix4x4._tempVector0);
		if (MathUtils3D.isZero(lengthSq)){
			Vector3.scale(cameraForward,-1 ,Matrix4x4._tempVector1);
			Matrix4x4._tempVector1.cloneTo(Matrix4x4._tempVector0);
		}
		else{
			Vector3.scale(Matrix4x4._tempVector0,1 / Math.sqrt(lengthSq),Matrix4x4._tempVector0);
		}
		Vector3.cross(cameraUp,Matrix4x4._tempVector0,Matrix4x4._tempVector2);
		Vector3.normalize(Matrix4x4._tempVector2,Matrix4x4._tempVector2);
		Vector3.cross(Matrix4x4._tempVector0,Matrix4x4._tempVector2,Matrix4x4._tempVector3);
		var crosse=Matrix4x4._tempVector2.elements;
		var finale=Matrix4x4._tempVector3.elements;
		var diffee=Matrix4x4._tempVector0.elements;
		var obpose=objectPosition.elements;
		var mate=mat.elements;
		mate[0]=crosse[0];
		mate[1]=crosse[1];
		mate[2]=crosse[2];
		mate[3]=0.0;
		mate[4]=finale[0];
		mate[5]=finale[1];
		mate[6]=finale[2];
		mate[7]=0.0;
		mate[8]=diffee[0];
		mate[9]=diffee[1];
		mate[10]=diffee[2];
		mate[11]=0.0;
		mate[12]=obpose[0];
		mate[13]=obpose[1];
		mate[14]=obpose[2];
		mate[15]=1.0;
	}

	Matrix4x4.translation=function(v3,out){
		var ve=v3.elements;
		var oe=out.elements;
		oe[0]=oe[5]=oe[10]=oe[15]=1;
		oe[12]=ve[0];
		oe[13]=ve[1];
		oe[14]=ve[2];
	}

	__static(Matrix4x4,
	['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();},'_tempVector0',function(){return this._tempVector0=new Vector3();},'_tempVector1',function(){return this._tempVector1=new Vector3();},'_tempVector2',function(){return this._tempVector2=new Vector3();},'_tempVector3',function(){return this._tempVector3=new Vector3();},'_tempQuaternion',function(){return this._tempQuaternion=new Quaternion();},'DEFAULT',function(){return this.DEFAULT=new Matrix4x4();},'ZERO',function(){return this.ZERO=new Matrix4x4(
		0,0,0,0,
		0,0,0,0,
		0,0,0,0,
		0,0,0,0);}
	]);
	return Matrix4x4;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.GradientMode
var GradientMode=(function(){
	function GradientMode(){}
	__class(GradientMode,'laya.d3.core.GradientMode');
	GradientMode.Blend=0;
	GradientMode.Fixed=1;
	return GradientMode;
})()


/**
*<code>TextureSheetAnimation</code> 类用于创建粒子帧动画。
*/
//class laya.d3.core.particleShuriKen.module.TextureSheetAnimation
var TextureSheetAnimation=(function(){
	function TextureSheetAnimation(frame,startFrame){
		/**@private */
		this._frame=null;
		/**@private */
		this._startFrame=null;
		/**纹理平铺。*/
		this.tiles=null;
		/**类型,0为whole sheet、1为singal row。*/
		this.type=0;
		/**是否随机行，type为1时有效。*/
		this.randomRow=false;
		/**行索引,type为1时有效。*/
		this.rowIndex=0;
		/**循环次数。*/
		this.cycles=0;
		/**UV通道类型,0为Noting,1为Everything,待补充,暂不支持。*/
		this.enableUVChannels=0;
		/**是否启用*/
		this.enable=false;
		this.tiles=new Vector2(1,1);
		this.type=0;
		this.randomRow=true;
		this.rowIndex=0;
		this.cycles=1;
		this.enableUVChannels=1;
		this._frame=frame;
		this._startFrame=startFrame;
	}

	__class(TextureSheetAnimation,'laya.d3.core.particleShuriKen.module.TextureSheetAnimation');
	var __proto=TextureSheetAnimation.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destTextureSheetAnimation=destObject;
		this.tiles.cloneTo(destTextureSheetAnimation.tiles);
		destTextureSheetAnimation.type=this.type;
		destTextureSheetAnimation.randomRow=this.randomRow;
		this._frame.cloneTo(destTextureSheetAnimation._frame);
		this._startFrame.cloneTo(destTextureSheetAnimation._startFrame);
		destTextureSheetAnimation.cycles=this.cycles;
		destTextureSheetAnimation.enableUVChannels=this.enableUVChannels;
		destTextureSheetAnimation.enable=this.enable;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destFrame;
		switch (this._frame.type){
			case 0:
				destFrame=FrameOverTime.createByConstant(this._frame.constant);
				break ;
			case 1:
				destFrame=FrameOverTime.createByOverTime(this._frame.frameOverTimeData.clone());
				break ;
			case 2:
				destFrame=FrameOverTime.createByRandomTwoConstant(this._frame.constantMin,this._frame.constantMax);
				break ;
			case 3:
				destFrame=FrameOverTime.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(),this._frame.frameOverTimeDataMax.clone());
				break ;
			};
		var destStartFrame;
		switch (this._startFrame.type){
			case 0:
				destStartFrame=StartFrame.createByConstant(this._startFrame.constant);
				break ;
			case 1:
				destStartFrame=StartFrame.createByRandomTwoConstant(this._startFrame.constantMin,this._startFrame.constantMax);
				break ;
			};
		var destTextureSheetAnimation=/*__JS__ */new this.constructor(destFrame,destStartFrame);
		this.tiles.cloneTo(destTextureSheetAnimation.tiles);
		destTextureSheetAnimation.type=this.type;
		destTextureSheetAnimation.randomRow=this.randomRow;
		destTextureSheetAnimation.cycles=this.cycles;
		destTextureSheetAnimation.enableUVChannels=this.enableUVChannels;
		destTextureSheetAnimation.enable=this.enable;
		return destTextureSheetAnimation;
	}

	/**获取时间帧率。*/
	__getset(0,__proto,'frame',function(){
		return this._frame;
	});

	/**获取开始帧率。*/
	__getset(0,__proto,'startFrame',function(){
		return this._startFrame;
	});

	return TextureSheetAnimation;
})()


/**
*<code>Rand</code> 类用于通过32位无符号整型随机种子创建随机数。
*/
//class laya.d3.math.Rand
var Rand=(function(){
	function Rand(seed){
		this._temp=new Uint32Array(1);
		this.seeds=new Uint32Array(4);
		this.seeds[0]=seed;
		this.seeds[1]=this.seeds[0] *0x6C078965+1;
		this.seeds[2]=this.seeds[1] *0x6C078965+1;
		this.seeds[3]=this.seeds[2] *0x6C078965+1;
	}

	__class(Rand,'laya.d3.math.Rand');
	var __proto=Rand.prototype;
	/**
	*获取无符号32位整形随机数。
	*@return 无符号32位整形随机数。
	*/
	__proto.getUint=function(){
		this._temp[0]=this.seeds[0] ^ (this.seeds[0] << 11);
		this.seeds[0]=this.seeds[1];
		this.seeds[1]=this.seeds[2];
		this.seeds[2]=this.seeds[3];
		this.seeds[3]=(this.seeds[3] ^ (this.seeds[3] >>> 19))^ (this._temp[0] ^ (this._temp[0] >>> 8));
		return this.seeds[3];
	}

	/**
	*获取0到1之间的浮点随机数。
	*@return 0到1之间的浮点随机数。
	*/
	__proto.getFloat=function(){
		this.getUint();
		return (this.seeds[3] & 0x007FFFFF)*(1.0 / 8388607.0);
	}

	/**
	*获取-1到1之间的浮点随机数。
	*@return-1到1之间的浮点随机数。
	*/
	__proto.getSignedFloat=function(){
		return this.getFloat()*2.0-1.0;
	}

	/**
	*设置随机种子。
	*@param seed 随机种子。
	*/
	/**
	*获取随机种子。
	*@return 随机种子。
	*/
	__getset(0,__proto,'seed',function(){
		return this.seeds[0];
		},function(seed){
		this.seeds[0]=seed;
		this.seeds[1]=this.seeds[0] *0x6C078965+1;
		this.seeds[2]=this.seeds[1] *0x6C078965+1;
		this.seeds[3]=this.seeds[2] *0x6C078965+1;
	});

	Rand.getFloatFromInt=function(v){
		return (v & 0x007FFFFF)*(1.0 / 8388607.0)
	}

	Rand.getByteFromInt=function(v){
		return (v & 0x007FFFFF)>>> 15;
	}

	return Rand;
})()


/**
*<code>RenderState</code> 类用于控制渲染状态。
*/
//class laya.d3.core.material.RenderState
var RenderState=(function(){
	function RenderState(){
		/**渲染剔除状态。*/
		this.cull=0;
		/**透明混合。*/
		this.blend=0;
		/**源混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
		this.srcBlend=0;
		/**目标混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
		this.dstBlend=0;
		/**RGB源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
		this.srcBlendRGB=0;
		/**RGB目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
		this.dstBlendRGB=0;
		/**Alpha源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
		this.srcBlendAlpha=0;
		/**Alpha目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
		this.dstBlendAlpha=0;
		/**混合常量颜色。*/
		this.blendConstColor=null;
		/**混合方程。*/
		this.blendEquation=0;
		/**RGB混合方程。*/
		this.blendEquationRGB=0;
		/**Alpha混合方程。*/
		this.blendEquationAlpha=0;
		/**深度测试函数。*/
		this.depthTest=0;
		/**是否深度写入。*/
		this.depthWrite=false;
		this.cull=2;
		this.blend=0;
		this.srcBlend=1;
		this.dstBlend=0;
		this.srcBlendRGB=1;
		this.dstBlendRGB=0;
		this.srcBlendAlpha=1;
		this.dstBlendAlpha=0;
		this.blendConstColor=new Vector4(1,1,1,1);
		this.blendEquation=0;
		this.blendEquationRGB=0;
		this.blendEquationAlpha=0;
		this.depthTest=0x0203;
		this.depthWrite=true;
	}

	__class(RenderState,'laya.d3.core.material.RenderState');
	var __proto=RenderState.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*设置渲染相关状态。
	*/
	__proto._setRenderStateBlendDepth=function(){
		var gl=LayaGL.instance;
		WebGLContext.setDepthMask(gl,this.depthWrite);
		if (this.depthTest===0)
			WebGLContext.setDepthTest(gl,false);
		else {
			WebGLContext.setDepthTest(gl,true);
			WebGLContext.setDepthFunc(gl,this.depthTest);
		}
		switch (this.blend){
			case 0:
				WebGLContext.setBlend(gl,false);
				break ;
			case 1:
				WebGLContext.setBlend(gl,true);
				WebGLContext.setBlendFunc(gl,this.srcBlend,this.dstBlend);
				break ;
			case 2:
				WebGLContext.setBlend(gl,true);
				break ;
			}
	}

	/**
	*设置渲染相关状态。
	*/
	__proto._setRenderStateFrontFace=function(isTarget,transform){
		var gl=LayaGL.instance;
		var forntFace=0;
		switch (this.cull){
			case 0:
				WebGLContext.setCullFace(gl,false);
				break ;
			case 1:
				WebGLContext.setCullFace(gl,true);
				if (isTarget){
					if (transform && transform._isFrontFaceInvert)
						forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
					else
					forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
					}else {
					if (transform && transform._isFrontFaceInvert)
						forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
					else
					forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
				}
				WebGLContext.setFrontFace(gl,forntFace);
				break ;
			case 2:
				WebGLContext.setCullFace(gl,true);
				if (isTarget){
					if (transform && transform._isFrontFaceInvert)
						forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
					else
					forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
					}else {
					if (transform && transform._isFrontFaceInvert)
						forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
					else
					forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
				}
				WebGLContext.setFrontFace(gl,forntFace);
				break ;
			}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(dest){
		var destState=dest;
		destState.cull=this.cull;
		destState.blend=this.blend;
		destState.srcBlend=this.srcBlend;
		destState.dstBlend=this.dstBlend;
		destState.srcBlendRGB=this.srcBlendRGB;
		destState.dstBlendRGB=this.dstBlendRGB;
		destState.srcBlendAlpha=this.srcBlendAlpha;
		destState.dstBlendAlpha=this.dstBlendAlpha;
		this.blendConstColor.cloneTo(destState.blendConstColor);
		destState.blendEquation=this.blendEquation;
		destState.blendEquationRGB=this.blendEquationRGB;
		destState.blendEquationAlpha=this.blendEquationAlpha;
		destState.depthTest=this.depthTest;
		destState.depthWrite=this.depthWrite;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	RenderState.CULL_NONE=0;
	RenderState.CULL_FRONT=1;
	RenderState.CULL_BACK=2;
	RenderState.BLEND_DISABLE=0;
	RenderState.BLEND_ENABLE_ALL=1;
	RenderState.BLEND_ENABLE_SEPERATE=2;
	RenderState.BLENDPARAM_ZERO=0;
	RenderState.BLENDPARAM_ONE=1;
	RenderState.BLENDPARAM_SRC_COLOR=0x0300;
	RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR=0x0301;
	RenderState.BLENDPARAM_DST_COLOR=0x0306;
	RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR=0x0307;
	RenderState.BLENDPARAM_SRC_ALPHA=0x0302;
	RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA=0x0303;
	RenderState.BLENDPARAM_DST_ALPHA=0x0304;
	RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA=0x0305;
	RenderState.BLENDPARAM_SRC_ALPHA_SATURATE=0x0308;
	RenderState.BLENDEQUATION_ADD=0;
	RenderState.BLENDEQUATION_SUBTRACT=1;
	RenderState.BLENDEQUATION_REVERSE_SUBTRACT=2;
	RenderState.DEPTHTEST_OFF=0;
	RenderState.DEPTHTEST_NEVER=0x0200;
	RenderState.DEPTHTEST_LESS=0x0201;
	RenderState.DEPTHTEST_EQUAL=0x0202;
	RenderState.DEPTHTEST_LEQUAL=0x0203;
	RenderState.DEPTHTEST_GREATER=0x0204;
	RenderState.DEPTHTEST_NOTEQUAL=0x0205;
	RenderState.DEPTHTEST_GEQUAL=0x0206;
	RenderState.DEPTHTEST_ALWAYS=0x0207;
	return RenderState;
})()


/**
*<code>GradientVelocity</code> 类用于创建渐变速度。
*/
//class laya.d3.core.particleShuriKen.module.GradientVelocity
var GradientVelocity=(function(){
	function GradientVelocity(){
		/**@private */
		this._type=0;
		/**@private */
		this._constant=null;
		/**@private */
		this._gradientX=null;
		/**@private */
		this._gradientY=null;
		/**@private */
		this._gradientZ=null;
		/**@private */
		this._constantMin=null;
		/**@private */
		this._constantMax=null;
		/**@private */
		this._gradientXMin=null;
		/**@private */
		this._gradientXMax=null;
		/**@private */
		this._gradientYMin=null;
		/**@private */
		this._gradientYMax=null;
		/**@private */
		this._gradientZMin=null;
		/**@private */
		this._gradientZMax=null;
	}

	__class(GradientVelocity,'laya.d3.core.particleShuriKen.module.GradientVelocity');
	var __proto=GradientVelocity.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientVelocity=destObject;
		destGradientVelocity._type=this._type;
		this._constant.cloneTo(destGradientVelocity._constant);
		this._gradientX.cloneTo(destGradientVelocity._gradientX);
		this._gradientY.cloneTo(destGradientVelocity._gradientY);
		this._gradientZ.cloneTo(destGradientVelocity._gradientZ);
		this._constantMin.cloneTo(destGradientVelocity._constantMin);
		this._constantMax.cloneTo(destGradientVelocity._constantMax);
		this._gradientXMin.cloneTo(destGradientVelocity._gradientXMin);
		this._gradientXMax.cloneTo(destGradientVelocity._gradientXMax);
		this._gradientYMin.cloneTo(destGradientVelocity._gradientYMin);
		this._gradientYMax.cloneTo(destGradientVelocity._gradientYMax);
		this._gradientZMin.cloneTo(destGradientVelocity._gradientZMin);
		this._gradientZMax.cloneTo(destGradientVelocity._gradientZMax);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientVelocity=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientVelocity);
		return destGradientVelocity;
	}

	/**
	*渐变速度Z。
	*/
	__getset(0,__proto,'gradientZ',function(){
		return this._gradientZ;
	});

	/**固定速度。*/
	__getset(0,__proto,'constant',function(){
		return this._constant;
	});

	/**
	*生命周期速度类型，0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
	*/
	__getset(0,__proto,'type',function(){
		return this._type;
	});

	/**
	*渐变最大速度X。
	*/
	__getset(0,__proto,'gradientXMax',function(){
		return this._gradientXMax;
	});

	/**最小固定速度。*/
	__getset(0,__proto,'constantMin',function(){
		return this._constantMin;
	});

	/**
	*渐变速度X。
	*/
	__getset(0,__proto,'gradientX',function(){
		return this._gradientX;
	});

	/**
	*渐变速度Y。
	*/
	__getset(0,__proto,'gradientY',function(){
		return this._gradientY;
	});

	/**
	*渐变最小速度X。
	*/
	__getset(0,__proto,'gradientXMin',function(){
		return this._gradientXMin;
	});

	/**最大固定速度。*/
	__getset(0,__proto,'constantMax',function(){
		return this._constantMax;
	});

	/**
	*渐变最小速度Y。
	*/
	__getset(0,__proto,'gradientYMin',function(){
		return this._gradientYMin;
	});

	/**
	*渐变最大速度Y。
	*/
	__getset(0,__proto,'gradientYMax',function(){
		return this._gradientYMax;
	});

	/**
	*渐变最小速度Z。
	*/
	__getset(0,__proto,'gradientZMin',function(){
		return this._gradientZMin;
	});

	/**
	*渐变最大速度Z。
	*/
	__getset(0,__proto,'gradientZMax',function(){
		return this._gradientZMax;
	});

	GradientVelocity.createByConstant=function(constant){
		var gradientVelocity=new GradientVelocity();
		gradientVelocity._type=0;
		gradientVelocity._constant=constant;
		return gradientVelocity;
	}

	GradientVelocity.createByGradient=function(gradientX,gradientY,gradientZ){
		var gradientVelocity=new GradientVelocity();
		gradientVelocity._type=1;
		gradientVelocity._gradientX=gradientX;
		gradientVelocity._gradientY=gradientY;
		gradientVelocity._gradientZ=gradientZ;
		return gradientVelocity;
	}

	GradientVelocity.createByRandomTwoConstant=function(constantMin,constantMax){
		var gradientVelocity=new GradientVelocity();
		gradientVelocity._type=2;
		gradientVelocity._constantMin=constantMin;
		gradientVelocity._constantMax=constantMax;
		return gradientVelocity;
	}

	GradientVelocity.createByRandomTwoGradient=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
		var gradientVelocity=new GradientVelocity();
		gradientVelocity._type=3;
		gradientVelocity._gradientXMin=gradientXMin;
		gradientVelocity._gradientXMax=gradientXMax;
		gradientVelocity._gradientYMin=gradientYMin;
		gradientVelocity._gradientYMax=gradientYMax;
		gradientVelocity._gradientZMin=gradientZMin;
		gradientVelocity._gradientZMax=gradientZMax;
		return gradientVelocity;
	}

	return GradientVelocity;
})()


/**
*<code>MeshFilter</code> 类用于创建网格过滤器。
*/
//class laya.d3.core.MeshFilter
var MeshFilter=(function(){
	function MeshFilter(owner){
		/**@private */
		this._owner=null;
		/**@private */
		this._sharedMesh=null;
		this._owner=owner;
	}

	__class(MeshFilter,'laya.d3.core.MeshFilter');
	var __proto=MeshFilter.prototype;
	/**
	*@private
	*/
	__proto._getMeshDefine=function(mesh){
		var define=0;
		for (var i=0,n=mesh._subMeshCount;i < n;i++){
			var subMesh=mesh._getSubMesh(i);
			var vertexElements=subMesh._vertexBuffer._vertexDeclaration.vertexElements;
			for (var j=0,m=vertexElements.length;j < m;j++){
				var vertexElement=vertexElements[j];
				var name=vertexElement.elementUsage;
				switch (name){
					case /*laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1:
						define |=MeshSprite3D.SHADERDEFINE_COLOR;
						break
					case /*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2:
						define |=MeshSprite3D.SHADERDEFINE_UV0;
						break ;
					case /*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE1*/8:
						define |=MeshSprite3D.SHADERDEFINE_UV1;
						break ;
					}
			}
		}
		return define;
	}

	/**
	*@private
	*/
	__proto._changeRenderObjectsByMesh=function(){
		var renderElementsCount=this._sharedMesh.subMeshCount;
		this._owner._render._renderElements.length=renderElementsCount;
		for (var i=0;i < renderElementsCount;i++){
			var render=this._owner._render;
			var elements=render._renderElements;
			var renderElement=elements[i];
			if (renderElement){
				renderElement.setGeometry(this._sharedMesh._getSubMesh(i));
				}else {
				var material=render.sharedMaterials[i];
				(material)|| (material=BlinnPhongMaterial.defaultMaterial);
				renderElement=elements[i]=new SubMeshRenderElement();
				renderElement.setTransform(this._owner._transform);
				renderElement.render=render;
				renderElement.material=material;
				renderElement.setGeometry(this._sharedMesh._getSubMesh(i));
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		this._owner=null;
		(this._sharedMesh)&& (this._sharedMesh._removeReference(),this._sharedMesh=null);
	}

	/**
	*设置共享网格。
	*@return value 共享网格。
	*/
	/**
	*获取共享网格。
	*@return 共享网格。
	*/
	__getset(0,__proto,'sharedMesh',function(){
		return this._sharedMesh;
		},function(value){
		if (this._sharedMesh!==value){
			var defineDatas=this._owner._render._defineDatas;
			var lastValue=this._sharedMesh;
			if (lastValue){
				lastValue._removeReference();
				defineDatas.remove(this._getMeshDefine(lastValue));
			}
			value._addReference();
			this._sharedMesh=value;
			defineDatas.add(this._getMeshDefine(value));
			this._changeRenderObjectsByMesh();
		}
		(this._owner._render)._onMeshChange(value);
	});

	return MeshFilter;
})()


/**
*<code>MathUtils</code> 类用于创建数学工具。
*/
//class laya.d3.math.MathUtils3D
var MathUtils3D=(function(){
	/**
	*创建一个 <code>MathUtils</code> 实例。
	*/
	function MathUtils3D(){}
	__class(MathUtils3D,'laya.d3.math.MathUtils3D');
	MathUtils3D.isZero=function(v){
		return Math.abs(v)< MathUtils3D.zeroTolerance;
	}

	MathUtils3D.nearEqual=function(n1,n2){
		if (MathUtils3D.isZero(n1-n2))
			return true;
		return false;
	}

	MathUtils3D.fastInvSqrt=function(value){
		if (MathUtils3D.isZero(value))
			return value;
		return 1.0 / Math.sqrt(value);
	}

	__static(MathUtils3D,
	['zeroTolerance',function(){return this.zeroTolerance=1e-6;},'MaxValue',function(){return this.MaxValue=3.40282347e+38;},'MinValue',function(){return this.MinValue=-3.40282347e+38;}
	]);
	return MathUtils3D;
})()


/**
*<code>MaterialInfo</code> 类用于描述地形材质信息。
*/
//class laya.d3.terrain.unit.MaterialInfo
var MaterialInfo=(function(){
	function MaterialInfo(){
		this.ambientColor=null;
		this.diffuseColor=null;
		this.specularColor=null;
		;
	}

	__class(MaterialInfo,'laya.d3.terrain.unit.MaterialInfo');
	return MaterialInfo;
})()


/**
*@private
*/
//class laya.d3.shader.ShaderData
var ShaderData=(function(){
	function ShaderData(ownerResource){
		/**@private */
		//this._ownerResource=null;
		/**@private */
		//this._data=null;
		/**@private [NATIVE]*/
		//this._int32Data=null;
		/**@private [NATIVE]*/
		//this._float32Data=null;
		/**@private [NATIVE]*/
		//this._nativeArray=null;
		/**@private [NATIVE]*/
		//this._frameCount=0;
		/**@private [NATIVE]*/
		this._runtimeCopyValues=[];
		this._ownerResource=ownerResource;
		this._initData();
	}

	__class(ShaderData,'laya.d3.shader.ShaderData');
	var __proto=ShaderData.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._initData=function(){
		this._data=new Object();
	}

	/**
	*获取布尔。
	*@param index shader索引。
	*@return 布尔。
	*/
	__proto.getBool=function(index){
		return this._data[index];
	}

	/**
	*设置布尔。
	*@param index shader索引。
	*@param value 布尔。
	*/
	__proto.setBool=function(index,value){
		this._data[index]=value;
	}

	/**
	*获取整形。
	*@param index shader索引。
	*@return 整形。
	*/
	__proto.getInt=function(index){
		return this._data[index];
	}

	/**
	*设置整型。
	*@param index shader索引。
	*@param value 整形。
	*/
	__proto.setInt=function(index,value){
		this._data[index]=value;
	}

	/**
	*获取浮点。
	*@param index shader索引。
	*@return 浮点。
	*/
	__proto.getNumber=function(index){
		return this._data[index];
	}

	/**
	*设置浮点。
	*@param index shader索引。
	*@param value 浮点。
	*/
	__proto.setNumber=function(index,value){
		this._data[index]=value;
	}

	/**
	*获取颜色。
	*@param index shader索引。
	*@return 颜色向量。
	*/
	__proto.getVector=function(index){
		return this._data[index];
	}

	/**
	*设置向量。
	*@param index shader索引。
	*@param value 向量。
	*/
	__proto.setVector=function(index,value){
		this._data[index]=value;
	}

	/**
	*获取四元数。
	*@param index shader索引。
	*@return 四元。
	*/
	__proto.getQuaternion=function(index){
		return this._data[index];
	}

	/**
	*设置四元数。
	*@param index shader索引。
	*@param value 四元数。
	*/
	__proto.setQuaternion=function(index,value){
		this._data[index]=value;
	}

	/**
	*获取矩阵。
	*@param index shader索引。
	*@return 矩阵。
	*/
	__proto.getMatrix4x4=function(index){
		return this._data[index];
	}

	/**
	*设置矩阵。
	*@param index shader索引。
	*@param value 矩阵。
	*/
	__proto.setMatrix4x4=function(index,value){
		this._data[index]=value;
	}

	/**
	*获取Buffer。
	*@param index shader索引。
	*@return
	*/
	__proto.getBuffer=function(shaderIndex){
		return this._data[shaderIndex];
	}

	/**
	*设置Buffer。
	*@param index shader索引。
	*@param value buffer数据。
	*/
	__proto.setBuffer=function(index,value){
		this._data[index]=value;
	}

	/**
	*设置纹理。
	*@param index shader索引。
	*@param value 纹理。
	*/
	__proto.setTexture=function(index,value){
		var lastValue=this._data[index];
		this._data[index]=value;
		if (this._ownerResource && this._ownerResource.referenceCount > 0){
			(lastValue)&& (lastValue._removeReference());
			(value)&& (value._addReference());
		}
	}

	/**
	*获取纹理。
	*@param index shader索引。
	*@return 纹理。
	*/
	__proto.getTexture=function(index){
		return this._data[index];
	}

	/**
	*设置Attribute。
	*@param index shader索引。
	*@param value 纹理。
	*/
	__proto.setAttribute=function(index,value){
		this._data[index]=value;
	}

	/**
	*获取Attribute。
	*@param index shader索引。
	*@return 纹理。
	*/
	__proto.getAttribute=function(index){
		return this._data[index];
	}

	/**
	*获取长度。
	*@return 长度。
	*/
	__proto.getLength=function(){
		return this._data.length;
	}

	/**
	*设置长度。
	*@param 长度。
	*/
	__proto.setLength=function(value){
		this._data.length=value;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		var destData=dest._data;
		for (var k in this._data){
			var value=this._data[k];
			if (value){
				if ((typeof value=='number')){
					destData[k]=value;
					}else if (((typeof value=='number')&& Math.floor(value)==value)){
					destData[k]=value;
					}else if ((typeof value=='boolean')){
					destData[k]=value;
					}else if ((value instanceof laya.d3.math.Vector2 )){
					var v2=(destData[k])|| (destData[k]=new Vector2());
					(value).cloneTo(v2);
					destData[k]=v2;
					}else if ((value instanceof laya.d3.math.Vector3 )){
					var v3=(destData[k])|| (destData[k]=new Vector3());
					(value).cloneTo(v3);
					destData[k]=v3;
					}else if ((value instanceof laya.d3.math.Vector4 )){
					var v4=(destData[k])|| (destData[k]=new Vector4());
					(value).cloneTo(v4);
					destData[k]=v4;
					}else if ((value instanceof laya.d3.math.Matrix4x4 )){
					var mat=(destData[k])|| (destData[k]=new Matrix4x4());
					(value).cloneTo(mat);
					destData[k]=mat;
					}else if ((value instanceof laya.webgl.resource.BaseTexture )){
					destData[k]=value;
				}
			}
		}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneToForNative=function(destObject){
		var dest=destObject;
		var diffSize=this._int32Data.length-dest._int32Data.length;
		if (diffSize > 0){
			dest.needRenewArrayBufferForNative(this._int32Data.length);
		}
		dest._int32Data.set(this._int32Data,0);
		var destData=dest._nativeArray;
		var dataCount=this._nativeArray.length;
		destData.length=dataCount;
		for (var i=0;i < dataCount;i++){
			var value=this._nativeArray[i];
			if (value){
				if ((typeof value=='number')){
					destData[i]=value;
					dest.setNumber(i,value);
					}else if (((typeof value=='number')&& Math.floor(value)==value)){
					destData[i]=value;
					dest.setInt(i,value);
					}else if ((typeof value=='boolean')){
					destData[i]=value;
					dest.setBool(i,value);
					}else if ((value instanceof laya.d3.math.Vector2 )){
					var v2=(destData[i])|| (destData[i]=new Vector2());
					(value).cloneTo(v2);
					destData[i]=v2;
					dest.setVector(i,v2);
					}else if ((value instanceof laya.d3.math.Vector3 )){
					var v3=(destData[i])|| (destData[i]=new Vector3());
					(value).cloneTo(v3);
					destData[i]=v3;
					dest.setVector(i,v3);
					}else if ((value instanceof laya.d3.math.Vector4 )){
					var v4=(destData[i])|| (destData[i]=new Vector4());
					(value).cloneTo(v4);
					destData[i]=v4;
					dest.setVector(i,v4);
					}else if ((value instanceof laya.d3.math.Matrix4x4 )){
					var mat=(destData[i])|| (destData[i]=new Matrix4x4());
					(value).cloneTo(mat);
					destData[i]=mat;
					dest.setMatrix4x4(i,mat);
					}else if ((value instanceof laya.webgl.resource.BaseTexture )){
					destData[i]=value;
					dest.setTexture(i,value);
				}
			}
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*@private [NATIVE]
	*/
	__proto._initDataForNative=function(){
		var length=8;
		if (!length){
			alert("ShaderData _initDataForNative error length=0");
		}
		this._frameCount=-1;
		this._runtimeCopyValues.length=0;
		this._nativeArray=[];
		this._data=new ArrayBuffer(length *4);
		this._int32Data=new Int32Array(this._data);
		this._float32Data=new Float32Array(this._data);
		LayaGL.createArrayBufferRef(this._data,/*laya.layagl.LayaGL.ARRAY_BUFFER_TYPE_DATA*/0,true);
	}

	__proto.needRenewArrayBufferForNative=function(index){
		if (index >=this._int32Data.length){
			var nByteLen=(index+1)*4;
			var pre=this._int32Data;
			var preConchRef=this._data["conchRef"];
			var prePtrID=this._data["_ptrID"];
			this._data=new ArrayBuffer(nByteLen);
			this._int32Data=new Int32Array(this._data);
			this._float32Data=new Float32Array(this._data);
			this._data["conchRef"]=preConchRef;
			this._data["_ptrID"]=prePtrID;
			pre && this._int32Data.set(pre,0);
			/*__JS__ */conch.updateArrayBufferRef(this._data['_ptrID'],preConchRef.isSyncToRender(),this._data);
		}
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getIntForNative=function(index){
		return this._int32Data[index];
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setIntForNative=function(index,value){
		this.needRenewArrayBufferForNative(index);
		this._int32Data[index]=value;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getBoolForNative=function(index){
		return this._int32Data[index]==1;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setBoolForNative=function(index,value){
		this.needRenewArrayBufferForNative(index);
		this._int32Data[index]=value;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getNumberForNative=function(index){
		return this._float32Data[index];
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setNumberForNative=function(index,value){
		this.needRenewArrayBufferForNative(index);
		this._float32Data[index]=value;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getMatrix4x4ForNative=function(index){
		alert("ShaderData getMatrix4x4 can't support");
		return null;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setMatrix4x4ForNative=function(index,value){
		this.needRenewArrayBufferForNative(index);
		this._nativeArray[index]=value;
		var nPtrID=this.setReferenceForNative(value.elements);
		this._int32Data[index]=nPtrID;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getVectorForNative=function(index){
		return this._nativeArray[index];
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setVectorForNative=function(index,value){
		this.needRenewArrayBufferForNative(index);
		this._nativeArray[index]=value;
		var nPtrID=this.setReferenceForNative(value.elements);
		this._int32Data[index]=nPtrID;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getQuaternionForNative=function(index){
		alert("ShaderData getQuaternion can't support");
		return null;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setQuaternionForNative=function(index,value){
		this.needRenewArrayBufferForNative(index);
		this._nativeArray[index]=value;
		var nPtrID=this.setReferenceForNative(value.elements);
		this._int32Data[index]=nPtrID;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getBufferForNative=function(shaderIndex){
		alert("ShaderData getBuffer can't support");
		return null;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setBufferForNative=function(index,value){
		this.needRenewArrayBufferForNative(index);
		this._nativeArray[index]=value;
		var nPtrID=this.setReferenceForNative(value);
		this._int32Data[index]=nPtrID;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getAttributeForNative=function(index){
		alert("ShaderData  getAttribute can't support");
		return null;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setAttributeForNative=function(index,value){
		this._nativeArray[index]=value;
		if (!value["_ptrID"]){
			LayaGL.createArrayBufferRef(value,/*laya.layagl.LayaGL.ARRAY_BUFFER_TYPE_DATA*/0,true);
		}
		LayaGL.syncBufferToRenderThread(value);
		this._int32Data[index]=value["_ptrID"];
	}

	/**
	*@private [NATIVE]
	*/
	__proto.getTextureForNative=function(index){
		alert("ShaderData getTexture can't support");
		return null;
	}

	/**
	*@private [NATIVE]
	*/
	__proto.setTextureForNative=function(index,value){
		if (!value)return;
		this.needRenewArrayBufferForNative(index);
		this._nativeArray[index]=value;
		var lastValue=this._nativeArray[index];
		this._int32Data[index]=value._getSource().id;
		if (this._ownerResource && this._ownerResource.referenceCount > 0){
			(lastValue)&& (lastValue._removeReference());
			(value)&& (value._addReference());
		}
	}

	__proto.setReferenceForNative=function(value){
		this.clearRuntimeCopyArray();
		var nRefID=0;
		var nPtrID=0;
		if (ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_){
			LayaGL.createArrayBufferRefs(value,/*laya.layagl.LayaGL.ARRAY_BUFFER_TYPE_DATA*/0,true,/*laya.layagl.LayaGL.ARRAY_BUFFER_REF_REFERENCE*/0);
			nRefID=0;
			nPtrID=value.getPtrID(nRefID);
			}else {
			LayaGL.createArrayBufferRefs(value,/*laya.layagl.LayaGL.ARRAY_BUFFER_TYPE_DATA*/0,true,/*laya.layagl.LayaGL.ARRAY_BUFFER_REF_COPY*/1);
			nRefID=value.getRefNum()-1;
			nPtrID=value.getPtrID(nRefID);
			this._runtimeCopyValues.push({"obj":value,"refID":nRefID,"ptrID":nPtrID});
		}
		LayaGL.syncBufferToRenderThread(value,nRefID);
		return nPtrID;
	}

	__proto.clearRuntimeCopyArray=function(){
		var currentFrame=LayaGL.getFrameCount();
		if (this._frameCount !=currentFrame){
			this._frameCount=currentFrame;
			for (var i=0,n=this._runtimeCopyValues.length;i < n;i++){
				var obj=this._runtimeCopyValues[i];
				obj.obj.clearRefNum();
			}
			this._runtimeCopyValues.length=0;
		}
	}

	ShaderData.setRuntimeValueMode=function(bReference){
		ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_=bReference;
	}

	ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_=true;
	return ShaderData;
})()


/**
*<code>KeyframeNodeList</code> 类用于创建KeyframeNode节点队列。
*/
//class laya.d3.animation.KeyframeNodeList
var KeyframeNodeList=(function(){
	function KeyframeNodeList(){
		this._nodes=[];
	}

	__class(KeyframeNodeList,'laya.d3.animation.KeyframeNodeList');
	var __proto=KeyframeNodeList.prototype;
	/**
	*通过索引获取节点。
	*@param index 索引。
	*@return 节点。
	*/
	__proto.getNodeByIndex=function(index){
		return this._nodes[index];
	}

	/**
	*通过索引设置节点。
	*@param index 索引。
	*@param 节点。
	*/
	__proto.setNodeByIndex=function(index,node){
		this._nodes[index]=node;
	}

	/**
	*设置节点个数。
	*@param value 节点个数。
	*/
	/**
	*获取节点个数。
	*@return 节点个数。
	*/
	__getset(0,__proto,'count',function(){
		return this._nodes.length;
		},function(value){
		this._nodes.length=value;
	});

	return KeyframeNodeList;
})()


/**
*<code>HalfFloatUtils</code> 类用于创建HalfFloat工具。
*/
//class laya.d3.math.HalfFloatUtils
var HalfFloatUtils=(function(){
	function HalfFloatUtils(){}
	__class(HalfFloatUtils,'laya.d3.math.HalfFloatUtils');
	HalfFloatUtils.__init__=function(){
		for (var i=0;i < 256;++i){
			var e=i-127;
			if (e <-27){
				HalfFloatUtils._baseTable[i | 0x000]=0x0000;
				HalfFloatUtils._baseTable[i | 0x100]=0x8000;
				HalfFloatUtils._shiftTable[i | 0x000]=24;
				HalfFloatUtils._shiftTable[i | 0x100]=24;
				}else if (e <-14){
				HalfFloatUtils._baseTable[i | 0x000]=0x0400 >> (-e-14);
				HalfFloatUtils._baseTable[i | 0x100]=(0x0400 >> (-e-14))| 0x8000;
				HalfFloatUtils._shiftTable[i | 0x000]=-e-1;
				HalfFloatUtils._shiftTable[i | 0x100]=-e-1;
				}else if (e <=15){
				HalfFloatUtils._baseTable[i | 0x000]=(e+15)<< 10;
				HalfFloatUtils._baseTable[i | 0x100]=((e+15)<< 10)| 0x8000;
				HalfFloatUtils._shiftTable[i | 0x000]=13;
				HalfFloatUtils._shiftTable[i | 0x100]=13;
				}else if (e < 128){
				HalfFloatUtils._baseTable[i | 0x000]=0x7c00;
				HalfFloatUtils._baseTable[i | 0x100]=0xfc00;
				HalfFloatUtils._shiftTable[i | 0x000]=24;
				HalfFloatUtils._shiftTable[i | 0x100]=24;
				}else {
				HalfFloatUtils._baseTable[i | 0x000]=0x7c00;
				HalfFloatUtils._baseTable[i | 0x100]=0xfc00;
				HalfFloatUtils._shiftTable[i | 0x000]=13;
				HalfFloatUtils._shiftTable[i | 0x100]=13;
			}
		}
		HalfFloatUtils._mantissaTable[0]=0;
		for (i=1;i < 1024;++i){
			var m=i << 13;
			e=0;
			while ((m & 0x00800000)===0){
				e-=0x00800000;
				m <<=1;
			}
			m &=~0x00800000;
			e+=0x38800000;
			HalfFloatUtils._mantissaTable[i]=m | e;
		}
		for (i=1024;i < 2048;++i){
			HalfFloatUtils._mantissaTable[i]=0x38000000+((i-1024)<< 13);
		}
		HalfFloatUtils._exponentTable[0]=0;
		for (i=1;i < 31;++i){
			HalfFloatUtils._exponentTable[i]=i << 23;
		}
		HalfFloatUtils._exponentTable[31]=0x47800000;
		HalfFloatUtils._exponentTable[32]=0x80000000;
		for (i=33;i < 63;++i){
			HalfFloatUtils._exponentTable[i]=0x80000000+((i-32)<< 23);
		}
		HalfFloatUtils._exponentTable[63]=0xc7800000;
		HalfFloatUtils._offsetTable[0]=0;
		for (i=1;i < 64;++i){
			if (i===32){
				HalfFloatUtils._offsetTable[i]=0;
				}else {
				HalfFloatUtils._offsetTable[i]=1024;
			}
		}
	}

	HalfFloatUtils.roundToFloat16Bits=function(num){
		HalfFloatUtils._floatView[0]=num;
		var f=HalfFloatUtils._uint32View[0];
		var e=(f >> 23)& 0x1ff;
		return HalfFloatUtils._baseTable[e]+((f & 0x007fffff)>> HalfFloatUtils._shiftTable[e]);
	}

	HalfFloatUtils.convertToNumber=function(float16bits){
		var m=float16bits >> 10;
		HalfFloatUtils._uint32View[0]=HalfFloatUtils._mantissaTable[HalfFloatUtils._offsetTable[m]+(float16bits & 0x3ff)]+HalfFloatUtils._exponentTable[m];
		return HalfFloatUtils._floatView[0];
	}

	__static(HalfFloatUtils,
	['_buffer',function(){return this._buffer=new ArrayBuffer(4);},'_floatView',function(){return this._floatView=new Float32Array(HalfFloatUtils._buffer);},'_uint32View',function(){return this._uint32View=new Uint32Array(HalfFloatUtils._buffer);},'_baseTable',function(){return this._baseTable=new Uint32Array(512);},'_shiftTable',function(){return this._shiftTable=new Uint32Array(512);},'_mantissaTable',function(){return this._mantissaTable=new Uint32Array(2048);},'_exponentTable',function(){return this._exponentTable=new Uint32Array(64);},'_offsetTable',function(){return this._offsetTable=new Uint32Array(64);}
	]);
	return HalfFloatUtils;
})()


/**
*...
*@author ...
*/
//class laya.d3.physics.Constraint3D
var Constraint3D=(function(){
	function Constraint3D(){
		/**@private */
		this._nativeConstraint=null;
		/**@private */
		this._simulation=null;
		/**获取刚体A。[只读]*/
		this.rigidbodyA=null;
		/**获取刚体A。[只读]*/
		this.rigidbodyB=null;
	}

	__class(Constraint3D,'laya.d3.physics.Constraint3D');
	return Constraint3D;
})()


/**
*@private
*/
//class laya.d3.MouseTouch
var MouseTouch=(function(){
	function MouseTouch(){
		/**@private */
		this._pressedSprite=null;
		/**@private */
		this._pressedLoopCount=-1;
		/**@private */
		this.sprite=null;
		/**@private */
		this.mousePositionX=0;
		/**@private */
		this.mousePositionY=0;
	}

	__class(MouseTouch,'laya.d3.MouseTouch');
	return MouseTouch;
})()


/**
*<code>CollisionMap</code> 类用于实现碰撞组合实例图。
*/
//class laya.d3.physics.CollisionTool
var CollisionTool=(function(){
	function CollisionTool(){
		/**@private */
		this._hitResultsPoolIndex=0;
		/**@private */
		this._contactPonintsPoolIndex=0;
		/**@private */
		this._collisions={};
		this._hitResultsPool=[];
		this._contactPointsPool=[];
		this._collisionsPool=[];
	}

	__class(CollisionTool,'laya.d3.physics.CollisionTool');
	var __proto=CollisionTool.prototype;
	/**
	*@private
	*/
	__proto.getHitResult=function(){
		var hitResult=this._hitResultsPool[this._hitResultsPoolIndex++];
		if (!hitResult){
			hitResult=new HitResult();
			this._hitResultsPool.push(hitResult);
		}
		return hitResult;
	}

	/**
	*@private
	*/
	__proto.recoverAllHitResultsPool=function(){
		this._hitResultsPoolIndex=0;
	}

	/**
	*@private
	*/
	__proto.getContactPoints=function(){
		var contactPoint=this._contactPointsPool[this._contactPonintsPoolIndex++];
		if (!contactPoint){
			contactPoint=new ContactPoint();
			this._contactPointsPool.push(contactPoint);
		}
		return contactPoint;
	}

	/**
	*@private
	*/
	__proto.recoverAllContactPointsPool=function(){
		this._contactPonintsPoolIndex=0;
	}

	/**
	*@private
	*/
	__proto.getCollision=function(physicComponentA,physicComponentB){
		var collision;
		var idA=physicComponentA.id;
		var idB=physicComponentB.id;
		var subCollisionFirst=this._collisions[idA];
		if (subCollisionFirst)
			collision=subCollisionFirst[idB];
		if (!collision){
			if (!subCollisionFirst){
				subCollisionFirst={};
				this._collisions[idA]=subCollisionFirst;
			}
			collision=this._collisionsPool.length===0 ? new Collision():this._collisionsPool.pop();
			collision._colliderA=physicComponentA;
			collision._colliderB=physicComponentB;
			subCollisionFirst[idB]=collision;
		}
		return collision;
	}

	/**
	*@private
	*/
	__proto.recoverCollision=function(collision){
		var idA=collision._colliderA.id;
		var idB=collision._colliderB.id;
		this._collisions[idA][idB]=null;
		this._collisionsPool.push(collision);
	}

	/**
	*@private
	*/
	__proto.garbageCollection=function(){
		this._hitResultsPoolIndex=0;
		this._hitResultsPool.length=0;
		this._contactPonintsPoolIndex=0;
		this._contactPointsPool.length=0;
		this._collisionsPool.length=0;
		for (var subCollisionsKey in this._collisionsPool){
			var subCollisions=this._collisionsPool[subCollisionsKey];
			var wholeDelete=true;
			for (var collisionKey in subCollisions){
				if (subCollisions[collisionKey])
					wholeDelete=false;
				else
				delete subCollisions[collisionKey];
			}
			if (wholeDelete)
				delete this._collisionsPool[subCollisionsKey];
		}
	}

	return CollisionTool;
})()


/**
*<code>BoneNode</code> 类用于实现骨骼节点。
*/
//class laya.d3.animation.AnimationNode
var AnimationNode=(function(){
	function AnimationNode(localPosition,localRotation,localScale,worldMatrix){
		/**@private */
		//this._children=null;
		/**@private */
		//this._parent=null;
		/**@private [只读]*/
		//this.transform=null;
		/**节点名称。 */
		//this.name=null;
		/**@private [NATIVE]*/
		//this._worldMatrixIndex=0;
		this._children=[];
		this.transform=new AnimationTransform3D(this,localPosition,localRotation,localScale,worldMatrix);
	}

	__class(AnimationNode,'laya.d3.animation.AnimationNode');
	var __proto=AnimationNode.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*添加子节点。
	*@param child 子节点。
	*/
	__proto.addChild=function(child){
		child._parent=this;
		child.transform.setParent(this.transform);
		this._children.push(child);
	}

	/**
	*移除子节点。
	*@param child 子节点。
	*/
	__proto.removeChild=function(child){
		var index=this._children.indexOf(child);
		(index!==-1)&& (this._children.splice(index,1));
	}

	/**
	*根据名字获取子节点。
	*@param name 名字。
	*/
	__proto.getChildByName=function(name){
		for (var i=0,n=this._children.length;i < n;i++){
			var child=this._children[i];
			if (child.name===name)
				return child;
		}
		return null;
	}

	/**
	*根据索引获取子节点。
	*@param index 索引。
	*/
	__proto.getChildByIndex=function(index){
		return this._children[index];
	}

	/**
	*获取子节点的个数。
	*/
	__proto.getChildCount=function(){
		return this._children.length;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destNode=destObject;
		destNode.name=this.name;
		for (var i=0,n=this._children.length;i < n;i++){
			var child=this._children[i];
			var destChild=child.clone();
			destNode.addChild(destChild);
			var transform=child.transform;
			var destTransform=destChild.transform;
			var destLocalPosition=destTransform.localPosition;
			var destLocalRotation=destTransform.localRotation;
			var destLocalScale=destTransform.localScale;
			transform.localPosition.cloneTo(destLocalPosition);
			transform.localRotation.cloneTo(destLocalRotation);
			transform.localScale.cloneTo(destLocalScale);
			destTransform.localPosition=destLocalPosition;
			destTransform.localRotation=destLocalRotation;
			destTransform.localScale=destLocalScale;
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=new AnimationNode();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*@private [NATIVE]
	*/
	__proto._cloneNative=function(localPositions,localRotations,localScales,animationNodeWorldMatrixs,animationNodeParentIndices,parentIndex,avatar){
		var curID=avatar._nativeCurCloneCount;
		animationNodeParentIndices[curID]=parentIndex;
		var localPosition=new Float32Array(localPositions.buffer,curID *3 *4,3);
		var localRotation=new Float32Array(localRotations.buffer,curID *4 *4,4);
		var localScale=new Float32Array(localScales.buffer,curID *3 *4,3);
		var worldMatrix=new Float32Array(animationNodeWorldMatrixs.buffer,curID *16 *4,16);
		var dest=new AnimationNode(localPosition,localRotation,localScale,worldMatrix);
		dest._worldMatrixIndex=curID;
		this._cloneToNative(dest,localPositions,localRotations,localScales,animationNodeWorldMatrixs,animationNodeParentIndices,curID,avatar);
		return dest;
	}

	/**
	*@private [NATIVE]
	*/
	__proto._cloneToNative=function(destObject,localPositions,localRotations,localScales,animationNodeWorldMatrixs,animationNodeParentIndices,parentIndex,avatar){
		var destNode=destObject;
		destNode.name=this.name;
		for (var i=0,n=this._children.length;i < n;i++){
			var child=this._children[i];
			avatar._nativeCurCloneCount++;
			var destChild=child._cloneNative(localPositions,localRotations,localScales,animationNodeWorldMatrixs,animationNodeParentIndices,parentIndex,avatar);
			destNode.addChild(destChild);
			var transform=child.transform;
			var destTransform=destChild.transform;
			var destLocalPosition=destTransform.localPosition;
			var destLocalRotation=destTransform.localRotation;
			var destLocalScale=destTransform.localScale;
			transform.localPosition.cloneTo(destLocalPosition);
			transform.localRotation.cloneTo(destLocalRotation);
			transform.localScale.cloneTo(destLocalScale);
			destTransform.localPosition=destLocalPosition;
			destTransform.localRotation=destLocalRotation;
			destTransform.localScale=destLocalScale;
		}
	}

	return AnimationNode;
})()


/**
*<code>Laya3D</code> 类用于初始化3D设置。
*/
//class Laya3D
var Laya3D=(function(){
	/**
	*创建一个 <code>Laya3D</code> 实例。
	*/
	function Laya3D(){}
	__class(Laya3D,'Laya3D');
	/**
	*获取是否可以启用物理。
	*@param 是否启用物理。
	*/
	__getset(1,Laya3D,'enbalePhysics',function(){
		return Laya3D._enbalePhysics;
	});

	Laya3D._cancelLoadByUrl=function(url){
		Laya.loader.cancelLoadByUrl(url);
		Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(url);
		Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(url);
		Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(url);
		Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(url);
	}

	Laya3D._changeWebGLSize=function(width,height){
		WebGL.onStageResize(width,height);
		RenderContext3D.clientWidth=width;
		RenderContext3D.clientHeight=height;
	}

	Laya3D.__init__=function(width,height,config){
		Config.isAntialias=config.isAntialias;
		Config.isAlpha=config.isAlpha;
		Config.premultipliedAlpha=config.premultipliedAlpha;
		Config.isStencil=config.isStencil;
		if (!WebGL.enable()){
			alert("Laya3D init error,must support webGL!");
			return;
		}
		RunDriver.changeWebGLSize=Laya3D._changeWebGLSize;
		Render.is3DMode=true;
		Laya.init(width,height);
		if (!Render.isConchApp){
			LayaGL.instance=WebGL.mainContext;
			LayaGL.instance.createCommandEncoder=function (reserveSize,adjustSize,isSyncToRenderThread){
				(reserveSize===void 0)&& (reserveSize=128);
				(adjustSize===void 0)&& (adjustSize=64);
				(isSyncToRenderThread===void 0)&& (isSyncToRenderThread=false);
				return new CommandEncoder(this,reserveSize,adjustSize,isSyncToRenderThread);
			}
		}
		if (Render.isConchApp)Laya3D.enableNative3D();
		Sprite3D.__init__();
		RenderableSprite3D.__init__();
		MeshSprite3D.__init__();
		SkinnedMeshSprite3D.__init__();
		ShuriKenParticle3D.__init__();
		BaseMaterial.__init__();
		BlinnPhongMaterial.__init__();
		PBRStandardMaterial.__init__();
		PBRSpecularMaterial.__init__();
		SkyProceduralMaterial.__init__();
		UnlitMaterial.__init__();
		TrailSprite3D.__init__();
		TrailMaterial.__init__();
		EffectMaterial.__init__();
		WaterPrimaryMaterial.__init__();
		ShurikenParticleMaterial.__init__();
		TerrainMaterial.__init__();
		ExtendTerrainMaterial.__init__();
		ShaderInit3D.__init__();
		Texture2D.__init__();
		TextureCube.__init__();
		SkyBox.__init__();
		SkyDome.__init__();
		FrustumCulling.__init__();
		HalfFloatUtils.__init__();
		var createMap=LoaderManager.createMap;
		createMap["lh"]=[ /*CLASS CONST:Laya3D.HIERARCHY*/"HIERARCHY",Sprite3D._parse];
		createMap["ls"]=[ /*CLASS CONST:Laya3D.HIERARCHY*/"HIERARCHY",Scene3D._parse];
		createMap["lm"]=[ /*CLASS CONST:Laya3D.MESH*/"MESH",Mesh._parse];
		createMap["lmat"]=[ /*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL",BaseMaterial._parse];
		createMap["ltc"]=[ /*CLASS CONST:Laya3D.TEXTURECUBE*/"TEXTURECUBE",TextureCube._parse];
		createMap["jpg"]=[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",Texture2D._parse];
		createMap["jpeg"]=[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",Texture2D._parse];
		createMap["bmp"]=[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",Texture2D._parse];
		createMap["gif"]=[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",Texture2D._parse];
		createMap["png"]=[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",Texture2D._parse];
		createMap["dds"]=[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",Texture2D._parse];
		createMap["ktx"]=[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",Texture2D._parse];
		createMap["pvr"]=[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",Texture2D._parse];
		createMap["lani"]=[ /*CLASS CONST:Laya3D.ANIMATIONCLIP*/"ANIMATIONCLIP",AnimationClip._parse];
		createMap["lav"]=[ /*CLASS CONST:Laya3D.AVATAR*/"AVATAR",Avatar._parse];
		createMap["thdata"]=[ /*CLASS CONST:Laya3D.TERRAINHEIGHTDATA*/"TERRAINHEIGHTDATA",TerrainHeightData._pharse];
		var parserMap=Loader.parserMap;
		parserMap[ /*CLASS CONST:Laya3D.HIERARCHY*/"HIERARCHY"]=Laya3D._loadHierarchy;
		parserMap[ /*CLASS CONST:Laya3D.MESH*/"MESH"]=Laya3D._loadMesh;
		parserMap[ /*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"]=Laya3D._loadMaterial;
		parserMap[ /*CLASS CONST:Laya3D.TEXTURECUBE*/"TEXTURECUBE"]=Laya3D._loadTextureCube;
		parserMap[ /*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D"]=Laya3D._loadTexture2D;
		parserMap[ /*CLASS CONST:Laya3D.ANIMATIONCLIP*/"ANIMATIONCLIP"]=Laya3D._loadAnimationClip;
		parserMap[ /*CLASS CONST:Laya3D.AVATAR*/"AVATAR"]=Laya3D._loadAvatar;
		Laya3D._innerFirstLevelLoaderManager.on(/*laya.events.Event.ERROR*/"error",null,Laya3D._eventLoadManagerError);
		Laya3D._innerSecondLevelLoaderManager.on(/*laya.events.Event.ERROR*/"error",null,Laya3D._eventLoadManagerError);
		Laya3D._innerThirdLevelLoaderManager.on(/*laya.events.Event.ERROR*/"error",null,Laya3D._eventLoadManagerError);
		Laya3D._innerFourthLevelLoaderManager.on(/*laya.events.Event.ERROR*/"error",null,Laya3D._eventLoadManagerError);
	}

	Laya3D.enableNative3D=function(){
		if (Render.isConchApp){
			/*__JS__ */LayaGL=window.LayaGLContext;
			var shaderData=ShaderData;
			var shader3D=ShaderInstance;
			var skinnedMeshRender=SkinnedMeshRenderer;
			var avatar=Avatar;
			var frustumCulling=FrustumCulling;
			shaderData.prototype._initData=shaderData.prototype._initDataForNative;
			shaderData.prototype.setBool=shaderData.prototype.setBoolForNative;
			shaderData.prototype.getBool=shaderData.prototype.getBoolForNative;
			shaderData.prototype.setInt=shaderData.prototype.setIntForNative;
			shaderData.prototype.getInt=shaderData.prototype.getIntForNative;
			shaderData.prototype.setNumber=shaderData.prototype.setNumberForNative;
			shaderData.prototype.getNumber=shaderData.prototype.getNumberForNative;
			shaderData.prototype.setVector=shaderData.prototype.setVectorForNative;
			shaderData.prototype.getVector=shaderData.prototype.getVectorForNative;
			shaderData.prototype.setQuaternion=shaderData.prototype.setQuaternionForNative;
			shaderData.prototype.getQuaternion=shaderData.prototype.getQuaternionForNative;
			shaderData.prototype.setMatrix4x4=shaderData.prototype.setMatrix4x4ForNative;
			shaderData.prototype.getMatrix4x4=shaderData.prototype.getMatrix4x4ForNative;
			shaderData.prototype.setBuffer=shaderData.prototype.setBufferForNative;
			shaderData.prototype.getBuffer=shaderData.prototype.getBufferForNative;
			shaderData.prototype.setTexture=shaderData.prototype.setTextureForNative;
			shaderData.prototype.getTexture=shaderData.prototype.getTextureForNative;
			shaderData.prototype.setAttribute=shaderData.prototype.setAttributeForNative;
			shaderData.prototype.getAttribute=shaderData.prototype.getAttributeForNative;
			shaderData.prototype.cloneTo=shaderData.prototype.cloneToForNative;
			shader3D.prototype._uniformMatrix2fv=shader3D.prototype._uniformMatrix2fvForNative;
			shader3D.prototype._uniformMatrix3fv=shader3D.prototype._uniformMatrix3fvForNative;
			shader3D.prototype._uniformMatrix4fv=shader3D.prototype._uniformMatrix4fvForNative;
			avatar.prototype._cloneDatasToAnimator=avatar.prototype._cloneDatasToAnimatorNative;
			frustumCulling.renderObjectCulling=FrustumCulling.renderObjectCullingNative;
			/*__JS__ */FloatKeyframe=window.conchFloatKeyframe;
			/*__JS__ */FloatArrayKeyframe=window.conchFloatArrayKeyframe;
			/*__JS__ */KeyframeNode=window.conchKeyframeNode;
			/*__JS__ */KeyframeNodeList=window.conchKeyframeNodeList;
			var animationClip=AnimationClip;
			animationClip.prototype._evaluateClipDatasRealTime=animationClip.prototype._evaluateClipDatasRealTimeForNative;
		}
		WebGL.shaderHighPrecision=false;
		var precisionFormat=LayaGL.instance.getShaderPrecisionFormat(/*laya.webgl.WebGLContext.FRAGMENT_SHADER*/0x8B30,/*laya.webgl.WebGLContext.HIGH_FLOAT*/0x8DF2);
		precisionFormat.precision ? WebGL.shaderHighPrecision=true :WebGL.shaderHighPrecision=false;
	}

	Laya3D.formatRelativePath=function(base,value){
		var path;
		path=base+value;
		var char1=value.charAt(0);
		if (char1==="."){
			var parts=path.split("/");
			for (var i=0,len=parts.length;i < len;i++){
				if (parts[i]=='..'){
					var index=i-1;
					if (index > 0 && parts[index]!=='..'){
						parts.splice(index,2);
						i-=2;
					}
				}
			}
			path=parts.join('/');
		}
		(URL.customFormat !=null)&& (path=URL.customFormat(path,null));
		return path;
	}

	Laya3D._endLoad=function(loader,content,subResous){
		if (subResous){
			for (var i=0,n=subResous.length;i < n;i++){
				var resou=Loader.getRes(subResous[i]);
				(resou)&& (resou._removeReference());
			}
		}
		loader.endLoad(content);
	}

	Laya3D._eventLoadManagerError=function(msg){
		Laya.loader.event(/*laya.events.Event.ERROR*/"error",msg);
	}

	Laya3D._addHierarchyInnerUrls=function(urls,urlMap,urlVersion,hierarchyBasePath,path,type,constructParams,propertyParams){
		var formatUrl=Laya3D.formatRelativePath(hierarchyBasePath,path);
		(urlVersion)&& (formatUrl=formatUrl+urlVersion);
		urls.push({url:formatUrl,type:type,constructParams:constructParams,propertyParams:propertyParams});
		urlMap.push(formatUrl);
		return formatUrl;
	}

	Laya3D._getSprite3DHierarchyInnerUrls=function(node,firstLevelUrls,secondLevelUrls,thirdLevelUrls,fourthLelUrls,subUrls,urlVersion,hierarchyBasePath){
		var i=0,n=0;
		var props=node.props;
		switch (node.type){
			case "Scene3D":;
				var lightmaps=props.lightmaps;
				for (i=0,n=lightmaps.length;i < n;i++){
					var lightMap=lightmaps[i];
					lightMap.path=Laya3D._addHierarchyInnerUrls(fourthLelUrls,subUrls,urlVersion,hierarchyBasePath,lightMap.path,/*CLASS CONST:Laya3D.TEXTURE2D*/"TEXTURE2D",lightMap.constructParams,lightMap.propertyParams);
				};
				var reflectionTextureData=props.reflectionTexture;
				(reflectionTextureData)&& (props.reflectionTexture=Laya3D._addHierarchyInnerUrls(thirdLevelUrls,subUrls,urlVersion,hierarchyBasePath,reflectionTextureData,/*CLASS CONST:Laya3D.TEXTURECUBE*/"TEXTURECUBE"));
				if (props.sky){
					var skyboxMaterial=props.sky.material;
					(skyboxMaterial)&& (skyboxMaterial.path=Laya3D._addHierarchyInnerUrls(secondLevelUrls,subUrls,urlVersion,hierarchyBasePath,skyboxMaterial.path,/*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"));
				}
				break ;
			case "Camera":;
				var skyboxMatData=props.skyboxMaterial;
				(skyboxMatData)&& (skyboxMatData.path=Laya3D._addHierarchyInnerUrls(secondLevelUrls,subUrls,urlVersion,hierarchyBasePath,skyboxMatData.path,/*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"));
				break ;
			case "TrailSprite3D":
			case "MeshSprite3D":
			case "SkinnedMeshSprite3D":;
				var meshPath=props.meshPath;
				(meshPath)&& (props.meshPath=Laya3D._addHierarchyInnerUrls(firstLevelUrls,subUrls,urlVersion,hierarchyBasePath,meshPath,/*CLASS CONST:Laya3D.MESH*/"MESH"));
				var materials=props.materials;
				if (materials)
					for (i=0,n=materials.length;i < n;i++)
				materials[i].path=Laya3D._addHierarchyInnerUrls(secondLevelUrls,subUrls,urlVersion,hierarchyBasePath,materials[i].path,/*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL");
				break ;
			case "ShuriKenParticle3D":;
				var parMeshPath=props.meshPath;
				(parMeshPath)&& (props.meshPath=Laya3D._addHierarchyInnerUrls(firstLevelUrls,subUrls,urlVersion,hierarchyBasePath,parMeshPath,/*CLASS CONST:Laya3D.MESH*/"MESH"));
				props.material.path=Laya3D._addHierarchyInnerUrls(secondLevelUrls,subUrls,urlVersion,hierarchyBasePath,props.material.path,/*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL");
				break ;
			case "Terrain":
				Laya3D._addHierarchyInnerUrls(fourthLelUrls,subUrls,urlVersion,hierarchyBasePath,props.dataPath,"TERRAIN");
				break ;
			};
		var components=node.components;
		if (components){
			for (var k=0,p=components.length;k < p;k++){
				var component=components[k];
				switch (component.type){
					case "Animator":;
						var avatarPath=component.avatarPath;
						var avatarData=component.avatar;
						(avatarData)&& (avatarData.path=Laya3D._addHierarchyInnerUrls(fourthLelUrls,subUrls,urlVersion,hierarchyBasePath,avatarData.path,"AVATAR"));
						var clipPaths=component.clipPaths;
						if (!clipPaths){
							var layersData=component.layers;
							for (i=0;i < layersData.length;i++){
								var states=layersData[i].states;
								for (var j=0,m=states.length;j < m;j++){
									var clipPath=states[j].clipPath;
									(clipPath)&& (states[j].clipPath=Laya3D._addHierarchyInnerUrls(fourthLelUrls,subUrls,urlVersion,hierarchyBasePath,clipPath,"ANIMATIONCLIP"));
								}
							}
							}else {
							for (i=0,n=clipPaths.length;i < n;i++)
							clipPaths[i]=Laya3D._addHierarchyInnerUrls(fourthLelUrls,subUrls,urlVersion,hierarchyBasePath,clipPaths[i],"ANIMATIONCLIP");
						}
						break ;
					case "PhysicsCollider":
					case "Rigidbody3D":
					case "CharacterController":;
						var shapes=component.shapes;
						for (i=0;i < shapes.length;i++){
							var shape=shapes[i];
							if (shape.type==="MeshColliderShape"){
								var mesh=shape.mesh;
								(mesh)&& (shape.mesh=Laya3D._addHierarchyInnerUrls(firstLevelUrls,subUrls,urlVersion,hierarchyBasePath,mesh,/*CLASS CONST:Laya3D.MESH*/"MESH"));
							}
						}
						break ;
					}
			}
		};
		var children=node.child;
		for (i=0,n=children.length;i < n;i++)
		Laya3D._getSprite3DHierarchyInnerUrls(children[i],firstLevelUrls,secondLevelUrls,thirdLevelUrls,fourthLelUrls,subUrls,urlVersion,hierarchyBasePath);
	}

	Laya3D._loadHierarchy=function(loader){
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onHierarchylhLoaded,[loader]);
		loader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
	}

	Laya3D._onHierarchylhLoaded=function(loader,lhData){
		var url=loader.url;
		var urlVersion=Utils3D.getURLVerion(url);
		var hierarchyBasePath=URL.getPath(url);
		var firstLevUrls=[];
		var secondLevUrls=[];
		var thirdLevUrls=[];
		var forthLevUrls=[];
		var subUrls=[];
		Laya3D._getSprite3DHierarchyInnerUrls(lhData.data,firstLevUrls,secondLevUrls,thirdLevUrls,forthLevUrls,subUrls,urlVersion,hierarchyBasePath);
		var urlCount=firstLevUrls.length+secondLevUrls.length+forthLevUrls.length;
		var totalProcessCount=urlCount+1;
		var weight=1 / totalProcessCount;
		Laya3D._onProcessChange(loader,0,weight,1.0);
		if (forthLevUrls.length > 0){
			var processCeil=urlCount / totalProcessCount;
			var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,weight,processCeil],false);
			Laya3D._innerFourthLevelLoaderManager._create(forthLevUrls,false,Handler.create(null,Laya3D._onHierarchyInnerForthLevResouLoaded,[loader,processHandler,lhData,subUrls,firstLevUrls,secondLevUrls,thirdLevUrls,weight+processCeil *forthLevUrls.length,processCeil]),processHandler,null,null,null,1,true);
			}else {
			Laya3D._onHierarchyInnerForthLevResouLoaded(loader,null,lhData,subUrls,firstLevUrls,secondLevUrls,thirdLevUrls,weight,processCeil);
		}
	}

	Laya3D._onHierarchyInnerForthLevResouLoaded=function(loader,processHandler,lhData,subUrls,firstLevUrls,secondLevUrls,thirdLevUrls,processOffset,processCeil){
		(processHandler)&& (processHandler.recover());
		if (thirdLevUrls.length > 0){
			var process=Handler.create(null,Laya3D._onProcessChange,[loader,processOffset,processCeil],false);
			Laya3D._innerThirdLevelLoaderManager._create(thirdLevUrls,false,Handler.create(null,Laya3D._onHierarchyInnerThirdLevResouLoaded,[loader,process,lhData,subUrls,firstLevUrls,secondLevUrls,processOffset+processCeil *secondLevUrls.length,processCeil]),processHandler,null,null,null,1,true);
			}else {
			Laya3D._onHierarchyInnerThirdLevResouLoaded(loader,null,lhData,subUrls,firstLevUrls,secondLevUrls,processOffset,processCeil);
		}
	}

	Laya3D._onHierarchyInnerThirdLevResouLoaded=function(loader,processHandler,lhData,subUrls,firstLevUrls,secondLevUrls,processOffset,processCeil){
		(processHandler)&& (processHandler.recover());
		if (secondLevUrls.length > 0){
			var process=Handler.create(null,Laya3D._onProcessChange,[loader,processOffset,processCeil],false);
			Laya3D._innerSecondLevelLoaderManager._create(secondLevUrls,false,Handler.create(null,Laya3D._onHierarchyInnerSecondLevResouLoaded,[loader,process,lhData,subUrls,firstLevUrls,processOffset+processCeil *secondLevUrls.length,processCeil]),processHandler,null,null,null,1,true);
			}else {
			Laya3D._onHierarchyInnerSecondLevResouLoaded(loader,null,lhData,subUrls,firstLevUrls,processOffset,processCeil);
		}
	}

	Laya3D._onHierarchyInnerSecondLevResouLoaded=function(loader,processHandler,lhData,subUrls,firstLevUrls,processOffset,processCeil){
		(processHandler)&& (processHandler.recover());
		if (firstLevUrls.length > 0){
			var process=Handler.create(null,Laya3D._onProcessChange,[loader,processOffset,processCeil],false);
			Laya3D._innerFirstLevelLoaderManager._create(firstLevUrls,false,Handler.create(null,Laya3D._onHierarchyInnerFirstLevResouLoaded,[loader,process,lhData,subUrls]),processHandler,null,null,null,1,true);
			}else {
			Laya3D._onHierarchyInnerFirstLevResouLoaded(loader,null,lhData,subUrls);
		}
	}

	Laya3D._onHierarchyInnerFirstLevResouLoaded=function(loader,processHandler,lhData,subUrls){
		(processHandler)&& (processHandler.recover());
		loader._cache=loader._createCache;
		var item=lhData.data.type==="Scene3D" ? Scene3D._parse(lhData,loader._propertyParams,loader._constructParams):Sprite3D._parse(lhData,loader._propertyParams,loader._constructParams);
		Laya3D._endLoad(loader,item,subUrls);
	}

	Laya3D._loadMesh=function(loader){
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onMeshLmLoaded,[loader]);
		loader.load(loader.url,/*laya.net.Loader.BUFFER*/"arraybuffer",false,null,true);
	}

	Laya3D._onMeshLmLoaded=function(loader,lmData){
		loader._cache=loader._createCache;
		var mesh=Mesh._parse(lmData,loader._propertyParams,loader._constructParams);
		Laya3D._endLoad(loader,mesh);
	}

	Laya3D._loadMaterial=function(loader){
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onMaterilLmatLoaded,[loader]);
		loader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
	}

	Laya3D._onMaterilLmatLoaded=function(loader,lmatData){
		var url=loader.url;
		var urlVersion=Utils3D.getURLVerion(url);
		var materialBasePath=URL.getPath(url);
		var urls=[];
		var subUrls=[];
		var customProps=lmatData.customProps;
		var formatSubUrl;
		var version=lmatData.version;
		switch (version){
			case "LAYAMATERIAL:01":
			case "LAYAMATERIAL:02":;
				var i=0,n=0;
				var textures=lmatData.props.textures;
				if (textures){
					for (i=0,n=textures.length;i < n;i++){
						var tex2D=textures[i];
						var tex2DPath=tex2D.path;
						if (tex2DPath){
							formatSubUrl=Laya3D.formatRelativePath(materialBasePath,tex2DPath);
							(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
							urls.push({url:formatSubUrl,constructParams:tex2D.constructParams,propertyParams:tex2D.propertyParams});
							subUrls.push(formatSubUrl);
							tex2D.path=formatSubUrl;
						}
					}
				}
				break ;
			default :
				throw new Error("Laya3D:unkonwn version.");
			};
		var urlCount=urls.length;
		var totalProcessCount=urlCount+1;
		var lmatWeight=1 / totalProcessCount;
		Laya3D._onProcessChange(loader,0,lmatWeight,1.0);
		if (urlCount > 0){
			var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,lmatWeight,urlCount / totalProcessCount],false);
			Laya3D._innerFourthLevelLoaderManager._create(urls,false,Handler.create(null,Laya3D._onMateialTexturesLoaded,[loader,processHandler,lmatData,subUrls]),processHandler,null,null,null,1,true);
			}else {
			Laya3D._onMateialTexturesLoaded(loader,null,lmatData,null);
		}
	}

	Laya3D._onMateialTexturesLoaded=function(loader,processHandler,lmatData,subUrls){
		loader._cache=loader._createCache;
		var mat=BaseMaterial._parse(lmatData,loader._propertyParams,loader._constructParams);
		Laya3D._endLoad(loader,mat,subUrls);
		(processHandler)&& (processHandler.recover());
	}

	Laya3D._loadAvatar=function(loader){
		loader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,function(data){
			loader._cache=loader._createCache;
			var avatar=Avatar._parse(data,loader._propertyParams,loader._constructParams);
			Laya3D._endLoad(loader,avatar);
		});
	}

	Laya3D._loadAnimationClip=function(loader){
		loader.load(loader.url,/*laya.net.Loader.BUFFER*/"arraybuffer",false,null,true);
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,function(data){
			loader._cache=loader._createCache;
			var clip=AnimationClip._parse(data,loader._propertyParams,loader._constructParams);
			Laya3D._endLoad(loader,clip);
		});
	}

	Laya3D._loadTexture2D=function(loader){
		var url=loader.url;
		var index=url.lastIndexOf('.')+1;
		var verIndex=url.indexOf('?');
		var endIndex=verIndex==-1 ? url.length :verIndex;
		var ext=url.substr(index,endIndex-index);
		var type;
		switch (ext){
			case "jpg":
			case "jpeg":
			case "bmp":
			case "gif":
			case "png":
				type="nativeimage";
				break ;
			case "dds":
			case "ktx":
			case "pvr":
				type=/*laya.net.Loader.BUFFER*/"arraybuffer";
				break ;
			}
		loader.load(loader.url,type,false,null,true);
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,function(image){
			loader._cache=loader._createCache;
			var tex=Texture2D._parse(image,loader._propertyParams,loader._constructParams);
			Laya3D._endLoad(loader,tex);
		});
	}

	Laya3D._loadTextureCube=function(loader){
		loader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
		loader.on(/*laya.events.Event.LOADED*/"loaded",null,Laya3D._onTextureCubeLtcLoaded,[loader]);
	}

	Laya3D._onTextureCubeLtcLoaded=function(loader,ltcData){
		var ltcBasePath=URL.getPath(loader.url);
		var urls=[Laya3D.formatRelativePath(ltcBasePath,ltcData.front),Laya3D.formatRelativePath(ltcBasePath,ltcData.back),Laya3D.formatRelativePath(ltcBasePath,ltcData.left),Laya3D.formatRelativePath(ltcBasePath,ltcData.right),Laya3D.formatRelativePath(ltcBasePath,ltcData.up),Laya3D.formatRelativePath(ltcBasePath,ltcData.down)];
		var ltcWeight=1.0 / 7.0;
		Laya3D._onProcessChange(loader,0,ltcWeight,1.0);
		var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,ltcWeight,6 / 7],false);
		Laya3D._innerFourthLevelLoaderManager.load(urls,Handler.create(null,Laya3D._onTextureCubeImagesLoaded,[loader,urls,processHandler]),processHandler,"nativeimage");
	}

	Laya3D._onTextureCubeImagesLoaded=function(loader,urls,processHandler){
		var images=new Array(6);
		for (var i=0;i < 6;i++)
		images[i]=Loader.getRes(urls[i]);
		loader._cache=loader._createCache;
		var tex=TextureCube._parse(images,loader._propertyParams,loader._constructParams);
		processHandler.recover();
		for (i=0;i < 6;i++)
		Loader.clearRes(urls[i]);
		Laya3D._endLoad(loader,tex);
	}

	Laya3D._onProcessChange=function(loader,offset,weight,process){
		process=offset+process *weight;
		(process < 1.0)&& (loader.event(/*laya.events.Event.PROGRESS*/"progress",process));
	}

	Laya3D.init=function(width,height,config,compolete){
		if (Laya3D._isInit)
			return;
		Laya3D._isInit=true;
		config=config || Config3D._defaultConfig;
		Laya3D._editerEnvironment=config._editerEnvironment;
		var physics3D=window.Physics3D;
		if (physics3D==null){
			Laya3D._enbalePhysics=false;
			Laya3D.__init__(width,height,config);
			compolete && compolete.run();
			}else {
			Laya3D._enbalePhysics=true;
			physics3D(config.defaultPhysicsMemory *1024 *1024).then(function(){
				Laya3D.__init__(width,height,config);
				compolete && compolete.run();
			});
		}
	}

	Laya3D.HIERARCHY="HIERARCHY";
	Laya3D.MESH="MESH";
	Laya3D.MATERIAL="MATERIAL";
	Laya3D.TEXTURE2D="TEXTURE2D";
	Laya3D.TEXTURECUBE="TEXTURECUBE";
	Laya3D.ANIMATIONCLIP="ANIMATIONCLIP";
	Laya3D.AVATAR="AVATAR";
	Laya3D.TERRAINHEIGHTDATA="TERRAINHEIGHTDATA";
	Laya3D.TERRAINRES="TERRAIN";
	Laya3D._isInit=false;
	Laya3D._enbalePhysics=false;
	Laya3D._editerEnvironment=false;
	Laya3D.debugMode=false;
	__static(Laya3D,
	['_innerFirstLevelLoaderManager',function(){return this._innerFirstLevelLoaderManager=new LoaderManager();},'_innerSecondLevelLoaderManager',function(){return this._innerSecondLevelLoaderManager=new LoaderManager();},'_innerThirdLevelLoaderManager',function(){return this._innerThirdLevelLoaderManager=new LoaderManager();},'_innerFourthLevelLoaderManager',function(){return this._innerFourthLevelLoaderManager=new LoaderManager();},'_physics3D',function(){return this._physics3D=window.Physics3D;},'physicsSettings',function(){return this.physicsSettings=new PhysicsSettings();}
	]);
	return Laya3D;
})()


/**
*...
*@author ...
*/
//class laya.d3.core.particleShuriKen.module.shape.ShapeUtils
var ShapeUtils=(function(){
	function ShapeUtils(){}
	__class(ShapeUtils,'laya.d3.core.particleShuriKen.module.shape.ShapeUtils');
	ShapeUtils._randomPointUnitArcCircle=function(arc,out,rand){
		var outE=out.elements;
		var angle=NaN;
		if (rand)
			angle=rand.getFloat()*arc;
		else
		angle=Math.random()*arc;
		outE[0]=Math.cos(angle);
		outE[1]=Math.sin(angle);
	}

	ShapeUtils._randomPointInsideUnitArcCircle=function(arc,out,rand){
		var outE=out.elements;
		ShapeUtils._randomPointUnitArcCircle(arc,out,rand);
		var range=NaN;
		if (rand)
			range=Math.pow(rand.getFloat(),1.0 / 2.0);
		else
		range=Math.pow(Math.random(),1.0 / 2.0);
		outE[0]=outE[0] *range;
		outE[1]=outE[1] *range;
	}

	ShapeUtils._randomPointUnitCircle=function(out,rand){
		var outE=out.elements;
		var angle=NaN;
		if (rand)
			angle=rand.getFloat()*Math.PI *2;
		else
		angle=Math.random()*Math.PI *2;
		outE[0]=Math.cos(angle);
		outE[1]=Math.sin(angle);
	}

	ShapeUtils._randomPointInsideUnitCircle=function(out,rand){
		var outE=out.elements;
		ShapeUtils._randomPointUnitCircle(out);
		var range=NaN;
		if (rand)
			range=Math.pow(rand.getFloat(),1.0 / 2.0);
		else
		range=Math.pow(Math.random(),1.0 / 2.0);
		outE[0]=outE[0] *range;
		outE[1]=outE[1] *range;
	}

	ShapeUtils._randomPointUnitSphere=function(out,rand){
		var outE=out.elements;
		var z=NaN;
		var a=NaN;
		if (rand){
			z=outE[2]=rand.getFloat()*2-1.0;
			a=rand.getFloat()*Math.PI *2;
			}else {
			z=outE[2]=Math.random()*2-1.0;
			a=Math.random()*Math.PI *2;
		};
		var r=Math.sqrt(1.0-z *z);
		outE[0]=r *Math.cos(a);
		outE[1]=r *Math.sin(a);
	}

	ShapeUtils._randomPointInsideUnitSphere=function(out,rand){
		var outE=out.elements;
		ShapeUtils._randomPointUnitSphere(out);
		var range=NaN;
		if (rand)
			range=Math.pow(rand.getFloat(),1.0 / 3.0);
		else
		range=Math.pow(Math.random(),1.0 / 3.0);
		outE[0]=outE[0] *range;
		outE[1]=outE[1] *range;
		outE[2]=outE[2] *range;
	}

	ShapeUtils._randomPointInsideHalfUnitBox=function(out,rand){
		var outE=out.elements;
		if (rand){
			outE[0]=(rand.getFloat()-0.5);
			outE[1]=(rand.getFloat()-0.5);
			outE[2]=(rand.getFloat()-0.5);
			}else {
			outE[0]=(Math.random()-0.5);
			outE[1]=(Math.random()-0.5);
			outE[2]=(Math.random()-0.5);
		}
	}

	return ShapeUtils;
})()


/**
*<code>VelocityOverLifetime</code> 类用于粒子的生命周期速度。
*/
//class laya.d3.core.particleShuriKen.module.VelocityOverLifetime
var VelocityOverLifetime=(function(){
	function VelocityOverLifetime(velocity){
		/**@private */
		this._velocity=null;
		/**是否启用*/
		this.enbale=false;
		/**速度空间,0为local,1为world。*/
		this.space=0;
		this._velocity=velocity;
	}

	__class(VelocityOverLifetime,'laya.d3.core.particleShuriKen.module.VelocityOverLifetime');
	var __proto=VelocityOverLifetime.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destVelocityOverLifetime=destObject;
		this._velocity.cloneTo(destVelocityOverLifetime._velocity);
		destVelocityOverLifetime.enbale=this.enbale;
		destVelocityOverLifetime.space=this.space;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destVelocity;
		switch(this._velocity.type){
			case 0:
				destVelocity=GradientVelocity.createByConstant(this._velocity.constant.clone());
				break ;
			case 1:
				destVelocity=GradientVelocity.createByGradient(this._velocity.gradientX.clone(),this._velocity.gradientY.clone(),this._velocity.gradientZ.clone());
				break ;
			case 2:
				destVelocity=GradientVelocity.createByRandomTwoConstant(this._velocity.constantMin.clone(),this._velocity.constantMax.clone());
				break ;
			case 3:
				destVelocity=GradientVelocity.createByRandomTwoGradient(this._velocity.gradientXMin.clone(),this._velocity.gradientYMin.clone(),this._velocity.gradientZMin.clone(),this._velocity.gradientXMax.clone(),this._velocity.gradientYMax.clone(),this._velocity.gradientZMax.clone());
				break ;
			};
		var destVelocityOverLifetime=/*__JS__ */new this.constructor(destVelocity);
		destVelocityOverLifetime.enbale=this.enbale;
		destVelocityOverLifetime.space=this.space;
		return destVelocityOverLifetime;
	}

	/**
	*获取尺寸。
	*/
	__getset(0,__proto,'velocity',function(){
		return this._velocity;
	});

	return VelocityOverLifetime;
})()


/**
*<code>GradientDataVector2</code> 类用于创建二维向量渐变。
*/
//class laya.d3.core.particleShuriKen.module.GradientDataVector2
var GradientDataVector2=(function(){
	function GradientDataVector2(){
		/**@private */
		this._currentLength=0;
		/**@private 开发者禁止修改。*/
		this._elements=null;
		this._elements=new Float32Array(12);
	}

	__class(GradientDataVector2,'laya.d3.core.particleShuriKen.module.GradientDataVector2');
	var __proto=GradientDataVector2.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*增加二维向量渐变。
	*@param key 生命周期，范围为0到1。
	*@param value 二维向量值。
	*/
	__proto.add=function(key,value){
		if (this._currentLength < 8){
			if ((this._currentLength===6)&& ((key!==1))){
				key=1;
				console.log("GradientDataVector2 warning:the forth key is  be force set to 1.");
			}
			this._elements[this._currentLength++]=key;
			this._elements[this._currentLength++]=value.x;
			this._elements[this._currentLength++]=value.y;
			}else {
			console.log("GradientDataVector2 warning:data count must lessEqual than 4");
		}
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destGradientDataVector2=destObject;
		destGradientDataVector2._currentLength=this._currentLength;
		var destElements=destGradientDataVector2._elements;
		destElements.length=this._elements.length;
		for (var i=0,n=this._elements.length;i < n;i++){
			destElements[i]=this._elements[i];
		}
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destGradientDataVector2=/*__JS__ */new this.constructor();
		this.cloneTo(destGradientDataVector2);
		return destGradientDataVector2;
	}

	/**二维向量渐变数量。*/
	__getset(0,__proto,'gradientCount',function(){
		return this._currentLength / 3;
	});

	return GradientDataVector2;
})()


/**
*<code>Point2PointConstraint</code> 类用于创建物理组件的父类。
*/
//class laya.d3.physics.constraints.Point2PointConstraint
var Point2PointConstraint=(function(){
	function Point2PointConstraint(){
		/**@private */
		this._damping=NaN;
		/**@private */
		this._impulseClamp=NaN;
		/**@private */
		this._tau=NaN;
		this._pivotInA=new Vector3();
		this._pivotInB=new Vector3();
	}

	__class(Point2PointConstraint,'laya.d3.physics.constraints.Point2PointConstraint');
	var __proto=Point2PointConstraint.prototype;
	__getset(0,__proto,'pivotInA',function(){
		return this._pivotInA;
		},function(value){
		this._pivotInA=value;
	});

	__getset(0,__proto,'pivotInB',function(){
		return this._pivotInB;
		},function(value){
		this._pivotInB=value;
	});

	__getset(0,__proto,'damping',function(){
		return this._damping;
		},function(value){
		this._damping=value;
	});

	__getset(0,__proto,'impulseClamp',function(){
		return this._impulseClamp;
		},function(value){
		this._impulseClamp=value;
	});

	__getset(0,__proto,'tau',function(){
		return this._tau;
		},function(value){
		this._tau=value;
	});

	return Point2PointConstraint;
})()


/**
*<code>Viewport</code> 类用于创建视口。
*/
//class laya.d3.math.Viewport
var Viewport=(function(){
	function Viewport(x,y,width,height){
		/**X轴坐标*/
		//this.x=NaN;
		/**Y轴坐标*/
		//this.y=NaN;
		/**宽度*/
		//this.width=NaN;
		/**高度*/
		//this.height=NaN;
		/**最小深度*/
		//this.minDepth=NaN;
		/**最大深度*/
		//this.maxDepth=NaN;
		this.minDepth=0.0;
		this.maxDepth=1.0;
		this.x=x;
		this.y=y;
		this.width=width;
		this.height=height;
	}

	__class(Viewport,'laya.d3.math.Viewport');
	var __proto=Viewport.prototype;
	/**
	*变换一个三维向量。
	*@param source 源三维向量。
	*@param matrix 变换矩阵。
	*@param vector 输出三维向量。
	*/
	__proto.project=function(source,matrix,out){
		Vector3.transformV3ToV3(source,matrix,out);
		var sourceEleme=source.elements;
		var matrixEleme=matrix.elements;
		var outEleme=out.elements;
		var a=(((sourceEleme[0] *matrixEleme[3])+(sourceEleme[1] *matrixEleme[7]))+(sourceEleme[2] *matrixEleme[11]))+matrixEleme[15];
		if (a!==1.0){
			outEleme[0]=outEleme[0] / a;
			outEleme[1]=outEleme[1] / a;
			outEleme[2]=outEleme[2] / a;
		}
		outEleme[0]=(((outEleme[0]+1.0)*0.5)*this.width)+this.x;
		outEleme[1]=(((-outEleme[1]+1.0)*0.5)*this.height)+this.y;
		outEleme[2]=(outEleme[2] *(this.maxDepth-this.minDepth))+this.minDepth;
	}

	__proto.project1=function(source,matrix,out){
		var v4=Vector3._tempVector4;
		Vector3.transformV3ToV4(source,matrix,v4);
		var v4e=v4.elements;
		var dist=v4e[3];
		if (dist < 1e-1 && dist >-1e-6)dist=1e-6;
		v4e[0] /=dist;
		v4e[1] /=dist;
		v4e[2] /=dist;
		var outEleme=out.elements;
		outEleme[0]=(v4e[0]+1)*this.width / 2+this.x;
		outEleme[1]=(-v4e[1]+1)*this.height / 2+this.y;
		outEleme[2]=v4e[3];
		return;
	}

	/**
	*反变换一个三维向量。
	*@param source 源三维向量。
	*@param matrix 变换矩阵。
	*@param vector 输出三维向量。
	*/
	__proto.unprojectFromMat=function(source,matrix,out){
		var sourceEleme=source.elements;
		var matrixEleme=matrix.elements;
		var outEleme=out.elements;
		outEleme[0]=(((sourceEleme[0]-this.x)/ (this.width))*2.0)-1.0;
		outEleme[1]=-((((sourceEleme[1]-this.y)/ (this.height))*2.0)-1.0);
		var halfDepth=(this.maxDepth-this.minDepth)/ 2;
		outEleme[2]=(sourceEleme[2]-this.minDepth-halfDepth)/ halfDepth;
		var a=(((outEleme[0] *matrixEleme[3])+(outEleme[1] *matrixEleme[7]))+(outEleme[2] *matrixEleme[11]))+matrixEleme[15];
		Vector3.transformV3ToV3(out,matrix,out);
		if (a!==1.0){
			outEleme[0]=outEleme[0] / a;
			outEleme[1]=outEleme[1] / a;
			outEleme[2]=outEleme[2] / a;
		}
	}

	/**
	*反变换一个三维向量。
	*@param source 源三维向量。
	*@param projection 透视投影矩阵。
	*@param view 视图矩阵。
	*@param world 世界矩阵,可设置为null。
	*@param out 输出向量。
	*/
	__proto.unprojectFromWVP=function(source,projection,view,world,out){
		Matrix4x4.multiply(projection,view,Viewport._tempMatrix4x4);
		(world)&& (Matrix4x4.multiply(Viewport._tempMatrix4x4,world,Viewport._tempMatrix4x4));
		Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4);
		this.unprojectFromMat(source,Viewport._tempMatrix4x4,out);
	}

	/**
	*克隆
	*@param out
	*/
	__proto.cloneTo=function(out){
		out.x=this.x;
		out.y=this.y;
		out.width=this.width;
		out.height=this.height;
		out.minDepth=this.minDepth;
		out.maxDepth=this.maxDepth;
	}

	__static(Viewport,
	['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();}
	]);
	return Viewport;
})()


/**
*<code>Rand</code> 类用于通过128位整型种子创建随机数,算法来自:https://github.com/AndreasMadsen/xorshift。
*/
//class laya.d3.math.RandX
var RandX=(function(){
	function RandX(seed){
		/**@private */
		this._state0U=NaN;
		/**@private */
		this._state0L=NaN;
		/**@private */
		this._state1U=NaN;
		/**@private */
		this._state1L=NaN;
		if (!((seed instanceof Array))|| seed.length!==4)
			throw new Error('Rand:Seed must be an array with 4 numbers');
		this._state0U=seed[0] | 0;
		this._state0L=seed[1] | 0;
		this._state1U=seed[2] | 0;
		this._state1L=seed[3] | 0;
	}

	__class(RandX,'laya.d3.math.RandX');
	var __proto=RandX.prototype;
	/**
	*通过2x32位的数组，返回64位的随机数。
	*@return 64位的随机数。
	*/
	__proto.randomint=function(){
		var s1U=this._state0U,s1L=this._state0L;
		var s0U=this._state1U,s0L=this._state1L;
		var sumL=(s0L >>> 0)+(s1L >>> 0);
		var resU=(s0U+s1U+(sumL / 2 >>> 31))>>> 0;
		var resL=sumL >>> 0;
		this._state0U=s0U;
		this._state0L=s0L;
		var t1U=0,t1L=0;
		var t2U=0,t2L=0;
		var a1=23;
		var m1=0xFFFFFFFF << (32-a1);
		t1U=(s1U << a1)| ((s1L & m1)>>> (32-a1));
		t1L=s1L << a1;
		s1U=s1U ^ t1U;
		s1L=s1L ^ t1L;
		t1U=s1U ^ s0U;
		t1L=s1L ^ s0L;
		var a2=18;
		var m2=0xFFFFFFFF >>> (32-a2);
		t2U=s1U >>> a2;
		t2L=(s1L >>> a2)| ((s1U & m2)<< (32-a2));
		t1U=t1U ^ t2U;
		t1L=t1L ^ t2L;
		var a3=5;
		var m3=0xFFFFFFFF >>> (32-a3);
		t2U=s0U >>> a3;
		t2L=(s0L >>> a3)| ((s0U & m3)<< (32-a3));
		t1U=t1U ^ t2U;
		t1L=t1L ^ t2L;
		this._state1U=t1U;
		this._state1L=t1L;
		return [resU,resL];
	}

	/**
	*返回[0,1)之间的随机数。
	*@return
	*/
	__proto.random=function(){
		var t2=this.randomint();
		var t2U=t2[0];
		var t2L=t2[1];
		var eU=0x3FF << (52-32);
		var eL=0;
		var a1=12;
		var m1=0xFFFFFFFF >>> (32-a1);
		var sU=t2U >>> a1;
		var sL=(t2L >>> a1)| ((t2U & m1)<< (32-a1));
		var xU=eU | sU;
		var xL=eL | sL;
		RandX._CONVERTION_BUFFER.setUint32(0,xU,false);
		RandX._CONVERTION_BUFFER.setUint32(4,xL,false);
		var d=/*__JS__ */Rand._CONVERTION_BUFFER.getFloat64(0,false);
		return d-1;
	}

	__static(RandX,
	['_CONVERTION_BUFFER',function(){return this._CONVERTION_BUFFER=new DataView(new ArrayBuffer(8));},'defaultRand',function(){return this.defaultRand=/*__JS__ */new Rand([0,Date.now()/ 65536,0,Date.now()% 65536]);}
	]);
	return RandX;
})()


/**
*...
*@author ...
*/
//class laya.d3.graphics.VertexElementFormat
var VertexElementFormat=(function(){
	function VertexElementFormat(){}
	__class(VertexElementFormat,'laya.d3.graphics.VertexElementFormat');
	VertexElementFormat.getElementInfos=function(element){
		var info=VertexElementFormat._elementInfos[element];
		if (info)
			return info;
		else
		throw "VertexElementFormat: this vertexElementFormat is not implement.";
	}

	VertexElementFormat.Single="single";
	VertexElementFormat.Vector2="vector2";
	VertexElementFormat.Vector3="vector3";
	VertexElementFormat.Vector4="vector4";
	VertexElementFormat.Color="color";
	VertexElementFormat.Byte4="byte4";
	VertexElementFormat.Short2="short2";
	VertexElementFormat.Short4="short4";
	VertexElementFormat.NormalizedShort2="normalizedshort2";
	VertexElementFormat.NormalizedShort4="normalizedshort4";
	VertexElementFormat.HalfVector2="halfvector2";
	VertexElementFormat.HalfVector4="halfvector4";
	__static(VertexElementFormat,
	['_elementInfos',function(){return this._elementInfos={
			"single":[1,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"vector2":[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"vector3":[3,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"vector4":[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"color":[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"byte4":[4,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,0],
			"short2":[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"short4":[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"normalizedshort2":[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"normalizedshort4":[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"halfvector2":[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0],
			"halfvector4":[4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,0]
	};}

	]);
	return VertexElementFormat;
})()


/**
*@private
*<code>ShaderInit</code> 类用于初始化内置Shader。
*/
//class laya.d3.shader.ShaderInit3D
var ShaderInit3D=(function(){
	/**
	*创建一个 <code>ShaderInit</code> 实例。
	*/
	function ShaderInit3D(){}
	__class(ShaderInit3D,'laya.d3.shader.ShaderInit3D');
	ShaderInit3D.__init__=function(){
		ShaderInit3D._rangeAttenTex=Utils3D._buildTexture2D(1024,1,/*laya.webgl.resource.BaseTexture.FORMAT_ALPHA8*/2,TextureGenerator.lightAttenTexture);
		ShaderInit3D._rangeAttenTex.wrapModeU=/*laya.webgl.resource.BaseTexture.WARPMODE_CLAMP*/1;
		ShaderInit3D._rangeAttenTex.wrapModeV=/*laya.webgl.resource.BaseTexture.WARPMODE_CLAMP*/1;
		ShaderInit3D._rangeAttenTex.lock=true;
		Shader3D.SHADERDEFINE_HIGHPRECISION=Shader3D.registerPublicDefine("HIGHPRECISION");
		Scene3D.SHADERDEFINE_FOG=Shader3D.registerPublicDefine("FOG");
		Scene3D.SHADERDEFINE_DIRECTIONLIGHT=Shader3D.registerPublicDefine("DIRECTIONLIGHT");
		Scene3D.SHADERDEFINE_POINTLIGHT=Shader3D.registerPublicDefine("POINTLIGHT");
		Scene3D.SHADERDEFINE_SPOTLIGHT=Shader3D.registerPublicDefine("SPOTLIGHT");
		Scene3D.SHADERDEFINE_CAST_SHADOW=Shader3D.registerPublicDefine("CASTSHADOW");
		Scene3D.SHADERDEFINE_SHADOW_PSSM1=Shader3D.registerPublicDefine("SHADOWMAP_PSSM1");
		Scene3D.SHADERDEFINE_SHADOW_PSSM2=Shader3D.registerPublicDefine("SHADOWMAP_PSSM2");
		Scene3D.SHADERDEFINE_SHADOW_PSSM3=Shader3D.registerPublicDefine("SHADOWMAP_PSSM3");
		Scene3D.SHADERDEFINE_SHADOW_PCF_NO=Shader3D.registerPublicDefine("SHADOWMAP_PCF_NO");
		Scene3D.SHADERDEFINE_SHADOW_PCF1=Shader3D.registerPublicDefine("SHADOWMAP_PCF1");
		Scene3D.SHADERDEFINE_SHADOW_PCF2=Shader3D.registerPublicDefine("SHADOWMAP_PCF2");
		Scene3D.SHADERDEFINE_SHADOW_PCF3=Shader3D.registerPublicDefine("SHADOWMAP_PCF3");
		Scene3D.SHADERDEFINE_REFLECTMAP=Shader3D.registerPublicDefine("REFLECTMAP");
		Shader3D.addInclude("Lighting.glsl","\nstruct DirectionLight {\n	vec3 Color;\n	vec3 Direction;\n};\n\nstruct PointLight {\n	vec3 Color;\n	vec3 Position;\n	float Range;\n};\n\nstruct SpotLight {\n	vec3 Color;\n	vec3 Position;\n	vec3 Direction;\n	float Spot;\n	float Range;\n};\n\n// Laya中使用衰减纹理\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\n	float fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\n	fRatio *= fRatio;\n	return 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\n}\n\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\n	vec3 distance = L * invLightRadius;\n	float attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\n	return attenuation * attenuation;\n}\n\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\n	float attenuationFactor = 30.0;\n	vec3 distance = L * invLightRadius;\n	float attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\n	attenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\n	// Second we move down the function therewith it reaches zero at abscissa 1:\n	attenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\n	attenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\n	// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\n	attenuation /= 1.0 - attenuationFactor;\n	return attenuation;\n}\n\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\n	mediump vec3 h = normalize(viewDir-lightVec);\n	lowp float ln = max (0.0, dot (-lightVec,normal));\n	float nh = max (0.0, dot (h,normal));\n	diffuseColor=lightColor * ln;\n	specularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\n}\n\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\n	vec3 lightVec=normalize(light.Direction);\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec,diffuseColor,specularColor);\n}\n\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\n	vec3 lightVec =  pos-light.Position;\n	//if( length(lightVec) > light.Range )\n	//	return;\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec/length(lightVec),diffuseColor,specularColor);\n	float attenuate = LayaAttenuation(lightVec, 1.0/light.Range);\n	diffuseColor *= attenuate;\n	specularColor*= attenuate;\n}\n\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\n	vec3 lightVec =  pos-light.Position;\n	//if( length(lightVec) > light.Range)\n	//	return;\n\n	vec3 normalLightVec=lightVec/length(lightVec);\n	LayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,normalLightVec,diffuseColor,specularColor);\n	vec2 cosAngles=cos(vec2(light.Spot,light.Spot*0.5)*0.5);//ConeAttenuation\n	float dl=dot(normalize(light.Direction),normalLightVec);\n	dl*=smoothstep(cosAngles[0],cosAngles[1],dl);\n	float attenuate = LayaAttenuation(lightVec, 1.0/light.Range)*dl;\n	diffuseColor *=attenuate;\n	specularColor *=attenuate;\n}\n\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\n	vec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\n\n	// Build orthonormal basis.\n	vec3 N = normalize(unitNormal);\n	vec3 T = normalize(tangent);\n	vec3 B = normalize(binormal);\n	mat3 TBN = mat3(T, B, N);\n\n	// Transform from tangent space to world space.\n	vec3 bumpedNormal = TBN*normalT;\n\n	return bumpedNormal;\n}\n\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\n	vec3 normalT;\n	normalT.x = 2.0 * normalMapSample.x - 1.0;\n	normalT.y = 1.0 - 2.0 * normalMapSample.y;\n	normalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\n\n	vec3 T = normalize(tangent);\n	vec3 B = normalize(binormal);\n	vec3 N = normalize(unitNormal);\n	mat3 TBN = mat3(T, B, N);\n\n	// Transform from tangent space to world space.\n	vec3 bumpedNormal = TBN * normalize(normalT);\n\n	return bumpedNormal;\n}\n\nvec3 DecodeLightmap(vec4 color) {\n	return color.rgb*color.a*5.0;\n}\n\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\n	vec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\n	transTexcoord.y+=1.0;\n	return transTexcoord;\n}\n\n");
		Shader3D.addInclude("ShadowHelper.glsl","uniform sampler2D u_shadowMap1;\nuniform sampler2D u_shadowMap2;\nuniform sampler2D u_shadowMap3;\nuniform vec2	  u_shadowPCFoffset;\nuniform vec4     u_shadowPSSMDistance;\nvec4 packDepth(const in float depth)\n{\n	const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n	const vec4 bitMask	= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n	vec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\n	res -= res.xxyz * bitMask;\n	return res;\n}\nfloat unpackDepth(const in vec4 rgbaDepth)\n{\n	const vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n	float depth = dot(rgbaDepth, bitShift);\n	return depth;\n}\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\n{\n	vec2 texelpos =texcoord / invsize;\n	vec2 lerps = fract( texelpos );\n	float sourcevals[4];\n	sourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\n	sourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\n	sourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\n	sourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\n	return mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\n}\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	int nPSNum = int(posViewZ>pssmDistance.x);\n	nPSNum += int(posViewZ>pssmDistance.y);\n	nPSNum += int(posViewZ>pssmDistance.z);\n	//真SB,webgl不支持在PS中直接访问数组\n	mat4 lightVP;\n	if( nPSNum == 0 )\n	{\n		lightVP = lightShadowVP[1];\n	}\n	else if( nPSNum == 1 )\n	{\n		lightVP = lightShadowVP[2];\n	}\n	else if( nPSNum == 2 )\n	{\n		lightVP = lightShadowVP[3];\n	}\n	vec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n	//为了效率，在CPU计算/2.0 + 0.5\n	//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n	vec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n	float fMyZ = vText.z - zBias;\n	/*\n	bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n	bool bInFrustum = all( bInFrustumVec );\n	bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n	bool bFrustumTest = all( bFrustumTestVec );\n	if ( bFrustumTest ) \n	*/\n	if( fMyZ <= 1.0 )\n	{\n		float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n		if ( nPSNum == 0 )\n		{\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,	fMyZ );\n			value = value/4.0;\n		} \n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF2\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n\n#endif\n#ifdef SHADOWMAP_PCF1\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			vec4 color = texture2D( shadowMap2,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n		vec4 color;\n		if ( nPSNum == 0 )\n		{\n			color = texture2D( shadowMap1,vText.xy );\n		}\n		else if( nPSNum == 1 )\n		{\n			color = texture2D( shadowMap2,vText.xy );\n		}\n		else if( nPSNum == 2 )\n		{\n			color = texture2D( shadowMap3,vText.xy );\n		}\n		zdepth = unpackDepth(color);\n		value = float(fMyZ < zdepth);\n#endif\n	}\n	return value;\n}\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	int nPSNum = int(posViewZ>pssmDistance.x);\n	nPSNum += int(posViewZ>pssmDistance.y);\n	//真SB,webgl不支持在PS中直接访问数组\n	mat4 lightVP;\n	if( nPSNum == 0 )\n	{\n		lightVP = lightShadowVP[1];\n	}\n	else if( nPSNum == 1 )\n	{\n		lightVP = lightShadowVP[2];\n	}\n	vec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n	//为了效率，在CPU计算/2.0 + 0.5\n	//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n	vec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n	float fMyZ = vText.z - zBias;\n	/*\n	bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n	bool bInFrustum = all( bInFrustumVec );\n	bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n	bool bFrustumTest = all( bFrustumTestVec );\n	if ( bFrustumTest ) \n	*/\n	if( fMyZ <= 1.0 )\n	{\n		float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n		if ( nPSNum == 0 )\n		{\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,	fMyZ );\n			value = value/4.0;\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n#endif\n#ifdef SHADOWMAP_PCF2\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n#endif\n#ifdef SHADOWMAP_PCF1\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			vec4 color = texture2D( shadowMap2,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n		vec4 color;\n		if ( nPSNum == 0 )\n		{\n			color = texture2D( shadowMap1,vText.xy );\n		}\n		else if( nPSNum == 1 )\n		{\n			color = texture2D( shadowMap2,vText.xy );\n		}\n		zdepth = unpackDepth(color);\n		value = float(fMyZ < zdepth);\n#endif\n	}\n	return value;\n}\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	if( posViewZ < pssmDistance.x )\n	{\n		vec3 vText = lightMVPPos.xyz / lightMVPPos.w;\n		float fMyZ = vText.z - zBias;\n		/*\n		bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n		bool bInFrustum = all( bInFrustumVec );\n		bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n		bool bFrustumTest = all( bFrustumTestVec );\n		*/\n		if ( fMyZ <= 1.0 ) \n		{\n			float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\n			value = value/4.0;\n#endif\n#ifdef SHADOWMAP_PCF2		\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF1\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF_NO		\n			vec4 color = texture2D( shadowMap1,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n#endif\n		}\n	}\n	return value;\n}");
		Shader3D.addInclude("BRDF.glsl","struct LayaGI\n{\n	vec3 diffuse;\n	vec3 specular;\n};\n\nvec4 LayaAirBRDF(in vec3 diffuseColor, in vec3 specularColor, in float oneMinusReflectivity, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n	float perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n	vec3 halfDir = SafeNormalize(viewDir - lightDir);\n	\n	float nv = abs(dot(normal, viewDir));\n	\n	float nl = clamp(dot(normal,   -lightDir),  0.0, 1.0);\n	float nh = clamp(dot(normal,     halfDir),  0.0, 1.0);\n	float lv = clamp(dot(lightDir,   viewDir),  0.0, 1.0);\n	float lh = clamp(dot(lightDir,  -halfDir),  0.0, 1.0);\n	\n	float diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\n	\n	float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n	\n	//#if UNITY_BRDF_GGX\n	float V = SmithJointGGXVisibilityTerm(nl, nv, roughness);\n	float D = GGXTerm(nh, roughness);\n	\n	float specularTerm = V * D * PI;\n	\n	specularTerm = sqrt(max(0.0001, specularTerm));\n	specularTerm = max(0.0, specularTerm * nl);\n	\n	float surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\n	float grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity), 0.0, 1.0);\n	\n	vec4 color;\n	color.rgb = diffuseColor * (gi.diffuse + lightColor * diffuseTerm) \n			  + specularTerm * lightColor * FresnelTerm (specularColor, lh)\n			  + surfaceReduction * gi.specular * FresnelLerp(specularColor, vec3(grazingTerm), nv);\n	\n	return color;\n}");
		Shader3D.addInclude("PBRUtils.glsl","struct DirectionLight\n{\n	vec3 Color;\n	vec3 Direction;\n};\n\nstruct PointLight\n{\n	vec3 Color;\n	vec3 Position;\n	float Range;\n};\n\nstruct SpotLight\n{\n	vec3 Color;\n	vec3 Position;\n	vec3 Direction;\n	float SpotAngle;\n	float Range;\n};\n\nvec3 UnpackScaleNormal(in vec2 uv0)\n{\n	#ifdef NORMALTEXTURE\n		vec3 normalT;\n		vec4 normalMapSample = texture2D(u_NormalTexture, uv0);\n		normalT.x = 2.0 * normalMapSample.x - 1.0;\n		normalT.y = 1.0 - 2.0 * normalMapSample.y;\n		normalT.xy *= u_normalScale;\n		normalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\n		\n		vec3 T = normalize(v_Tangent);\n		vec3 B = normalize(v_Binormal);\n		vec3 N = normalize(v_Normal);\n		mat3 TBN = mat3(T, B, N);\n		\n		vec3 bumpedNormal = TBN * normalize(normalT);\n		return bumpedNormal;\n	#else\n		return normalize(v_Normal);\n	#endif\n}\n\nvec4 DielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\n\nfloat PI = 3.14159265359;\n\nvec3 FresnelTerm (in vec3 F0, in float cosA)\n{\n	return F0 + (vec3(1.0) - F0) * pow(1.0 - cosA, 5.0);\n}\n\nvec3 FresnelLerp (in vec3 F0, in vec3 F90, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);\n    return mix(F0, F90, t);\n}\n\nfloat PerceptualRoughnessToRoughness(in float perceptualRoughness)\n{\n	return perceptualRoughness * perceptualRoughness;\n}\n\nfloat PerceptualRoughnessToSpecularPower(in float perceptualRoughness)\n{\n	float m = PerceptualRoughnessToRoughness(perceptualRoughness);\n	float sq = max(0.0001, m * m);\n	float n = (2.0 / sq) - 2.0;\n	n = max(n, 0.0001);\n	return n;\n}\n\nfloat RoughnessToPerceptualRoughness(in float roughness)\n{\n	return sqrt(roughness);\n}\n\nfloat SmoothnessToRoughness(in float smoothness)\n{\n	return (1.0 - smoothness) * (1.0 - smoothness);\n}\n\nfloat SmoothnessToPerceptualRoughness(in float smoothness)\n{\n	return (1.0 - smoothness);\n}\n\nvec3 SafeNormalize(in vec3 inVec)\n{\n	float dp3 = max(0.001,dot(inVec,inVec));\n	return inVec * (1.0 / sqrt(dp3));\n}\n\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float perceptualRoughness)\n{\n	float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n	float lightScatter	= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL,5.0));\n	float viewScatter	= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV,5.0));\n\n	return lightScatter * viewScatter;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n	float a = roughness;\n	float lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n	float lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n\n	return 0.5 / (lambdaV + lambdaL + 0.00001);\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n	float a2 = roughness * roughness;\n	float d = (NdotH * a2 - NdotH) * NdotH + 1.0;\n	return 0.31830988618 * a2 / (d * d + 0.0000001);\n}\n\nfloat OneMinusReflectivityFromMetallic(in float metallic)\n{\n	float oneMinusDielectricSpec = DielectricSpecularColor.a;\n	return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nfloat SpecularStrength(vec3 specular)\n{\n    //(SHADER_TARGET < 30)return specular.r; \n    return max (max (specular.r, specular.g), specular.b);\n}\n\nvec3 DiffuseAndSpecularFromMetallic(in vec3 diffuseColor, in float metallic, out vec3 specularColor, out float oneMinusReflectivity)\n{\n	specularColor = mix(DielectricSpecularColor.rgb, diffuseColor, metallic);\n	oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n	return diffuseColor * oneMinusReflectivity;\n}\n\nvec3 EnergyConservationBetweenDiffuseAndSpecular(in vec3 diffuseColor, in vec3 specularColor, out float oneMinusReflectivity)\n{\n	oneMinusReflectivity = 1.0 - SpecularStrength(specularColor);\n	return diffuseColor * oneMinusReflectivity;\n}\n\nvec4 Occlusion(in vec2 uv0){\n	#ifdef OCCLUSIONTEXTURE\n		vec4 occlusionTextureColor = texture2D(u_OcclusionTexture, uv0);\n		float occ = occlusionTextureColor.g;\n		float oneMinusT = 1.0 - u_occlusionStrength;\n		float lerpOneTo = oneMinusT + occ * u_occlusionStrength;\n		return occlusionTextureColor * lerpOneTo;\n	#else\n		return vec4(1.0);\n	#endif\n}\n\nvec2 ParallaxOffset(in vec3 viewDir){\n	#ifdef PARALLAXTEXTURE\n		float h = texture2D(u_ParallaxTexture, v_Texcoord0).g;\n		h = h * u_parallaxScale - u_parallaxScale / 2.0;\n		vec3 v = viewDir;\n		v.z += 0.42;\n		vec2 offset = h * (v.xy / v.z);\n		return v_Texcoord0 + offset;\n	#else\n		return v_Texcoord0;\n	#endif\n}\n\nvec3 ReflectCubeMap(in vec3 viewDir, in vec3 normal){\n	#ifdef REFLECTMAP\n		vec3 incident = -viewDir;\n		vec3 reflectionVector = reflect(incident, normal);\n		vec3 reflectionColor = textureCube(u_ReflectTexture, vec3(-reflectionVector.x, reflectionVector.yz)).rgb;\n		return reflectionColor * u_ReflectIntensity;\n	#else\n		return vec3(0.0);\n	#endif\n}\n\nfloat LayaAttenuation(in vec3 L, in float invLightRadius)\n{\n	float fRatio = clamp(length(L) * invLightRadius, 0.0, 1.0);\n	fRatio *= fRatio;\n	return 1.0 / (1.0 + 25.0 * fRatio) * clamp(4.0*(1.0 - fRatio), 0.0, 1.0); //fade to black as if 4 pixel texture\n}\n\nvec3 LayaPreMultiplyAlpha(vec3 diffColor, float alpha, float oneMinusReflectivity, out float outModifiedAlpha)\n{\n	#ifdef ALPHAPREMULTIPLY\n		diffColor *= alpha;\n		outModifiedAlpha = 1.0 - oneMinusReflectivity + alpha * oneMinusReflectivity;\n	#else\n		outModifiedAlpha = alpha;\n	#endif\n	return diffColor;\n}\n\n");
		Shader3D.addInclude("PBRStandardLighting.glsl","#include \"PBRUtils.glsl\"\n#include \"BRDF.glsl\"\n\nvec4 PBRStandardLight(in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n	float oneMinusReflectivity;\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float alpha;\n	\n	diffuseColor = DiffuseAndSpecularFromMetallic (albedoColor.rgb, metallic, specularColor, oneMinusReflectivity);\n	\n	diffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\n	\n	vec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n	color.a = alpha;\n	return color;\n}\n\nvec4 PBRStandardDiectionLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\n{\n	vec3 lightVec = normalize(light.Direction);\n	return PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec4 PBRStandardPointLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\n{\n	vec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\n	float distance = dot(lightCoord, lightCoord);\n	float attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\n	vec3 lightVec = normalize(pos - light.Position);\n	return PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\nvec4 PBRStandardSpotLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n{\n	vec3 lightVec =  pos - light.Position;\n	vec3 normalLightVec = normalize(lightVec);\n	vec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\n	float dl = dot(normalize(light.Direction), normalLightVec);\n	dl *= smoothstep(cosAngles[0], cosAngles[1], dl);\n	float attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\n	return PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n//{\n//	vec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\n//	\n//	float distance = dot(lightCoord, lightCoord);\n//	float attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//	//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//	//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\n//	vec3 lightVec = normalize(pos - light.Position);\n//	return PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n//}\n\nvec2 MetallicGloss(in float albedoTextureAlpha, in vec2 uv0)\n{\n	vec2 mg;\n	\n	#ifdef METALLICGLOSSTEXTURE\n		vec4 metallicGlossTextureColor = texture2D(u_MetallicGlossTexture, uv0);\n		#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n			mg.r = metallicGlossTextureColor.r;\n			mg.g = albedoTextureAlpha;\n		#else\n		    mg = metallicGlossTextureColor.ra;\n		#endif\n		mg.g *= u_smoothnessScale;\n	#else\n		mg.r = u_metallic;\n		#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n			mg.g = albedoTextureAlpha * u_smoothnessScale;\n		#else\n			mg.g = u_smoothness;\n		#endif\n	#endif\n	\n	return mg;\n}\n\n");
		Shader3D.addInclude("PBRSpecularLighting.glsl","#include \"PBRUtils.glsl\"\n#include \"BRDF.glsl\"\n\nvec4 PBRSpecularLight(in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n	float oneMinusReflectivity;\n	vec3 diffuseColor;\n	float alpha;\n	\n	diffuseColor = EnergyConservationBetweenDiffuseAndSpecular (albedoColor.rgb, specularColor, oneMinusReflectivity);\n	\n	diffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\n	\n	vec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n	color.a = alpha;\n	return color;\n}\n\nvec4 PBRSpecularDiectionLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\n{\n	vec3 lightVec = normalize(light.Direction);\n	return PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec4 PBRSpecularPointLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\n{\n	vec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\n	float distance = dot(lightCoord, lightCoord);\n	float attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\n	vec3 lightVec = normalize(pos - light.Position);\n	return PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\nvec4 PBRSpecularSpotLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n{\n	vec3 lightVec =  pos - light.Position;\n	vec3 normalLightVec = normalize(lightVec);\n	vec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\n	float dl = dot(normalize(light.Direction), normalLightVec);\n	dl *= smoothstep(cosAngles[0], cosAngles[1], dl);\n	float attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\n	return PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n//{\n//	vec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\n//	\n//	float distance = dot(lightCoord, lightCoord);\n//	float attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//	//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//	//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\n//	vec3 lightVec = normalize(pos - light.Position);\n//	return PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n//}\n\nvec4 SpecularGloss(float albedoTextureAlpha, in vec2 uv0)\n{\n    vec4 sg;\n	\n	#ifdef SPECULARTEXTURE\n		vec4 specularTextureColor = texture2D(u_SpecularTexture, uv0);\n		#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n			sg.rgb = specularTextureColor.rgb;\n			sg.a = albedoTextureAlpha;\n		#else\n			sg = specularTextureColor;\n		#endif\n		sg.a *= u_smoothnessScale;\n	#else\n		sg.rgb = u_SpecularColor.rgb;\n		#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n			sg.a = albedoTextureAlpha * u_smoothnessScale;\n		#else\n			sg.a = u_smoothness;\n		#endif\n	#endif\n	\n    return sg;\n}\n\n");
		var vs,ps;
		var attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0,
			'a_Color':/*laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1,
			'a_Normal':/*laya.d3.graphics.Vertex.VertexMesh.MESH_NORMAL0*/3,
			'a_Texcoord0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2,
			'a_Texcoord1':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE1*/8,
			'a_BoneWeights':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDINDICES0*/6,
			'a_Tangent0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TANGENT0*/5};
		var uniformMap={
			'u_Bones':/*laya.d3.shader.Shader3D.PERIOD_CUSTOM*/0,
			'u_DiffuseTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_SpecularTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_NormalTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlphaTestValue':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_MaterialSpecular':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_Shininess':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_TilingOffset':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_WorldMat':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_LightmapScaleOffset':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_LightMap':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_CameraPos':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_ReflectTexture':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_ReflectIntensity':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogStart':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogRange':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_DirectionLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_DirectionLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Position':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Range':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Position':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Range':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Spot':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_AmbientColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap1':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap2':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap3':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowPSSMDistance':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_lightShadowVP':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowPCFoffset':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4};
		vs="#include \"Lighting.glsl\";\n\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\n	attribute vec2 a_Texcoord0;\n	varying vec2 v_Texcoord0;\n#endif\n\n#if defined(LIGHTMAP)&&defined(UV1)\n	attribute vec2 a_Texcoord1;\n#endif\n\n#ifdef LIGHTMAP\n	uniform vec4 u_LightmapScaleOffset;\n	varying vec2 v_LightMapUV;\n#endif\n\n#ifdef COLOR\n	attribute vec4 a_Color;\n	varying vec4 v_Color;\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal; \n	uniform vec3 u_CameraPos;\n	varying vec3 v_ViewDir; \n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n	attribute vec4 a_Tangent0;\n	varying vec3 v_Tangent;\n	varying vec3 v_Binormal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position=skinTransform*a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0=a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nvoid main_normal()\n{\n	#ifdef BONE\n		mat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position=skinTransform*a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n		mat3 worldInvMat;\n		#ifdef BONE\n			worldInvMat=inverse(mat3(u_WorldMat*skinTransform));\n		#else\n			worldInvMat=inverse(mat3(u_WorldMat));\n		#endif  \n		v_Normal=a_Normal*worldInvMat;\n		#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n			v_Tangent=a_Tangent0.xyz*worldInvMat;\n			v_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n		#endif\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\n		#ifdef BONE\n			v_PositionWorld=(u_WorldMat*position).xyz;\n		#else\n			v_PositionWorld=(u_WorldMat*a_Position).xyz;\n		#endif\n	#endif\n	\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n		v_ViewDir=u_CameraPos-v_PositionWorld;\n	#endif\n\n	#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n		v_Texcoord0=a_Texcoord0;\n		#ifdef TILINGOFFSET\n			v_Texcoord0=TransformUV(v_Texcoord0,u_TilingOffset);\n		#endif\n	#endif\n\n	#ifdef LIGHTMAP\n		#ifdef SCALEOFFSETLIGHTINGMAPUV\n			#ifdef UV1\n				v_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n			#else\n				v_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n			#endif \n			v_LightMapUV.y=1.0-v_LightMapUV.y;\n		#else\n			#ifdef UV1\n				v_LightMapUV=a_Texcoord1;\n			#else\n				v_LightMapUV=a_Texcoord0;\n			#endif \n		#endif \n	#endif\n\n	#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n		v_Color=a_Color;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include \"Lighting.glsl\";\n\nuniform vec4 u_DiffuseColor;\n\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n	varying vec4 v_Color;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	varying vec3 v_ViewDir; \n#endif\n\n#ifdef ALPHATEST\n	uniform float u_AlphaTestValue;\n#endif\n\n#ifdef DIFFUSEMAP\n	uniform sampler2D u_DiffuseTexture;\n#endif\n\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n	varying vec2 v_Texcoord0;\n#endif\n\n#ifdef LIGHTMAP\n	varying vec2 v_LightMapUV;\n	uniform sampler2D u_LightMap;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	uniform vec3 u_MaterialSpecular;\n	uniform float u_Shininess;\n	#ifdef SPECULARMAP \n		uniform sampler2D u_SpecularTexture;\n	#endif\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	varying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n	uniform sampler2D u_NormalTexture;\n	varying vec3 v_Tangent;\n	varying vec3 v_Binormal;\n#endif\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n	varying vec3 v_PositionWorld;\n#endif\n\n#include \"ShadowHelper.glsl\"\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nvoid main_castShadow()\n{\n	//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\nvoid main_normal()\n{\n	vec3 globalDiffuse=u_AmbientColor;\n	#ifdef LIGHTMAP	\n		globalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\n	#endif\n	\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		vec3 normal;\n		#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n			vec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\n			normal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\n		#else\n			normal = normalize(v_Normal);\n		#endif\n		vec3 viewDir= normalize(v_ViewDir);\n	#endif\n	\n	vec4 mainColor=u_DiffuseColor;\n	#ifdef DIFFUSEMAP\n		vec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n		mainColor=mainColor*difTexColor;\n	#endif \n	#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n		mainColor=mainColor*v_Color;\n	#endif \n    \n	#ifdef ALPHATEST\n		if(mainColor.a<u_AlphaTestValue)\n			discard;\n	#endif\n  \n	\n	vec3 diffuse = vec3(0.0);\n	vec3 specular= vec3(0.0);\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		vec3 dif,spe;\n		#ifdef SPECULARMAP\n			vec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\n		#else\n			#ifdef DIFFUSEMAP\n				vec3 gloss=vec3(difTexColor.a);\n			#else\n				vec3 gloss=vec3(1.0);\n			#endif\n		#endif\n	#endif\n\n	\n	#ifdef DIRECTIONLIGHT\n		LayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n \n	#ifdef POINTLIGHT\n		LayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n\n	#ifdef SPOTLIGHT\n		LayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\n		diffuse+=dif;\n		specular+=spe;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse)*shadowValue,mainColor.a);\n	#else\n		gl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		#ifdef RECEIVESHADOW\n			gl_FragColor.rgb+=specular*shadowValue;\n		#else\n			gl_FragColor.rgb+=specular;\n		#endif\n	#endif\n	  \n	#ifdef FOG\n		float lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\n		gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n		main_normal();\n	#endif  \n}\n\n";
		var shader=Shader3D.add("BLINNPHONG");
		var subShader=new SubShader(attributeMap,uniformMap,SkinnedMeshSprite3D.shaderDefines,BlinnPhongMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0,
			'a_Color':/*laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1};
		uniformMap={
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_Color':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1
		};
		vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n\n\nvoid main()\n{\n  gl_Position = u_MvpMatrix * a_Position;\n  v_Color=a_Color;\n}";
		ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nuniform vec4 u_Color;\n\nvoid main()\n{\n  gl_FragColor = v_Color * u_Color; \n}\n\n";
		shader=Shader3D.add("LineShader");
		subShader=new SubShader(attributeMap,uniformMap);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0,
			'a_Normal':/*laya.d3.graphics.Vertex.VertexMesh.MESH_NORMAL0*/3,
			'a_Tangent0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TANGENT0*/5,
			'a_Texcoord0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2,
			'a_BoneWeights':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDINDICES0*/6
		};
		uniformMap={
			'u_Bones':/*laya.d3.shader.Shader3D.PERIOD_CUSTOM*/0,
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_WorldMat':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_CameraPos':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_AlphaTestValue':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlbedoColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_EmissionColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlbedoTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_NormalTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_ParallaxTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_MetallicGlossTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_OcclusionTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_EmissionTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_metallic':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_smoothness':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_smoothnessScale':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_occlusionStrength':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_normalScale':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_parallaxScale':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_TilingOffset':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DirectionLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_DirectionLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLightMatrix':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Position':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Range':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Position':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Range':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.SpotAngle':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_RangeTexture':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_ReflectTexture':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_ReflectIntensity':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_AmbientColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap1':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap2':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap3':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowPSSMDistance':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_lightShadowVP':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowPCFoffset':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogStart':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogRange':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4
		};
		vs="#include \"Lighting.glsl\";\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n	  varying vec4 v_lightMVPPos;\n	  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0 = a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n	mat3 worldMat;\n	#ifdef BONE\n		mat4 skinTransform = mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n		worldMat=mat3(u_WorldMat*skinTransform);\n		v_PositionWorld = (u_WorldMat * position).xyz;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n		worldMat = mat3(u_WorldMat);\n		v_PositionWorld = (u_WorldMat * a_Position).xyz;\n	#endif\n	\n	v_Normal = worldMat * a_Normal;\n	v_Tangent = worldMat * a_Tangent0.xyz;\n	v_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n  \n	v_Texcoord0 = a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=TransformUV(v_Texcoord0,u_TilingOffset);\n	#endif\n  \n	v_ViewDir = u_CameraPos - v_PositionWorld;\n  \n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
		ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\nuniform vec3 u_AmbientColor;\nuniform vec4 u_AlbedoColor;\n\n#ifdef ALBEDOTEXTURE\n	uniform sampler2D u_AlbedoTexture;\n#endif\n#ifdef METALLICGLOSSTEXTURE\n	uniform sampler2D u_MetallicGlossTexture;\n#endif\n#ifdef NORMALTEXTURE\n	uniform sampler2D u_NormalTexture;\n	uniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n	uniform sampler2D u_ParallaxTexture;\n	uniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n	uniform sampler2D u_OcclusionTexture;\n	uniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n	#ifdef EMISSIONTEXTURE\n		uniform sampler2D u_EmissionTexture;\n	#endif\n	uniform vec4 u_EmissionColor;\n#endif\n#ifdef REFLECTMAP\n	uniform samplerCube u_ReflectTexture;\n	uniform float u_ReflectIntensity;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\nuniform sampler2D u_RangeTexture;\n//uniform sampler2D u_AngleTexture;\nuniform mat4 u_PointLightMatrix;\n//uniform mat4 u_SpotLightMatrix;\n\n#include \"PBRStandardLighting.glsl\"\n#include \"ShadowHelper.glsl\"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\nvoid main_castShadow()\n{\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\n\nvoid main_normal()\n{	\n	vec3 viewDir = normalize(v_ViewDir);\n	\n	vec2 uv0 = ParallaxOffset(viewDir);\n	\n	vec2 mg;\n	vec4 albedoColor;\n	#ifdef ALBEDOTEXTURE\n		vec4 abledoTextureColor = texture2D(u_AlbedoTexture, uv0);\n		albedoColor = abledoTextureColor * u_AlbedoColor;\n		mg = MetallicGloss(abledoTextureColor.a, uv0);\n	#else\n		albedoColor = u_AlbedoColor;\n		mg = MetallicGloss(1.0, uv0);\n	#endif\n	\n	#ifdef ALPHATEST\n		if(albedoColor.a < u_AlphaTestValue)\n			discard;\n	#endif\n	\n	vec3 normal = UnpackScaleNormal(uv0);\n  \n	LayaGI gi;\n	gi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\n	gi.specular = ReflectCubeMap(viewDir, normal);\n  \n	vec4 color = vec4(0.0);\n	\n	#ifdef DIRECTIONLIGHT\n		color += PBRStandardDiectionLight(albedoColor, mg.r, mg.g, normal, viewDir, u_DirectionLight, gi);\n	#endif\n \n	#ifdef POINTLIGHT\n		color.a = 0.0;\n		color += PBRStandardPointLight(albedoColor, mg.r, mg.g, normal, viewDir, u_PointLight, v_PositionWorld, gi);\n	#endif\n	\n	#ifdef SPOTLIGHT\n		color.a = 0.0;\n		color += PBRStandardSpotLight(albedoColor, mg.r, mg.g, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\n	#endif\n	\n	#ifdef EMISSION\n		vec4 emissionColor = u_EmissionColor;\n		#ifdef EMISSIONTEXTURE\n			emissionColor *=  texture2D(u_EmissionTexture, uv0);\n		#endif\n		color.rgb += emissionColor.rgb;\n	#endif\n	\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor = vec4(color.rgb * shadowValue, color.a);\n	#else\n		gl_FragColor = color;\n	#endif\n	\n	#ifdef FOG\n		float lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n		gl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n		main_normal();\n	#endif  \n}";
		shader=Shader3D.add("PBRStandard");
		subShader=new SubShader(attributeMap,uniformMap,SkinnedMeshSprite3D.shaderDefines,PBRStandardMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0,
			'a_Normal':/*laya.d3.graphics.Vertex.VertexMesh.MESH_NORMAL0*/3,
			'a_Tangent0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TANGENT0*/5,
			'a_Texcoord0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2,
			'a_BoneWeights':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDINDICES0*/6
		};
		uniformMap={
			'u_Bones':/*laya.d3.shader.Shader3D.PERIOD_CUSTOM*/0,
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_WorldMat':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_CameraPos':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_AlphaTestValue':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlbedoColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_SpecularColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_EmissionColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlbedoTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_NormalTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_ParallaxTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_SpecularTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_OcclusionTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_EmissionTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_smoothness':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_smoothnessScale':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_occlusionStrength':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_normalScale':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_parallaxScale':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_TilingOffset':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DirectionLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_DirectionLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLightMatrix':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Position':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Range':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Position':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Range':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.SpotAngle':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_RangeTexture':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_ReflectTexture':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_ReflectIntensity':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_AmbientColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap1':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap2':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap3':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowPSSMDistance':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_lightShadowVP':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowPCFoffset':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogStart':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogRange':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4
		};
		vs="#include \"Lighting.glsl\";\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n	  varying vec4 v_lightMVPPos;\n	  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n	#ifdef BONE\n		mat4 skinTransform=mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	 \n	//TODO没考虑UV动画呢\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		v_Texcoord0 = a_Texcoord0;\n	#endif\n		v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n	mat3 worldMat;\n	#ifdef BONE\n		mat4 skinTransform = mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n		worldMat=mat3(u_WorldMat*skinTransform);\n		v_PositionWorld = (u_WorldMat * position).xyz;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n		worldMat = mat3(u_WorldMat);\n		v_PositionWorld = (u_WorldMat * a_Position).xyz;\n	#endif\n	\n	v_Normal = worldMat * a_Normal;\n	v_Tangent = worldMat * a_Tangent0.xyz;\n	v_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n  \n	v_Texcoord0 = a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=TransformUV(v_Texcoord0,u_TilingOffset);\n	#endif\n  \n	v_ViewDir = u_CameraPos - v_PositionWorld;\n  \n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1 \n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW\n		main_castShadow();\n	#else\n		main_normal();\n	#endif\n}";
		ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\nuniform vec3 u_AmbientColor;\nuniform vec4 u_AlbedoColor;\nuniform vec4 u_SpecularColor;\n\n#ifdef ALBEDOTEXTURE\n	uniform sampler2D u_AlbedoTexture;\n#endif\n#ifdef SPECULARTEXTURE\n	uniform sampler2D u_SpecularTexture;\n#endif\n#ifdef NORMALTEXTURE\n	uniform sampler2D u_NormalTexture;\n	uniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n	uniform sampler2D u_ParallaxTexture;\n	uniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n	uniform sampler2D u_OcclusionTexture;\n	uniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n	#ifdef EMISSIONTEXTURE\n		uniform sampler2D u_EmissionTexture;\n	#endif\n	uniform vec4 u_EmissionColor;\n#endif\n#ifdef REFLECTMAP\n	uniform samplerCube u_ReflectTexture;\n	uniform float u_ReflectIntensity;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\nuniform sampler2D u_RangeTexture;\n//uniform sampler2D u_AngleTexture;\nuniform mat4 u_PointLightMatrix;\n//uniform mat4 u_SpotLightMatrix;\n\n#include \"PBRSpecularLighting.glsl\"\n#include \"ShadowHelper.glsl\"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\nvoid main_castShadow()\n{\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\n\nvoid main_normal()\n{	\n	vec3 viewDir = normalize(v_ViewDir);\n	\n	vec2 uv0 = ParallaxOffset(viewDir);\n	\n	vec4 sg;\n	vec4 albedoColor;\n	#ifdef ALBEDOTEXTURE\n		vec4 albedoTextureColor = texture2D(u_AlbedoTexture, uv0);\n		albedoColor = albedoTextureColor * u_AlbedoColor;\n		sg = SpecularGloss(albedoTextureColor.a, uv0);\n	#else\n		albedoColor = u_AlbedoColor;\n		sg = SpecularGloss(1.0, uv0);\n	#endif\n	\n	#ifdef ALPHATEST\n		if(albedoColor.a < u_AlphaTestValue)\n			discard;\n	#endif\n  \n	vec3 normal = UnpackScaleNormal(uv0);\n	\n	LayaGI gi;\n	gi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\n	gi.specular = ReflectCubeMap(viewDir, normal);\n	\n	//float a = (sg.r+sg.g+sg.b) / 3.0;\n  \n	vec4 color = vec4(0.0);\n	\n	#ifdef DIRECTIONLIGHT\n		color += PBRSpecularDiectionLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_DirectionLight, gi);\n	#endif\n \n	#ifdef POINTLIGHT\n		color.a = 0.0;\n		color += PBRSpecularPointLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_PointLight, v_PositionWorld, gi);\n	#endif\n	\n	#ifdef SPOTLIGHT\n		color.a = 0.0;\n		color += PBRSpecularSpotLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\n	#endif\n	\n	#ifdef EMISSION\n		vec4 emissionColor = u_EmissionColor;\n		#ifdef EMISSIONTEXTURE\n			emissionColor *=  texture2D(u_EmissionTexture, uv0);\n		#endif\n		color.rgb += emissionColor.rgb;\n	#endif\n	\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n		#endif\n		gl_FragColor = vec4(color.rgb * shadowValue, color.a);\n	#else\n		gl_FragColor = color;\n	#endif\n	\n	#ifdef FOG\n		float lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n		gl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n	#endif\n}\n\nvoid main()\n{\n	#ifdef CASTSHADOW		\n		main_castShadow();\n	#else\n		main_normal();\n	#endif  \n}\n\n";
		shader=Shader3D.add("PBRSpecular");
		subShader=new SubShader(attributeMap,uniformMap,SkinnedMeshSprite3D.shaderDefines,PBRSpecularMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0,
			'a_Color':/*laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1,
			'a_Texcoord0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2,
			'a_BoneWeights':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDINDICES0*/6
		};
		uniformMap={
			'u_Bones':/*laya.d3.shader.Shader3D.PERIOD_CUSTOM*/0,
			'u_AlbedoTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlbedoColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_TilingOffset':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlphaTestValue':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_FogStart':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogRange':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4
		};
		vs="#include \"Lighting.glsl\";\n\nattribute vec4 a_Position;\n\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\n\nattribute vec4 a_Color;\nvarying vec4 v_Color;\nvarying vec2 v_Texcoord0;\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main() {\n	#ifdef BONE\n		mat4 skinTransform = mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n\n	v_Texcoord0 = a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=TransformUV(v_Texcoord0,u_TilingOffset);\n	#endif\n\n	#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n		v_Color = a_Color;\n	#endif\n}";
		ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n	varying vec4 v_Color;\n#endif\n\n#ifdef ALBEDOTEXTURE\n	uniform sampler2D u_AlbedoTexture;\n	varying vec2 v_Texcoord0;\n#endif\n\nuniform vec4 u_AlbedoColor;\n\n#ifdef ALPHATEST\n	uniform float u_AlphaTestValue;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	#ifdef ADDTIVEFOG\n	#else\n		uniform vec3 u_FogColor;\n	#endif\n#endif\n\nvoid main()\n{\n	vec4 color =  u_AlbedoColor;\n	#ifdef ALBEDOTEXTURE\n		color *= texture2D(u_AlbedoTexture, v_Texcoord0);\n	#endif\n	#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n		color *= v_Color;\n	#endif\n	\n	#ifdef ALPHATEST\n		if(color.a < u_AlphaTestValue)\n			discard;\n	#endif\n	\n	gl_FragColor = color;\n	\n	#ifdef FOG\n		float lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n		#ifdef ADDTIVEFOG\n			gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\n		#else\n			gl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n		#endif\n	#endif\n	\n}\n\n";
		shader=Shader3D.add("Unlit");
		subShader=new SubShader(attributeMap,uniformMap,SkinnedMeshSprite3D.shaderDefines,UnlitMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0,
			'a_Texcoord0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2,
			'a_BoneWeights':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDWEIGHT0*/7,
			'a_BoneIndices':/*laya.d3.graphics.Vertex.VertexMesh.MESH_BLENDINDICES0*/6
		};
		uniformMap={
			'u_Bones':/*laya.d3.shader.Shader3D.PERIOD_CUSTOM*/0,
			'u_AlbedoTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlbedoColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_TilingOffset':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AlphaTestValue':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_FogStart':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogRange':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4
		};
		vs="#include \"Lighting.glsl\";\n\nattribute vec4 a_Position;\nattribute vec4 a_Color;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\n\nvarying vec4 v_Color;\nvarying vec2 v_Texcoord0;\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\n#ifdef BONE\n	const int c_MaxBoneCount = 24;\n	attribute vec4 a_BoneIndices;\n	attribute vec4 a_BoneWeights;\n	uniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main()\n{\n	#ifdef BONE\n		mat4 skinTransform = mat4(0.0);\n		skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n		skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n		skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n		skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n		vec4 position = skinTransform * a_Position;\n		gl_Position = u_MvpMatrix * position;\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n	\n	v_Texcoord0 = a_Texcoord0;\n	#ifdef TILINGOFFSET\n		v_Texcoord0=TransformUV(v_Texcoord0,u_TilingOffset);\n	#endif\n		\n	v_Color = a_Color;\n}";
		ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#ifdef COLOR\n	varying vec4 v_Color;\n#endif\nvarying vec2 v_Texcoord0;\n\n#ifdef MAINTEXTURE\n	uniform sampler2D u_AlbedoTexture;\n#endif\n\nuniform vec4 u_AlbedoColor;\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	#ifdef ADDTIVEFOG\n	#else\n		uniform vec3 u_FogColor;\n	#endif\n#endif\n\nvoid main()\n{\n	vec4 color =  2.0 * u_AlbedoColor;\n	#ifdef COLOR\n		color *= v_Color;\n	#endif\n	#ifdef MAINTEXTURE\n		color *= texture2D(u_AlbedoTexture, v_Texcoord0);\n	#endif\n	\n	gl_FragColor = color;\n	\n	#ifdef FOG\n		float lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n		#ifdef ADDTIVEFOG\n			gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\n		#else\n			gl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n		#endif\n	#endif\n}\n\n";
		shader=Shader3D.add("Effect");
		subShader=new SubShader(attributeMap,uniformMap,SkinnedMeshSprite3D.shaderDefines,EffectMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_CornerTextureCoordinate':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0*/0,
			'a_MeshPosition':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_POSITION0*/1,
			'a_MeshColor':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_COLOR0*/2,
			'a_MeshTextureCoordinate':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0*/3,
			'a_ShapePositionStartLifeTime':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME*/4,
			'a_DirectionTime':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_DIRECTIONTIME*/5,
			'a_StartColor':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTCOLOR0*/6,
			'a_EndColor':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_ENDCOLOR0*/7,
			'a_StartSize':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTSIZE*/8,
			'a_StartRotation0':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTROTATION*/9,
			'a_StartSpeed':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTSPEED*/10,
			'a_Random0':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_RANDOM0*/11,
			'a_Random1':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_RANDOM1*/12,
			'a_SimulationWorldPostion':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION*/13,
			'a_SimulationWorldRotation':/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION*/14};
		uniformMap={
			'u_Tintcolor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_TilingOffset':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_texture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_WorldPosition':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_WorldRotation':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_PositionScale':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SizeScale':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ScalingMode':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_Gravity':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ThreeDStartRotation':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_StretchedBillboardLengthScale':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_StretchedBillboardSpeedScale':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SimulationSpace':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_CurrentTime':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ColorOverLifeGradientAlphas':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ColorOverLifeGradientColors':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_MaxColorOverLifeGradientAlphas':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_MaxColorOverLifeGradientColors':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLVelocityConst':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLVelocityGradientX':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLVelocityGradientY':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLVelocityGradientZ':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLVelocityConstMax':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLVelocityGradientMaxX':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLVelocityGradientMaxY':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLVelocityGradientMaxZ':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_VOLSpaceType':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SOLSizeGradient':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SOLSizeGradientX':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SOLSizeGradientY':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SOLSizeGradientZ':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SOLSizeGradientMax':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SOLSizeGradientMaxX':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SOLSizeGradientMaxY':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SOLSizeGradientMaxZ':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityConst':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityConstSeprarate':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradient':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradientX':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradientY':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradientZ':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityConstMax':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityConstMaxSeprarate':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradientMax':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradientMaxX':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradientMaxY':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradientMaxZ':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_ROLAngularVelocityGradientMaxW':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_TSACycles':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_TSASubUVLength':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_TSAGradientUVs':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_TSAMaxGradientUVs':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_CameraPosition':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_CameraDirection':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_CameraUp':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_View':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_Projection':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_FogStart':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogRange':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4};
		vs="#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n	attribute vec4 a_CornerTextureCoordinate;\n#endif\n#ifdef RENDERMODE_MESH\n	attribute vec3 a_MeshPosition;\n	attribute vec4 a_MeshColor;\n	attribute vec2 a_MeshTextureCoordinate;\n	varying vec4 v_MeshColor;\n#endif\n\nattribute vec4 a_ShapePositionStartLifeTime;\nattribute vec4 a_DirectionTime;\nattribute vec4 a_StartColor;\nattribute vec3 a_StartSize;\nattribute vec3 a_StartRotation0;\nattribute float a_StartSpeed;\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n  attribute vec4 a_Random0;\n#endif\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  attribute vec4 a_Random1;\n#endif\nattribute vec3 a_SimulationWorldPostion;\nattribute vec4 a_SimulationWorldRotation;\n\nvarying float v_Discard;\nvarying vec4 v_Color;\n#ifdef DIFFUSEMAP\n	varying vec2 v_TextureCoordinate;\n#endif\n\nuniform float u_CurrentTime;\nuniform vec3 u_Gravity;\n\nuniform vec3 u_WorldPosition;\nuniform vec4 u_WorldRotation;\nuniform bool u_ThreeDStartRotation;\nuniform int u_ScalingMode;\nuniform vec3 u_PositionScale;\nuniform vec3 u_SizeScale;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\n#ifdef STRETCHEDBILLBOARD\n	uniform vec3 u_CameraPosition;\n#endif\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\nuniform vec3 u_CameraUp;\n\nuniform  float u_StretchedBillboardLengthScale;\nuniform  float u_StretchedBillboardSpeedScale;\nuniform int u_SimulationSpace;\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  int  u_VOLSpaceType;\n#endif\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\n  uniform  vec3 u_VOLVelocityConst;\n#endif\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n  uniform  vec3 u_VOLVelocityConstMax;\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\n#endif\n\n#ifdef COLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n#ifdef RANDOMCOLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n\n\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\n#endif\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\n#endif\n\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  float u_ROLAngularVelocityConst;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  float u_ROLAngularVelocityConstMax;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\n  #endif\n#endif\n#ifdef ROTATIONOVERLIFETIMESEPERATE\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\n	uniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\n  uniform  float u_TSACycles;\n  uniform  vec2 u_TSASubUVLength;\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\n#endif\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\n#endif\n\n#ifdef FOG\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef TILINGOFFSET\n	uniform vec4 u_TilingOffset;\n#endif\n\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\n{\n	float halfRoll = rot.z * 0.5;\n    float halfPitch = rot.x * 0.5;\n	float halfYaw = rot.y * 0.5;\n\n	float sinRoll = sin(halfRoll);\n	float cosRoll = cos(halfRoll);\n	float sinPitch = sin(halfPitch);\n	float cosPitch = cos(halfPitch);\n	float sinYaw = sin(halfYaw);\n	float cosYaw = cos(halfYaw);\n\n	float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n	float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n	float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n	float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n	\n	//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n	//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n	//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n	\n	float x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n	float xx = quaX * x;\n    float xy = quaX * y;\n	float xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n	\n}\n\n//假定axis已经归一化\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\n{\n	float halfAngle = angle * 0.5;\n	float sin = sin(halfAngle);\n	\n	float quaX = axis.x * sin;\n	float quaY = axis.y * sin;\n	float quaZ = axis.z * sin;\n	float quaW = cos(halfAngle);\n	\n	//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n	//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n	//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n	\n	float x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n	float xx = quaX * x;\n    float xy = quaX * y;\n	float xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n	\n}\n\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \n{\n	return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n \n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n	float curValue;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientNumber=gradientNumbers[i];\n		float key=gradientNumber.x;\n		if(key>=normalizedAge)\n		{\n			vec2 lastGradientNumber=gradientNumbers[i-1];\n			float lastKey=lastGradientNumber.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			curValue=mix(lastGradientNumber.y,gradientNumber.y,age);\n			break;\n		}\n	}\n	return curValue;\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n	float totalValue=0.0;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientNumber=gradientNumbers[i];\n		float key=gradientNumber.x;\n		vec2 lastGradientNumber=gradientNumbers[i-1];\n		float lastValue=lastGradientNumber.y;\n		\n		if(key>=normalizedAge){\n			float lastKey=lastGradientNumber.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			totalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\n			break;\n		}\n		else{\n			totalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\n		}\n	}\n	return totalValue;\n}\n#endif\n\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\n{\n	vec4 overTimeColor;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientAlpha=gradientAlphas[i];\n		float alphaKey=gradientAlpha.x;\n		if(alphaKey>=normalizedAge)\n		{\n			vec2 lastGradientAlpha=gradientAlphas[i-1];\n			float lastAlphaKey=lastGradientAlpha.x;\n			float age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\n			overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n			break;\n		}\n	}\n	\n	for(int i=1;i<4;i++)\n	{\n		vec4 gradientColor=gradientColors[i];\n		float colorKey=gradientColor.x;\n		if(colorKey>=normalizedAge)\n		{\n			vec4 lastGradientColor=gradientColors[i-1];\n			float lastColorKey=lastGradientColor.x;\n			float age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\n			overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n			break;\n		}\n	}\n	return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\n{\n	float overTimeFrame;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientFrame=gradientFrames[i];\n		float key=gradientFrame.x;\n		if(key>=normalizedAge)\n		{\n			vec2 lastGradientFrame=gradientFrames[i-1];\n			float lastKey=lastGradientFrame.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n			break;\n		}\n	}\n	return floor(overTimeFrame);\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\nvec3 computeParticleLifeVelocity(in float normalizedAge)\n{\n  vec3 outLifeVelocity;\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\n	 outLifeVelocity=u_VOLVelocityConst; \n  #endif\n  #ifdef VELOCITYOVERLIFETIMECURVE\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n	 outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\n	                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\n					 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n  #endif\n					\n  return outLifeVelocity;\n} \n#endif\n\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\n{\n   vec3 startPosition;\n   vec3 lifePosition;\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	#ifdef VELOCITYOVERLIFETIMECONSTANT\n		  startPosition=startVelocity*age;\n		  lifePosition=lifeVelocity*age;\n	#endif\n	#ifdef VELOCITYOVERLIFETIMECURVE\n		  startPosition=startVelocity*age;\n		  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n	#endif\n	#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n		  startPosition=startVelocity*age;\n		  lifePosition=lifeVelocity*age;\n	#endif\n	#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n		  startPosition=startVelocity*age;\n		  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\n	      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\n	      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n	#endif\n	\n	vec3 finalPosition;\n	if(u_VOLSpaceType==0){\n	  if(u_ScalingMode!=2)\n	   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\n	  else\n	   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\n	}\n	else{\n	  if(u_ScalingMode!=2)\n	    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\n	  else\n	    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\n	}\n  #else\n	 startPosition=startVelocity*age;\n	 vec3 finalPosition;\n	 if(u_ScalingMode!=2)\n	   finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\n	 else\n	   finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_SimulationSpace==0)\n    finalPosition=finalPosition+a_SimulationWorldPostion;\n  else if(u_SimulationSpace==1) \n    finalPosition=finalPosition+u_WorldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return  finalPosition;\n}\n\n\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\n{\n	#ifdef COLOROVERLIFETIME\n	  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\n	#endif\n	\n	#ifdef RANDOMCOLOROVERLIFETIME\n	  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\n	#endif\n\n    return color;\n}\n\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\n{\n	#ifdef SIZEOVERLIFETIMECURVE\n		size*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVES\n	    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n	#endif\n	#ifdef SIZEOVERLIFETIMECURVESEPERATE\n		size*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n	    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n	    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\n	#endif\n	return size;\n}\n\n#ifdef RENDERMODE_MESH\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\n{\n	#ifdef SIZEOVERLIFETIMECURVE\n		size*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVES\n	    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n	#endif\n	#ifdef SIZEOVERLIFETIMECURVESEPERATE\n		size*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n	    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n	    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\n		,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\n	#endif\n	return size;\n}\n#endif\n\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\n{ \n	#ifdef ROTATIONOVERLIFETIME\n		#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConst*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n		#endif\n	#endif\n	#ifdef ROTATIONOVERLIFETIMESEPERATE\n		#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n		#endif\n	#endif\n	return rotation;\n}\n\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\n{ \n	#ifdef ROTATIONOVERLIFETIME\n	#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConst*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n		#endif\n	#endif\n	#ifdef ROTATIONOVERLIFETIMESEPERATE\n		#ifdef ROTATIONOVERLIFETIMECONSTANT\n			vec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			vec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\n	        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\n	        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n		#endif\n	#endif\n	return rotation;\n}\n#endif\n\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\n{ \n	#ifdef TEXTURESHEETANIMATIONCURVE\n		float cycleNormalizedAge=normalizedAge*u_TSACycles;\n		float frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\n		float totalULength=frame*u_TSASubUVLength.x;\n		float floorTotalULength=floor(totalULength);\n	    uv.x+=totalULength-floorTotalULength;\n		uv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n	#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n		float cycleNormalizedAge=normalizedAge*u_TSACycles;\n		float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n	    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\n		float totalULength=frame*u_TSASubUVLength.x;\n		float floorTotalULength=floor(totalULength);\n	    uv.x+=totalULength-floorTotalULength;\n		uv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n	return uv;\n}\n\nvoid main()\n{\n	float age = u_CurrentTime - a_DirectionTime.w;\n	float normalizedAge = age/a_ShapePositionStartLifeTime.w;\n	vec3 lifeVelocity;\n	if(normalizedAge<1.0){ \n	vec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\n	#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n		lifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\n	#endif \n	vec3 gravityVelocity=u_Gravity*age;\n	\n	vec4 worldRotation;\n	if(u_SimulationSpace==0)\n		worldRotation=a_SimulationWorldRotation;\n	else\n		worldRotation=u_WorldRotation;\n	\n	vec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\n   \n   \n   #ifdef SPHERHBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\n	    corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n		#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n			if(u_ThreeDStartRotation){\n				vec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\n				center += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\n			}\n			else{\n				float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n				float c = cos(rot);\n				float s = sin(rot);\n				mat2 rotation= mat2(c, -s, s, c);\n				corner=rotation*corner;\n				center += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n			}\n		#else\n			if(u_ThreeDStartRotation){\n				center += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\n			}\n			else{\n				float c = cos(a_StartRotation0.x);\n				float s = sin(a_StartRotation0.x);\n				mat2 rotation= mat2(c, -s, s, c);\n				corner=rotation*corner;\n				center += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n			}\n		#endif\n   #endif\n   \n   #ifdef STRETCHEDBILLBOARD\n	vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n	vec3 velocity;\n	#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	    if(u_VOLSpaceType==0)\n		  velocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\n	    else\n		  velocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\n    #else\n	    velocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\n    #endif	\n		vec3 cameraUpVector = normalize(velocity);\n		vec3 direction = normalize(center-u_CameraPosition);\n        vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n		\n		sideVector=u_SizeScale.xzy*sideVector;\n		cameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\n		\n	    vec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n		\n	    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n	    corner=rotaionZHalfPI*corner;\n	    corner.y=corner.y-abs(corner.y);\n		\n	    float speed=length(velocity);//TODO:\n	    center +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef HORIZONTALBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n	    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n		\n		float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n	    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n		corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef VERTICALBILLBOARD\n		vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n		\n		float rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n	    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n		corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef RENDERMODE_MESH\n	    vec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\n		#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n			if(u_ThreeDStartRotation){\n				vec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\n				center+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\n			}\n			else{\n				#ifdef ROTATIONOVERLIFETIME\n					float angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n					if(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n						center+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\n					}\n					else{\n						#ifdef SHAPE\n							center+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n						#else\n							if(u_SimulationSpace==0)\n								center+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\n							else if(u_SimulationSpace==1)\n								center+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\n						#endif\n					}\n				#endif\n				#ifdef ROTATIONOVERLIFETIMESEPERATE\n					//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\n					vec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\n					center+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\n				#endif		\n			}\n		#else\n			if(u_ThreeDStartRotation){\n				center+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\n			}\n			else{\n				if(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n					if(u_SimulationSpace==0)\n						center+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\n					else if(u_SimulationSpace==1)\n						center+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\n				}\n				else{\n					#ifdef SHAPE\n						if(u_SimulationSpace==0)\n							center+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\n						else if(u_SimulationSpace==1)\n							center+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);	\n					#else\n						if(u_SimulationSpace==0)\n							center+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\n						else if(u_SimulationSpace==1)\n							center+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\n					#endif\n				}\n			}\n		#endif\n		v_MeshColor=a_MeshColor;\n   #endif\n   \n    gl_Position=u_Projection*u_View*vec4(center,1.0);\n    v_Color = computeParticleColor(a_StartColor, normalizedAge);\n	#ifdef DIFFUSEMAP\n		#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n			v_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\n		#endif\n		#ifdef RENDERMODE_MESH\n			v_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\n		#endif\n		\n		#ifdef TILINGOFFSET\n			v_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y)*u_TilingOffset.xy+vec2(u_TilingOffset.z,-u_TilingOffset.w);//需要特殊处理\n			v_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y);//需要特殊处理\n		#endif\n	#endif\n    v_Discard=0.0;\n	  \n	#ifdef FOG\n		v_PositionWorld=center;\n	#endif\n   }\n   else\n	{\n		v_Discard=1.0;\n	}\n}\n\n";
		ps="#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying float v_Discard;\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\nuniform vec4 u_Tintcolor;\n\n#ifdef RENDERMODE_MESH\n	varying vec4 v_MeshColor;\n#endif\n\n#ifdef FOG\n	varying vec3 v_PositionWorld;\n	uniform vec3 u_CameraPosition;\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	#ifdef ADDTIVEFOG\n	#else\n		uniform vec3 u_FogColor;\n	#endif\n#endif\n\n\nvoid main()\n{	\n	#ifdef RENDERMODE_MESH\n		gl_FragColor=v_MeshColor;\n	#else\n		gl_FragColor=vec4(1.0);	\n	#endif\n		\n	#ifdef DIFFUSEMAP\n		if(v_Discard!=0.0)\n			discard;\n		#ifdef TINTCOLOR\n			gl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\n		#else\n			gl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n		#endif\n	#else\n		#ifdef TINTCOLOR\n			gl_FragColor*=u_Tintcolor*2.0*v_Color;\n		#else\n			gl_FragColor*=v_Color;\n		#endif\n	#endif\n	\n	#ifdef FOG\n		vec3 toEye=u_CameraPosition-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n		\n		float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n		#ifdef ADDTIVEFOG\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\n		#else\n			gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n		#endif\n	#endif\n}";
		shader=Shader3D.add("PARTICLESHURIKEN");
		subShader=new SubShader(attributeMap,uniformMap,ShuriKenParticle3D.shaderDefines,ShurikenParticleMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0};
		uniformMap={
			'u_TintColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_Exposure':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_Rotation':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_CubeTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3};
		vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nuniform float u_Rotation;\nvarying vec3 v_Texcoord;\n\n\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\n{\n	float angle = degrees * 3.141593 / 180.0;\n	float sina=sin(angle);\n	float cosa=cos(angle);\n	mat2 m = mat2(cosa, -sina, sina, cosa);\n	return vec4(m*vertex.xz, vertex.yw).xzyw;\n}\n		\nvoid main()\n{\n	vec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\n	gl_Position = (u_MvpMatrix*position).xyww;\n	v_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\n}\n";
		ps="#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec3 v_Texcoord;\n\nuniform samplerCube u_CubeTexture;\nuniform float u_Exposure;\nuniform vec4 u_TintColor;\n\n\nvoid main()\n{	\n	vec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\n	gl_FragColor=vec4(color,1.0);\n}\n\n";
		shader=Shader3D.add("SkyBox");
		subShader=new SubShader(attributeMap,uniformMap);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0};
		uniformMap={
			'u_SunSize':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_SunSizeConvergence':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_AtmosphereThickness':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_SkyTint':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_GroundTint':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_Exposure':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_DirectionLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_DirectionLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4
		};
		vs="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include \"Lighting.glsl\";\n\n#define OUTER_RADIUS 1.025\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\n#define MIE 0.0010             // Mie constant 米氏散射\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\n\nconst float SKY_GROUND_THRESHOLD = 0.02;\nconst float outerRadius = OUTER_RADIUS;\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\nconst float innerRadius = 1.0;\nconst float innerRadius2 = 1.0;\nconst float cameraHeight = 0.0001;\n\nconst float HDSundiskIntensityFactor = 15.0;\nconst float simpleSundiskIntensityFactor = 27.0;\n\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\nconst float kmESun = MIE * SUN_BRIGHTNESS;\nconst float km4PI = MIE * 4.0 * 3.14159265;\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\nconst float scaleDepth = 0.25;\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\n\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\n\nattribute vec4 a_Position;\n\nuniform mat4 u_MvpMatrix;\nuniform vec3 u_SkyTint;\nuniform vec3 u_GroundTint;\nuniform float u_Exposure;\nuniform float u_AtmosphereThickness;\nuniform DirectionLight u_DirectionLight;\n\nvarying vec3 v_GroundColor;\nvarying vec3 v_SkyColor;\n\n#ifdef SUN_HIGH_QUALITY\n	varying vec3 v_Vertex;\n#elif defined(SUN_SIMPLE)\n	varying vec3 v_RayDir;\n#else\n	varying float v_SkyGroundFactor;\n#endif\n\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n	varying vec3 v_SunColor;\n#endif\n\n// Calculates the Rayleigh phase function\nfloat getRayleighPhase(vec3 light, vec3 ray) \n{\n	float eyeCos = dot(light, ray);\n	return 0.75 + 0.75*eyeCos*eyeCos;\n}\n\nfloat scaleAngle(float inCos)\n{\n	float x = 1.0 - inCos;\n	return 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\n\nvoid main () {\n	gl_Position = (u_MvpMatrix*a_Position).xyww;\n\n	vec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\n	vec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\n	vec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\n\n	float krESun = RAYLEIGH * SUN_BRIGHTNESS;\n	float kr4PI = RAYLEIGH * 4.0 * 3.14159265;\n\n	vec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\n\n	// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n	vec3 eyeRay = normalize(a_Position.xyz);\n\n	float far = 0.0;\n	vec3 cIn, cOut;\n	if (eyeRay.y >= 0.0) {// Sky\n		// Calculate the length of the \"atmosphere\"\n		far = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\n\n		// Calculate the ray's starting position, then calculate its scattering offset\n		float height = innerRadius + cameraHeight;\n		float depth = exp(scaleOverScaleDepth * -cameraHeight);\n		float startAngle = dot(eyeRay, cameraPos) / height;\n		float startOffset = depth*scaleAngle(startAngle);\n\n		// Initialize the scattering loop variables\n		float sampleLength = far / samples;\n		float scaledLength = sampleLength * scale;\n		vec3 sampleRay = eyeRay * sampleLength;\n		vec3 samplePoint = cameraPos + sampleRay * 0.5;\n\n		vec3 frontColor = vec3(0.0);\n		//unrolling this manually to avoid some platform for loop slow\n		{\n			float height = length(samplePoint);\n			float depth = exp(scaleOverScaleDepth * (innerRadius - height));\n			float lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\n			float cameraAngle = dot(eyeRay, samplePoint) / height;\n			float scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\n			vec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\n			frontColor += attenuate * (depth * scaledLength);\n			samplePoint += sampleRay;\n		}\n		{\n			float height = length(samplePoint);\n			float depth = exp(scaleOverScaleDepth * (innerRadius - height));\n			float lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\n			float cameraAngle = dot(eyeRay, samplePoint) / height;\n			float scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\n			vec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\n			frontColor += attenuate * (depth * scaledLength);\n			samplePoint += sampleRay;\n		}\n\n		// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n		cIn = frontColor * (invWavelength * krESun);\n		cOut = frontColor * kmESun;\n	} else {// Ground\n		far = (-cameraHeight) / (min(-0.001, eyeRay.y));\n		vec3 pos = cameraPos + far * eyeRay;\n\n		// Calculate the ray's starting position, then calculate its scattering offset\n		float depth = exp((-cameraHeight) * (1.0/scaleDepth));\n		float cameraAngle = dot(-eyeRay, pos);\n		float lightAngle = dot(-u_DirectionLight.Direction, pos);\n		float cameraScale = scaleAngle(cameraAngle);\n		float lightScale = scaleAngle(lightAngle);\n		float cameraOffset = depth*cameraScale;\n		float temp = lightScale + cameraScale;\n\n		// Initialize the scattering loop variables\n		float sampleLength = far / samples;\n		float scaledLength = sampleLength * scale;\n		vec3 sampleRay = eyeRay * sampleLength;\n		vec3 samplePoint = cameraPos + sampleRay * 0.5;\n\n		// Now loop through the sample rays\n		vec3 frontColor = vec3(0.0, 0.0, 0.0);\n		vec3 attenuate;\n\n		// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\n		{\n			float height = length(samplePoint);\n			float depth = exp(scaleOverScaleDepth * (innerRadius - height));\n			float scatter = depth*temp - cameraOffset;\n			attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n			frontColor += attenuate * (depth * scaledLength);\n			samplePoint += sampleRay;\n		}\n\n		cIn = frontColor * (invWavelength * krESun + kmESun);\n		cOut = clamp(attenuate, 0.0, 1.0);\n	}\n\n	#ifdef SUN_HIGH_QUALITY\n		v_Vertex = -a_Position.xyz;\n	#elif defined(SUN_SIMPLE) \n		v_RayDir = -eyeRay;\n	#else\n		v_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\n	#endif\n\n	// if we want to calculate color in vprog:\n	// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\n	v_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\n	v_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_DirectionLight.Direction, -eyeRay));\n\n	\n	// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\n	// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\n	// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\n	float lightColorIntensity = clamp(length(u_DirectionLight.Color), 0.25, 1.0);\n\n	#ifdef SUN_HIGH_QUALITY \n		v_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\n	#elif defined(SUN_SIMPLE) \n		v_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\n	#endif\n}\n";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include \"Lighting.glsl\";\n\nconst float MIE_G = -0.990;\nconst float MIE_G2 = 0.9801;\nconst float SKY_GROUND_THRESHOLD = 0.02;\n\nuniform float u_SunSize;\nuniform float u_SunSizeConvergence;\nuniform DirectionLight u_DirectionLight;\n\n\nvarying vec3 v_GroundColor;\nvarying vec3 v_SkyColor;\n\n\n#ifdef SUN_HIGH_QUALITY\n	varying vec3 v_Vertex;\n#elif defined(SUN_SIMPLE)\n	varying vec3 v_RayDir;\n#else\n	varying float v_SkyGroundFactor;\n#endif\n\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n	varying vec3 v_SunColor;\n#endif\n\n// Calculates the Mie phase function\nfloat getMiePhase(float eyeCos, float eyeCos2) {\n	float temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\n	temp = pow(temp, pow(u_SunSize,0.65) * 10.0);\n	temp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\n	temp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\n	return temp;\n}\n\n// Calculates the sun shape\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\n	#ifdef SUN_HIGH_QUALITY\n		float focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\n		return getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\n	#else //SUN_SIMPLE\n		vec3 delta = lightPos - ray;\n		float dist = length(delta);\n		float spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\n		return spot * spot;\n	#endif\n}\n\nvoid main() {\n	// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\n	// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\n	// if y < 0 [eyeRay.y > 0] - sky\n	vec3 col = vec3(0.0, 0.0, 0.0);\n\n	#ifdef SUN_HIGH_QUALITY\n		vec3 ray = normalize(v_Vertex);\n		float y = ray.y / SKY_GROUND_THRESHOLD;\n	#elif defined(SUN_SIMPLE) \n		vec3 ray = v_RayDir;\n		float y = ray.y / SKY_GROUND_THRESHOLD;	\n	#else\n		float y = v_SkyGroundFactor;\n	#endif\n\n	// if we did precalculate color in vprog: just do lerp between them\n	col = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\n\n	#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n		if (y < 0.0)\n			col += v_SunColor * calcSunAttenuation(-u_DirectionLight.Direction, -ray);\n	#endif\n\n	col = sqrt(col);//linear space convert to gamma space\n	gl_FragColor=vec4(col,1.0);\n}\n\n";
		shader=Shader3D.add("SkyBoxProcedural");
		subShader=new SubShader(attributeMap,uniformMap,null,SkyProceduralMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0,
			'a_Normal':/*laya.d3.graphics.Vertex.VertexMesh.MESH_NORMAL0*/3,
			'a_Texcoord0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2
		};
		uniformMap={
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_WorldMat':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_CameraPos':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_LightmapScaleOffset':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_LightMap':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_SplatAlphaTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseTexture1':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseTexture2':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseTexture3':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseTexture4':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseTexture5':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseScaleOffset1':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseScaleOffset2':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseScaleOffset3':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseScaleOffset4':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_DiffuseScaleOffset5':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_FogStart':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogRange':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_FogColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_DirectionLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_DirectionLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Position':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Range':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Attenuation':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_PointLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Position':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Direction':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Range':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Spot':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_SpotLight.Color':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_AmbientColor':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap1':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap2':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowMap3':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowPSSMDistance':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_lightShadowVP':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_shadowPCFoffset':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4
		};
		vs="attribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\n\nvarying vec2 v_Texcoord0;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef LIGHTMAP\n	varying vec2 v_LightMapUV;\n	uniform vec4 u_LightmapScaleOffset;\n#endif\n\n#ifdef RECEIVESHADOW\n	varying float v_posViewZ;\n	#ifdef SHADOWMAP_PSSM1 \n		varying vec4 v_lightMVPPos;\n		uniform mat4 u_lightShadowVP[4];\n	#endif\n#endif\n\nvoid main()\n{\n	gl_Position = u_MvpMatrix * a_Position;\n  \n	v_Texcoord0 = a_Texcoord0;\n  \n	#ifdef LIGHTMAP\n		v_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\n		v_LightMapUV.y = 1.0 - v_LightMapUV.y;\n	#endif\n  \n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n		v_Normal = a_Normal;\n	#endif\n\n	#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n		v_PositionWorld=(u_WorldMat*a_Position).xyz;\n	#endif\n\n	#ifdef RECEIVESHADOW\n		v_posViewZ = gl_Position.w;\n		#ifdef SHADOWMAP_PSSM1\n			v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n		#endif\n	#endif\n}";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include \"Lighting.glsl\";\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	uniform vec3 u_CameraPos;\n	varying vec3 v_Normal;\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\nvarying float v_posViewZ;\n\nuniform vec3 u_AmbientColor;\n\nuniform sampler2D u_SplatAlphaTexture;\n\nuniform sampler2D u_DiffuseTexture1;\nuniform sampler2D u_DiffuseTexture2;\nuniform sampler2D u_DiffuseTexture3;\nuniform sampler2D u_DiffuseTexture4;\nuniform sampler2D u_DiffuseTexture5;\n\nuniform vec4 u_DiffuseScaleOffset1;\nuniform vec4 u_DiffuseScaleOffset2;\nuniform vec4 u_DiffuseScaleOffset3;\nuniform vec4 u_DiffuseScaleOffset4;\nuniform vec4 u_DiffuseScaleOffset5;\n\nvarying vec2 v_Texcoord0;\n\n#ifdef LIGHTMAP\n	uniform sampler2D u_LightMap;\n	varying vec2 v_LightMapUV;\n#endif\n\nvoid main()\n{\n	vec4 splatAlpha = vec4(1.0);\n	#ifdef ExtendTerrain_DETAIL_NUM1\n		splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r;\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM2\n		splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM3\n		splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM4\n		splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\n	#endif\n	#ifdef ExtendTerrain_DETAIL_NUM5\n		splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n		vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n		vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n		vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n		vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n		vec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\n		gl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\n	#endif\n		gl_FragColor.w = splatAlpha.a;\n		\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n    vec3 normal = v_Normal;\n	vec3 dif, spe;\n#endif\n\nvec3 diffuse = vec3(0.0);\nvec3 specular= vec3(0.0);\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	vec3 toEye;\n	#ifdef FOG\n		toEye=u_CameraPos-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n	#else\n		toEye=normalize(u_CameraPos-v_PositionWorld);\n	#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n	LayaAirBlinnPhongDiectionLight(vec3(0.0), 1.0, normal, vec3(1.0), toEye,u_DirectionLight, dif, spe);\n	diffuse+=dif;\n	specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n	LayaAirBlinnPhongPointLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_PointLight, dif, spe);\n	diffuse+=dif;\n	specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n	LayaAirBlinnPhongSpotLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_SpotLight, dif, spe);\n	diffuse+=dif;\n	specular+=spe;\n#endif\n\nvec3 globalDiffuse = u_AmbientColor;\n#ifdef LIGHTMAP\n	globalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\n#endif\n\n#ifdef RECEIVESHADOW\n	float shadowValue = 1.0;\n	#ifdef SHADOWMAP_PSSM3\n		shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif\n	#ifdef SHADOWMAP_PSSM2\n		shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif \n	#ifdef SHADOWMAP_PSSM1\n		shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n	#endif\n	gl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\n#else\n	gl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	#ifdef RECEIVESHADOW\n		gl_FragColor.rgb += specular * shadowValue;\n	#else\n		gl_FragColor.rgb += specular;\n	#endif\n#endif\n\n#ifdef FOG\n	float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\n\n\n\n\n";
		shader=Shader3D.add("ExtendTerrain");
		subShader=new SubShader(attributeMap,uniformMap,RenderableSprite3D.shaderDefines,ExtendTerrainMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position' :/*laya.d3.core.trail.VertexTrail.TRAIL_POSITION0*/0,
			'a_OffsetVector':/*laya.d3.core.trail.VertexTrail.TRAIL_OFFSETVECTOR*/1,
			'a_Texcoord0X' :/*laya.d3.core.trail.VertexTrail.TRAIL_TEXTURECOORDINATE0X*/4,
			'a_Texcoord0Y' :/*laya.d3.core.trail.VertexTrail.TRAIL_TEXTURECOORDINATE0Y*/3,
			'a_BirthTime' :/*laya.d3.core.trail.VertexTrail.TRAIL_TIME0*/2
		};
		uniformMap={
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_View':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_Projection':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_TilingOffset':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_MainTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_MainColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_CurTime' :/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_LifeTime' :/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_WidthCurve' :/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_WidthCurveKeyLength' :/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_GradientColorkey' :/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_GradientAlphakey' :/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2
		};
		vs="attribute vec3 a_Position;\nattribute vec3 a_OffsetVector;\nattribute vec4 a_Color;\nattribute float a_Texcoord0X;\nattribute float a_Texcoord0Y;\nattribute float a_BirthTime;\n\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\nuniform vec4 u_TilingOffset;\n\nuniform float u_CurTime;\nuniform float u_LifeTime;\nuniform vec4 u_WidthCurve[10];\nuniform int u_WidthCurveKeyLength;\n\nuniform vec4 u_GradientColorkey[10];\nuniform vec2 u_GradientAlphakey[10];\n\nvarying vec2 v_Texcoord0;\nvarying vec4 v_Color;\n\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\n{\n	float t2 = t * t;\n	float t3 = t2 * t;\n	float a = 2.0 * t3 - 3.0 * t2 + 1.0;\n	float b = t3 - 2.0 * t2 + t;\n	float c = t3 - t2;\n	float d = -2.0 * t3 + 3.0 * t2;\n	return a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\n}\n\nfloat getCurWidth(in float normalizeTime)\n{\n	float width;\n	if(normalizeTime == 0.0){\n		width=u_WidthCurve[0].w;\n	}\n	else if(normalizeTime >= 1.0){\n		width=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\n	}\n	else{\n		for(int i = 0; i < 10; i ++ )\n		{\n			if(normalizeTime == u_WidthCurve[i].x){\n				width=u_WidthCurve[i].w;\n				break;\n			}\n			\n			vec4 lastFrame = u_WidthCurve[i];\n			vec4 nextFrame = u_WidthCurve[i + 1];\n			if(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\n			{\n				float duration = nextFrame.x - lastFrame.x;\n				float t = (normalizeTime - lastFrame.x) / duration;\n				float outTangent = lastFrame.z;\n				float inTangent = nextFrame.y;\n				float value1 = lastFrame.w;\n				float value2 = nextFrame.w;\n				width=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\n				break;\n			}\n		}\n	}\n	return width;\n}	\n\nvec4 getColorFromGradientByBlend(in vec4 gradientColors[10], in vec2 gradientAlphas[10], in float normalizeTime)\n{\n	vec4 color;\n	for(int i = 1; i < 10; i++)\n	{\n		vec4 gradientColor = gradientColors[i];\n		float colorKey = gradientColor.x;\n		if(colorKey >= normalizeTime)\n		{\n			vec4 lastGradientColor = gradientColors[i-1];\n			float lastColorKey = lastGradientColor.x;\n			float age = (normalizeTime - lastColorKey) / (colorKey - lastColorKey);\n			color.rgb = mix(gradientColors[i-1].yzw, gradientColor.yzw, age);\n			break;\n		}\n	}\n	for(int i = 1; i < 10; i++)\n	{\n		vec2 gradientAlpha = gradientAlphas[i];\n		float alphaKey = gradientAlpha.x;\n		if(alphaKey >= normalizeTime)\n		{\n			vec2 lastGradientAlpha = gradientAlphas[i-1];\n			float lastAlphaKey = lastGradientAlpha.x;\n			float age = (normalizeTime - lastAlphaKey) / (alphaKey - lastAlphaKey);\n			color.a = mix(lastGradientAlpha.y, gradientAlpha.y, age);\n			break;\n		}\n	}\n	return color;\n}\n\nvec4 getColorFromGradientByFixed(in vec4 gradientColors[10], in vec2 gradientAlphas[10], in float normalizeTime)\n{\n	vec4 color;\n	for(int i = 1; i < 10; i++)\n	{\n		vec4 gradientColor = gradientColors[i];\n		if(gradientColor.w >= normalizeTime)\n		{\n			color.rgb = gradientColor.xyz;\n			break;\n		}\n	}\n	for(int i = 1; i < 10; i++)\n	{\n		vec2 gradientAlpha = gradientAlphas[i];\n		if(gradientAlpha.y >= normalizeTime)\n		{\n			color.a = gradientAlpha.x;\n			break;\n		}\n	}\n	return color;\n}\n\nvoid main()\n{\n	float normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\n	\n	#ifdef TILINGOFFSET\n		v_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\n	#else\n		v_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\n	#endif\n	\n	#ifdef GRADIENTMODE_BLEND\n		v_Color = getColorFromGradientByBlend(u_GradientColorkey, u_GradientAlphakey, normalizeTime);\n	#else\n		v_Color = getColorFromGradientByFixed(u_GradientColorkey, u_GradientAlphakey, normalizeTime);\n	#endif\n	\n	gl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\n}\n";
		ps="#ifdef HIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\nuniform sampler2D u_MainTexture;\nuniform vec4 u_MainColor;\n\nvarying vec2 v_Texcoord0;\nvarying vec4 v_Color;\n\nvoid main()\n{	\n	vec4 color = 2.0 * u_MainColor * v_Color;\n	#ifdef MAINTEXTURE\n		vec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\n		color *= mainTextureColor;\n	#endif\n	gl_FragColor = color;\n}\n\n";
		shader=Shader3D.add("Trail");
		subShader=new SubShader(attributeMap,uniformMap,TrailSprite3D.shaderDefines,TrailMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
		attributeMap={
			'a_Position':/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0,
			'a_Normal':/*laya.d3.graphics.Vertex.VertexMesh.MESH_NORMAL0*/3,
			'a_Tangent0':/*laya.d3.graphics.Vertex.VertexMesh.MESH_TANGENT0*/5
		};
		uniformMap={
			'u_MvpMatrix':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_WorldMat':/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2,
			'u_CameraPos':/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3,
			'u_Time':/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4,
			'u_MainTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_NormalTexture':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_HorizonColor':/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_WaveScale' :/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1,
			'u_WaveSpeed' :/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1
		};
		vs="attribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\nuniform float u_WaveScale;\nuniform vec4 u_WaveSpeed;\nuniform float u_Time;\n\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\nvoid main()\n{\n	vec4 positionWorld = u_WorldMat * a_Position;\n	vec4 position = u_MvpMatrix * a_Position;\n	\n	vec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\n	\n	v_Texcoord0 = temp.xy * vec2(0.4, 0.45);\n	v_Texcoord1 = temp.wz;\n	\n	mat3 worldMat = mat3(u_WorldMat);\n	v_Normal = worldMat * a_Normal;\n	v_Tangent = worldMat * a_Tangent0.xyz;\n	v_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n	\n	v_ViewDir = u_CameraPos - positionWorld.xyz;\n	gl_Position = position;\n}";
		ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#ifdef MAINTEXTURE\n	uniform sampler2D u_MainTexture;\n#endif\n\n#ifdef NORMALTEXTURE\n	uniform sampler2D u_NormalTexture;\n#endif\n\nuniform vec4 u_HorizonColor;\n\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\n#include \"Lighting.glsl\"\n\nvoid main()\n{\n	vec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\n	vec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\n	\n	vec3 normal1 = NormalSampleToWorldSpace1(bumpColor1, v_Tangent, v_Binormal, v_Normal);\n	vec3 normal2 = NormalSampleToWorldSpace1(bumpColor2, v_Tangent, v_Binormal, v_Normal);\n	\n	vec3 normal = normalize((normal1 + normal2) * 0.5);\n	vec3 viewDir = normalize(v_ViewDir);\n	float fresnel = dot(viewDir, normal);\n	\n	vec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\n	\n	vec4 color;\n	color.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\n	color.a = u_HorizonColor.a;\n	\n	gl_FragColor = color;\n}\n\n";
		shader=Shader3D.add("WaterPrimary");
		subShader=new SubShader(attributeMap,uniformMap,null,WaterPrimaryMaterial.shaderDefines);
		shader.addSubShader(subShader);
		subShader.addShaderPass(vs,ps);
	}

	ShaderInit3D._rangeAttenTex=null;
	return ShaderInit3D;
})()


/**
*<code>Render</code> 类用于渲染器的父类，抽象类不允许实例。
*/
//class laya.d3.core.render.BaseRender extends laya.events.EventDispatcher
var BaseRender=(function(_super){
	function BaseRender(owner){
		/**@private */
		//this._id=0;
		/**@private */
		//this._lightmapScaleOffset=null;
		/**@private */
		//this._lightmapIndex=0;
		/**@private */
		//this._receiveShadow=false;
		/**@private */
		//this._materialsInstance=null;
		/**@private */
		//this._castShadow=false;
		/**@private [实现IListPool接口]*/
		this._indexInList=-1;
		/**@private */
		this._indexInCastShadowList=-1;
		/**@private */
		//this._boundingSphere=null;
		/**@private */
		//this._boundingBox=null;
		/**@private */
		//this._boundingBoxCenter=null;
		/**@private */
		//this._boundingSphereNeedChange=false;
		/**@private */
		//this._boundingBoxNeedChange=false;
		/**@private */
		//this._boundingBoxCenterNeedChange=false;
		/**@private */
		//this._octreeNodeNeedChange=false;
		/**@private */
		//this._enable=false;
		/**@private */
		//this._shaderValues=null;
		/**@private */
		//this._defineDatas=null;
		/**@private */
		//this._materials=null;
		/**@private */
		//this._scene=null;
		/**@private */
		//this._owner=null;
		/**@private */
		//this._renderElements=null;
		/**@private */
		//this._distanceForSort=NaN;
		/**@private */
		this._visible=true;
		/**@private */
		//this._treeNode=null;
		/**@private */
		//this._updateLoopCount=0;
		/**@private */
		//this._updateCamera=null;
		/**@private */
		this._isPartOfStaticBatch=false;
		/**@private */
		this._staticBatch=null;
		/**排序矫正值。*/
		//this.sortingFudge=NaN;
		/**@private [NATIVE]*/
		//this._cullingBufferIndex=0;
		BaseRender.__super.call(this);
		this._id=++BaseRender._uniqueIDCounter;
		this._indexInCastShadowList=-1;
		this._boundingBox=new BoundBox(new Vector3(),new Vector3());
		this._boundingBoxCenter=new Vector3();
		this._boundingSphere=new BoundSphere(new Vector3(),0);
		if (Render.isConchApp){
			var length=FrustumCulling._cullingBufferLength;
			this._cullingBufferIndex=length;
			var cullingBuffer=FrustumCulling._cullingBuffer;
			var resizeLength=length+5;
			if (resizeLength >=cullingBuffer.length){
				var temp=cullingBuffer;
				cullingBuffer=FrustumCulling._cullingBuffer=new Float32Array(cullingBuffer.length+4096);
				cullingBuffer.set(temp,0);
			}
			cullingBuffer[length]=1;
			FrustumCulling._cullingBufferLength=resizeLength;
		}
		this._boundingSphereNeedChange=true;
		this._boundingBoxNeedChange=true;
		this._boundingBoxCenterNeedChange=true;
		this._octreeNodeNeedChange=true;
		this._materials=[];
		this._renderElements=[];
		this._owner=owner;
		this._enable=true;
		this._materialsInstance=[];
		this._shaderValues=new ShaderData(null);
		this._defineDatas=new DefineDatas();
		this.lightmapIndex=-1;
		this._castShadow=false;
		this.receiveShadow=false;
		this.sortingFudge=0.0;
		(owner)&& (this._owner.transform.on(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this,this._onWorldMatNeedChange));
	}

	__class(BaseRender,'laya.d3.core.render.BaseRender',_super);
	var __proto=BaseRender.prototype;
	Laya.imps(__proto,{"laya.resource.ISingletonElement":true})
	/**
	*@private
	*/
	__proto._changeMaterialReference=function(lastValue,value){
		(lastValue)&& (lastValue._removeReference());
		value._addReference();
	}

	/**
	*@private
	*/
	__proto._getInstanceMaterial=function(material,index){
		var insMat=/*__JS__ */new material.constructor();
		material.cloneTo(insMat);
		insMat.name=insMat.name+"(Instance)";
		this._materialsInstance[index]=true;
		this._changeMaterialReference(this._materials[index],insMat);
		this._materials[index]=insMat;
		return insMat;
	}

	/**
	*@private
	*/
	__proto._applyLightMapParams=function(){
		if (this._scene && this._lightmapIndex >=0){
			var lightMaps=this._scene.getlightmaps();
			if (this._lightmapIndex < lightMaps.length){
				this._defineDatas.add(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
				this._shaderValues.setTexture(RenderableSprite3D.LIGHTMAP,lightMaps[this._lightmapIndex]);
				}else {
				this._defineDatas.remove(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
			}
			}else {
			this._defineDatas.remove(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
		}
	}

	/**
	*@private
	*/
	__proto._onWorldMatNeedChange=function(){
		this._boundingSphereNeedChange=true;
		this._boundingBoxNeedChange=true;
		this._boundingBoxCenterNeedChange=true;
		this._octreeNodeNeedChange=true;
	}

	/**
	*@private
	*/
	__proto._renderRenderableBoundBox=function(){}
	/**
	*@private
	*/
	__proto._calculateBoundingSphere=function(){
		throw("BaseRender: must override it.");
	}

	/**
	*@private
	*/
	__proto._calculateBoundingBox=function(){
		throw("BaseRender: must override it.");
	}

	/**
	*@private [实现ISingletonElement接口]
	*/
	__proto._getIndexInList=function(){
		return this._indexInList;
	}

	/**
	*@private [实现ISingletonElement接口]
	*/
	__proto._setIndexInList=function(index){
		this._indexInList=index;
	}

	/**
	*@private
	*/
	__proto._setBelongScene=function(scene){
		if (this._scene!==scene){
			this._scene=scene;
			this._applyLightMapParams();
		}
	}

	/**
	*@private
	*@param boundFrustum 如果boundFrustum为空则为摄像机不裁剪模式。
	*/
	__proto._needRender=function(boundFrustum){
		return true;
	}

	/**
	*@private
	*逐精灵执行。
	*/
	__proto._renderUpdate=function(context,transform){}
	/**
	*@private
	*逐精灵和相机执行。
	*/
	__proto._renderUpdateWithCamera=function(context,transform){}
	/**
	*@private
	*/
	__proto._updateOctreeNode=function(){
		var treeNode=this._treeNode;
		if (treeNode && this._octreeNodeNeedChange){
			treeNode.updateObject(this);
			this._octreeNodeNeedChange=false;
		}
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		this.offAll();
		var i=0,n=0;
		for (i=0,n=this._renderElements.length;i < n;i++)
		this._renderElements[i].destroy();
		for (i=0,n=this._materials.length;i < n;i++)
		(this._materials[i].destroyed)|| (this._materials[i]._removeReference());
		this._renderElements=null;
		this._owner=null;
		this._materials=null;
		this._boundingBox=null;
		this._boundingBoxCenter=null;
		this._boundingSphere=null;
		this._lightmapScaleOffset=null;
	}

	/**
	*获取包围球,只读,不允许修改其值。
	*@return 包围球。
	*/
	__getset(0,__proto,'boundingSphere',function(){
		if (this._boundingSphereNeedChange){
			this._calculateBoundingSphere();
			this._boundingSphereNeedChange=false;
		}
		return this._boundingSphere;
	});

	/**
	*获取唯一标识ID,通常用于识别。
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	/**
	*设置第一个实例材质。
	*@param value 第一个实例材质。
	*/
	/**
	*返回第一个实例材质,第一次使用会拷贝实例对象。
	*@return 第一个实例材质。
	*/
	__getset(0,__proto,'material',function(){
		var material=this._materials[0];
		if (material && !this._materialsInstance[0]){
			var insMat=this._getInstanceMaterial(material,0);
			var renderElement=this._renderElements[0];
			(renderElement)&& (renderElement.material=insMat);
		}
		return this._materials[0];
		},function(value){
		this.sharedMaterial=value;
	});

	/**
	*是否是静态的一部分。
	*/
	__getset(0,__proto,'isPartOfStaticBatch',function(){
		return this._isPartOfStaticBatch;
	});

	/**
	*设置第一个材质。
	*@param value 第一个材质。
	*/
	/**
	*返回第一个材质。
	*@return 第一个材质。
	*/
	__getset(0,__proto,'sharedMaterial',function(){
		return this._materials[0];
		},function(value){
		var lastValue=this._materials[0];
		if (lastValue!==value){
			this._materials[0]=value;
			this._materialsInstance[0]=false;
			this._changeMaterialReference(lastValue,value);
			var renderElement=this._renderElements[0];
			(renderElement)&& (renderElement.material=value);
		}
	});

	/**
	*设置光照贴图的索引。
	*@param value 光照贴图的索引。
	*/
	/**
	*获取光照贴图的索引。
	*@return 光照贴图的索引。
	*/
	__getset(0,__proto,'lightmapIndex',function(){
		return this._lightmapIndex;
		},function(value){
		if (this._lightmapIndex!==value){
			this._lightmapIndex=value;
			this._applyLightMapParams();
		}
	});

	/**
	*设置光照贴图的缩放和偏移。
	*@param 光照贴图的缩放和偏移。
	*/
	/**
	*获取光照贴图的缩放和偏移。
	*@return 光照贴图的缩放和偏移。
	*/
	__getset(0,__proto,'lightmapScaleOffset',function(){
		return this._lightmapScaleOffset;
		},function(value){
		this._lightmapScaleOffset=value;
		this._shaderValues.setVector(RenderableSprite3D.LIGHTMAPSCALEOFFSET,value);
		this._defineDatas.add(RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
	});

	/**
	*设置是否产生阴影。
	*@param value 是否产生阴影。
	*/
	/**
	*获取是否产生阴影。
	*@return 是否产生阴影。
	*/
	__getset(0,__proto,'castShadow',function(){
		return this._castShadow;
		},function(value){
		if (this._castShadow!==value){
			if (this._owner.activeInHierarchy){
				if (value)
					this._scene._addShadowCastRenderObject(this);
				else
				this._scene._removeShadowCastRenderObject(this);
			}
			this._castShadow=value;
		}
	});

	/**
	*设置是否可用。
	*@param value 是否可用。
	*/
	/**
	*获取是否可用。
	*@return 是否可用。
	*/
	__getset(0,__proto,'enable',function(){
		return this._enable;
		},function(value){
		this._enable=!!value;
	});

	/**
	*设置实例材质列表。
	*@param value 实例材质列表。
	*/
	/**
	*获取潜拷贝实例材质列表,第一次使用会拷贝实例对象。
	*@return 浅拷贝实例材质列表。
	*/
	__getset(0,__proto,'materials',function(){
		for (var i=0,n=this._materials.length;i < n;i++){
			if (!this._materialsInstance[i]){
				var insMat=this._getInstanceMaterial(this._materials[i],i);
				var renderElement=this._renderElements[i];
				(renderElement)&& (renderElement.material=insMat);
			}
		}
		return this._materials.slice();
		},function(value){
		this.sharedMaterials=value;
	});

	/**
	*设置材质列表。
	*@param value 材质列表。
	*/
	/**
	*获取浅拷贝材质列表。
	*@return 浅拷贝材质列表。
	*/
	__getset(0,__proto,'sharedMaterials',function(){
		var materials=this._materials.slice();
		return materials;
		},function(value){
		if (!value)
			throw new Error("BaseRender: shadredMaterials value can't be null.");
		var len=value.length;
		this._materialsInstance.length=len;
		for (var i=0;i < len;i++){
			var lastValue=this._materials[i];
			if (lastValue!==value[i]){
				this._materialsInstance[i]=false;
				this._changeMaterialReference(lastValue,value[i]);
				var renderElement=this._renderElements[i];
				(renderElement)&& (renderElement.material=value[i]);
			}
		}
		this._materials=value;
	});

	/**
	*获取包围盒,只读,不允许修改其值。
	*@return 包围盒。
	*/
	__getset(0,__proto,'boundingBox',function(){
		if (this._boundingBoxNeedChange){
			this._calculateBoundingBox();
			this._boundingBoxNeedChange=false;
		}
		return this._boundingBox;
	});

	/**
	*获取包围盒中心,不允许修改其值。
	*@return 包围盒中心。
	*/
	__getset(0,__proto,'boundingBoxCenter',function(){
		if (this._boundingBoxCenterNeedChange){
			var boundBox=this.boundingBox;
			Vector3.add(boundBox.min,boundBox.max,this._boundingBoxCenter);
			Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
			this._boundingBoxCenterNeedChange=false;
		}
		return this._boundingBoxCenter;
	});

	/**
	*设置是否接收阴影属性
	*/
	/**
	*获得是否接收阴影属性
	*/
	__getset(0,__proto,'receiveShadow',function(){
		return this._receiveShadow;
		},function(value){
		if (this._receiveShadow!==value){
			this._receiveShadow=value;
			if (value)
				this._defineDatas.add(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
			else
			this._defineDatas.remove(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
		}
	});

	BaseRender._uniqueIDCounter=0;
	__static(BaseRender,
	['_tempBoundBoxCorners',function(){return this._tempBoundBoxCorners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];},'_greenColor',function(){return this._greenColor=new Vector4(0.0,1.0,0.0,1.0);}
	]);
	return BaseRender;
})(EventDispatcher)


/**
*<code>Transform3D</code> 类用于实现3D变换。
*/
//class laya.d3.core.Transform3D extends laya.events.EventDispatcher
var Transform3D=(function(_super){
	function Transform3D(owner){
		/**@private */
		this._owner=null;
		/**@private */
		this._children=null;
		/**@private */
		this._parent=null;
		/**@private */
		this._dummy=null;
		/**@private */
		this._transformFlag=0;
		/**变换中心点,注意:该中心点不受变换的影响。*/
		this.pivot=null;
		Transform3D.__super.call(this);
		this._localPosition=new Vector3(0,0,0);
		this._localRotation=new Quaternion(0,0,0,1);
		this._localScale=new Vector3(1,1,1);
		this._localRotationEuler=new Vector3(0,0,0);
		this._localMatrix=new Matrix4x4();
		this._position=new Vector3(0,0,0);
		this._rotation=new Quaternion(0,0,0,1);
		this._scale=new Vector3(1,1,1);
		this._rotationEuler=new Vector3(0,0,0);
		this._worldMatrix=new Matrix4x4();
		this._forward=new Vector3();
		this._up=new Vector3();
		this._right=new Vector3();
		this._owner=owner;
		this._children=[];
		this._setTransformFlag(0x01 | 0x02 | 0x04,false);
		this._setTransformFlag(0x08 | 0x10 | 0x80 | 0x20 | 0x40,true);
	}

	__class(Transform3D,'laya.d3.core.Transform3D',_super);
	var __proto=Transform3D.prototype;
	/**
	*@private
	*/
	__proto._setTransformFlag=function(type,value){
		if (value)
			this._transformFlag |=type;
		else
		this._transformFlag &=~type;
	}

	/**
	*@private
	*/
	__proto._getTransformFlag=function(type){
		return (this._transformFlag & type)!=0;
	}

	/**
	*@private
	*/
	__proto._setParent=function(value){
		if (this._parent!==value){
			if (this._parent){
				var parentChilds=this._parent._children;
				var index=parentChilds.indexOf(this);
				parentChilds.splice(index,1);
			}
			if (value){
				value._children.push(this);
				(value)&& (this._onWorldTransform());
			}
			this._parent=value;
		}
	}

	/**
	*@private
	*/
	__proto._updateLocalMatrix=function(){
		if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0)){
			var scalePivot=Transform3D._tempVector30;
			Vector3.multiply(this.pivot,this._localScale,scalePivot);
			var scaleOffsetPosition=Transform3D._tempVector31;
			Vector3.subtract(scalePivot,this.pivot,scaleOffsetPosition);
			var rotationOffsetPosition=Transform3D._tempVector32;
			var localRot=this.localRotation;
			Vector3.transformQuat(scalePivot,localRot,rotationOffsetPosition);
			Vector3.subtract(rotationOffsetPosition,scalePivot,rotationOffsetPosition);
			var resultLocalPosition=Transform3D._tempVector33;
			Vector3.subtract(this._localPosition,scaleOffsetPosition,resultLocalPosition);
			Vector3.subtract(resultLocalPosition,rotationOffsetPosition,resultLocalPosition);
			Matrix4x4.createAffineTransformation(resultLocalPosition,localRot,this._localScale,this._localMatrix);
			}else {
			Matrix4x4.createAffineTransformation(this._localPosition,this.localRotation,this._localScale,this._localMatrix);
		}
	}

	/**
	*@private
	*/
	__proto._onWorldPositionRotationTransform=function(){
		if (!this._getTransformFlag(0x40)|| !this._getTransformFlag(0x08)|| !this._getTransformFlag(0x10)|| !this._getTransformFlag(0x80)){
			this._setTransformFlag(0x40 | 0x08 | 0x10 | 0x80,true);
			this.event(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this._transformFlag);
			for (var i=0,n=this._children.length;i < n;i++)
			this._children[i]._onWorldPositionRotationTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldPositionScaleTransform=function(){
		if (!this._getTransformFlag(0x40)|| !this._getTransformFlag(0x08)|| !this._getTransformFlag(0x20)){
			this._setTransformFlag(0x40 | 0x08 | 0x20,true);
			this.event(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this._transformFlag);
			for (var i=0,n=this._children.length;i < n;i++)
			this._children[i]._onWorldPositionScaleTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldPositionTransform=function(){
		if (!this._getTransformFlag(0x40)|| !this._getTransformFlag(0x08)){
			this._setTransformFlag(0x40 | 0x08,true);
			this.event(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this._transformFlag);
			for (var i=0,n=this._children.length;i < n;i++)
			this._children[i]._onWorldPositionTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldRotationTransform=function(){
		if (!this._getTransformFlag(0x40)|| !this._getTransformFlag(0x10)|| !this._getTransformFlag(0x80)){
			this._setTransformFlag(0x40 | 0x10 | 0x80,true);
			this.event(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this._transformFlag);
			for (var i=0,n=this._children.length;i < n;i++)
			this._children[i]._onWorldPositionRotationTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldScaleTransform=function(){
		if (!this._getTransformFlag(0x40)|| !this._getTransformFlag(0x20)){
			this._setTransformFlag(0x40 | 0x20,true);
			this.event(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this._transformFlag);
			for (var i=0,n=this._children.length;i < n;i++)
			this._children[i]._onWorldPositionScaleTransform();
		}
	}

	/**
	*@private
	*/
	__proto._onWorldTransform=function(){
		if (!this._getTransformFlag(0x40)|| !this._getTransformFlag(0x08)|| !this._getTransformFlag(0x10)|| !this._getTransformFlag(0x80)|| !this._getTransformFlag(0x20)){
			this._setTransformFlag(0x40 | 0x08 | 0x10 | 0x80 | 0x20,true);
			this.event(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this._transformFlag);
			for (var i=0,n=this._children.length;i < n;i++)
			this._children[i]._onWorldTransform();
		}
	}

	/**
	*平移变换。
	*@param translation 移动距离。
	*@param isLocal 是否局部空间。
	*/
	__proto.translate=function(translation,isLocal){
		(isLocal===void 0)&& (isLocal=true);
		if (isLocal){
			Matrix4x4.createFromQuaternion(this.localRotation,Transform3D._tempMatrix0);
			Vector3.transformCoordinate(translation,Transform3D._tempMatrix0,Transform3D._tempVector30);
			Vector3.add(this.localPosition,Transform3D._tempVector30,this._localPosition);
			this.localPosition=this._localPosition;
			}else {
			Vector3.add(this.position,translation,this._position);
			this.position=this._position;
		}
	}

	/**
	*旋转变换。
	*@param rotations 旋转幅度。
	*@param isLocal 是否局部空间。
	*@param isRadian 是否弧度制。
	*/
	__proto.rotate=function(rotation,isLocal,isRadian){
		(isLocal===void 0)&& (isLocal=true);
		(isRadian===void 0)&& (isRadian=true);
		var rot;
		if (isRadian){
			rot=rotation;
			}else {
			Vector3.scale(rotation,Math.PI / 180.0,Transform3D._tempVector30);
			rot=Transform3D._tempVector30;
		}
		Quaternion.createFromYawPitchRoll(rot.y,rot.x,rot.z,Transform3D._tempQuaternion0);
		if (isLocal){
			Quaternion.multiply(this._localRotation,Transform3D._tempQuaternion0,this._localRotation);
			this.localRotation=this._localRotation;
			}else {
			Quaternion.multiply(Transform3D._tempQuaternion0,this.rotation,this._rotation);
			this.rotation=this._rotation;
		}
	}

	/**
	*观察目标位置。
	*@param target 观察目标。
	*@param up 向上向量。
	*@param isLocal 是否局部空间。
	*/
	__proto.lookAt=function(target,up,isLocal){
		(isLocal===void 0)&& (isLocal=false);
		var targetE=target.elements;
		var eyeE;
		if (isLocal){
			eyeE=this._localPosition.elements;
			if (Math.abs(eyeE[0]-targetE[0])< MathUtils3D.zeroTolerance && Math.abs(eyeE[1]-targetE[1])< MathUtils3D.zeroTolerance && Math.abs(eyeE[2]-targetE[2])< MathUtils3D.zeroTolerance)
				return;
			Quaternion.lookAt(this._localPosition,target,up,this._localRotation);
			this._localRotation.invert(this._localRotation);
			this.localRotation=this._localRotation;
			}else {
			var worldPosition=this.position;
			eyeE=worldPosition.elements;
			if (Math.abs(eyeE[0]-targetE[0])< MathUtils3D.zeroTolerance && Math.abs(eyeE[1]-targetE[1])< MathUtils3D.zeroTolerance && Math.abs(eyeE[2]-targetE[2])< MathUtils3D.zeroTolerance)
				return;
			Quaternion.lookAt(worldPosition,target,up,this._rotation);
			this._rotation.invert(this._rotation);
			this.rotation=this._rotation;
		}
	}

	/**
	*@private
	*/
	__getset(0,__proto,'_isFrontFaceInvert',function(){
		var scale=this.scale;
		var isInvert=scale.x < 0;
		(scale.y < 0)&& (isInvert=!isInvert);
		(scale.z < 0)&& (isInvert=!isInvert);
		return isInvert;
	});

	/**
	*获取所属精灵。
	*/
	__getset(0,__proto,'owner',function(){
		return this._owner;
	});

	/**
	*设置局部位置Y轴分量。
	*@param y 局部位置Y轴分量。
	*/
	/**
	*获取局部位置Y轴分量。
	*@return 局部位置Y轴分量。
	*/
	__getset(0,__proto,'localPositionY',function(){
		return this._localPosition.elements[1];
		},function(y){
		this._localPosition.elements[1]=y;
		this.localPosition=this._localPosition;
	});

	/**
	*设置局部缩放X。
	*@param value 局部缩放X。
	*/
	/**
	*获取局部缩放X。
	*@return 局部缩放X。
	*/
	__getset(0,__proto,'localScaleX',function(){
		return this._localScale.elements[0];
		},function(value){
		this._localScale.elements[0]=value;
		this.localScale=this._localScale;
	});

	/**
	*获取世界矩阵是否需要更新。
	*@return 世界矩阵是否需要更新。
	*/
	__getset(0,__proto,'worldNeedUpdate',function(){
		return this._getTransformFlag(0x40);
	});

	/**
	*设置局部位置X轴分量。
	*@param x 局部位置X轴分量。
	*/
	/**
	*获取局部位置X轴分量。
	*@return 局部位置X轴分量。
	*/
	__getset(0,__proto,'localPositionX',function(){
		return this._localPosition.elements[0];
		},function(x){
		this._localPosition.elements[0]=x;
		this.localPosition=this._localPosition;
	});

	/**
	*设置局部位置。
	*@param value 局部位置。
	*/
	/**
	*获取局部位置。
	*@return 局部位置。
	*/
	__getset(0,__proto,'localPosition',function(){
		return this._localPosition;
		},function(value){
		if (this._localPosition!==value)
			value.cloneTo(this._localPosition);
		this._setTransformFlag(0x04,true);
		this._onWorldPositionTransform();
	});

	/**
	*设置局部位置Z轴分量。
	*@param z 局部位置Z轴分量。
	*/
	/**
	*获取局部位置Z轴分量。
	*@return 局部位置Z轴分量。
	*/
	__getset(0,__proto,'localPositionZ',function(){
		return this._localPosition.elements[2];
		},function(z){
		this._localPosition.elements[2]=z;
		this.localPosition=this._localPosition;
	});

	/**
	*设置局部旋转四元数X分量。
	*@param x 局部旋转四元数X分量。
	*/
	/**
	*获取局部旋转四元数X分量。
	*@return 局部旋转四元数X分量。
	*/
	__getset(0,__proto,'localRotationX',function(){
		return this.localRotation.elements[0];
		},function(x){
		this._localRotation.elements[0]=x;
		this.localRotation=this._localRotation;
	});

	/**
	*设置局部旋转四元数Y分量。
	*@param y 局部旋转四元数Y分量。
	*/
	/**
	*获取局部旋转四元数Y分量。
	*@return 局部旋转四元数Y分量。
	*/
	__getset(0,__proto,'localRotationY',function(){
		return this.localRotation.elements[1];
		},function(y){
		this._localRotation.elements[1]=y;
		this.localRotation=this._localRotation;
	});

	/**
	*设置局部旋转四元数Z分量。
	*@param z 局部旋转四元数Z分量。
	*/
	/**
	*获取局部旋转四元数Z分量。
	*@return 局部旋转四元数Z分量。
	*/
	__getset(0,__proto,'localRotationZ',function(){
		return this.localRotation.elements[2];
		},function(z){
		this._localRotation.elements[2]=z;
		this.localRotation=this._localRotation;
	});

	/**
	*设置局部旋转四元数W分量。
	*@param w 局部旋转四元数W分量。
	*/
	/**
	*获取局部旋转四元数W分量。
	*@return 局部旋转四元数W分量。
	*/
	__getset(0,__proto,'localRotationW',function(){
		return this.localRotation.elements[3];
		},function(w){
		this._localRotation.elements[3]=w;
		this.localRotation=this._localRotation;
	});

	/**
	*设置局部旋转。
	*@param value 局部旋转。
	*/
	/**
	*获取局部旋转。
	*@return 局部旋转。
	*/
	__getset(0,__proto,'localRotation',function(){
		if (this._getTransformFlag(0x01)){
			var eulerE=this._localRotationEuler.elements;
			Quaternion.createFromYawPitchRoll(eulerE[1] / Transform3D._angleToRandin,eulerE[0] / Transform3D._angleToRandin,eulerE[2] / Transform3D._angleToRandin,this._localRotation);
			this._setTransformFlag(0x01,false);
		}
		return this._localRotation;
		},function(value){
		if (this._localRotation!==value)
			value.cloneTo(this._localRotation);
		this._localRotation.normalize(this._localRotation);
		this._setTransformFlag(0x02 | 0x04,true);
		this._setTransformFlag(0x01,false);
		if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
			this._onWorldPositionRotationTransform();
		else
		this._onWorldRotationTransform();
	});

	/**
	*设置局部缩放Y。
	*@param value 局部缩放Y。
	*/
	/**
	*获取局部缩放Y。
	*@return 局部缩放Y。
	*/
	__getset(0,__proto,'localScaleY',function(){
		return this._localScale.elements[1];
		},function(value){
		this._localScale.elements[1]=value;
		this.localScale=this._localScale;
	});

	/**
	*设置局部缩放Z。
	*@param value 局部缩放Z。
	*/
	/**
	*获取局部缩放Z。
	*@return 局部缩放Z。
	*/
	__getset(0,__proto,'localScaleZ',function(){
		return this._localScale.elements[2];
		},function(value){
		this._localScale.elements[2]=value;
		this.localScale=this._localScale;
	});

	/**
	*设置世界位置。
	*@param value 世界位置。
	*/
	/**
	*获取世界位置。
	*@return 世界位置。
	*/
	__getset(0,__proto,'position',function(){
		if (this._getTransformFlag(0x08)){
			if (this._parent !=null){
				var parentPosition=this._parent.position;
				Vector3.multiply(this._localPosition,this._parent.scale,Transform3D._tempVector30);
				Vector3.transformQuat(Transform3D._tempVector30,this._parent.rotation,Transform3D._tempVector30);
				Vector3.add(parentPosition,Transform3D._tempVector30,this._position);
				}else {
				this._localPosition.cloneTo(this._position);
			}
			this._setTransformFlag(0x08,false);
		}
		return this._position;
		},function(value){
		if (this._parent !=null){
			Vector3.subtract(value,this._parent.position,this._localPosition);
			var parentScaleE=this._parent.scale.elements;
			var psX=parentScaleE[0],psY=parentScaleE[1],psZ=parentScaleE[2];
			if (psX!==1.0 || psY!==1.0 || psZ!==1.0){
				var invertScale=Transform3D._tempVector30;
				var invertScaleE=invertScale.elements;
				invertScaleE[0]=1.0 / psX;
				invertScaleE[1]=1.0 / psY;
				invertScaleE[2]=1.0 / psZ;
				Vector3.multiply(this._localPosition,invertScale,this._localPosition);
			};
			var parentRotation=this._parent.rotation;
			parentRotation.invert(Transform3D._tempQuaternion0);
			Vector3.transformQuat(this._localPosition,Transform3D._tempQuaternion0,this._localPosition);
			}else {
			value.cloneTo(this._localPosition);
		}
		this.localPosition=this._localPosition;
		if (this._position!==value)
			value.cloneTo(this._position);
		this._setTransformFlag(0x08,false);
	});

	/**
	*设置局部空间的Y轴欧拉角。
	*@param value 局部空间的Y轴欧拉角。
	*/
	/**
	*获取局部空间的Y轴欧拉角。
	*@return 局部空间的Y轴欧拉角。
	*/
	__getset(0,__proto,'localRotationEulerY',function(){
		return this.localRotationEuler.elements[1];
		},function(value){
		this._localRotationEuler.elements[1]=value;
		this.localRotationEuler=this._localRotationEuler;
	});

	/**
	*设置局部缩放。
	*@param value 局部缩放。
	*/
	/**
	*获取局部缩放。
	*@return 局部缩放。
	*/
	__getset(0,__proto,'localScale',function(){
		return this._localScale;
		},function(value){
		if (this._localScale!==value)
			value.cloneTo(this._localScale);
		this._setTransformFlag(0x04,true);
		if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
			this._onWorldPositionScaleTransform();
		else
		this._onWorldScaleTransform();
	});

	/**
	*设置局部空间的X轴欧拉角。
	*@param value 局部空间的X轴欧拉角。
	*/
	/**
	*获取局部空间的X轴欧拉角。
	*@return 局部空间的X轴欧拉角。
	*/
	__getset(0,__proto,'localRotationEulerX',function(){
		return this.localRotationEuler.elements[0];
		},function(value){
		this._localRotationEuler.elements[0]=value;
		this.localRotationEuler=this._localRotationEuler;
	});

	/**
	*设置局部空间的Z轴欧拉角。
	*@param value 局部空间的Z轴欧拉角。
	*/
	/**
	*获取局部空间的Z轴欧拉角。
	*@return 局部空间的Z轴欧拉角。
	*/
	__getset(0,__proto,'localRotationEulerZ',function(){
		return this.localRotationEuler.elements[2];
		},function(value){
		this._localRotationEuler.elements[2]=value;
		this.localRotationEuler=this._localRotationEuler;
	});

	/**
	*设置局部空间的欧拉角。
	*@param value 欧拉角的旋转值。
	*/
	/**
	*获取局部空间欧拉角。
	*@return 欧拉角的旋转值。
	*/
	__getset(0,__proto,'localRotationEuler',function(){
		if (this._getTransformFlag(0x02)){
			this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
			var eulerE=Transform3D._tempVector30.elements;
			var localRotationEulerE=this._localRotationEuler.elements;
			localRotationEulerE[0]=eulerE[1] *Transform3D._angleToRandin;
			localRotationEulerE[1]=eulerE[0] *Transform3D._angleToRandin;
			localRotationEulerE[2]=eulerE[2] *Transform3D._angleToRandin;
			this._setTransformFlag(0x02,false);
		}
		return this._localRotationEuler;
		},function(value){
		if (this._localRotationEuler!==value)
			value.cloneTo(this._localRotationEuler);
		this._setTransformFlag(0x02,false);
		this._setTransformFlag(0x01 | 0x04,true);
		if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
			this._onWorldPositionRotationTransform();
		else
		this._onWorldRotationTransform();
	});

	/**
	*设置局部矩阵。
	*@param value 局部矩阵。
	*/
	/**
	*获取局部矩阵。
	*@return 局部矩阵。
	*/
	__getset(0,__proto,'localMatrix',function(){
		if (this._getTransformFlag(0x04)){
			this._updateLocalMatrix();
			this._setTransformFlag(0x04,false);
		}
		return this._localMatrix;
		},function(value){
		if (this._localMatrix!==value)
			value.cloneTo(this._localMatrix);
		this._localMatrix.decomposeTransRotScale(this._localPosition,this._localRotation,this._localScale);
		this._setTransformFlag(0x04,false);
		this._onWorldTransform();
	});

	/**
	*设置世界旋转。
	*@param value 世界旋转。
	*/
	/**
	*获取世界旋转。
	*@return 世界旋转。
	*/
	__getset(0,__proto,'rotation',function(){
		if (this._getTransformFlag(0x10)){
			if (this._parent !=null)
				Quaternion.multiply(this._parent.rotation,this.localRotation,this._rotation);
			else
			this.localRotation.cloneTo(this._rotation);
			this._setTransformFlag(0x10,false);
		}
		return this._rotation;
		},function(value){
		if (this._parent !=null){
			this._parent.rotation.invert(Transform3D._tempQuaternion0);
			Quaternion.multiply(Transform3D._tempQuaternion0,value,this._localRotation);
			}else {
			value.cloneTo(this._localRotation);
		}
		this.localRotation=this._localRotation;
		if (value!==this._rotation)
			value.cloneTo(this._rotation);
		this._setTransformFlag(0x10,false);
	});

	/**
	*设置世界缩放。
	*@param value 世界缩放。
	*/
	/**
	*获取世界缩放。
	*@return 世界缩放。
	*/
	__getset(0,__proto,'scale',function(){
		if (!this._getTransformFlag(0x20))
			return this._scale;
		if (this._parent!==null)
			Vector3.multiply(this._parent.scale,this._localScale,this._scale);
		else
		this._localScale.cloneTo(this._scale);
		this._setTransformFlag(0x20,false);
		return this._scale;
		},function(value){
		if (this._parent!==null){
			var pScaleE=this._parent.scale.elements;
			var invPScaleE=Transform3D._tempVector30.elements;
			invPScaleE[0]=1.0 / pScaleE[0];
			invPScaleE[1]=1.0 / pScaleE[1];
			invPScaleE[2]=1.0 / pScaleE[2];
			Vector3.multiply(value,Transform3D._tempVector30,this._localScale);
			}else {
			value.cloneTo(this._localScale);
		}
		this.localScale=this._localScale;
		if (this._scale!==value)
			value.cloneTo(this._scale);
		this._setTransformFlag(0x20,false);
	});

	/**
	*设置世界空间的旋转角度。
	*@param 欧拉角的旋转值，顺序为x、y、z。
	*/
	/**
	*获取世界空间的旋转角度。
	*@return 欧拉角的旋转值，顺序为x、y、z。
	*/
	__getset(0,__proto,'rotationEuler',function(){
		if (this._getTransformFlag(0x80)){
			this.rotation.getYawPitchRoll(Transform3D._tempVector30);
			var eulerE=Transform3D._tempVector30.elements;
			var rotationEulerE=this._rotationEuler.elements;
			rotationEulerE[0]=eulerE[1] *Transform3D._angleToRandin;
			rotationEulerE[1]=eulerE[0] *Transform3D._angleToRandin;
			rotationEulerE[2]=eulerE[2] *Transform3D._angleToRandin;
			this._setTransformFlag(0x80,false);
		}
		return this._rotationEuler;
		},function(value){
		Quaternion.createFromYawPitchRoll(value.y / Transform3D._angleToRandin,value.x / Transform3D._angleToRandin,value.z / Transform3D._angleToRandin,this._rotation);
		this.rotation=this._rotation;
		if (this._rotationEuler!==value)
			value.cloneTo(this._rotationEuler);
		this._setTransformFlag(0x80,false);
	});

	/**
	*设置世界矩阵。
	*@param value 世界矩阵。
	*/
	/**
	*获取世界矩阵。
	*@return 世界矩阵。
	*/
	__getset(0,__proto,'worldMatrix',function(){
		if (this._getTransformFlag(0x40)){
			if (this._parent !=null)
				Matrix4x4.multiply(this._parent.worldMatrix,this.localMatrix,this._worldMatrix);
			else
			this.localMatrix.cloneTo(this._worldMatrix);
			this._setTransformFlag(0x40,false);
		}
		return this._worldMatrix;
		},function(value){
		if (this._parent===null){
			value.cloneTo(this._localMatrix);
			}else {
			this._parent.worldMatrix.invert(this._localMatrix);
			Matrix4x4.multiply(this._localMatrix,value,this._localMatrix);
		}
		this.localMatrix=this._localMatrix;
		if (this._worldMatrix!==value)
			value.cloneTo(this._worldMatrix);
		this._setTransformFlag(0x40,false);
	});

	/**
	*获取向前方向。
	*@return 向前方向。
	*/
	__getset(0,__proto,'forward',function(){
		var worldMatElem=this.worldMatrix.elements;
		this._forward.elements[0]=-worldMatElem[8];
		this._forward.elements[1]=-worldMatElem[9];
		this._forward.elements[2]=-worldMatElem[10];
		return this._forward;
	});

	/**
	*获取向上方向。
	*@return 向上方向。
	*/
	__getset(0,__proto,'up',function(){
		var worldMatElem=this.worldMatrix.elements;
		this._up.elements[0]=worldMatElem[4];
		this._up.elements[1]=worldMatElem[5];
		this._up.elements[2]=worldMatElem[6];
		return this._up;
	});

	/**
	*获取向右方向。
	*@return 向右方向。
	*/
	__getset(0,__proto,'right',function(){
		var worldMatElem=this.worldMatrix.elements;
		this._right.elements[0]=worldMatElem[0];
		this._right.elements[1]=worldMatElem[1];
		this._right.elements[2]=worldMatElem[2];
		return this._right;
	});

	Transform3D.TRANSFORM_LOCALQUATERNION=0x01;
	Transform3D.TRANSFORM_LOCALEULER=0x02;
	Transform3D.TRANSFORM_LOCALMATRIX=0x04;
	Transform3D.TRANSFORM_WORLDPOSITION=0x08;
	Transform3D.TRANSFORM_WORLDQUATERNION=0x10;
	Transform3D.TRANSFORM_WORLDSCALE=0x20;
	Transform3D.TRANSFORM_WORLDMATRIX=0x40;
	Transform3D.TRANSFORM_WORLDEULER=0x80;
	__static(Transform3D,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempMatrix0',function(){return this._tempMatrix0=new Matrix4x4();},'_angleToRandin',function(){return this._angleToRandin=180 / Math.PI;}
	]);
	return Transform3D;
})(EventDispatcher)


/**
*<code>AnimationTransform3D</code> 类用于实现3D变换。
*/
//class laya.d3.animation.AnimationTransform3D extends laya.events.EventDispatcher
var AnimationTransform3D=(function(_super){
	function AnimationTransform3D(owner,localPosition,localRotation,localScale,worldMatrix){
		/**@private */
		//this._localMatrix=null;
		/**@private */
		//this._worldMatrix=null;
		/**@private */
		//this._localPosition=null;
		/**@private */
		//this._localRotation=null;
		/**@private */
		//this._localScale=null;
		/**@private */
		//this._localQuaternionUpdate=false;
		/**@private */
		//this._locaEulerlUpdate=false;
		/**@private */
		//this._localUpdate=false;
		/**@private */
		//this._parent=null;
		/**@private */
		//this._children=null;
		/**@private */
		//this._localRotationEuler=null;
		/**@private */
		//this._owner=null;
		/**@private */
		//this._worldUpdate=false;
		AnimationTransform3D.__super.call(this);
		this._owner=owner;
		this._children=[];
		this._localMatrix=new Float32Array(16);
		if (Render.isConchApp){
			this._localPosition=new Vector3(0,0,0,localPosition);
			this._localRotation=new Quaternion(0,0,0,1,localRotation);
			this._localScale=new Vector3(0,0,0,localScale);
			this._worldMatrix=worldMatrix;
			}else {
			this._localPosition=new Vector3();
			this._localRotation=new Quaternion();
			this._localScale=new Vector3();
			this._worldMatrix=new Float32Array(16);
		}
		this._localQuaternionUpdate=false;
		this._locaEulerlUpdate=false;
		this._localUpdate=false;
		this._worldUpdate=true;
	}

	__class(AnimationTransform3D,'laya.d3.animation.AnimationTransform3D',_super);
	var __proto=AnimationTransform3D.prototype;
	/**
	*@private
	*/
	__proto._getlocalMatrix=function(){
		if (this._localUpdate){
			Utils3D._createAffineTransformationArray(this._localPosition.elements,this._localRotation.elements,this._localScale.elements,this._localMatrix);
			this._localUpdate=false;
		}
		return this._localMatrix;
	}

	/**
	*@private
	*/
	__proto._onWorldTransform=function(){
		if (!this._worldUpdate){
			this._worldUpdate=true;
			for (var i=0,n=this._children.length;i < n;i++)
			this._children[i]._onWorldTransform();
		}
	}

	/**
	*获取世界矩阵。
	*@return 世界矩阵。
	*/
	__proto.getWorldMatrix=function(){
		if (!Render.isConchApp && this._worldUpdate){
			if (this._parent !=null){
				Utils3D.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(),this._getlocalMatrix(),this._worldMatrix);
				}else {
				var locMat=this._getlocalMatrix();
				for (var i=0;i < 16;++i)
				this._worldMatrix[i]=locMat[i];
			}
			this._worldUpdate=false;
		}
		return this._worldMatrix;
	}

	/**
	*设置父3D变换。
	*@param value 父3D变换。
	*/
	__proto.setParent=function(value){
		if (this._parent!==value){
			if (this._parent){
				var parentChilds=this._parent._children;
				var index=parentChilds.indexOf(this);
				parentChilds.splice(index,1);
			}
			if (value){
				value._children.push(this);
				(value)&& (this._onWorldTransform());
			}
			this._parent=value;
		}
	}

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'localPosition',function(){
		return this._localPosition;
		},function(value){
		this._localPosition=value;
		this._localUpdate=true;
		this._onWorldTransform();
	});

	/*
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'localRotation',function(){
		if (this._localQuaternionUpdate){
			var eulerE=this._localRotationEuler.elements;
			Quaternion.createFromYawPitchRoll(eulerE[1] / AnimationTransform3D._angleToRandin,eulerE[0] / AnimationTransform3D._angleToRandin,eulerE[2] / AnimationTransform3D._angleToRandin,this._localRotation);
			this._localQuaternionUpdate=false;
		}
		return this._localRotation;
		},function(value){
		this._localRotation=value;
		this._locaEulerlUpdate=true;
		this._localQuaternionUpdate=false;
		this._localUpdate=true;
		this._onWorldTransform();
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'localScale',function(){
		return this._localScale;
		},function(value){
		this._localScale=value;
		this._localUpdate=true;
		this._onWorldTransform();
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'localRotationEuler',function(){
		if (this._locaEulerlUpdate){
			this._localRotation.getYawPitchRoll(AnimationTransform3D._tempVector3);
			var eulerE=AnimationTransform3D._tempVector3.elements;
			var localRotationEulerE=this._localRotationEuler.elements;
			localRotationEulerE[0]=eulerE[1] *AnimationTransform3D._angleToRandin;
			localRotationEulerE[1]=eulerE[0] *AnimationTransform3D._angleToRandin;
			localRotationEulerE[2]=eulerE[2] *AnimationTransform3D._angleToRandin;
			this._locaEulerlUpdate=false;
		}
		return this._localRotationEuler;
		},function(value){
		this._localRotationEuler=value;
		this._locaEulerlUpdate=false;
		this._localQuaternionUpdate=true;
		this._localUpdate=true;
		this._onWorldTransform();
	});

	__static(AnimationTransform3D,
	['_tempVector3',function(){return this._tempVector3=new Vector3();},'_angleToRandin',function(){return this._angleToRandin=180 / Math.PI;}
	]);
	return AnimationTransform3D;
})(EventDispatcher)


/**
*<code>Script3D</code> 类用于创建脚本的父类,该类为抽象类,不允许实例。
*/
//class laya.d3.component.Script3D extends laya.components.Component
var Script3D=(function(_super){
	function Script3D(){
		Script3D.__super.call(this);;
	}

	__class(Script3D,'laya.d3.component.Script3D',_super);
	var __proto=Script3D.prototype;
	/**
	*@private
	*/
	__proto._checkProcessTriggers=function(){
		var prototype=laya.d3.component.Script3D.prototype;
		if (this.onTriggerEnter!==prototype.onTriggerEnter)
			return true;
		if (this.onTriggerStay!==prototype.onTriggerStay)
			return true;
		if (this.onTriggerExit!==prototype.onTriggerExit)
			return true;
		return false;
	}

	/**
	*@private
	*/
	__proto._checkProcessCollisions=function(){
		var prototype=laya.d3.component.Script3D.prototype;
		if (this.onCollisionEnter!==prototype.onCollisionEnter)
			return true;
		if (this.onCollisionStay!==prototype.onCollisionStay)
			return true;
		if (this.onCollisionExit!==prototype.onCollisionExit)
			return true;
		return false;
	}

	/**
	*@inheritDoc
	*/
	__proto._onAwake=function(){
		this.onAwake();
		if (this.onStart!==laya.d3.component.Script3D.prototype.onStart)
			Laya.startTimer.callLater(this,this.onStart);
	}

	/**
	*@inheritDoc
	*/
	__proto._onEnable=function(){
		(this.owner)._scene._scriptPool.add(this);
		var proto=laya.d3.component.Script3D.prototype;
		if (this.onKeyDown!==proto.onKeyDown){
			Laya.stage.on(/*laya.events.Event.KEY_DOWN*/"keydown",this,this.onKeyDown);
		}
		if (this.onKeyPress!==proto.onKeyPress){
			Laya.stage.on(/*laya.events.Event.KEY_PRESS*/"keypress",this,this.onKeyUp);
		}
		if (this.onKeyUp!==proto.onKeyUp){
			Laya.stage.on(/*laya.events.Event.KEY_UP*/"keyup",this,this.onKeyUp);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._onDisable=function(){
		(this.owner)._scene._scriptPool.remove(this);
		this.owner.offAllCaller(this);
		Laya.stage.offAllCaller(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._isScript=function(){
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._onAdded=function(){
		var sprite=this.owner;
		var scripts=sprite._scripts;
		scripts || (sprite._scripts=scripts=[]);
		scripts.push(this);
		if (!sprite._needProcessCollisions)
			sprite._needProcessCollisions=this._checkProcessCollisions();
		if (!sprite._needProcessTriggers)
			sprite._needProcessTriggers=this._checkProcessTriggers();
	}

	/**
	*@inheritDoc
	*/
	__proto._onDestroy=function(){
		var scripts=(this.owner)._scripts;
		scripts.splice(scripts.indexOf(this),1);
		var sprite=this.owner;
		sprite._needProcessTriggers=false;
		for (var i=0,n=scripts.length;i < n;i++){
			if (scripts[i]._checkProcessTriggers()){
				sprite._needProcessTriggers=true;
				break ;
			}
		}
		sprite._needProcessCollisions=false;
		for (i=0,n=scripts.length;i < n;i++){
			if (scripts[i]._checkProcessCollisions()){
				sprite._needProcessCollisions=true;
				break ;
			}
		}
		this.onDestroy();
	}

	/**
	*创建后只执行一次
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onAwake=function(){}
	/**
	*每次启动后执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onEnable=function(){}
	/**
	*第一次执行update之前执行，只会执行一次
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onStart=function(){}
	/**
	*开始触发时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onTriggerEnter=function(other){}
	/**
	*持续触发时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onTriggerStay=function(other){}
	/**
	*结束触发时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onTriggerExit=function(other){}
	/**
	*开始碰撞时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onCollisionEnter=function(collision){}
	/**
	*持续碰撞时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onCollisionStay=function(collision){}
	/**
	*结束碰撞时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onCollisionExit=function(collision){}
	/**
	*鼠标按下时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onMouseDown=function(){}
	/**
	*鼠标拖拽时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onMouseDrag=function(){}
	/**
	*鼠标点击时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onMouseClick=function(){}
	/**
	*鼠标弹起时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onMouseUp=function(){}
	/**
	*鼠标进入时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onMouseEnter=function(){}
	/**
	*鼠标经过时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onMouseOver=function(){}
	/**
	*鼠标离开时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onMouseOut=function(){}
	/**
	*键盘按下时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onKeyDown=function(e){}
	/**
	*键盘产生一个字符时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onKeyPress=function(e){}
	/**
	*键盘抬起时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onKeyUp=function(e){}
	/**
	*每帧更新时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onUpdate=function(){}
	/**
	*每帧更新时执行，在update之后执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onLateUpdate=function(){}
	/**
	*渲染之前执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onPreRender=function(){}
	/**
	*渲染之后执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onPostRender=function(){}
	/**
	*禁用时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onDisable=function(){}
	/**
	*销毁时执行
	*此方法为虚方法，使用时重写覆盖即可
	*/
	__proto.onDestroy=function(){}
	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'isSingleton',function(){
		return false;
	});

	return Script3D;
})(Component)


/**
*<code>PhysicsComponent</code> 类用于创建物理组件的父类。
*/
//class laya.d3.physics.PhysicsComponent extends laya.components.Component
var PhysicsComponent=(function(_super){
	function PhysicsComponent(collisionGroup,canCollideWith){
		/**@private */
		this._restitution=0.0;
		/**@private */
		this._friction=0.5;
		/**@private */
		this._rollingFriction=0.0;
		/**@private */
		this._ccdMotionThreshold=0.0;
		/**@private */
		this._ccdSweptSphereRadius=0.0;
		/**@private */
		this._colliderShape=null;
		/**@private */
		this._transformFlag=2147483647;
		/**@private */
		//this._nativeColliderObject=null;
		/**@private */
		//this._simulation=null;
		/**@private */
		this._enableProcessCollisions=true;
		/**@private */
		this._inPhysicUpdateListIndex=-1;
		/**是否可以缩放Shape。 */
		this.canScaleShape=true;
		PhysicsComponent.__super.call(this);
		this._collisionGroup=/*laya.d3.utils.Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER*/0x1;
		this._canCollideWith=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER;
		this._collisionGroup=collisionGroup;
		this._canCollideWith=canCollideWith;
		PhysicsComponent._physicObjectsMap[this.id]=this;
	}

	__class(PhysicsComponent,'laya.d3.physics.PhysicsComponent',_super);
	var __proto=PhysicsComponent.prototype;
	/**
	*@private
	*/
	__proto._isValid=function(){
		return this._simulation && this._colliderShape && this._enabled;
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		(data.collisionGroup !=null)&& (this.collisionGroup=data.collisionGroup);
		(data.canCollideWith !=null)&& (this.canCollideWith=data.canCollideWith);
		(data.ccdMotionThreshold !=null)&& (this.ccdMotionThreshold=data.ccdMotionThreshold);
		(data.ccdSweptSphereRadius !=null)&& (this.ccdSweptSphereRadius=data.ccdSweptSphereRadius);
	}

	/**
	*@private
	*/
	__proto._parseShape=function(shapesData){
		var shapeCount=shapesData.length;
		if (shapeCount===1){
			var shape=ColliderShape._creatShape(shapesData[0]);
			this.colliderShape=shape;
			}else {
			var compoundShape=new CompoundColliderShape();
			for (var i=0;i < shapeCount;i++){
				shape=ColliderShape._creatShape(shapesData[i]);
				compoundShape.addChildShape(shape);
			}
			this.colliderShape=compoundShape;
		}
	}

	/**
	*@private
	*/
	__proto._onScaleChange=function(scale){
		this._colliderShape._setScale(scale);
	}

	/**
	*@private
	*/
	__proto._setTransformFlag=function(type,value){
		if (value)
			this._transformFlag |=type;
		else
		this._transformFlag &=~type;
	}

	/**
	*@private
	*/
	__proto._getTransformFlag=function(type){
		return (this._transformFlag & type)!=0;
	}

	/**
	*@private
	*/
	__proto._addToSimulation=function(){}
	/**
	*@private
	*/
	__proto._removeFromSimulation=function(){}
	/**
	*@private
	*/
	__proto._derivePhysicsTransformation=function(force){
		this._innerDerivePhysicsTransformation(this._nativeColliderObject.getWorldTransform(),force);
	}

	/**
	*@private
	*通过渲染矩阵更新物理矩阵。
	*/
	__proto._innerDerivePhysicsTransformation=function(physicTransformOut,force){
		var transform=(this.owner)._transform;
		var rotationE=transform.rotation.elements;
		if (force || this._getTransformFlag(/*laya.d3.core.Transform3D.TRANSFORM_WORLDPOSITION*/0x08)){
			var shapeOffset=this._colliderShape.localOffset;
			var shapeOffsetE=shapeOffset.elements;
			var position=transform.position;
			var positionE=position.elements;
			var nativePosition=PhysicsComponent._nativeVector30;
			if (shapeOffsetE[0]!==0 || shapeOffsetE[1]!==0 || shapeOffsetE[2]!==0){
				var physicPosition=PhysicsComponent._tempVector30;
				var physicPositionE=physicPosition.elements;
				PhysicsComponent.physicVector3TransformQuat(shapeOffset,rotationE[0],rotationE[1],rotationE[2],rotationE[3],physicPosition);
				Vector3.add(position,physicPosition,physicPosition);
				nativePosition.setValue(-physicPositionE[0],physicPositionE[1],physicPositionE[2]);
				}else {
				nativePosition.setValue(-positionE[0],positionE[1],positionE[2]);
			}
			physicTransformOut.setOrigin(nativePosition);
			this._setTransformFlag(/*laya.d3.core.Transform3D.TRANSFORM_WORLDPOSITION*/0x08,false);
		}
		if (force || this._getTransformFlag(/*laya.d3.core.Transform3D.TRANSFORM_WORLDQUATERNION*/0x10)){
			var shapeRotation=this._colliderShape.localRotation;
			var shapeRotationE=shapeRotation.elements;
			var nativeRotation=PhysicsComponent._nativeQuaternion0;
			if (shapeRotationE[0]!==0 || shapeRotationE[1]!==0 || shapeRotationE[2]!==0 || shapeRotationE[3]!==1){
				var physicRotation=PhysicsComponent._tempQuaternion0;
				PhysicsComponent.physicQuaternionMultiply(rotationE[0],rotationE[1],rotationE[2],rotationE[3],shapeRotation,physicRotation);
				var physicRotationE=physicRotation.elements;
				nativeRotation.setValue(-physicRotationE[0],physicRotationE[1],physicRotationE[2],-physicRotationE[3]);
				}else {
				nativeRotation.setValue(-rotationE[0],rotationE[1],rotationE[2],-rotationE[3]);
			}
			physicTransformOut.setRotation(nativeRotation);
			this._setTransformFlag(/*laya.d3.core.Transform3D.TRANSFORM_WORLDQUATERNION*/0x10,false);
		}
		if (force || this._getTransformFlag(/*laya.d3.core.Transform3D.TRANSFORM_WORLDSCALE*/0x20)){
			this._onScaleChange(transform.scale);
			this._setTransformFlag(/*laya.d3.core.Transform3D.TRANSFORM_WORLDSCALE*/0x20,false);
		}
	}

	/**
	*@private
	*通过物理矩阵更新渲染矩阵。
	*/
	__proto._updateTransformComponent=function(physicsTransform){
		var localOffset=this._colliderShape.localOffset;
		var localRotation=this._colliderShape.localRotation;
		var shapeOffsetE=localOffset.elements;
		var shapeRotationE=localRotation.elements;
		var transform=(this.owner)._transform;
		var position=transform.position;
		var rotation=transform.rotation;
		var positionE=position.elements;
		var nativePosition=physicsTransform.getOrigin();
		var nativeRotation=physicsTransform.getRotation();
		var nativeRotX=-nativeRotation.x();
		var nativeRotY=nativeRotation.y();
		var nativeRotZ=nativeRotation.z();
		var nativeRotW=-nativeRotation.w();
		if (shapeOffsetE[0]!==0 || shapeOffsetE[1]!==0 || shapeOffsetE[2]!==0){
			var rotShapePosition=PhysicsComponent._tempVector30;
			PhysicsComponent.physicVector3TransformQuat(localOffset,nativeRotX,nativeRotY,nativeRotZ,nativeRotW,rotShapePosition);
			var rotShapePositionE=rotShapePosition.elements;
			positionE[0]=-nativePosition.x()-rotShapePositionE[0];
			positionE[1]=nativePosition.y()-rotShapePositionE[1];
			positionE[2]=nativePosition.z()-rotShapePositionE[2];
			}else {
			positionE[0]=-nativePosition.x();
			positionE[1]=nativePosition.y();
			positionE[2]=nativePosition.z();
		}
		transform.position=position;
		if (shapeRotationE[0]!==0 || shapeRotationE[1]!==0 || shapeRotationE[2]!==0 || shapeRotationE[3]!==1){
			var invertShapeRotaion=PhysicsComponent._tempQuaternion0;
			localRotation.invert(invertShapeRotaion);
			PhysicsComponent.physicQuaternionMultiply(nativeRotX,nativeRotY,nativeRotZ,nativeRotW,invertShapeRotaion,rotation);
			}else {
			var rotationE=rotation.elements;
			rotationE[0]=nativeRotX;
			rotationE[1]=nativeRotY;
			rotationE[2]=nativeRotZ;
			rotationE[3]=nativeRotW;
		}
		transform.rotation=rotation;
	}

	/**
	*@inheritDoc
	*/
	__proto._onEnable=function(){
		this._simulation=(this.owner._scene).physicsSimulation;
		this._nativeColliderObject.setContactProcessingThreshold(1e30);
		if (this._colliderShape && this._enabled){
			this._derivePhysicsTransformation(true);
			this._addToSimulation();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._onDisable=function(){
		if (this._colliderShape && this._enabled)
			this._removeFromSimulation();
		this._simulation=null;
	}

	/**
	*@private
	*/
	__proto._onShapeChange=function(colShape){
		var btColObj=this._nativeColliderObject;
		var flags=btColObj.getCollisionFlags();
		if (colShape.needsCustomCollisionCallback){
			if ((flags & 8)===0)
				btColObj.setCollisionFlags(flags | 8);
			}else {
			if ((flags & 8)> 0)
				btColObj.setCollisionFlags(flags ^ 8);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._onAdded=function(){
		this.enabled=this._enabled;
		this.restitution=this._restitution;
		this.friction=this._friction;
		this.rollingFriction=this._rollingFriction;
		this.ccdMotionThreshold=this._ccdMotionThreshold;
		this.ccdSweptSphereRadius=this._ccdSweptSphereRadius;
		(this.owner).transform.on(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this,this._onTransformChanged);
	}

	/**
	*@inheritDoc
	*/
	__proto._onDestroy=function(){
		var physics3D=Laya3D._physics3D;
		delete PhysicsComponent._physicObjectsMap[this.id];
		physics3D.destroy(this._nativeColliderObject);
		this._colliderShape.destroy();
		_super.prototype._onDestroy.call(this);
		this._nativeColliderObject=null;
		this._colliderShape=null;
		this._simulation=null;
		(this.owner).transform.off(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this,this._onTransformChanged);
	}

	/**
	*@private
	*/
	__proto._onTransformChanged=function(flag){
		if (PhysicsComponent._addUpdateList){
			flag &=/*laya.d3.core.Transform3D.TRANSFORM_WORLDPOSITION*/0x08 | /*laya.d3.core.Transform3D.TRANSFORM_WORLDQUATERNION*/0x10 | /*laya.d3.core.Transform3D.TRANSFORM_WORLDSCALE*/0x20;
			if (flag){
				this._transformFlag |=flag;
				if (this._isValid()&& this._inPhysicUpdateListIndex===-1)
					this._simulation._physicsUpdateList.add(this);
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._cloneTo=function(dest){
		var destPhysicsComponent=dest;
		destPhysicsComponent.restitution=this._restitution;
		destPhysicsComponent.friction=this._friction;
		destPhysicsComponent.rollingFriction=this._rollingFriction;
		destPhysicsComponent.ccdMotionThreshold=this._ccdMotionThreshold;
		destPhysicsComponent.ccdSweptSphereRadius=this._ccdSweptSphereRadius;
		destPhysicsComponent.collisionGroup=this._collisionGroup;
		destPhysicsComponent.canCollideWith=this._canCollideWith;
		destPhysicsComponent.canScaleShape=this.canScaleShape;
		(this._colliderShape)&& (destPhysicsComponent.colliderShape=this._colliderShape.clone());
	}

	/**
	*获取是否激活。
	*/
	__getset(0,__proto,'isActive',function(){
		return this._nativeColliderObject ? this._nativeColliderObject.isActive():false;
	});

	/**
	*设置弹力。
	*@param 弹力。
	*/
	/**
	*获取弹力。
	*@return 弹力。
	*/
	__getset(0,__proto,'restitution',function(){
		return this._restitution;
		},function(value){
		this._restitution=value;
		this._nativeColliderObject && this._nativeColliderObject.setRestitution(value);
	});

	/**
	*设置摩擦力。
	*@param value 摩擦力。
	*/
	/**
	*获取摩擦力。
	*@return 摩擦力。
	*/
	__getset(0,__proto,'friction',function(){
		return this._friction;
		},function(value){
		this._friction=value;
		this._nativeColliderObject && this._nativeColliderObject.setFriction(value);
	});

	/**
	*设置滚动摩擦力。
	*@param 滚动摩擦力。
	*/
	/**
	*获取滚动摩擦力。
	*@return 滚动摩擦力。
	*/
	__getset(0,__proto,'rollingFriction',function(){
		return this._nativeColliderObject.getRollingFriction();
		},function(value){
		this._rollingFriction=value;
		this._nativeColliderObject && this._nativeColliderObject.setRollingFriction(value);
	});

	/**
	*设置用于连续碰撞检测(CCD)的速度阈值，当物体移动速度小于该值时不进行CCD检测,防止快速移动物体(例如:子弹)错误的穿过其它物体,0表示禁止。
	*@param value 连续碰撞检测(CCD)的速度阈值。
	*/
	/**
	*获取用于连续碰撞检测(CCD)的速度阈值,当物体移动速度小于该值时不进行CCD检测,防止快速移动物体(例如:子弹)错误的穿过其它物体,0表示禁止。
	*@return 连续碰撞检测(CCD)的速度阈值。
	*/
	__getset(0,__proto,'ccdMotionThreshold',function(){
		return this._ccdMotionThreshold;
		},function(value){
		this._ccdMotionThreshold=value;
		this._nativeColliderObject && this._nativeColliderObject.setCcdMotionThreshold(value);
	});

	/**
	*设置用于进入连续碰撞检测(CCD)范围的球半径。
	*@param 球半径。
	*/
	/**
	*获取用于进入连续碰撞检测(CCD)范围的球半径。
	*@return 球半径。
	*/
	__getset(0,__proto,'ccdSweptSphereRadius',function(){
		return this._ccdSweptSphereRadius;
		},function(value){
		this._ccdSweptSphereRadius=value;
		this._nativeColliderObject && this._nativeColliderObject.setCcdSweptSphereRadius(value);
	});

	/**
	*设置所属碰撞组。
	*@param 所属碰撞组。
	*/
	/**
	*获取所属碰撞组。
	*@return 所属碰撞组。
	*/
	__getset(0,__proto,'collisionGroup',function(){
		return this._collisionGroup;
		},function(value){
		if (this._collisionGroup!==value){
			this._collisionGroup=value;
			if (this._simulation && this._colliderShape && this._enabled){
				this._removeFromSimulation();
				this._addToSimulation();
			}
		}
	});

	/**
	*获取模拟器。
	*@return 模拟器。
	*/
	__getset(0,__proto,'simulation',function(){
		return this._simulation;
	});

	/**
	*设置碰撞形状。
	*/
	/**
	*获取碰撞形状。
	*/
	__getset(0,__proto,'colliderShape',function(){
		return this._colliderShape;
		},function(value){
		var lastColliderShape=this._colliderShape;
		if (lastColliderShape){
			lastColliderShape._attatched=false;
			lastColliderShape._attatchedCollisionObject=null;
		}
		this._colliderShape=value;
		if (value){
			if (value._attatched){
				throw "PhysicsComponent: this shape has attatched to other entity.";
				}else {
				value._attatched=true;
				value._attatchedCollisionObject=this;
			}
			if (this._nativeColliderObject){
				this._nativeColliderObject.setCollisionShape(value._nativeShape);
				var canInSimulation=this._simulation && this._enabled;
				(canInSimulation && lastColliderShape)&& (this._removeFromSimulation());
				this._onShapeChange(value);
				if (canInSimulation){
					this._derivePhysicsTransformation(true);
					this._addToSimulation();
				}
			}
			}else {
			if (this._simulation && this._enabled)
				lastColliderShape && this._removeFromSimulation();
		}
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'enabled',_super.prototype._$get_enabled,function(value){
		if (this._simulation && this._colliderShape){
			if (value){
				this._derivePhysicsTransformation(true);
				this._addToSimulation();
				}else {
				this._removeFromSimulation();
			}
		}
		Laya.superSet(Component,this,'enabled',value);
	});

	/**
	*设置可碰撞的碰撞组。
	*@param 可碰撞组。
	*/
	/**
	*获取可碰撞的碰撞组。
	*@return 可碰撞组。
	*/
	__getset(0,__proto,'canCollideWith',function(){
		return this._canCollideWith;
		},function(value){
		if (this._canCollideWith!==value){
			this._canCollideWith=value;
			if (this._simulation && this._colliderShape && this._enabled){
				this._removeFromSimulation();
				this._addToSimulation();
			}
		}
	});

	PhysicsComponent._createAffineTransformationArray=function(tranX,tranY,tranZ,rotX,rotY,rotZ,rotW,scale,outE){
		var x2=rotX+rotX,y2=rotY+rotY,z2=rotZ+rotZ;
		var xx=rotX *x2,xy=rotX *y2,xz=rotX *z2,yy=rotY *y2,yz=rotY *z2,zz=rotZ *z2;
		var wx=rotW *x2,wy=rotW *y2,wz=rotW *z2,sx=scale[0],sy=scale[1],sz=scale[2];
		outE[0]=(1-(yy+zz))*sx;
		outE[1]=(xy+wz)*sx;
		outE[2]=(xz-wy)*sx;
		outE[3]=0;
		outE[4]=(xy-wz)*sy;
		outE[5]=(1-(xx+zz))*sy;
		outE[6]=(yz+wx)*sy;
		outE[7]=0;
		outE[8]=(xz+wy)*sz;
		outE[9]=(yz-wx)*sz;
		outE[10]=(1-(xx+yy))*sz;
		outE[11]=0;
		outE[12]=tranX;
		outE[13]=tranY;
		outE[14]=tranZ;
		outE[15]=1;
	}

	PhysicsComponent.physicVector3TransformQuat=function(source,qx,qy,qz,qw,out){
		var destination=out.elements;
		var se=source.elements;
		var x=se[0],y=se[1],z=se[2],
		ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
		destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
		destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
		destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
	}

	PhysicsComponent.physicQuaternionMultiply=function(lx,ly,lz,lw,right,out){
		var re=right.elements;
		var oe=out.elements;
		var rx=re[0];
		var ry=re[1];
		var rz=re[2];
		var rw=re[3];
		var a=(ly *rz-lz *ry);
		var b=(lz *rx-lx *rz);
		var c=(lx *ry-ly *rx);
		var d=(lx *rx+ly *ry+lz *rz);
		oe[0]=(lx *rw+rx *lw)+a;
		oe[1]=(ly *rw+ry *lw)+b;
		oe[2]=(lz *rw+rz *lw)+c;
		oe[3]=lw *rw-d;
	}

	PhysicsComponent.ACTIVATIONSTATE_ACTIVE_TAG=1;
	PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING=2;
	PhysicsComponent.ACTIVATIONSTATE_WANTS_DEACTIVATION=3;
	PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION=4;
	PhysicsComponent.ACTIVATIONSTATE_DISABLE_SIMULATION=5;
	PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT=1;
	PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT=2;
	PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE=4;
	PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK=8;
	PhysicsComponent.COLLISIONFLAGS_CHARACTER_OBJECT=16;
	PhysicsComponent.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT=32;
	PhysicsComponent.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING=64;
	PhysicsComponent._physicObjectsMap={};
	PhysicsComponent._addUpdateList=true;
	__static(PhysicsComponent,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempQuaternion1',function(){return this._tempQuaternion1=new Quaternion();},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_nativeVector30',function(){return this._nativeVector30=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeQuaternion0',function(){return this._nativeQuaternion0=new Laya3D._physics3D.btQuaternion(0,0,0,1);}
	]);
	return PhysicsComponent;
})(Component)


/**
*<code>Animator</code> 类用于创建动画组件。
*/
//class laya.d3.component.Animator extends laya.components.Component
var Animator=(function(_super){
	function Animator(){
		/**@private */
		//this._speed=NaN;
		/**@private */
		//this._avatar=null;
		/**@private */
		//this._keyframeNodeOwnerMap=null;
		/**@private */
		//this._updateMark=0;
		/**@private */
		//this._controllerLayers=null;
		/**@private */
		//this._linkSprites=null;
		/**@private */
		//this._avatarNodeMap=null;
		/**@private */
		this._linkAvatarSpritesData={};
		/**@private [NATIVE]*/
		//this._animationNodeLocalPositions=null;
		/**@private [NATIVE]*/
		//this._animationNodeLocalRotations=null;
		/**@private [NATIVE]*/
		//this._animationNodeLocalScales=null;
		/**@private [NATIVE]*/
		//this._animationNodeWorldMatrixs=null;
		/**@private [NATIVE]*/
		//this._animationNodeParentIndices=null;
		this._keyframeNodeOwners=[];
		this._linkAvatarSprites=[];
		this._renderableSprites=[];
		this.cullingMode=2;
		Animator.__super.call(this);
		this._controllerLayers=[];
		this._linkSprites={};
		this._speed=1.0;
		this._keyframeNodeOwnerMap={};
		this._updateMark=0;
	}

	__class(Animator,'laya.d3.component.Animator',_super);
	var __proto=Animator.prototype;
	/**
	*@private
	*/
	__proto._linkToSprites=function(linkSprites){
		for (var k in linkSprites){
			var nodeOwner=this.owner;
			var path=linkSprites[k];
			for (var j=0,m=path.length;j < m;j++){
				var p=path[j];
				if (p===""){
					break ;
					}else {
					nodeOwner=nodeOwner.getChildByName(p);
					if (!nodeOwner)
						break ;
				}
			}
			(nodeOwner)&& (this.linkSprite3DToAvatarNode(k,nodeOwner));
		}
	}

	/**
	*@private
	*/
	__proto._addKeyframeNodeOwner=function(clipOwners,node,propertyOwner){
		var nodeIndex=node._indexInList;
		var fullPath=node.fullPath;
		var keyframeNodeOwner=this._keyframeNodeOwnerMap[fullPath];
		if (keyframeNodeOwner){
			keyframeNodeOwner.referenceCount++;
			clipOwners[nodeIndex]=keyframeNodeOwner;
			}else {
			var property=propertyOwner;
			for (var i=0,n=node.propertyCount;i < n;i++){
				property=property[node.getPropertyByIndex(i)];
				if (!property)
					break ;
			}
			keyframeNodeOwner=this._keyframeNodeOwnerMap[fullPath]=new KeyframeNodeOwner();
			keyframeNodeOwner.fullPath=fullPath;
			keyframeNodeOwner.indexInList=this._keyframeNodeOwners.length;
			keyframeNodeOwner.referenceCount=1;
			keyframeNodeOwner.propertyOwner=propertyOwner;
			var propertyCount=node.propertyCount;
			var propertys=__newvec(propertyCount);
			for (i=0;i < propertyCount;i++)
			propertys[i]=node.getPropertyByIndex(i);
			keyframeNodeOwner.property=propertys;
			keyframeNodeOwner.type=node.type;
			if (property){
				if (node.type===0)
					keyframeNodeOwner.defaultValue=property;
				else
				keyframeNodeOwner.defaultValue=property.elements.slice();
			}
			this._keyframeNodeOwners.push(keyframeNodeOwner);
			clipOwners[nodeIndex]=keyframeNodeOwner;
		}
	}

	/**
	*@private
	*/
	__proto._removeKeyframeNodeOwner=function(nodeOwners,node){
		var fullPath=node.fullPath;
		var keyframeNodeOwner=this._keyframeNodeOwnerMap[fullPath];
		if (keyframeNodeOwner){
			keyframeNodeOwner.referenceCount--;
			if (keyframeNodeOwner.referenceCount===0){
				delete this._keyframeNodeOwnerMap[fullPath];
				this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(keyframeNodeOwner),1);
			}
			nodeOwners[node._indexInList]=null;
		}
	}

	/**
	*@private
	*/
	__proto._getOwnersByClip=function(clipStateInfo){
		var frameNodes=clipStateInfo._clip._nodes;
		var frameNodesCount=frameNodes.count;
		var nodeOwners=clipStateInfo._nodeOwners;
		nodeOwners.length=frameNodesCount;
		for (var i=0;i < frameNodesCount;i++){
			var node=frameNodes.getNodeByIndex(i);
			var property=this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] :this.owner;
			for (var j=0,m=node.ownerPathCount;j < m;j++){
				var ownPat=node.getOwnerPathByIndex(j);
				if (ownPat===""){
					break ;
					}else {
					property=property.getChildByName(ownPat);
					if (!property)
						break ;
				}
			}
			if (property){
				var propertyOwner=node.propertyOwner;
				(propertyOwner)&& (property=property[propertyOwner]);
				property && this._addKeyframeNodeOwner(nodeOwners,node,property);
			}
		}
	}

	/**
	*@private
	*/
	__proto._getOwnersByClipAsync=function(clipStateInfo){
		var clip=clipStateInfo._clip;
		this._getOwnersByClip(clipStateInfo);
	}

	/**
	*@private
	*/
	__proto._getAvatarOwnersAndInitDatasAsync=function(){
		for (var i=0,n=this._controllerLayers.length;i < n;i++){
			var clipStateInfos=this._controllerLayers[i]._states;
			for (var j=0,m=clipStateInfos.length;j < m;j++)
			this._getOwnersByClipAsync(clipStateInfos[j]);
		}
		this._avatar._cloneDatasToAnimator(this);
		for (var k in this._linkAvatarSpritesData){
			var sprites=this._linkAvatarSpritesData[k];
			if (sprites){
				for (var c=0,p=sprites.length;c < p;c++)
				this._isLinkSpriteToAnimationNode(sprites[c],k,true);
			}
		}
	}

	/**
	*@private
	*/
	__proto._eventScript=function(scripts,clipState,playState,from,to){
		var events=clipState._clip._events;
		var eventIndex=playState._playEventIndex;
		for (var n=events.length;eventIndex < n;eventIndex++){
			var eve=events[eventIndex];
			var eventTime=eve.time;
			if (from <=eventTime && eventTime < to){
				for (var j=0,m=scripts.length;j < m;j++){
					var script=scripts[j];
					var fun=script[eve.eventName];
					(fun)&& (fun.apply(script,eve.params));
				}
				}else {
				break ;
			}
		}
		playState._playEventIndex=eventIndex;
	}

	/**
	*@private
	*/
	__proto._updatePlayer=function(animatorState,playState,elapsedTime,islooping){
		var clipDuration=animatorState._clip._duration *(animatorState.clipEnd-animatorState.clipStart);
		var lastElapsedTime=playState._elapsedTime;
		var elapsedPlaybackTime=lastElapsedTime+elapsedTime;
		playState._lastElapsedTime=lastElapsedTime;
		playState._elapsedTime=elapsedPlaybackTime;
		var normalizedTime=elapsedPlaybackTime / clipDuration;
		playState._normalizedTime=normalizedTime;
		var playTime=normalizedTime % 1.0;
		playState._normalizedPlayTime=playTime < 0?playTime+1.0:playTime;
		playState._duration=clipDuration;
		var scripts=animatorState._scripts;
		if ((!islooping && elapsedPlaybackTime >=clipDuration)){
			playState._finish=true;
			playState._elapsedTime=clipDuration;
			playState._normalizedPlayTime=1.0;
			if (scripts){
				for (var i=0,n=scripts.length;i < n;i++)
				scripts[i].onStateExit();
			}
			return;
		}
		if (clipDuration > 0){
			if (elapsedPlaybackTime >=clipDuration){
				do {
					elapsedPlaybackTime-=clipDuration;
					playState._playEventIndex=0;
				}while (elapsedPlaybackTime >=clipDuration)
			}
			}else {
			playState._resetPlayState(0.0);
		}
		if (scripts){
			for (i=0,n=scripts.length;i < n;i++)
			scripts[i].onStateUpdate();
		}
	}

	/**
	*@private
	*/
	__proto._updateEventScript=function(stateInfo,playStateInfo,islooping){
		var scripts=(this.owner)._scripts;
		if (scripts){
			var clipDuration=stateInfo._clip._duration;
			var lastElapsedTime=playStateInfo._lastElapsedTime;
			var elapsedTime=playStateInfo._elapsedTime;
			var lastLoop=Math.floor(lastElapsedTime / clipDuration);
			var loop=Math.floor(elapsedTime / clipDuration);
			var lastTime=lastElapsedTime % clipDuration;
			var time=elapsedTime % clipDuration;
			var loopCount=loop-lastLoop;
			if (islooping){
				if (loopCount > 0){
					this._eventScript(scripts,stateInfo,playStateInfo,lastTime,clipDuration);
					for (var i=0,n=loopCount-1;i < n;i++)
					this._eventScript(scripts,stateInfo,playStateInfo,0,clipDuration);
					this._eventScript(scripts,stateInfo,playStateInfo,0,time);
					}else {
					this._eventScript(scripts,stateInfo,playStateInfo,lastTime,time);
				}
				}else {
				if (loopCount > 0)
					this._eventScript(scripts,stateInfo,playStateInfo,lastTime,clipDuration);
				else
				this._eventScript(scripts,stateInfo,playStateInfo,lastTime,time);
			}
		}
	}

	/**
	*@private
	*/
	__proto._updateClipDatas=function(animatorState,addtive,playStateInfo,scale){
		var clip=animatorState._clip;
		var clipDuration=clip._duration;
		var curPlayTime=animatorState.clipStart *clipDuration+playStateInfo._normalizedPlayTime *playStateInfo._duration;
		var currentFrameIndices=animatorState._currentFrameIndices;
		var frontPlay=playStateInfo._elapsedTime > playStateInfo._lastElapsedTime;
		clip._evaluateClipDatasRealTime(clip._nodes,curPlayTime,currentFrameIndices,addtive,frontPlay);
	}

	/**
	*@private
	*/
	__proto._applyFloat=function(pro,proName,nodeOwner,additive,weight,isFirstLayer,data){
		if (nodeOwner.updateMark===this._updateMark){
			if (additive){
				pro[proName]+=weight *(data);
				}else {
				var oriValue=pro[proName];
				pro[proName]=oriValue+weight *(data-oriValue);
			}
			}else {
			if (isFirstLayer){
				if (additive)
					pro[proName]=nodeOwner.defaultValue+data;
				else
				pro[proName]=data;
				}else {
				if (additive){
					pro[proName]=nodeOwner.defaultValue+weight *(data);
					}else {
					var defValue=nodeOwner.defaultValue;
					pro[proName]=defValue+weight *(data-defValue);
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._applyPositionAndRotationEuler=function(nodeOwner,additive,weight,isFirstLayer,data,out){
		if (nodeOwner.updateMark===this._updateMark){
			if (additive){
				out[0]+=weight *data[0];
				out[1]+=weight *data[1];
				out[2]+=weight *data[2];
				}else {
				var oriX=out[0];
				var oriY=out[1];
				var oriZ=out[2];
				out[0]=oriX+weight *(data[0]-oriX);
				out[1]=oriY+weight *(data[1]-oriY);
				out[2]=oriZ+weight *(data[2]-oriZ);
			}
			}else {
			if (isFirstLayer){
				if (additive){
					var defValue=nodeOwner.defaultValue;
					out[0]=defValue[0]+data[0];
					out[1]=defValue[1]+data[1];
					out[2]=defValue[2]+data[2];
					}else {
					out[0]=data[0];
					out[1]=data[1];
					out[2]=data[2];
				}
				}else {
				defValue=nodeOwner.defaultValue;
				if (additive){
					out[0]=defValue[0]+weight *data[0];
					out[1]=defValue[1]+weight *data[1];
					out[2]=defValue[2]+weight *data[2];
					}else {
					var defX=defValue[0];
					var defY=defValue[1];
					var defZ=defValue[2];
					out[0]=defX+weight *(data[0]-defX);
					out[1]=defY+weight *(data[1]-defY);
					out[2]=defZ+weight *(data[2]-defZ);
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._applyRotation=function(nodeOwner,additive,weight,isFirstLayer,clipRot,localRotationE){
		if (nodeOwner.updateMark===this._updateMark){
			if (additive){
				var tempQuat=Animator._tempQuaternionArray1;
				Utils3D.quaternionWeight(clipRot,weight,tempQuat);
				Utils3D.quaterionNormalize(tempQuat,tempQuat);
				Utils3D.quaternionMultiply(localRotationE,tempQuat,localRotationE);
				}else {
				Quaternion._lerpArray(localRotationE,clipRot,weight,localRotationE);
			}
			}else {
			if (isFirstLayer){
				if (additive){
					var defaultRot=nodeOwner.defaultValue;
					Utils3D.quaternionMultiply(defaultRot,clipRot,localRotationE);
					}else {
					localRotationE[0]=clipRot[0];
					localRotationE[1]=clipRot[1];
					localRotationE[2]=clipRot[2];
					localRotationE[3]=clipRot[3];
				}
				}else {
				defaultRot=nodeOwner.defaultValue;
				if (additive){
					tempQuat=Animator._tempQuaternionArray1;
					Utils3D.quaternionWeight(clipRot,weight,tempQuat);
					Utils3D.quaterionNormalize(tempQuat,tempQuat);
					Utils3D.quaternionMultiply(defaultRot,tempQuat,localRotationE);
					}else {
					Quaternion._lerpArray(defaultRot,clipRot,weight,localRotationE);
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._applyScale=function(nodeOwner,additive,weight,isFirstLayer,clipSca,localScaleE){
		if (nodeOwner.updateMark===this._updateMark){
			if (additive){
				var scale=Animator._tempVector3Array1;
				Utils3D.scaleWeight(clipSca,weight,scale);
				localScaleE[0]=localScaleE[0] *scale[0];
				localScaleE[1]=localScaleE[1] *scale[1];
				localScaleE[2]=localScaleE[2] *scale[2];
				}else {
				Utils3D.scaleBlend(localScaleE,clipSca,weight,localScaleE);
			}
			}else {
			if (isFirstLayer){
				if (additive){
					var defaultSca=nodeOwner.defaultValue;
					localScaleE[0]=defaultSca[0] *clipSca[0];
					localScaleE[1]=defaultSca[1] *clipSca[1];
					localScaleE[2]=defaultSca[2] *clipSca[2];
					}else {
					localScaleE[0]=clipSca[0];
					localScaleE[1]=clipSca[1];
					localScaleE[2]=clipSca[2];
				}
				}else {
				defaultSca=nodeOwner.defaultValue;
				if (additive){
					scale=Animator._tempVector3Array1;
					Utils3D.scaleWeight(clipSca,weight,scale);
					localScaleE[0]=defaultSca[0] *scale[0];
					localScaleE[1]=defaultSca[1] *scale[1];
					localScaleE[2]=defaultSca[2] *scale[2];
					}else {
					Utils3D.scaleBlend(defaultSca,clipSca,weight,localScaleE);
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._applyCrossData=function(nodeOwner,additive,weight,isFirstLayer,srcValue,desValue,crossWeight){
		var pro=nodeOwner.propertyOwner;
		if (pro){
			switch (nodeOwner.type){
				case 0:;
					var proPat=nodeOwner.property;
					var m=proPat.length-1;
					for (var j=0;j < m;j++){
						pro=pro[proPat[j]];
						if (!pro)
							break ;
					};
					var crossValue=srcValue+crossWeight *(desValue-srcValue);
					this._applyFloat(pro,proPat[m],nodeOwner,additive,weight,isFirstLayer,crossValue);
					break ;
				case 1:;
					var localPos=pro.localPosition;
					var position=Animator._tempVector3Array0;
					var srcX=srcValue[0],srcY=srcValue[1],srcZ=srcValue[2];
					position[0]=srcX+crossWeight *(desValue[0]-srcX);
					position[1]=srcY+crossWeight *(desValue[1]-srcY);
					position[2]=srcZ+crossWeight *(desValue[2]-srcZ);
					this._applyPositionAndRotationEuler(nodeOwner,additive,weight,isFirstLayer,position,localPos.elements);
					pro.localPosition=localPos;
					break ;
				case 2:;
					var localRot=pro.localRotation;
					var rotation=Animator._tempQuaternionArray0;
					Quaternion._lerpArray(srcValue,desValue,crossWeight,rotation);
					this._applyRotation(nodeOwner,additive,weight,isFirstLayer,rotation,localRot.elements);
					pro.localRotation=localRot;
					break ;
				case 3:;
					var localSca=pro.localScale;
					var scale=Animator._tempVector3Array0;
					Utils3D.scaleBlend(srcValue,desValue,crossWeight,scale);
					this._applyScale(nodeOwner,additive,weight,isFirstLayer,scale,localSca.elements);
					pro.localScale=localSca;
					break ;
				case 4:;
					var localEuler=pro.localRotationEuler;
					var rotationEuler=Animator._tempVector3Array0;
					srcX=srcValue[0],srcY=srcValue[1],srcZ=srcValue[2];
					rotationEuler[0]=srcX+crossWeight *(desValue[0]-srcX);
					rotationEuler[1]=srcY+crossWeight *(desValue[1]-srcY);
					rotationEuler[2]=srcZ+crossWeight *(desValue[2]-srcZ);
					this._applyPositionAndRotationEuler(nodeOwner,additive,weight,isFirstLayer,rotationEuler,localEuler.elements);
					pro.localRotationEuler=localEuler;
					break ;
				}
			nodeOwner.updateMark=this._updateMark;
		}
	}

	/**
	*@private
	*/
	__proto._setClipDatasToNode=function(stateInfo,additive,weight,isFirstLayer){
		var nodes=stateInfo._clip._nodes;
		var nodeOwners=stateInfo._nodeOwners;
		for (var i=0,n=nodes.count;i < n;i++){
			var nodeOwner=nodeOwners[i];
			if (nodeOwner){
				var pro=nodeOwner.propertyOwner;
				if (pro){
					switch (nodeOwner.type){
						case 0:;
							var proPat=nodeOwner.property;
							var m=proPat.length-1;
							for (var j=0;j < m;j++){
								pro=pro[proPat[j]];
								if (!pro)
									break ;
							}
							this._applyFloat(pro,proPat[m],nodeOwner,additive,weight,isFirstLayer,nodes.getNodeByIndex(i).data);
							break ;
						case 1:;
							var localPos=pro.localPosition;
							this._applyPositionAndRotationEuler(nodeOwner,additive,weight,isFirstLayer,nodes.getNodeByIndex(i).data,localPos.elements);
							pro.localPosition=localPos;
							break ;
						case 2:;
							var localRot=pro.localRotation;
							this._applyRotation(nodeOwner,additive,weight,isFirstLayer,nodes.getNodeByIndex(i).data,localRot.elements);
							pro.localRotation=localRot;
							break ;
						case 3:;
							var localSca=pro.localScale;
							this._applyScale(nodeOwner,additive,weight,isFirstLayer,nodes.getNodeByIndex(i).data,localSca.elements);
							pro.localScale=localSca;
							break ;
						case 4:;
							var localEuler=pro.localRotationEuler;
							this._applyPositionAndRotationEuler(nodeOwner,additive,weight,isFirstLayer,nodes.getNodeByIndex(i).data,localEuler.elements);
							pro.localRotationEuler=localEuler;
							break ;
						}
					nodeOwner.updateMark=this._updateMark;
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._setCrossClipDatasToNode=function(controllerLayer,srcState,destState,crossWeight,isFirstLayer){
		var nodeOwners=controllerLayer._crossNodesOwners;
		var ownerCount=controllerLayer._crossNodesOwnersCount;
		var additive=controllerLayer.blendingMode!==AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
		var weight=controllerLayer.defaultWeight;
		var destDataIndices=controllerLayer._destCrossClipNodeIndices;
		var destNodes=destState._clip._nodes;
		var destNodeOwners=destState._nodeOwners;
		var srcDataIndices=controllerLayer._srcCrossClipNodeIndices;
		var srcNodeOwners=srcState._nodeOwners;
		var srcNodes=srcState._clip._nodes;
		for (var i=0;i < ownerCount;i++){
			var nodeOwner=nodeOwners[i];
			if (nodeOwner){
				var srcIndex=srcDataIndices[i];
				var destIndex=destDataIndices[i];
				var srcValue=srcIndex!==-1 ? srcNodes.getNodeByIndex(srcIndex).data :destNodeOwners[destIndex].defaultValue;
				var desValue=destIndex!==-1 ? destNodes.getNodeByIndex(destIndex).data :srcNodeOwners[srcIndex].defaultValue;
				this._applyCrossData(nodeOwner,additive,weight,isFirstLayer,srcValue,desValue,crossWeight);
			}
		}
	}

	/**
	*@private
	*/
	__proto._setFixedCrossClipDatasToNode=function(controllerLayer,destState,crossWeight,isFirstLayer){
		var nodeOwners=controllerLayer._crossNodesOwners;
		var ownerCount=controllerLayer._crossNodesOwnersCount;
		var additive=controllerLayer.blendingMode!==AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
		var weight=controllerLayer.defaultWeight;
		var destDataIndices=controllerLayer._destCrossClipNodeIndices;
		var destNodes=destState._clip._nodes;
		for (var i=0;i < ownerCount;i++){
			var nodeOwner=nodeOwners[i];
			if (nodeOwner){
				var destIndex=destDataIndices[i];
				var srcValue=nodeOwner.crossFixedValue;
				var desValue=destIndex!==-1 ? destNodes.getNodeByIndex(destIndex).data :nodeOwner.defaultValue;
				this._applyCrossData(nodeOwner,additive,weight,isFirstLayer,srcValue,desValue,crossWeight);
			}
		}
	}

	/**
	*@private
	*/
	__proto._revertDefaultKeyframeNodes=function(clipStateInfo){
		var nodeOwners=clipStateInfo._nodeOwners;
		for (var i=0,n=nodeOwners.length;i < n;i++){
			var nodeOwner=nodeOwners[i];
			if (nodeOwner){
				var pro=nodeOwner.propertyOwner;
				if (pro){
					switch (nodeOwner.type){
						case 0:;
							var proPat=nodeOwner.property;
							var m=proPat.length-1;
							for (var j=0;j < m;j++){
								pro=pro[proPat[j]];
								if (!pro)
									break ;
							}
						pro[proPat[m]]=nodeOwner.defaultValue;
							break ;
						case 1:;
							var locPos=pro.localPosition;
							var locPosE=locPos.elements;
						var def=nodeOwner.defaultValue;
							locPosE[0]=def[0];
							locPosE[1]=def[1];
							locPosE[2]=def[2];
							pro.localPosition=locPos;
							break ;
						case 2:;
							var locRot=pro.localRotation;
							var locRotE=locRot.elements;
						def=nodeOwner.defaultValue;
							locRotE[0]=def[0];
							locRotE[1]=def[1];
							locRotE[2]=def[2];
							locRotE[3]=def[3];
							pro.localRotation=locRot;
							break ;
						case 3:;
							var locSca=pro.localScale;
							var locScaE=locSca.elements;
						def=nodeOwner.defaultValue;
							locScaE[0]=def[0];
							locScaE[1]=def[1];
							locScaE[2]=def[2];
							pro.localScale=locSca;
							break ;
						case 4:;
							var locEul=pro.localRotationEuler;
							var locEulE=locEul.elements;
						def=nodeOwner.defaultValue;
							locEulE[0]=def[0];
							locEulE[1]=def[1];
							locEulE[2]=def[2];
							pro.localRotationEuler=locEul;
							break ;
						default :
							throw "Animator:unknown type.";
						}
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._removeClip=function(clipStateInfos,statesMap,index,state){
		var clip=state._clip;
		clip._removeReference();
		clipStateInfos.splice(index,1);
		delete statesMap[state.name];
		var clipStateInfo=clipStateInfos[index];
		var frameNodes=clip._nodes;
		var nodeOwners=clipStateInfo._nodeOwners;
		for (var i=0,n=frameNodes.count;i < n;i++)
		this._removeKeyframeNodeOwner(nodeOwners,frameNodes.getNodeByIndex(i));
	}

	/**
	*@private
	*/
	__proto._isLinkSpriteToAnimationNodeData=function(sprite,nodeName,isLink){
		var linkSprites=this._linkAvatarSpritesData[nodeName];
		if (isLink){
			linkSprites || (this._linkAvatarSpritesData[nodeName]=linkSprites=[]);
			linkSprites.push(sprite);
			}else {
			linkSprites.splice(sprite,1);
		}
	}

	/**
	*@private
	*/
	__proto._isLinkSpriteToAnimationNode=function(sprite,nodeName,isLink){
		if (this._avatar){
			var node=this._avatarNodeMap[nodeName];
			if (node){
				if (isLink){
					sprite._transform._dummy=node.transform;
					this._linkAvatarSprites.push(sprite);
					var nodeTransform=node.transform;
					var spriteTransform=sprite.transform;
					if (!spriteTransform.owner.isStatic && nodeTransform){
						var spriteWorldMatrix=spriteTransform.worldMatrix;
						var ownParTra=(this.owner)._transform._parent;
						if (ownParTra){
							Utils3D.matrix4x4MultiplyMFM(ownParTra.worldMatrix,nodeTransform.getWorldMatrix(),spriteWorldMatrix);
							}else {
							var sprWorE=spriteWorldMatrix.elements;
							var nodWorE=nodeTransform.getWorldMatrix();
							for (var i=0;i < 16;i++)
							sprWorE[i]=nodWorE[i];
						}
						spriteTransform.worldMatrix=spriteWorldMatrix;
					}
					}else {
					sprite._transform._dummy=null;
					this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(sprite),1);
				}
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._onAdded=function(){
		var parent=this.owner._parent;
		(this.owner)._setHierarchyAnimator(this,parent ? (parent)._hierarchyAnimator :null);
		(this.owner)._changeAnimatorToLinkSprite3DNoAvatar(this,true,/*new vector.<>*/[]);
	}

	/**
	*@inheritDoc
	*/
	__proto._onDestroy=function(){
		var parent=this.owner._parent;
		(this.owner)._clearHierarchyAnimator(this,parent ? (parent)._hierarchyAnimator :null);
		(this.owner)._changeAnimatorToLinkSprite3DNoAvatar(this,false,/*new vector.<>*/[]);
	}

	/**
	*@inheritDoc
	*/
	__proto._onEnableInScene=function(){
		(this.owner._scene)._animatorPool.add(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._onDisableInScene=function(){
		(this.owner._scene)._animatorPool.remove(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._onEnable=function(){
		for (var i=0,n=this._controllerLayers.length;i < n;i++){
			if (this._controllerLayers[i].playOnWake){
				var defaultClip=this.getDefaultState(i);
				(defaultClip)&& (this.play(null,i,0));
			}
		}
	}

	/**
	*@private
	*/
	__proto._handleSpriteOwnersBySprite=function(isLink,path,sprite){
		for (var i=0,n=this._controllerLayers.length;i < n;i++){
			var clipStateInfos=this._controllerLayers[i]._states;
			for (var j=0,m=clipStateInfos.length;j < m;j++){
				var clipStateInfo=clipStateInfos[j];
				var clip=clipStateInfo._clip;
				var nodePath=path.join("/");
				var ownersNodes=clip._nodesMap[nodePath];
				if (ownersNodes){
					var nodeOwners=clipStateInfo._nodeOwners;
					for (var k=0,p=ownersNodes.length;k < p;k++){
						if (isLink)
							this._addKeyframeNodeOwner(nodeOwners,ownersNodes[k],sprite);
						else
						this._removeKeyframeNodeOwner(nodeOwners,ownersNodes[k]);
					}
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._updateAvatarNodesToSprite=function(){
		for (var i=0,n=this._linkAvatarSprites.length;i < n;i++){
			var sprite=this._linkAvatarSprites[i];
			var nodeTransform=sprite.transform._dummy;
			var spriteTransform=sprite.transform;
			if (!spriteTransform.owner.isStatic && nodeTransform){
				var spriteWorldMatrix=spriteTransform.worldMatrix;
				var ownParTra=(this.owner)._transform._parent;
				if (ownParTra){
					Utils3D.matrix4x4MultiplyMFM(ownParTra.worldMatrix,nodeTransform.getWorldMatrix(),spriteWorldMatrix);
					}else {
					var sprWorE=spriteWorldMatrix.elements;
					var nodWorE=nodeTransform.getWorldMatrix();
					for (var j=0;j < 16;j++)
					sprWorE[j]=nodWorE[j];
				}
				spriteTransform.worldMatrix=spriteWorldMatrix;
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		var avatarData=data.avatar;
		if (avatarData){
			this.avatar=Loader.getRes(avatarData.path);
			var linkSprites=avatarData.linkSprites;
			this._linkSprites=linkSprites;
			this._linkToSprites(linkSprites);
		};
		var clipPaths=data.clipPaths;
		var play=data.playOnWake;
		var layersData=data.layers;
		for (var i=0;i < layersData.length;i++){
			var layerData=layersData[i];
			var animatorLayer=new AnimatorControllerLayer(layerData.name);
			if (i===0)
				animatorLayer.defaultWeight=1.0;
			else
			animatorLayer.defaultWeight=layerData.weight;
			var blendingModeData=layerData.blendingMode;
			(blendingModeData)&& (animatorLayer.blendingMode=blendingModeData);
			this.addControllerLayer(animatorLayer);
			var states=layerData.states;
			for (var j=0,m=states.length;j < m;j++){
				var state=states[j];
				var clipPath=state.clipPath;
				if (clipPath){
					var name=state.name;
					var motion;
					motion=Loader.getRes(clipPath);
					if (motion){
						var animatorState=new AnimatorState();
						animatorState.name=name;
						animatorState.clip=motion;
						motion._addReference();
						this.addState(animatorState,i);
						(j===0)&& (this.setDefaultClip(name,i));
					}
				}
			}
			(play!==undefined)&& (animatorLayer.playOnWake=play);
		};
		var cullingModeData=data.cullingMode;
		(cullingModeData!==undefined)&& (this.cullingMode=cullingModeData);
	}

	/**
	*@private
	*/
	__proto._update=function(){
		if (this._speed===0)
			return;
		var needRender=false;
		if (this.cullingMode===2){
			needRender=false;
			for (var i=0,n=this._renderableSprites.length;i < n;i++){
				if (this._renderableSprites[i]._render._visible){
					needRender=true;
					break ;
				}
			}
			}else {
			needRender=true;
		}
		this._updateMark++;
		var timer=(this.owner._scene).timer;
		var delta=timer._delta / 1000.0;
		var timerScale=timer.scale;
		for (i=0,n=this._controllerLayers.length;i < n;i++){
			var controllerLayer=this._controllerLayers[i];
			var playStateInfo=controllerLayer._playStateInfo;
			var crossPlayStateInfo=controllerLayer._crossPlayStateInfo;
			addtive=controllerLayer.blendingMode!==AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
			switch (controllerLayer._playType){
				case 0:;
					var animatorState=controllerLayer._currentPlayState;
					var clip=animatorState._clip;
					var speed=this._speed *animatorState.speed;
					var finish=playStateInfo._finish;
					finish || this._updatePlayer(animatorState,playStateInfo,delta *speed,clip.islooping);
					if (needRender){
						var addtive=controllerLayer.blendingMode!==AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
						this._updateClipDatas(animatorState,addtive,playStateInfo,timerScale *speed);
					this._setClipDatasToNode(animatorState,addtive,controllerLayer.defaultWeight,i===0);
						finish || this._updateEventScript(animatorState,playStateInfo,clip.islooping);
					}
					break ;
				case 1:
					animatorState=controllerLayer._currentPlayState;
					clip=animatorState._clip;
					var crossClipState=controllerLayer._crossPlayState;
					var crossClip=crossClipState._clip;
					var crossDuratuion=controllerLayer._crossDuration;
					var startPlayTime=crossPlayStateInfo._startPlayTime;
					var crossClipDuration=crossClip._duration-startPlayTime;
					var crossScale=crossDuratuion > crossClipDuration ? crossClipDuration / crossDuratuion :1.0;
					var crossSpeed=this._speed *crossClipState.speed;
					this._updatePlayer(crossClipState,crossPlayStateInfo,delta *crossScale *crossSpeed,crossClip.islooping);
					var crossWeight=((crossPlayStateInfo._elapsedTime-startPlayTime)/ crossScale)/ crossDuratuion;
					if (crossWeight >=1.0){
						if (needRender){
							this._updateClipDatas(crossClipState,addtive,crossPlayStateInfo,timerScale *crossSpeed);
						this._setClipDatasToNode(crossClipState,addtive,controllerLayer.defaultWeight,i===0);
							controllerLayer._playType=0;
							controllerLayer._currentPlayState=crossClipState;
							crossPlayStateInfo._cloneTo(playStateInfo);
						}
						}else {
						if (!playStateInfo._finish){
							speed=this._speed *animatorState.speed;
							this._updatePlayer(animatorState,playStateInfo,delta *speed,clip.islooping);
							if (needRender){
								this._updateClipDatas(animatorState,addtive,playStateInfo,timerScale *speed);
							}
						}
						if (needRender){
							this._updateClipDatas(crossClipState,addtive,crossPlayStateInfo,timerScale *crossScale *crossSpeed);
							this._setCrossClipDatasToNode(controllerLayer,animatorState,crossClipState,crossWeight,i===0);
						}
					}
					if (needRender){
						this._updateEventScript(animatorState,playStateInfo,false);
						this._updateEventScript(crossClipState,crossPlayStateInfo,crossClip.islooping);
					}
					break ;
				case 2:
					crossClipState=controllerLayer._crossPlayState;
					crossClip=crossClipState._clip;
					crossDuratuion=controllerLayer._crossDuration;
					startPlayTime=crossPlayStateInfo._startPlayTime;
					crossClipDuration=crossClip._duration-startPlayTime;
					crossScale=crossDuratuion > crossClipDuration ? crossClipDuration / crossDuratuion :1.0;
					crossSpeed=this._speed *crossClipState.speed;
					this._updatePlayer(crossClipState,crossPlayStateInfo,delta *crossScale *crossSpeed,crossClip.islooping);
					if (needRender){
						crossWeight=((crossPlayStateInfo._elapsedTime-startPlayTime)/ crossScale)/ crossDuratuion;
						if (crossWeight >=1.0){
							this._updateClipDatas(crossClipState,addtive,crossPlayStateInfo,timerScale *crossSpeed);
							this._setClipDatasToNode(crossClipState,addtive,1.0,i===0);
							controllerLayer._playType=0;
							controllerLayer._currentPlayState=crossClipState;
							crossPlayStateInfo._cloneTo(playStateInfo);
							}else {
							this._updateClipDatas(crossClipState,addtive,crossPlayStateInfo,timerScale *crossScale *crossSpeed);
							this._setFixedCrossClipDatasToNode(controllerLayer,crossClipState,crossWeight,i===0);
						}
						this._updateEventScript(crossClipState,crossPlayStateInfo,crossClip.islooping);
					}
					break ;
				}
		}
		if (needRender){
			if (this._avatar){
				Render.isConchApp && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions,this._animationNodeLocalRotations,this._animationNodeLocalScales,this._animationNodeWorldMatrixs,this._animationNodeParentIndices);
				this._updateAvatarNodesToSprite();
			}
		}
	}

	/**
	*@private
	*/
	__proto._cloneTo=function(dest){
		var animator=dest;
		animator.avatar=this.avatar;
		for (var i=0,n=this._controllerLayers.length;i < n;i++){
			var controllLayer=this._controllerLayers[i];
			animator.addControllerLayer(controllLayer.clone());
			var animatorStates=controllLayer._states;
			for (var j=0,m=animatorStates.length;j < m;j++){
				var state=animatorStates[j];
				animator.addState(state.clone(),i);
				(j==0)&& (animator.setDefaultClip(state.name,i));
			}
		}
		animator._linkSprites=this._linkSprites;
		animator._linkToSprites(this._linkSprites);
	}

	/**
	*获取默认动画状态。
	*@param layerIndex 层索引。
	*@return 默认动画状态。
	*/
	__proto.getDefaultState=function(layerIndex){
		(layerIndex===void 0)&& (layerIndex=0);
		var controllerLayer=this._controllerLayers[layerIndex];
		return controllerLayer._defaultState;
	}

	/**
	*设置默认动画片段。
	*@param playName 默认动画片段名称。
	*/
	__proto.setDefaultClip=function(playName,layerIndex){
		(layerIndex===void 0)&& (layerIndex=0);
		var controllerLayer=this._controllerLayers[layerIndex];
		controllerLayer._defaultState=controllerLayer._statesMap[playName];
	}

	/**
	*添加动画状态。
	*@param state 动画状态。
	*@param layerIndex 层索引。
	*/
	__proto.addState=function(state,layerIndex){
		(layerIndex===void 0)&& (layerIndex=0);
		var stateName=state.name;
		var controllerLayer=this._controllerLayers[layerIndex];
		var statesMap=controllerLayer._statesMap;
		var states=controllerLayer._states;
		if (statesMap[stateName]){
			throw "Animator:this stat's name has exist.";
			}else {
			statesMap[stateName]=state;
			states.push(state);
			state._clip._addReference();
			if (this._avatar){
				this._getOwnersByClipAsync(state);
				}else {
				this._getOwnersByClipAsync(state);
			}
		}
	}

	/**
	*移除动画状态。
	*@param state 动画状态。
	*@param layerIndex 层索引。
	*/
	__proto.removeState=function(state,layerIndex){
		(layerIndex===void 0)&& (layerIndex=0);
		var controllerLayer=this._controllerLayers[layerIndex];
		var clipStateInfos=controllerLayer._states;
		var statesMap=controllerLayer._statesMap;
		var index=-1;
		for (var i=0,n=clipStateInfos.length;i < n;i++){
			if (clipStateInfos[i]===state){
				index=i;
				break ;
			}
		}
		if (index!==-1)
			this._removeClip(clipStateInfos,statesMap,index,state);
	}

	/**
	*添加控制器层。
	*/
	__proto.addControllerLayer=function(controllderLayer){
		this._controllerLayers.push(controllderLayer);
	}

	/**
	*获取控制器层。
	*/
	__proto.getControllerLayer=function(layerInex){
		(layerInex===void 0)&& (layerInex=0);
		return this._controllerLayers[layerInex];
	}

	/**
	*获取当前的播放状态。
	*@param layerIndex 层索引。
	*@return 动画播放状态。
	*/
	__proto.getCurrentAnimatorPlayState=function(layerInex){
		(layerInex===void 0)&& (layerInex=0);
		return this._controllerLayers[layerInex]._playStateInfo;
	}

	/**
	*播放动画。
	*@param name 如果为null则播放默认动画，否则按名字播放动画片段。
	*@param layerIndex 层索引。
	*@param normalizedTime 归一化的播放起始时间。
	*/
	__proto.play=function(name,layerIndex,normalizedTime){
		(layerIndex===void 0)&& (layerIndex=0);
		(normalizedTime===void 0)&& (normalizedTime=Number.NEGATIVE_INFINITY);
		var controllerLayer=this._controllerLayers[layerIndex];
		var defaultState=controllerLayer._defaultState;
		if (!name && !defaultState)
			throw new Error("Animator:must have  default clip value,please set clip property.");
		var curPlayState=controllerLayer._currentPlayState;
		var playStateInfo=controllerLayer._playStateInfo;
		var animatorState=name ? controllerLayer._statesMap[name] :defaultState;
		var clipDuration=animatorState._clip._duration;
		if (curPlayState!==animatorState){
			if (normalizedTime!==Number.NEGATIVE_INFINITY)
				playStateInfo._resetPlayState(clipDuration *normalizedTime);
			else
			playStateInfo._resetPlayState(0.0);
			(curPlayState!==null && curPlayState!==animatorState)&& (this._revertDefaultKeyframeNodes(curPlayState));
			controllerLayer._playType=0;
			controllerLayer._currentPlayState=animatorState;
			}else {
			if (normalizedTime!==Number.NEGATIVE_INFINITY){
				playStateInfo._resetPlayState(clipDuration *normalizedTime);
				controllerLayer._playType=0;
			}
		};
		var scripts=animatorState._scripts;
		if (scripts){
			for (var i=0,n=scripts.length;i < n;i++)
			scripts[i].onStateEnter();
		}
	}

	/**
	*在当前动画状态和目标动画状态之间进行融合过渡播放。
	*@param name 目标动画状态。
	*@param transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。
	*@param layerIndex 层索引。
	*@param normalizedTime 归一化的播放起始时间。
	*/
	__proto.crossFade=function(name,transitionDuration,layerIndex,normalizedTime){
		(layerIndex===void 0)&& (layerIndex=0);
		(normalizedTime===void 0)&& (normalizedTime=Number.NEGATIVE_INFINITY);
		var controllerLayer=this._controllerLayers[layerIndex];
		var destAnimatorState=controllerLayer._statesMap[name];
		if (destAnimatorState){
			var playType=controllerLayer._playType;
			if (playType===-1){
				this.play(name,layerIndex,normalizedTime);
				return;
			};
			var crossPlayStateInfo=controllerLayer._crossPlayStateInfo;
			var crossNodeOwners=controllerLayer._crossNodesOwners;
			var crossNodeOwnerIndicesMap=controllerLayer._crossNodesOwnersIndicesMap;
			var srcAnimatorState=controllerLayer._currentPlayState;
			var destNodeOwners=destAnimatorState._nodeOwners;
			var destCrossClipNodeIndices=controllerLayer._destCrossClipNodeIndices;
			var destClip=destAnimatorState._clip;
			var destNodes=destClip._nodes;
			var destNodesMap=destClip._nodesDic;
			switch (playType){
				case 0:;
					var srcNodeOwners=srcAnimatorState._nodeOwners;
					var scrCrossClipNodeIndices=controllerLayer._srcCrossClipNodeIndices;
					var srcClip=srcAnimatorState._clip;
					var srcNodes=srcClip._nodes;
					var srcNodesMap=srcClip._nodesDic;
					controllerLayer._playType=1;
					var crossMark=++controllerLayer._crossMark;
					var crossCount=controllerLayer._crossNodesOwnersCount=0;
					for (var i=0,n=srcNodes.count;i < n;i++){
						var srcNode=srcNodes.getNodeByIndex(i);
						var srcIndex=srcNode._indexInList;
						var srcNodeOwner=srcNodeOwners[srcIndex];
						if (srcNodeOwner){
							var srcFullPath=srcNode.fullPath;
							scrCrossClipNodeIndices[crossCount]=srcIndex;
							var destNode=destNodesMap[srcFullPath];
							if (destNode)
								destCrossClipNodeIndices[crossCount]=destNode._indexInList;
							else
							destCrossClipNodeIndices[crossCount]=-1;
							crossNodeOwnerIndicesMap[srcFullPath]=crossMark;
							crossNodeOwners[crossCount]=srcNodeOwner;
							crossCount++;
						}
					}
					for (i=0,n=destNodes.count;i < n;i++){
						destNode=destNodes.getNodeByIndex(i);
						var destIndex=destNode._indexInList;
						var destNodeOwner=destNodeOwners[destIndex];
						if (destNodeOwner){
							var destFullPath=destNode.fullPath;
							if (!srcNodesMap[destFullPath]){
								scrCrossClipNodeIndices[crossCount]=-1;
								destCrossClipNodeIndices[crossCount]=destIndex;
								crossNodeOwnerIndicesMap[destFullPath]=crossMark;
								crossNodeOwners[crossCount]=destNodeOwner;
								crossCount++;
							}
						}
					}
					break ;
				case 1:
				case 2:
					controllerLayer._playType=2;
					for (i=0,n=crossNodeOwners.length;i < n;i++){
						var nodeOwner=crossNodeOwners[i];
						nodeOwner.saveCrossFixedValue();
						destNode=destNodesMap[nodeOwner.fullPath];
						if (destNode)
							destCrossClipNodeIndices[i]=destNode._indexInList;
						else
						destCrossClipNodeIndices[i]=-1;
					}
					crossCount=controllerLayer._crossNodesOwnersCount;
					crossMark=controllerLayer._crossMark;
					for (i=0,n=destNodes.count;i < n;i++){
						destNode=destNodes.getNodeByIndex(i);
						destIndex=destNode._indexInList;
						destNodeOwner=destNodeOwners[destIndex];
						if (destNodeOwner){
							destFullPath=destNode.fullPath;
							if (crossNodeOwnerIndicesMap[destFullPath]!==crossMark){
								destCrossClipNodeIndices[crossCount]=destIndex;
								crossNodeOwnerIndicesMap[destFullPath]=crossMark;
								nodeOwner=destNodeOwners[destIndex];
								crossNodeOwners[crossCount]=nodeOwner;
								nodeOwner.saveCrossFixedValue();
								crossCount++;
							}
						}
					}
					break ;
				default :
				}
			controllerLayer._crossNodesOwnersCount=crossCount;
			controllerLayer._crossPlayState=destAnimatorState;
			controllerLayer._crossDuration=srcAnimatorState._clip._duration *transitionDuration;
			if (normalizedTime!==Number.NEGATIVE_INFINITY)
				crossPlayStateInfo._resetPlayState(destClip._duration *normalizedTime);
			else
			crossPlayStateInfo._resetPlayState(0.0);
		};
		var scripts=destAnimatorState._scripts;
		if (scripts){
			for (i=0,n=scripts.length;i < n;i++)
			scripts[i].onStateEnter();
		}
	}

	/**
	*关联精灵节点到Avatar节点,此Animator必须有Avatar文件。
	*@param nodeName 关联节点的名字。
	*@param sprite3D 精灵节点。
	*@return 是否关联成功。
	*/
	__proto.linkSprite3DToAvatarNode=function(nodeName,sprite3D){
		if (sprite3D._hierarchyAnimator===this){
			this._isLinkSpriteToAnimationNodeData(sprite3D,nodeName,true);
			this._isLinkSpriteToAnimationNode(sprite3D,nodeName,true);
			return true;
			}else {
			throw("Animator:sprite3D must belong to this Animator");
			return false;
		}
	}

	/**
	*解除精灵节点到Avatar节点的关联,此Animator必须有Avatar文件。
	*@param sprite3D 精灵节点。
	*@return 是否解除关联成功。
	*/
	__proto.unLinkSprite3DToAvatarNode=function(sprite3D){
		if (sprite3D._hierarchyAnimator===this){
			var dummy=sprite3D.transform._dummy;
			if (dummy){
				var nodeName=dummy._owner.name;
				this._isLinkSpriteToAnimationNodeData(sprite3D,nodeName,false);
				this._isLinkSpriteToAnimationNode(sprite3D,nodeName,false);
				return true;
				}else {
				return false;
			}
			}else {
			throw("Animator:sprite3D must belong to this Animator");
			return false;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		for (var i=0,n=this._controllerLayers.length;i < n;i++){
			var clipStateInfos=this._controllerLayers[i]._states;
			for (var j=0,m=clipStateInfos.length;j < m;j++)
			clipStateInfos[j]._clip._removeReference();
		}
	}

	/**
	*@private
	*[NATIVE]
	*/
	__proto._updateAnimationNodeWorldMatix=function(localPositions,localRotations,localScales,worldMatrixs,parentIndices){
		LayaGL.instance.updateAnimationNodeWorldMatix(localPositions,localRotations,localScales,parentIndices,worldMatrixs);
	}

	/**
	*设置avatar。
	*@param value avatar。
	*/
	/**
	*获取avatar。
	*@return avator。
	*/
	__getset(0,__proto,'avatar',function(){
		return this._avatar;
		},function(value){
		if (this._avatar!==value){
			this._avatar=value;
			if (value){
				this._getAvatarOwnersAndInitDatasAsync();
				(this.owner)._changeHierarchyAnimatorAvatar(this,value);
				}else {
				var parent=this.owner._parent;
				(this.owner)._changeHierarchyAnimatorAvatar(this,parent ? (parent)._hierarchyAnimator._avatar :null);
			}
		}
	});

	/**
	*设置动画的播放速度,1.0为正常播放速度。
	*@param 动画的播放速度。
	*/
	/**
	*获取动画的播放速度,1.0为正常播放速度。
	*@return 动画的播放速度。
	*/
	__getset(0,__proto,'speed',function(){
		return this._speed;
		},function(value){
		this._speed=value;
	});

	Animator._update=function(scene){
		var pool=scene._animatorPool;
		var elements=pool.elements;
		for (var i=0,n=pool.length;i < n;i++){
			var animator=elements[i];
			(animator && animator.enabled)&& (animator._update());
		}
	}

	Animator._tempVector3Array0=new Float32Array(3);
	Animator._tempVector3Array1=new Float32Array(3);
	Animator._tempQuaternionArray0=new Float32Array(4);
	Animator._tempQuaternionArray1=new Float32Array(4);
	Animator.CULLINGMODE_ALWAYSANIMATE=0;
	Animator.CULLINGMODE_CULLCOMPLETELY=2;
	return Animator;
})(Component)


/**
*<code>ConstraintComponent</code> 类用于创建约束的父类。
*/
//class laya.d3.physics.constraints.ConstraintComponent extends laya.components.Component
var ConstraintComponent=(function(_super){
	function ConstraintComponent(){
		/**@private */
		this._nativeConstraint=null;
		/**@private */
		this._breakingImpulseThreshold=NaN;
		/**@private */
		this._connectedBody=null;
		/**@private */
		this._feedbackEnabled=false;
		ConstraintComponent.__super.call(this);
	}

	__class(ConstraintComponent,'laya.d3.physics.constraints.ConstraintComponent',_super);
	var __proto=ConstraintComponent.prototype;
	/**
	*@inheritDoc
	*/
	__proto._onDestroy=function(){
		var physics3D=Laya3D._physics3D;
		physics3D.destroy(this._nativeConstraint);
		this._nativeConstraint=null;
	}

	/**
	*设置打破冲力阈值。
	*@param value 打破冲力阈值。
	*/
	/**
	*获取打破冲力阈值。
	*@return 打破冲力阈值。
	*/
	__getset(0,__proto,'breakingImpulseThreshold',function(){
		return this._breakingImpulseThreshold;
		},function(value){
		this._nativeConstraint.BreakingImpulseThreshold=value;
		this._breakingImpulseThreshold=value;
	});

	/**
	*@inheritDoc
	*/
	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'enabled',function(){
		return Laya.superGet(Component,this,'enabled');
		},function(value){
		this._nativeConstraint.IsEnabled=value;
		Laya.superSet(Component,this,'enabled',value);
	});

	/**
	*获取应用的冲力。
	*/
	__getset(0,__proto,'appliedImpulse',function(){
		if (!this._feedbackEnabled){
			this._nativeConstraint.EnableFeedback(true);
			this._feedbackEnabled=true;
		}
		return this._nativeConstraint.AppliedImpulse;
	});

	/**
	*设置已连接刚体。
	*@param value 已连接刚体。
	*/
	/**
	*获取已连接的刚体。
	*@return 已连接刚体。
	*/
	__getset(0,__proto,'connectedBody',function(){
		return this._connectedBody;
		},function(value){
		this._connectedBody=value;
	});

	return ConstraintComponent;
})(Component)


/**
*<code>ShaderPass</code> 类用于实现ShaderPass。
*/
//class laya.d3.shader.ShaderPass extends laya.webgl.utils.ShaderCompile
var ShaderPass=(function(_super){
	function ShaderPass(owner,vs,ps){
		/**@private */
		//this._owner=null;
		/**@private */
		//this._cacheSharders=null;
		/**@private */
		//this._publicValidDefine=0;
		/**@private */
		//this._spriteValidDefine=0;
		/**@private */
		//this._materialValidDefine=0;
		/**@private */
		//this._validDefineMap=null;
		this._renderState=new RenderState();
		this._owner=owner;
		this._cacheSharders=[];
		this._publicValidDefine=0;
		this._spriteValidDefine=0;
		this._materialValidDefine=0;
		this._validDefineMap={};
		ShaderPass.__super.call(this,vs,ps,null,this._validDefineMap);
		var publicDefineMap=this._owner._publicDefinesMap;
		var spriteDefineMap=this._owner._spriteDefinesMap;
		var materialDefineMap=this._owner._materialDefinesMap;
		for (var k in this._validDefineMap){
			if (publicDefineMap[k] !=null)
				this._publicValidDefine |=publicDefineMap[k];
			else if (spriteDefineMap[k] !=null)
			this._spriteValidDefine |=spriteDefineMap[k];
			else if (materialDefineMap[k] !=null)
			this._materialValidDefine |=materialDefineMap[k];
		}
	}

	__class(ShaderPass,'laya.d3.shader.ShaderPass',_super);
	var __proto=ShaderPass.prototype;
	/**
	*@private
	*/
	__proto._definesToNameDic=function(value,int2Name){
		var o={};
		var d=1;
		for (var i=0;i < 32;i++){
			d=1 << i;
			if (d > value)break ;
			if (value & d){
				var name=int2Name[d];
				o[name]="";
			}
		}
		return o;
	}

	/**
	*@inheritDoc
	*/
	__proto._compileToTree=function(parent,lines,start,includefiles,defs){
		var node,preNode;
		var text,name,fname;
		var ofs=0,words,noUseNode;
		var i=0,n=0,j=0;
		for (i=start;i < lines.length;i++){
			text=lines[i];
			if (text.length < 1)continue ;
			ofs=text.indexOf("//");
			if (ofs===0)continue ;
			if (ofs >=0)text=text.substr(0,ofs);
			node=noUseNode || new ShaderNode(includefiles);
			noUseNode=null;
			node.text=text;
			if ((ofs=text.indexOf("#"))>=0){
				name="#";
				for (j=ofs+1,n=text.length;j < n;j++){
					var c=text.charAt(j);
					if (c===' ' || c==='\t' || c==='?')break ;
					name+=c;
				}
				node.name=name;
				switch (name){
					case "#ifdef":
					case "#ifndef":
						node.setParent(parent);
						parent=node;
						if (defs){
							words=text.substr(j).split(ShaderCompile._splitToWordExps3);
							for (j=0;j < words.length;j++){
								text=words[j];
								text.length && (defs[text]=true);
							}
						}
						continue ;
					case "#if":
					case "#elif":
						node.setParent(parent);
						parent=node;
						if (defs){
							words=text.substr(j).split(ShaderCompile._splitToWordExps3);
							for (j=0;j < words.length;j++){
								text=words[j];
								text.length && text !="defined" && (defs[text]=true);
							}
						}
						continue ;
					case "#else":
						parent=parent.parent;
						preNode=parent.childs[parent.childs.length-1];
						node.setParent(parent);
						parent=node;
						continue ;
					case "#endif":
						parent=parent.parent;
						preNode=parent.childs[parent.childs.length-1];
						node.setParent(parent);
						continue ;
					case "#include":
						words=ShaderCompile.splitToWords(text,null);
						var inlcudeFile=ShaderCompile.includes[words[1]];
						if (!inlcudeFile){
							throw "ShaderCompile error no this include file:"+words[1];
						}
						if ((ofs=words[0].indexOf("?"))< 0){
							node.setParent(parent);
							text=inlcudeFile.getWith(words[2]=='with' ? words[3] :null);
							this._compileToTree(node,text.split('\n'),0,includefiles,defs);
							node.text="";
							continue ;
						}
						node.setCondition(words[0].substr(ofs+1),1);
						node.text=inlcudeFile.getWith(words[2]=='with' ? words[3] :null);
						break ;
					case "#import":
						words=ShaderCompile.splitToWords(text,null);
						fname=words[1];
						includefiles.push({node:node,file:ShaderCompile.includes[fname],ofs:node.text.length});
						continue ;
					}
				}else {
				preNode=parent.childs[parent.childs.length-1];
				if (preNode && !preNode.name){
					includefiles.length > 0 && ShaderCompile.splitToWords(text,preNode);
					noUseNode=node;
					preNode.text+="\n"+text;
					continue ;
				}
				includefiles.length > 0 && ShaderCompile.splitToWords(text,node);
			}
			node.setParent(parent);
		}
	}

	/**
	*@private
	*/
	__proto.withCompile=function(publicDefine,spriteDefine,materialDefine){
		publicDefine &=this._publicValidDefine;
		spriteDefine &=this._spriteValidDefine;
		materialDefine &=this._materialValidDefine;
		var shader;
		var spriteDefShaders,materialDefShaders;
		spriteDefShaders=this._cacheSharders[publicDefine];
		if (spriteDefShaders){
			materialDefShaders=spriteDefShaders[spriteDefine];
			if (materialDefShaders){
				shader=materialDefShaders[materialDefine];
				if (shader)
					return shader;
				}else {
				materialDefShaders=spriteDefShaders[spriteDefine]=[];
			}
			}else {
			spriteDefShaders=this._cacheSharders[publicDefine]=[];
			materialDefShaders=spriteDefShaders[spriteDefine]=[];
		};
		var publicDefGroup=this._definesToNameDic(publicDefine,this._owner._publicDefines);
		var spriteDefGroup=this._definesToNameDic(spriteDefine,this._owner._spriteDefines);
		var materialDefGroup=this._definesToNameDic(materialDefine,this._owner._materialDefines);
		var key;
		if (Shader3D.debugMode){
			var publicDefGroupStr="";
			for (key in publicDefGroup)
			publicDefGroupStr+=key+" ";
			var spriteDefGroupStr="";
			for (key in spriteDefGroup)
			spriteDefGroupStr+=key+" ";
			var materialDefGroupStr="";
			for (key in materialDefGroup)
			materialDefGroupStr+=key+" ";
			if (!WebGL.shaderHighPrecision)
				publicDefine+=Shader3D.SHADERDEFINE_HIGHPRECISION;
			console.log("%cShader3DDebugMode---(Name:"+this._owner._owner._name+" PassIndex:"+this._owner._passes.indexOf(this)+" PublicDefine:"+publicDefine+" SpriteDefine:"+spriteDefine+" MaterialDefine:"+materialDefine+" PublicDefineGroup:"+publicDefGroupStr+" SpriteDefineGroup:"+spriteDefGroupStr+"MaterialDefineGroup: "+materialDefGroupStr+")---ShaderCompile3DDebugMode","color:green");
		};
		var defMap={};
		var defineStr="";
		if (publicDefGroup){
			for (key in publicDefGroup){
				defineStr+="#define "+key+"\n";
				defMap[key]=true;
			}
		}
		if (spriteDefGroup){
			for (key in spriteDefGroup){
				defineStr+="#define "+key+"\n";
				defMap[key]=true;
			}
		}
		if (materialDefGroup){
			for (key in materialDefGroup){
				defineStr+="#define "+key+"\n";
				defMap[key]=true;
			}
		};
		var vs=this._VS.toscript(defMap,[]);
		var vsVersion='';
		if (vs[0].indexOf('#version')==0){
			vsVersion=vs[0]+'\n';
			vs.shift();
		};
		var ps=this._PS.toscript(defMap,[]);
		var psVersion='';
		if (ps[0].indexOf('#version')==0){
			psVersion=ps[0]+'\n';
			ps.shift();
		}
		shader=new ShaderInstance(vsVersion+defineStr+vs.join('\n'),psVersion+defineStr+ps.join('\n'),this._owner._attributeMap,this._owner._uniformMap);
		materialDefShaders[materialDefine]=shader;
		return shader;
	}

	/**
	*获取渲染状态。
	*@return 渲染状态。
	*/
	__getset(0,__proto,'renderState',function(){
		return this._renderState;
	});

	return ShaderPass;
})(ShaderCompile)


/**
*@private
*/
//class laya.d3.core.render.SubMeshRenderElement extends laya.d3.core.render.RenderElement
var SubMeshRenderElement=(function(_super){
	function SubMeshRenderElement(){
		/**@private */
		//this._dynamicWorldPositionNormalNeedUpdate=false;
		/**@private */
		//this._dynamicBatch=false;
		/**@private */
		//this._dynamicMultiSubMesh=false;
		/**@private */
		//this._dynamicVertexCount=0;
		/**@private */
		//this._dynamicWorldPositions=null;
		/**@private */
		//this._dynamicWorldNormals=null;
		/**@private */
		//this.skinnedDatas=null;
		/**@private */
		//this.staticBatchIndexStart=0;
		/**@private */
		//this.staticBatchIndexEnd=0;
		/**@private */
		//this.staticBatchElementList=null;
		/**@private */
		//this.dynamicBatchElementList=null;
		/**@private */
		//this.dynamicVertexDeclaration=null;
		SubMeshRenderElement.__super.call(this);
		this._dynamicWorldPositionNormalNeedUpdate=true;
	}

	__class(SubMeshRenderElement,'laya.d3.core.render.SubMeshRenderElement',_super);
	var __proto=SubMeshRenderElement.prototype;
	/**
	*@private
	*/
	__proto._onWorldMatrixChanged=function(){
		this._dynamicWorldPositionNormalNeedUpdate=true;
	}

	/**
	*@inheritDoc
	*/
	__proto._computeWorldPositionsAndNormals=function(positionOffset,normalOffset,multiSubMesh,vertexCount){
		if (this._dynamicWorldPositionNormalNeedUpdate){
			var subMesh=this._geometry;
			var vertexBuffer=subMesh._vertexBuffer;
			var vertexFloatCount=vertexBuffer.vertexDeclaration.vertexStride / 4;
			var oriVertexes=vertexBuffer.getData();
			var worldMat=this._transform.worldMatrix;
			var rotation=this._transform.rotation;
			var indices=subMesh._indices;
			for (var i=0;i < vertexCount;i++){
				var index=multiSubMesh ? indices[i] :i;
				var oriOffset=index *vertexFloatCount;
				var bakeOffset=i *3;
				Utils3D.transformVector3ArrayToVector3ArrayCoordinate(oriVertexes,oriOffset+positionOffset,worldMat,this._dynamicWorldPositions,bakeOffset);
				(normalOffset!==-1)&& (Utils3D.transformVector3ArrayByQuat(oriVertexes,oriOffset+normalOffset,rotation,this._dynamicWorldNormals,bakeOffset));
			}
			this._dynamicWorldPositionNormalNeedUpdate=false;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.setTransform=function(transform){
		if (this._transform!==transform){
			(this._transform)&& (this._transform.off(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this,this._onWorldMatrixChanged));
			(transform)&& (transform.on(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this,this._onWorldMatrixChanged));
			this._dynamicWorldPositionNormalNeedUpdate=true;
			this._transform=transform;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.setGeometry=function(geometry){
		if (this._geometry!==geometry){
			var subMesh=geometry;
			var mesh=subMesh._mesh;
			if (mesh){
				var multiSubMesh=mesh._subMeshCount > 1;
				var dynBatVerCount=multiSubMesh ? subMesh._indexCount :mesh._vertexCount;
				if (dynBatVerCount <=/*laya.d3.graphics.SubMeshDynamicBatch.maxAllowVertexCount*/10){
					var length=dynBatVerCount *3;
					this._dynamicBatch=true;
					this._dynamicWorldPositions=new Float32Array(length);
					this._dynamicWorldNormals=new Float32Array(length);
					this._dynamicVertexCount=dynBatVerCount;
					this._dynamicMultiSubMesh=multiSubMesh;
					}else {
					this._dynamicBatch=false;
				}
			}
			this._geometry=geometry;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.addToOpaqueRenderQueue=function(context,queue){
		var subMeshStaticBatch=this.staticBatch;
		var elements=queue.elements;
		if (subMeshStaticBatch){
			var staManager=MeshRenderStaticBatchManager.instance;
			var staLightIndex=this.render.lightmapIndex+1;
			var staLightMapMarks=(staManager._opaqueBatchMarks[staLightIndex])|| (staManager._opaqueBatchMarks[staLightIndex]=[]);
			var staReceiveShadowMarks=(staLightMapMarks[this.render.receiveShadow ? 0 :1])|| (staLightMapMarks[this.render.receiveShadow ? 0 :1]=[]);
			var staMaterialMarks=(staReceiveShadowMarks[this.material.id])|| (staReceiveShadowMarks[this.material.id]=[]);
			var staBatchMarks=(staMaterialMarks[subMeshStaticBatch._batchID])|| (staMaterialMarks[subMeshStaticBatch._batchID]=new Array(3));
			if (staManager._updateCountMark===staBatchMarks[0]){
				var staBatchIndex=staBatchMarks[1];
				if (staBatchMarks[2]){
					elements[staBatchIndex].staticBatchElementList.push(this);
					}else {
					var staOriElement=elements[staBatchIndex];
					var staOriRender=staOriElement.render;
					var staBatchElement=staManager._getBatchRenderElementFromPool();
					staBatchElement.setGeometry(subMeshStaticBatch);
					staBatchElement.material=staOriElement.material;
					var staRootOwner=subMeshStaticBatch.batchOwner._owner;
					var staBatchTransform=staRootOwner ? staRootOwner._transform :null;
					staBatchElement.setTransform(staBatchTransform);
					var staBatchRender=subMeshStaticBatch.batchOwner._getBatchRender(context,staOriRender.lightmapIndex,staOriRender.receiveShadow);
					staBatchRender._setBelongScene(context.scene);
					staBatchRender._distanceForSort=staOriRender._distanceForSort;
					staBatchElement.render=staBatchRender;
					var staBatchList=staBatchElement.staticBatchElementList;
					staBatchList.length=0;
					staBatchList.push(staOriElement);
					staBatchList.push(this);
					elements[staBatchIndex]=staBatchElement;
					staBatchMarks[2]=true;
				}
				}else {
				staBatchMarks[0]=staManager._updateCountMark;
				staBatchMarks[1]=elements.length;
				staBatchMarks[2]=false;
				elements.push(this);
			}
			}else {
			if (this._dynamicBatch){
				var verDec=(this._geometry)._vertexBuffer.vertexDeclaration;
				var dynManager=MeshRenderDynamicBatchManager.instance;
				var dynLightIndex=this.render.lightmapIndex+1;
				var dynLightMapMarks=(dynManager._opaqueBatchMarks[dynLightIndex])|| (dynManager._opaqueBatchMarks[dynLightIndex]=[]);
				var dynReceiveShadowMarks=(dynLightMapMarks[this.render.receiveShadow ? 0 :1])|| (dynLightMapMarks[this.render.receiveShadow ? 0 :1]=[]);
				var dynMaterialMarks=(dynReceiveShadowMarks[this.material.id])|| (dynReceiveShadowMarks[this.material.id]=[]);
				var dynBatchMarks=(dynMaterialMarks[verDec.id])|| (dynMaterialMarks[verDec.id]=new Array(3));
				if (dynManager._updateCountMark===dynBatchMarks[0]){
					var dynBatchIndex=dynBatchMarks[1];
					if (dynBatchMarks[2]){
						elements[dynBatchIndex].dynamicBatchElementList.push(this);
						}else {
						var dynOriElement=elements[dynBatchIndex];
						var dynOriRender=dynOriElement.render;
						var dynBatchElement=dynManager._getBatchRenderElementFromPool();
						dynBatchElement.setGeometry(SubMeshDynamicBatch.instance);
						dynBatchElement.material=dynOriElement.material;
						dynBatchElement.setTransform(null);
						var dynBatchRender=dynManager._getBatchRender(dynOriRender.lightmapIndex,dynOriRender.receiveShadow);
						dynBatchRender._setBelongScene(context.scene);
						dynBatchRender._distanceForSort=dynOriRender._distanceForSort;
						dynBatchElement.render=dynBatchRender;
						dynBatchElement.dynamicVertexDeclaration=verDec;
						var dynBatchList=dynBatchElement.dynamicBatchElementList;
						dynBatchList.length=0;
						dynBatchList.push(dynOriElement);
						dynBatchList.push(this);
						elements[dynBatchIndex]=dynBatchElement;
						dynBatchMarks[2]=true;
					}
					}else {
					dynBatchMarks[0]=dynManager._updateCountMark;
					dynBatchMarks[1]=elements.length;
					dynBatchMarks[2]=false;
					elements.push(this);
				}
				}else {
				elements.push(this);
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.addToTransparentRenderQueue=function(context,queue){
		var subMeshStaticBatch=this.staticBatch;
		var elements=queue.elements;
		if (subMeshStaticBatch){
			var staManager=MeshRenderStaticBatchManager.instance;
			var staLastElement=queue.lastTransparentRenderElement;
			if (staLastElement){
				var staLastRender=staLastElement.render;
				if (staLastElement._geometry._getType()!==this._geometry._getType()|| staLastElement.staticBatch!==subMeshStaticBatch || staLastElement.material!==this.material || staLastRender.receiveShadow!==this.render.receiveShadow || staLastRender.lightmapIndex!==this.render.lightmapIndex){
					elements.push(this);
					queue.lastTransparentBatched=false;
					}else {
					if (queue.lastTransparentBatched){
						(elements [elements.length-1]).staticBatchElementList.push((this));
						}else {
						var staBatchElement=staManager._getBatchRenderElementFromPool();
						staBatchElement.setGeometry(subMeshStaticBatch);
						staBatchElement.material=staLastElement.material;
						var staRootOwner=subMeshStaticBatch.batchOwner._owner;
						var staBatchTransform=staRootOwner ? staRootOwner._transform :null;
						staBatchElement.setTransform(staBatchTransform);
						var staBatchRender=subMeshStaticBatch.batchOwner._getBatchRender(context,staLastRender.lightmapIndex,staLastRender.receiveShadow);
						staBatchRender._setBelongScene(context.scene);
						staBatchRender._distanceForSort=staLastRender._distanceForSort;
						staBatchElement.render=staBatchRender;
						var staBatchList=staBatchElement.staticBatchElementList;
						staBatchList.length=0;
						staBatchList.push(staLastElement);
						staBatchList.push(this);
						elements[elements.length-1]=staBatchElement;
					}
					queue.lastTransparentBatched=true;
				}
				}else {
				elements.push(this);
				queue.lastTransparentBatched=false;
			}
			}else {
			if (this._dynamicBatch){
				var verDec=(this._geometry)._vertexBuffer.vertexDeclaration;
				var dynManager=MeshRenderDynamicBatchManager.instance;
				var dynLastElement=queue.lastTransparentRenderElement;
				if (dynLastElement){
					var dynLastRender=dynLastElement.render;
					if (dynLastElement._geometry._getType()!==this._geometry._getType()|| (dynLastElement._geometry)._vertexBuffer._vertexDeclaration!==verDec || dynLastElement.material!==this.material || dynLastRender.receiveShadow!==this.render.receiveShadow || dynLastRender.lightmapIndex!==this.render.lightmapIndex){
						elements.push(this);
						queue.lastTransparentBatched=false;
						}else {
						if (queue.lastTransparentBatched){
							(elements [elements.length-1]).dynamicBatchElementList.push((this));
							}else {
							var dynBatchElement=dynManager._getBatchRenderElementFromPool();
							dynBatchElement.setGeometry(SubMeshDynamicBatch.instance);
							dynBatchElement.material=dynLastElement.material;
							dynBatchElement.setTransform(null);
							var dynBatchRender=dynManager._getBatchRender(dynLastRender.lightmapIndex,dynLastRender.receiveShadow);
							dynBatchRender._setBelongScene(context.scene);
							dynBatchRender._distanceForSort=dynLastRender._distanceForSort;
							dynBatchElement.render=dynBatchRender;
							dynBatchElement.dynamicVertexDeclaration=verDec;
							var dynBatchList=dynBatchElement.dynamicBatchElementList;
							dynBatchList.length=0;
							dynBatchList.push(dynLastElement);
							dynBatchList.push(this);
							elements[elements.length-1]=dynBatchElement;
						}
						queue.lastTransparentBatched=true;
					}
					}else {
					elements.push(this);
					queue.lastTransparentBatched=false;
				}
				}else {
				elements.push(this);
			}
		}
		queue.lastTransparentRenderElement=this;
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		this._dynamicWorldPositions=null;
		this._dynamicWorldNormals=null;
		this.skinnedDatas=null;
		this.staticBatch=null;
		this.staticBatchElementList=null;
		this.dynamicBatchElementList=null;
		this.dynamicVertexDeclaration=null;
	}

	return SubMeshRenderElement;
})(RenderElement)


/**
*@private
*<code>BufferState</code> 类用于实现渲染所需的Buffer状态集合。
*/
//class laya.d3.core.BufferState extends laya.webgl.BufferStateBase
var BufferState=(function(_super){
	/**
	*创建一个 <code>BufferState</code> 实例。
	*/
	function BufferState(){
		BufferState.__super.call(this);
	}

	__class(BufferState,'laya.d3.core.BufferState',_super);
	var __proto=BufferState.prototype;
	/**
	*@private
	*vertexBuffer的vertexDeclaration不能为空,该函数比较消耗性能，建议初始化时使用。
	*/
	__proto.applyVertexBuffer=function(vertexBuffer){
		if (BufferStateBase._curBindedBufferState===this){
			var gl=LayaGL.instance;
			var verDec=vertexBuffer.vertexDeclaration;
			var valueData=null;
			if (Render.isConchApp)
				valueData=verDec._shaderValues._nativeArray;
			else
			valueData=verDec._shaderValues._data;
			vertexBuffer.bind();
			for (var k in valueData){
				var loc=parseInt(k);
				var attribute=valueData[k];
				gl.enableVertexAttribArray(loc);
				gl.vertexAttribPointer(loc,attribute[0],attribute[1],!!attribute[2],attribute[3],attribute[4]);
			}
			}else {
			throw "BufferState: must call bind() function first.";
		}
	}

	/**
	*@private
	*vertexBuffers中的vertexDeclaration不能为空,该函数比较消耗性能，建议初始化时使用。
	*/
	__proto.applyVertexBuffers=function(vertexBuffers){
		if (BufferStateBase._curBindedBufferState===this){
			var gl=LayaGL.instance;
			for (var i=0,n=vertexBuffers.length;i < n;i++){
				var verBuf=vertexBuffers[i];
				var verDec=verBuf.vertexDeclaration;
				var valueData=null;
				if (Render.isConchApp)
					valueData=verDec._shaderValues._nativeArray;
				else
				valueData=verDec._shaderValues._data;
				verBuf.bind();
				for (var k in valueData){
					var loc=parseInt(k);
					var attribute=valueData[k];
					gl.enableVertexAttribArray(loc);
					gl.vertexAttribPointer(loc,attribute[0],attribute[1],!!attribute[2],attribute[3],attribute[4]);
				}
			}
			}else {
			throw "BufferState: must call bind() function first.";
		}
	}

	/**
	*@private
	*/
	__proto.applyIndexBuffer=function(indexBuffer){
		if (BufferStateBase._curBindedBufferState===this){
			if (this._bindedIndexBuffer!==indexBuffer){
				indexBuffer._bindForVAO();
				this._bindedIndexBuffer=indexBuffer;
			}
			}else {
			throw "BufferState: must call bind() function first.";
		}
	}

	return BufferState;
})(BufferStateBase)


/**
*<code>BoxColliderShape</code> 类用于创建盒子形状碰撞器。
*/
//class laya.d3.physics.shape.BoxColliderShape extends laya.d3.physics.shape.ColliderShape
var BoxColliderShape=(function(_super){
	function BoxColliderShape(sizeX,sizeY,sizeZ){
		/**@private */
		//this._sizeX=NaN;
		/**@private */
		//this._sizeY=NaN;
		/**@private */
		//this._sizeZ=NaN;
		BoxColliderShape.__super.call(this);
		(sizeX===void 0)&& (sizeX=1.0);
		(sizeY===void 0)&& (sizeY=1.0);
		(sizeZ===void 0)&& (sizeZ=1.0);
		this._sizeX=sizeX;
		this._sizeY=sizeY;
		this._sizeZ=sizeZ;
		this._type=/*laya.d3.physics.shape.ColliderShape.SHAPETYPES_BOX*/0;
		BoxColliderShape._nativeSize.setValue(sizeX / 2,sizeY / 2,sizeZ / 2);
		this._nativeShape=new Laya3D._physics3D.btBoxShape(BoxColliderShape._nativeSize);
	}

	__class(BoxColliderShape,'laya.d3.physics.shape.BoxColliderShape',_super);
	var __proto=BoxColliderShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto.clone=function(){
		var dest=new BoxColliderShape(this._sizeX,this._sizeY,this._sizeZ);
		this.cloneTo(dest);
		return dest;
	}

	/**
	*获取X轴尺寸。
	*/
	__getset(0,__proto,'sizeX',function(){
		return this._sizeX;
	});

	/**
	*获取Y轴尺寸。
	*/
	__getset(0,__proto,'sizeY',function(){
		return this._sizeY;
	});

	/**
	*获取Z轴尺寸。
	*/
	__getset(0,__proto,'sizeZ',function(){
		return this._sizeZ;
	});

	__static(BoxColliderShape,
	['_nativeSize',function(){return this._nativeSize=new Laya3D._physics3D.btVector3(0,0,0);}
	]);
	return BoxColliderShape;
})(ColliderShape)


/**
*<code>MeshColliderShape</code> 类用于创建网格碰撞器。
*/
//class laya.d3.physics.shape.MeshColliderShape extends laya.d3.physics.shape.ColliderShape
var MeshColliderShape=(function(_super){
	function MeshColliderShape(){
		/**@private */
		this._mesh=null;
		/**@private */
		this._convex=false;
		MeshColliderShape.__super.call(this);
	}

	__class(MeshColliderShape,'laya.d3.physics.shape.MeshColliderShape',_super);
	var __proto=MeshColliderShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._setScale=function(value){
		if (this._compoundParent){
			this.updateLocalTransformations();
			}else {
			var valueE=value.elements;
			ColliderShape._nativeScale.setValue(valueE[0],valueE[1],valueE[2]);
			this._nativeShape.setLocalScaling(ColliderShape._nativeScale);
			this._nativeShape.updateBound();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		var destMeshCollider=destObject;
		destMeshCollider.convex=this._convex;
		destMeshCollider.mesh=this._mesh;
		_super.prototype.cloneTo.call(this,destObject);
	}

	/**
	*@inheritDoc
	*/
	__proto.clone=function(){
		var dest=new MeshColliderShape();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		if (this._nativeShape){
			var physics3D=Laya3D._physics3D;
			physics3D.destroy(this._nativeShape);
			this._nativeShape=null;
		}
	}

	/**
	*设置网格。
	*@param 网格。
	*/
	/**
	*获取网格。
	*@return 网格。
	*/
	__getset(0,__proto,'mesh',function(){
		return this._mesh;
		},function(value){
		if (this._mesh!==value){
			var physics3D=Laya3D._physics3D;
			if (this._mesh){
				physics3D.destroy(this._nativeShape);
			}
			if (value){
				this._nativeShape=new physics3D.btGImpactMeshShape(value._getPhysicMesh());
				this._nativeShape.updateBound();
			}
			this._mesh=value;
		}
	});

	/**
	*设置是否使用凸多边形。
	*@param value 是否使用凸多边形。
	*/
	/**
	*获取是否使用凸多边形。
	*@return 是否使用凸多边形。
	*/
	__getset(0,__proto,'convex',function(){
		return this._convex;
		},function(value){
		this._convex=value;
	});

	return MeshColliderShape;
})(ColliderShape)


/**
*<code>FloatKeyFrame</code> 类用于创建浮点关键帧实例。
*/
//class laya.d3.core.FloatKeyframe extends laya.d3.core.Keyframe
var FloatKeyframe=(function(_super){
	function FloatKeyframe(){
		//this.inTangent=NaN;
		//this.outTangent=NaN;
		//this.value=NaN;
		FloatKeyframe.__super.call(this);
	}

	__class(FloatKeyframe,'laya.d3.core.FloatKeyframe',_super);
	var __proto=FloatKeyframe.prototype;
	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destKeyFrame=destObject;
		destKeyFrame.inTangent=this.inTangent;
		destKeyFrame.outTangent=this.outTangent;
		destKeyFrame.value=this.value;
	}

	return FloatKeyframe;
})(Keyframe)


/**
*<code>TerrainFilter</code> 类用于创建TerrainFilter过滤器。
*/
//class laya.d3.terrain.TerrainFilter extends laya.d3.core.GeometryElement
var TerrainFilter=(function(_super){
	function TerrainFilter(owner,chunkOffsetX,chunkOffsetZ,gridSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse){
		this._owner=null;
		this._gridSize=NaN;
		this.memorySize=0;
		this._numberVertices=0;
		this._maxNumberIndices=0;
		this._currentNumberIndices=0;
		this._numberTriangle=0;
		this._vertexBuffer=null;
		this._indexBuffer=null;
		this._indexArrayBuffer=null;
		this._boundingBoxCorners=null;
		this._leafs=null;
		this._leafNum=0;
		this._terrainHeightData=null;
		this._terrainHeightDataWidth=0;
		this._terrainHeightDataHeight=0;
		this._chunkOffsetX=0;
		this._chunkOffsetZ=0;
		this._cameraCoordinateInverse=false;
		this._cameraPos=null;
		this._currentLOD=0;
		//LOD级别 4个叶子节点 第1个叶子的level<<24+第2个叶子的level<<16+第3个叶子的level<<8+第4个叶子的level
		this._perspectiveFactor=NaN;
		this._LODTolerance=0;
		/**@private */
		this._boundingSphere=null;
		/**@private */
		this._boundingBox=null;
		TerrainFilter.__super.call(this);
		this._bufferState=new BufferState();
		this._owner=owner;
		this._cameraPos=new Vector3();
		this._chunkOffsetX=chunkOffsetX;
		this._chunkOffsetZ=chunkOffsetZ;
		this._gridSize=gridSize;
		this._terrainHeightData=terrainHeightData;
		this._terrainHeightDataWidth=heightDataWidth;
		this._terrainHeightDataHeight=heightDataHeight;
		this._leafNum=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
		this._leafs=__newvec(this._leafNum);
		this._cameraCoordinateInverse=cameraCoordinateInverse;
		for (var i=0;i < this._leafNum;i++){
			this._leafs[i]=new TerrainLeaf();
		}
		this.recreateResource();
	}

	__class(TerrainFilter,'laya.d3.terrain.TerrainFilter',_super);
	var __proto=TerrainFilter.prototype;
	__proto.recreateResource=function(){
		this._currentNumberIndices=0;
		this._numberTriangle=0;
		var nLeafVertexCount=TerrainLeaf.LEAF_VERTEXT_COUNT;
		var nLeafIndexCount=TerrainLeaf.LEAF_MAX_INDEX_COUNT;
		this._numberVertices=nLeafVertexCount *this._leafNum;
		this._maxNumberIndices=nLeafIndexCount *this._leafNum;
		this._indexArrayBuffer=new Uint16Array(this._maxNumberIndices);
		var vertexDeclaration=VertexPositionTerrain.vertexDeclaration;
		var vertexFloatStride=vertexDeclaration.vertexStride / 4;
		var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
		var nNum=TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM;
		var i=0,x=0,z=0;
		for (i=0;i < this._leafNum;i++){
			x=i % nNum;
			z=Math.floor(i / nNum);
			this._leafs[i].calcVertextBuffer(this._chunkOffsetX,this._chunkOffsetZ,x *TerrainLeaf.LEAF_GRID_NUM,z *TerrainLeaf.LEAF_GRID_NUM,this._gridSize,vertices,i *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT,vertexFloatStride,this._terrainHeightData,this._terrainHeightDataWidth,this._terrainHeightDataHeight,this._cameraCoordinateInverse);
		}
		for (i=0;i < this._leafNum;i++){
			x=i % nNum;
			z=Math.floor(i / nNum);
			this._leafs[i].calcSkirtVertextBuffer(this._chunkOffsetX,this._chunkOffsetZ,x *TerrainLeaf.LEAF_GRID_NUM,z *TerrainLeaf.LEAF_GRID_NUM,this._gridSize,vertices,this._leafNum *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT+i *TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT,vertexFloatStride,this._terrainHeightData,this._terrainHeightDataWidth,this._terrainHeightDataHeight);
		}
		this.assembleIndexInit();
		this._vertexBuffer=new VertexBuffer3D(vertexDeclaration.vertexStride *this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.vertexDeclaration=vertexDeclaration;
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._maxNumberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(this._indexArrayBuffer);
		this.memorySize=(this._vertexBuffer._byteLength+this._indexBuffer._byteLength)*2;
		this.calcOriginalBoudingBoxAndSphere();
		this._bufferState.bind();
		this._bufferState.applyVertexBuffer(this._vertexBuffer);
		this._bufferState.applyIndexBuffer(this._indexBuffer);
		this._bufferState.unBind();
	}

	__proto.setLODLevel=function(leafsLODLevel){
		if (leafsLODLevel.length !=4)return true;
		var nLOD=((leafsLODLevel[0]+1)<< 24)+((leafsLODLevel[1]+1)<< 16)+((leafsLODLevel[2]+1)<< 8)+(leafsLODLevel[3]+1);
		if (this._currentLOD==nLOD){
			return false;
		}
		this._currentLOD=nLOD;
		return true;
	}

	__proto.assembleIndexInit=function(){
		this._currentNumberIndices=0;
		this._numberTriangle=0;
		var nOffsetIndex=0;
		for (var i=0;i < this._leafNum;i++){
			var planeLODIndex=TerrainLeaf.getPlaneLODIndex(i,0);
			this._indexArrayBuffer.set(planeLODIndex,nOffsetIndex);
			nOffsetIndex+=planeLODIndex.length;
			var skirtLODIndex=TerrainLeaf.getSkirtLODIndex(i,0);
			this._indexArrayBuffer.set(skirtLODIndex,nOffsetIndex);
			nOffsetIndex+=skirtLODIndex.length;
			this._currentNumberIndices+=(planeLODIndex.length+skirtLODIndex.length);
		}
		this._numberTriangle=this._currentNumberIndices / 3;
	}

	__proto.isNeedAssemble=function(camera,cameraPostion){
		var perspectiveFactor=Math.min(camera.viewport.width,camera.viewport.height)/ (2 *Math.tan(Math.PI *camera.fieldOfView / 180.0));
		if (this._perspectiveFactor !=perspectiveFactor){
			this._perspectiveFactor=perspectiveFactor;
			return 1;
		}
		if (this._LODTolerance !=Terrain.LOD_TOLERANCE_VALUE){
			this._LODTolerance=Terrain.LOD_TOLERANCE_VALUE;
			return 1;
		}
		if (Vector3.equals(cameraPostion,this._cameraPos)==false){
			this._cameraPos.x=cameraPostion.x;
			this._cameraPos.y=cameraPostion.y;
			this._cameraPos.z=cameraPostion.z;
			return 2;
		}
		return 0;
	}

	__proto.assembleIndex=function(camera,cameraPostion){
		var nNeedType=this.isNeedAssemble(camera,cameraPostion);
		if (nNeedType > 0){
			for (var i=0;i < this._leafNum;i++){
				TerrainFilter._TEMP_ARRAY_BUFFER[i]=this._leafs[i].determineLod(cameraPostion,this._perspectiveFactor,Terrain.LOD_TOLERANCE_VALUE,nNeedType==1);
			}
			if (this.setLODLevel(TerrainFilter._TEMP_ARRAY_BUFFER)){
				this._currentNumberIndices=0;
				this._numberTriangle=0;
				var nOffsetIndex=0;
				for (i=0;i < this._leafNum;i++){
					var nLODLevel=TerrainFilter._TEMP_ARRAY_BUFFER[i];
					var planeLODIndex=TerrainLeaf.getPlaneLODIndex(i,nLODLevel);
					this._indexArrayBuffer.set(planeLODIndex,nOffsetIndex);
					nOffsetIndex+=planeLODIndex.length;
					var skirtLODIndex=TerrainLeaf.getSkirtLODIndex(i,nLODLevel);
					this._indexArrayBuffer.set(skirtLODIndex,nOffsetIndex);
					nOffsetIndex+=skirtLODIndex.length;
					this._currentNumberIndices+=(planeLODIndex.length+skirtLODIndex.length);
				}
				this._numberTriangle=this._currentNumberIndices / 3;
				return true;
			}
		}
		return false;
	}

	__proto.calcOriginalBoudingBoxAndSphere=function(){
		var sizeOfY=new Vector2(2147483647,-2147483647);
		for (var i=0;i < this._leafNum;i++){
			sizeOfY.x=this._leafs[i]._sizeOfY.x < sizeOfY.x ? this._leafs[i]._sizeOfY.x :sizeOfY.x;
			sizeOfY.y=this._leafs[i]._sizeOfY.y > sizeOfY.y ? this._leafs[i]._sizeOfY.y :sizeOfY.y;
		};
		var min=new Vector3(this._chunkOffsetX *TerrainLeaf.CHUNK_GRID_NUM *this._gridSize,sizeOfY.x,this._chunkOffsetZ *TerrainLeaf.CHUNK_GRID_NUM *this._gridSize);
		var max=new Vector3((this._chunkOffsetX+1)*TerrainLeaf.CHUNK_GRID_NUM *this._gridSize,sizeOfY.y,(this._chunkOffsetZ+1)*TerrainLeaf.CHUNK_GRID_NUM *this._gridSize);
		if (TerrainLeaf.__ADAPT_MATRIX__){
			Vector3.transformV3ToV3(min,TerrainLeaf.__ADAPT_MATRIX__,min);
			Vector3.transformV3ToV3(max,TerrainLeaf.__ADAPT_MATRIX__,max);
		}
		this._boundingBox=new BoundBox(min,max);
		var size=new Vector3();
		Vector3.subtract(max,min,size);
		Vector3.scale(size,0.5,size);
		var center=new Vector3();
		Vector3.add(min,size,center);
		this._boundingSphere=new BoundSphere(center,Vector3.scalarLength(size));
		this._boundingBoxCorners=__newvec(8,null);
		this._boundingBox.getCorners(this._boundingBoxCorners);
	}

	__proto.calcLeafBoudingBox=function(worldMatrix){
		for (var i=0;i < this._leafNum;i++){
			this._leafs[i].calcLeafBoudingBox(worldMatrix);
		}
	}

	__proto.calcLeafBoudingSphere=function(worldMatrix,maxScale){
		for (var i=0;i < this._leafNum;i++){
			this._leafs[i].calcLeafBoudingSphere(worldMatrix,maxScale);
		}
	}

	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index==0){
			return this._vertexBuffer;
		}
		return null;
	}

	__proto._getIndexBuffer=function(){
		return this._indexBuffer;
	}

	/**
	*@inheritDoc
	*/
	__proto._getType=function(){
		return TerrainFilter._type;
	}

	/**
	*@inheritDoc
	*/
	__proto._prepareRender=function(state){
		var terrainMaterial=state.renderElement.material;
		if (terrainMaterial.getRenderState(0).blend==/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0){
			var camera=state.camera;
			if (this.assembleIndex(camera,camera.transform.position)){
				this._indexBuffer.setData(this._indexArrayBuffer);
			}
		}
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._render=function(state){
		this._bufferState.bind();
		LayaGL.instance.drawElements(Terrain.RENDER_LINE_MODEL ? /*laya.webgl.WebGLContext.LINES*/0x0001 :/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._currentNumberIndices,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
		Stat.trianglesFaces+=this._numberTriangle;
		Stat.renderBatch++;
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		this._owner=null;
		this._bufferState.destroy();
		if (this._vertexBuffer)this._vertexBuffer.destroy();
		if (this._indexBuffer)this._indexBuffer.destroy();
	}

	__static(TerrainFilter,
	['_TEMP_ARRAY_BUFFER',function(){return this._TEMP_ARRAY_BUFFER=new Uint32Array(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM *TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);},'_type',function(){return this._type=GeometryElement._typeCounter++;}
	]);
	return TerrainFilter;
})(GeometryElement)


/**
*<code>PixelLineFilter</code> 类用于线过滤器。
*/
//class laya.d3.core.pixelLine.PixelLineFilter extends laya.d3.core.GeometryElement
var PixelLineFilter=(function(_super){
	function PixelLineFilter(owner,maxLineCount){
		/**@private */
		this._floatCountPerVertices=7;
		/**@private */
		this._owner=null;
		/**@private */
		this._vertexBuffer=null;
		/**@private */
		this._vertices=null;
		/**@private */
		this._maxLineCount=0;
		/**@private */
		this._lineCount=0;
		PixelLineFilter.__super.call(this);
		this._bufferState=new BufferState();
		var pointCount=maxLineCount *2;
		this._owner=owner;
		this._maxLineCount=maxLineCount;
		this._vertices=new Float32Array(pointCount *this._floatCountPerVertices);
		this._vertexBuffer=new VertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride *pointCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.vertexDeclaration=PixelLineVertex.vertexDeclaration;
		this._bufferState.bind();
		this._bufferState.applyVertexBuffer(this._vertexBuffer);
		this._bufferState.unBind();
	}

	__class(PixelLineFilter,'laya.d3.core.pixelLine.PixelLineFilter',_super);
	var __proto=PixelLineFilter.prototype;
	/**
	*@private
	*/
	__proto._resizeLineData=function(maxCount){
		var pointCount=maxCount *2;
		var lastVertices=this._vertices;
		this._vertexBuffer.destroy();
		this._maxLineCount=maxCount;
		var vertexCount=pointCount *this._floatCountPerVertices;
		this._vertices=new Float32Array(vertexCount);
		this._vertexBuffer=new VertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride *pointCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.vertexDeclaration=PixelLineVertex.vertexDeclaration;
		if (vertexCount < lastVertices.length){
			this._vertices.set(new Float32Array(lastVertices.buffer,0,vertexCount));
			this._vertexBuffer.setData(this._vertices,0,0,vertexCount);
			}else {
			this._vertices.set(lastVertices);
			this._vertexBuffer.setData(this._vertices,0,0,lastVertices.length);
		}
		this._bufferState.bind();
		this._bufferState.applyVertexBuffer(this._vertexBuffer);
		this._bufferState.unBind();
	}

	/**
	*@private
	*/
	__proto._updateLineVertices=function(offset,startPosition,endPosition,startColor,endColor){
		var startPositione=startPosition.elements;
		var endPositione=endPosition.elements;
		var startColore=startColor.elements;
		var endColore=endColor.elements;
		this._vertices[offset+0]=startPositione[0];
		this._vertices[offset+1]=startPositione[1];
		this._vertices[offset+2]=startPositione[2];
		this._vertices[offset+3]=startColore[0];
		this._vertices[offset+4]=startColore[1];
		this._vertices[offset+5]=startColore[2];
		this._vertices[offset+6]=startColore[3];
		this._vertices[offset+7]=endPositione[0];
		this._vertices[offset+8]=endPositione[1];
		this._vertices[offset+9]=endPositione[2];
		this._vertices[offset+10]=endColore[0];
		this._vertices[offset+11]=endColore[1];
		this._vertices[offset+12]=endColore[2];
		this._vertices[offset+13]=endColore[3];
	}

	/**
	*@private
	*/
	__proto._removeLineData=function(index){
		var floatCount=this._floatCountPerVertices *2;
		var nextIndex=index+1;
		var offset=index *floatCount;
		var nextOffset=nextIndex *floatCount;
		var rightPartVertices=new Float32Array(this._vertices.buffer,nextIndex *floatCount *4,(this._lineCount-nextIndex)*floatCount);
		this._vertexBuffer.setData(rightPartVertices,offset);
		this._vertices.set(rightPartVertices,offset);
		this._lineCount--;
	}

	/**
	*@private
	*/
	__proto._updateLineData=function(index,startPosition,endPosition,startColor,endColor){
		var floatCount=this._floatCountPerVertices *2;
		var offset=index *floatCount;
		this._updateLineVertices(offset,startPosition,endPosition,startColor,endColor);
		this._vertexBuffer.setData(this._vertices,offset,offset,floatCount);
	}

	/**
	*@private
	*/
	__proto._updateLineDatas=function(index,data){
		var floatCount=this._floatCountPerVertices *2;
		var offset=index *floatCount;
		var count=data.length;
		for (var i=0;i < count;i++){
			var line=data[i];
			this._updateLineVertices((index+i)*floatCount,line.startPosition,line.endPosition,line.startColor,line.endColor);
		}
		this._vertexBuffer.setData(this._vertices,offset,offset,floatCount *count);
	}

	/**
	*获取线段数据
	*@return 线段数据。
	*/
	__proto._getLineData=function(index,out){
		var startPosition=out.startPosition.elements;
		var startColor=out.startColor.elements;
		var endPosition=out.endPosition.elements;
		var endColor=out.endColor.elements;
		var vertices=this._vertices;
		var offset=index *this._floatCountPerVertices *2;
		startPosition[0]=vertices[offset+0];
		startPosition[1]=vertices[offset+1];
		startPosition[2]=vertices[offset+2];
		startColor[0]=vertices[offset+0];
		startColor[1]=vertices[offset+1];
		startColor[2]=vertices[offset+2];
		startColor[3]=vertices[offset+3];
		endPosition[0]=vertices[offset+0];
		endPosition[1]=vertices[offset+1];
		endPosition[2]=vertices[offset+2];
		endColor[0]=vertices[offset+0];
		endColor[1]=vertices[offset+1];
		endColor[2]=vertices[offset+2];
		endColor[3]=vertices[offset+3];
	}

	/**
	*@inheritDoc
	*/
	__proto._prepareRender=function(state){
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._render=function(state){
		if (this._lineCount > 0){
			this._bufferState.bind();
			LayaGL.instance.drawArrays(/*laya.webgl.WebGLContext.LINES*/0x0001,0,this._lineCount *2);
			Stat.renderBatch++;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		if (this._destroyed)
			return;
		_super.prototype.destroy.call(this);
		this._bufferState.destroy();
		this._vertexBuffer.destroy();
		this._bufferState=null;
		this._vertexBuffer=null;
		this._vertices=null;
	}

	return PixelLineFilter;
})(GeometryElement)


/**
*<code>HemisphereShape</code> 类用于创建半球形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.HemisphereShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var HemisphereShape=(function(_super){
	function HemisphereShape(){
		/**发射器半径。*/
		this.radius=NaN;
		/**从外壳发射。*/
		this.emitFromShell=false;
		HemisphereShape.__super.call(this);
		this.radius=1.0;
		this.emitFromShell=false;
		this.randomDirection=false;
	}

	__class(HemisphereShape,'laya.d3.core.particleShuriKen.module.shape.HemisphereShape',_super);
	var __proto=HemisphereShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=minE[2]=-this.radius;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=this.radius;
		maxE[2]=0;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=-1;
		minE[2]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=maxE[2]=1;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		var rpE=position.elements;
		if (rand){
			rand.seed=randomSeeds[16];
			if (this.emitFromShell)
				ShapeUtils._randomPointUnitSphere(position,rand);
			else
			ShapeUtils._randomPointInsideUnitSphere(position,rand);
			randomSeeds[16]=rand.seed;
			}else {
			if (this.emitFromShell)
				ShapeUtils._randomPointUnitSphere(position);
			else
			ShapeUtils._randomPointInsideUnitSphere(position);
		}
		Vector3.scale(position,this.radius,position);
		var z=rpE[2];
		(z < 0.0)&& (rpE[2]=z *-1.0);
		if (this.randomDirection){
			if (rand){
				rand.seed=randomSeeds[17];
				ShapeUtils._randomPointUnitSphere(direction,rand);
				randomSeeds[17]=rand.seed;
				}else {
				ShapeUtils._randomPointUnitSphere(direction);
			}
			}else {
			position.cloneTo(direction);
		}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.radius=this.radius;
		destShape.emitFromShell=this.emitFromShell;
		destShape.randomDirection=this.randomDirection;
	}

	return HemisphereShape;
})(BaseShape)


/**
*<code>CapsuleColliderShape</code> 类用于创建胶囊形状碰撞器。
*/
//class laya.d3.physics.shape.CapsuleColliderShape extends laya.d3.physics.shape.ColliderShape
var CapsuleColliderShape=(function(_super){
	function CapsuleColliderShape(radius,length,orientation){
		/**@private */
		//this._radius=NaN;
		/**@private */
		//this._length=NaN;
		/**@private */
		//this._orientation=0;
		CapsuleColliderShape.__super.call(this);
		(radius===void 0)&& (radius=0.5);
		(length===void 0)&& (length=1.25);
		(orientation===void 0)&& (orientation=/*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPY*/1);
		this._radius=radius;
		this._length=length;
		this._orientation=orientation;
		this._type=/*laya.d3.physics.shape.ColliderShape.SHAPETYPES_CAPSULE*/3;
		switch (orientation){
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPX*/0:
				this._nativeShape=new Laya3D._physics3D.btCapsuleShapeX(radius,length-radius *2);
				break ;
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPY*/1:
				this._nativeShape=new Laya3D._physics3D.btCapsuleShape(radius,length-radius *2);
				break ;
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPZ*/2:
				this._nativeShape=new Laya3D._physics3D.btCapsuleShapeZ(radius,length-radius *2);
				break ;
			default :
				throw "CapsuleColliderShape:unknown orientation.";
			}
	}

	__class(CapsuleColliderShape,'laya.d3.physics.shape.CapsuleColliderShape',_super);
	var __proto=CapsuleColliderShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._setScale=function(value){
		var fixScale=CapsuleColliderShape._tempVector30;
		var valueE=value.elements;
		var fixScaleE=fixScale.elements;
		switch (this.orientation){
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPX*/0:
				fixScaleE[0]=valueE[0];
				fixScaleE[1]=fixScaleE[2]=Math.max(valueE[1],valueE[2]);
				break ;
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPY*/1:
				fixScaleE[1]=valueE[1];
				fixScaleE[0]=fixScaleE[2]=Math.max(valueE[0],valueE[2]);
				break ;
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPZ*/2:
				fixScaleE[2]=valueE[2];
				fixScaleE[0]=fixScaleE[1]=Math.max(valueE[0],valueE[1]);
				break ;
			default :
				throw "CapsuleColliderShape:unknown orientation.";
			}
		_super.prototype._setScale.call(this,fixScale);
	}

	/**
	*@inheritDoc
	*/
	__proto.clone=function(){
		var dest=new CapsuleColliderShape(this._radius,this._length,this._orientation);
		this.cloneTo(dest);
		return dest;
	}

	/**
	*获取半径。
	*/
	__getset(0,__proto,'radius',function(){
		return this._radius;
	});

	/**
	*获取长度。
	*/
	__getset(0,__proto,'length',function(){
		return this._length;
	});

	/**
	*获取方向。
	*/
	__getset(0,__proto,'orientation',function(){
		return this._orientation;
	});

	__static(CapsuleColliderShape,
	['_tempVector30',function(){return this._tempVector30=new Vector3();}
	]);
	return CapsuleColliderShape;
})(ColliderShape)


/**
*<code>ConeColliderShape</code> 类用于创建圆柱碰撞器。
*/
//class laya.d3.physics.shape.ConeColliderShape extends laya.d3.physics.shape.ColliderShape
var ConeColliderShape=(function(_super){
	function ConeColliderShape(radius,height,orientation){
		/**@private */
		//this._orientation=0;
		/**@private */
		this._radius=1;
		/**@private */
		this._height=0.5;
		ConeColliderShape.__super.call(this);
		(radius===void 0)&& (radius=0.5);
		(height===void 0)&& (height=1.0);
		(orientation===void 0)&& (orientation=/*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPY*/1);
		this._radius=radius;
		this._height=height;
		this._orientation=orientation;
		this._type=/*laya.d3.physics.shape.ColliderShape.SHAPETYPES_CYLINDER*/2;
		switch (orientation){
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPX*/0:
				this._nativeShape=new Laya3D._physics3D.btConeShapeX(radius,height);
				break ;
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPY*/1:
				this._nativeShape=new Laya3D._physics3D.btConeShape(radius,height);
				break ;
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPZ*/2:
				this._nativeShape=new Laya3D._physics3D.btConeShapeZ(radius,height);
				break ;
			default :
				throw "ConeColliderShape:unknown orientation.";
			}
	}

	__class(ConeColliderShape,'laya.d3.physics.shape.ConeColliderShape',_super);
	var __proto=ConeColliderShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto.clone=function(){
		var dest=new ConeColliderShape(this._radius,this._height,this._orientation);
		this.cloneTo(dest);
		return dest;
	}

	/**
	*获取半径。
	*/
	__getset(0,__proto,'radius',function(){
		return this._radius;
	});

	/**
	*获取高度。
	*/
	__getset(0,__proto,'height',function(){
		return this._height;
	});

	/**
	*获取方向。
	*/
	__getset(0,__proto,'orientation',function(){
		return this._orientation;
	});

	return ConeColliderShape;
})(ColliderShape)


/**
*<code>SubMesh</code> 类用于创建子网格数据模板。
*/
//class laya.d3.resource.models.SubMesh extends laya.d3.core.GeometryElement
var SubMesh=(function(_super){
	function SubMesh(mesh){
		/**@private */
		this._mesh=null;
		/**@private */
		this._boneIndicesList=null;
		/**@private */
		this._subIndexBufferStart=null;
		/**@private */
		this._subIndexBufferCount=null;
		/**@private */
		this._skinAnimationDatas=null;
		/**@private */
		this._indexInMesh=0;
		/**@private */
		this._vertexStart=0;
		/**@private */
		this._indexStart=0;
		/**@private */
		this._indexCount=0;
		/**@private */
		this._indices=null;
		/**@private [只读]*/
		this._vertexBuffer=null;
		/**@private [只读]*/
		this._indexBuffer=null;
		SubMesh.__super.call(this);
		this._bufferState=new BufferState();
		this._mesh=mesh;
		this._boneIndicesList=[];
		this._subIndexBufferStart=[];
		this._subIndexBufferCount=[];
	}

	__class(SubMesh,'laya.d3.resource.models.SubMesh',_super);
	var __proto=SubMesh.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getType=function(){
		return SubMesh._type;
	}

	/**
	*@inheritDoc
	*/
	__proto._render=function(state){
		this._bufferState.bind();
		var skinAnimationDatas=(state.renderElement).skinnedDatas;
		var boneIndicesListCount=this._boneIndicesList.length;
		var shader=state.shader;
		for (var i=0;i < boneIndicesListCount;i++){
			(skinAnimationDatas)&& (shader.uploadCustomUniform(SkinnedMeshSprite3D.BONES,skinAnimationDatas[i]));
			LayaGL.instance.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._subIndexBufferCount[i],/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._subIndexBufferStart[i] *2);
		}
		Stat.renderBatch++;
		Stat.trianglesFaces+=this._indexCount / 3;
	}

	/**
	*@private
	*/
	__proto.getIndices=function(){
		return this._indices;
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		if (this._destroyed)
			return;
		_super.prototype.destroy.call(this);
		this._bufferState.destroy();
		this._indexBuffer.destroy();
		this._bufferState=null;
		this._indexBuffer=null;
		this._mesh=null;
		this._boneIndicesList=null;
		this._subIndexBufferStart=null;
		this._subIndexBufferCount=null;
		this._skinAnimationDatas=null;
	}

	__static(SubMesh,
	['_type',function(){return this._type=GeometryElement._typeCounter++;}
	]);
	return SubMesh;
})(GeometryElement)


/**
*<code>VertexBuffer3D</code> 类用于创建顶点缓冲。
*/
//class laya.d3.graphics.VertexBuffer3D extends laya.webgl.utils.Buffer
var VertexBuffer3D=(function(_super){
	function VertexBuffer3D(byteLength,bufferUsage,canRead,dateType){
		/**@private */
		this._vertexCount=0;
		/**@private */
		this._canRead=false;
		/**@private */
		this._dataType=0;
		/**@private */
		this._vertexDeclaration=null;
		(canRead===void 0)&& (canRead=false);
		(dateType===void 0)&& (dateType=0);
		VertexBuffer3D.__super.call(this);
		this._vertexCount=-1;
		this._bufferUsage=bufferUsage;
		this._bufferType=/*laya.webgl.WebGLContext.ARRAY_BUFFER*/0x8892;
		this._canRead=canRead;
		this._dataType=dateType;
		this._byteLength=byteLength;
		this.bind();
		LayaGL.instance.bufferData(this._bufferType,this._byteLength,this._bufferUsage);
		if (canRead){
			switch (dateType){
				case 0:
					this._buffer=new Float32Array(byteLength / 4);
					break ;
				case 1:
					this._buffer=new Uint8Array(byteLength);
					break ;
				}
		}
	}

	__class(VertexBuffer3D,'laya.d3.graphics.VertexBuffer3D',_super);
	var __proto=VertexBuffer3D.prototype;
	/**
	*@inheritDoc
	*/
	__proto.bind=function(){
		if (Buffer._bindedVertexBuffer!==this._glBuffer){
			LayaGL.instance.bindBuffer(/*laya.webgl.WebGLContext.ARRAY_BUFFER*/0x8892,this._glBuffer);
			Buffer._bindedVertexBuffer=this._glBuffer;
			return true;
			}else {
			return false;
		}
	}

	/**
	*设置数据。
	*@param data 顶点数据。
	*@param bufferOffset 顶点缓冲中的偏移。
	*@param dataStartIndex 顶点数据的偏移。
	*@param dataCount 顶点数据的数量。
	*/
	__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
		(bufferOffset===void 0)&& (bufferOffset=0);
		(dataStartIndex===void 0)&& (dataStartIndex=0);
		(dataCount===void 0)&& (dataCount=4294967295);
		this.bind();
		var needSubData=dataStartIndex!==0 || dataCount!==4294967295;
		if (needSubData){
			switch (this._dataType){
				case 0:
					data=new Float32Array(data.buffer,dataStartIndex *4,dataCount);
					break ;
				case 1:
					data=new Uint8Array(data.buffer,dataStartIndex,dataCount);
					break ;
				}
		}
		switch (this._dataType){
			case 0:
				LayaGL.instance.bufferSubData(this._bufferType,bufferOffset *4,data);
				break ;
			case 1:
				LayaGL.instance.bufferSubData(this._bufferType,bufferOffset,data);
				break ;
			}
		if (this._canRead)
			this._buffer.set(data,bufferOffset);
	}

	/**
	*获取顶点数据。
	*@return 顶点数据。
	*/
	__proto.getData=function(){
		if (this._canRead)
			return this._buffer;
		else
		throw new Error("Can't read data from VertexBuffer with only write flag!");
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		this._buffer=null;
		this._vertexDeclaration=null;
	}

	/**
	*获取顶点声明。
	*/
	/**
	*获取顶点声明。
	*/
	__getset(0,__proto,'vertexDeclaration',function(){
		return this._vertexDeclaration;
		},function(value){
		if (this._vertexDeclaration!==value){
			this._vertexDeclaration=value;
			this._vertexCount=value ? this._byteLength / value.vertexStride :-1;
		}
	});

	/**
	*获取顶点个数。
	*@return 顶点个数。
	*/
	__getset(0,__proto,'vertexCount',function(){
		return this._vertexCount;
	});

	/**
	*获取是否可读。
	*@return 是否可读。
	*/
	__getset(0,__proto,'canRead',function(){
		return this._canRead;
	});

	VertexBuffer3D.DATATYPE_FLOAT32ARRAY=0;
	VertexBuffer3D.DATATYPE_UINT8ARRAY=1;
	return VertexBuffer3D;
})(Buffer)


/**
*<code>CompoundColliderShape</code> 类用于创建盒子形状碰撞器。
*/
//class laya.d3.physics.shape.CompoundColliderShape extends laya.d3.physics.shape.ColliderShape
var CompoundColliderShape=(function(_super){
	function CompoundColliderShape(){
		CompoundColliderShape.__super.call(this);
		this._childColliderShapes=[];
		this._type=/*laya.d3.physics.shape.ColliderShape.SHAPETYPES_COMPOUND*/5;
		this._nativeShape=new Laya3D._physics3D.btCompoundShape();
	}

	__class(CompoundColliderShape,'laya.d3.physics.shape.CompoundColliderShape',_super);
	var __proto=CompoundColliderShape.prototype;
	/**
	*@private
	*/
	__proto._clearChildShape=function(shape){
		shape._attatched=false;
		shape._compoundParent=null;
		shape._indexInCompound=-1;
	}

	/**
	*@inheritDoc
	*/
	__proto._addReference=function(){}
	/**
	*@inheritDoc
	*/
	__proto._removeReference=function(){}
	/**
	*@private
	*/
	__proto._updateChildTransform=function(shape){
		var offsetE=shape.localOffset.elements;
		var rotationE=shape.localRotation.elements;
		var nativeOffset=ColliderShape._nativeVector30;
		var nativeQuaternion=ColliderShape._nativQuaternion0;
		var nativeTransform=ColliderShape._nativeTransform0;
		nativeOffset.setValue(-offsetE[0],offsetE[1],offsetE[2]);
		nativeQuaternion.setValue(-rotationE[0],rotationE[1],rotationE[2],-rotationE[3]);
		nativeTransform.setOrigin(nativeOffset);
		nativeTransform.setRotation(nativeQuaternion);
		this._nativeShape.updateChildTransform(shape._indexInCompound,nativeTransform,true);
	}

	/**
	*添加子碰撞器形状。
	*@param shape 子碰撞器形状。
	*/
	__proto.addChildShape=function(shape){
		if (shape._attatched)
			throw "CompoundColliderShape: this shape has attatched to other entity.";
		shape._attatched=true;
		shape._compoundParent=this;
		shape._indexInCompound=this._childColliderShapes.length;
		this._childColliderShapes.push(shape);
		var offsetE=shape.localOffset.elements;
		var rotationE=shape.localRotation.elements;
		CompoundColliderShape._nativeOffset.setValue(-offsetE[0],offsetE[1],offsetE[2]);
		CompoundColliderShape._nativRotation.setValue(-rotationE[0],rotationE[1],rotationE[2],-rotationE[3]);
		CompoundColliderShape._nativeTransform.setOrigin(CompoundColliderShape._nativeOffset);
		CompoundColliderShape._nativeTransform.setRotation(CompoundColliderShape._nativRotation);
		var nativeScale=this._nativeShape.getLocalScaling();
		this._nativeShape.setLocalScaling(CompoundColliderShape._nativeVector3One);
		this._nativeShape.addChildShape(CompoundColliderShape._nativeTransform,shape._nativeShape);
		this._nativeShape.setLocalScaling(nativeScale);
		(this._attatchedCollisionObject)&& (this._attatchedCollisionObject.colliderShape=this);
	}

	/**
	*移除子碰撞器形状。
	*@param shape 子碰撞器形状。
	*/
	__proto.removeChildShape=function(shape){
		if (shape._compoundParent===this){
			var index=shape._indexInCompound;
			this._clearChildShape(shape);
			var endShape=this._childColliderShapes[this._childColliderShapes.length-1];
			endShape._indexInCompound=index;
			this._childColliderShapes[index]=endShape;
			this._childColliderShapes.pop();
			this._nativeShape.removeChildShapeByIndex(index);
		}
	}

	/**
	*清空子碰撞器形状。
	*/
	__proto.clearChildShape=function(){
		for (var i=0,n=this._childColliderShapes.length;i < n;i++){
			this._clearChildShape(this._childColliderShapes[i]);
			this._nativeShape.removeChildShapeByIndex(0);
		}
		this._childColliderShapes.length=0;
	}

	/**
	*获取子形状数量。
	*@return
	*/
	__proto.getChildShapeCount=function(){
		return this._childColliderShapes.length;
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		var destCompoundColliderShape=destObject;
		destCompoundColliderShape.clearChildShape();
		for (var i=0,n=this._childColliderShapes.length;i < n;i++)
		destCompoundColliderShape.addChildShape(this._childColliderShapes[i].clone());
	}

	/**
	*@inheritDoc
	*/
	__proto.clone=function(){
		var dest=new CompoundColliderShape();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		for (var i=0,n=this._childColliderShapes.length;i < n;i++){
			var childShape=this._childColliderShapes[i];
			if (childShape._referenceCount===0)
				childShape.destroy();
		}
	}

	__static(CompoundColliderShape,
	['_nativeVector3One',function(){return this._nativeVector3One=new Laya3D._physics3D.btVector3(1,1,1);},'_nativeTransform',function(){return this._nativeTransform=new Laya3D._physics3D.btTransform();},'_nativeOffset',function(){return this._nativeOffset=new Laya3D._physics3D.btVector3(0,0,0);},'_nativRotation',function(){return this._nativRotation=new Laya3D._physics3D.btQuaternion(0,0,0,1);}
	]);
	return CompoundColliderShape;
})(ColliderShape)


/**
*<code>IndexBuffer3D</code> 类用于创建索引缓冲。
*/
//class laya.d3.graphics.IndexBuffer3D extends laya.webgl.utils.Buffer
var IndexBuffer3D=(function(_super){
	function IndexBuffer3D(indexType,indexCount,bufferUsage,canRead){
		/**@private */
		this._indexType=null;
		/**@private */
		this._indexTypeByteCount=0;
		/**@private */
		this._indexCount=0;
		/**@private */
		this._canRead=false;
		(bufferUsage===void 0)&& (bufferUsage=0x88E4);
		(canRead===void 0)&& (canRead=false);
		IndexBuffer3D.__super.call(this);
		this._indexType=indexType;
		this._indexCount=indexCount;
		this._bufferUsage=bufferUsage;
		this._bufferType=/*laya.webgl.WebGLContext.ELEMENT_ARRAY_BUFFER*/0x8893;
		this._canRead=canRead;
		var byteLength=0;
		if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort")
			this._indexTypeByteCount=2;
		else if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte")
		this._indexTypeByteCount=1;
		else
		throw new Error("unidentification index type.");
		byteLength=this._indexTypeByteCount *indexCount;
		this._byteLength=byteLength;
		var curBufSta=BufferStateBase._curBindedBufferState;
		if (curBufSta){
			if (curBufSta._bindedIndexBuffer===this){
				LayaGL.instance.bufferData(this._bufferType,byteLength,this._bufferUsage);
				}else {
				curBufSta.unBind();
				this.bind();
				LayaGL.instance.bufferData(this._bufferType,byteLength,this._bufferUsage);
				curBufSta.bind();
			}
			}else {
			this.bind();
			LayaGL.instance.bufferData(this._bufferType,byteLength,this._bufferUsage);
		}
		if (canRead){
			if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort")
				this._buffer=new Uint16Array(indexCount);
			else if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte")
			this._buffer=new Uint8Array(indexCount);
		}
	}

	__class(IndexBuffer3D,'laya.d3.graphics.IndexBuffer3D',_super);
	var __proto=IndexBuffer3D.prototype;
	/**
	*@inheritDoc
	*/
	__proto._bindForVAO=function(){
		if (BufferStateBase._curBindedBufferState){
			LayaGL.instance.bindBuffer(/*laya.webgl.WebGLContext.ELEMENT_ARRAY_BUFFER*/0x8893,this._glBuffer);
			}else {
			throw "IndexBuffer3D: must bind current BufferState.";
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.bind=function(){
		if (BufferStateBase._curBindedBufferState){
			throw "IndexBuffer3D: must unbind current BufferState.";
			}else {
			if (Buffer._bindedIndexBuffer!==this._glBuffer){
				LayaGL.instance.bindBuffer(/*laya.webgl.WebGLContext.ELEMENT_ARRAY_BUFFER*/0x8893,this._glBuffer);
				Buffer._bindedIndexBuffer=this._glBuffer;
				return true;
				}else {
				return false;
			}
		}
	}

	/**
	*设置数据。
	*@param data 索引数据。
	*@param bufferOffset 索引缓冲中的偏移。
	*@param dataStartIndex 索引数据的偏移。
	*@param dataCount 索引数据的数量。
	*/
	__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
		(bufferOffset===void 0)&& (bufferOffset=0);
		(dataStartIndex===void 0)&& (dataStartIndex=0);
		(dataCount===void 0)&& (dataCount=4294967295);
		var byteCount=0;
		if (this._indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort"){
			byteCount=2;
			if (dataStartIndex!==0 || dataCount!==4294967295)
				data=new Uint16Array(data.buffer,dataStartIndex *byteCount,dataCount);
			}else if (this._indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte"){
			byteCount=1;
			if (dataStartIndex!==0 || dataCount!==4294967295)
				data=new Uint8Array(data.buffer,dataStartIndex *byteCount,dataCount);
		};
		var curBufSta=BufferStateBase._curBindedBufferState;
		if (curBufSta){
			if (curBufSta._bindedIndexBuffer===this){
				LayaGL.instance.bufferSubData(this._bufferType,bufferOffset *byteCount,data);
				}else {
				curBufSta.unBind();
				this.bind();
				LayaGL.instance.bufferSubData(this._bufferType,bufferOffset *byteCount,data);
				curBufSta.bind();
			}
			}else {
			this.bind();
			LayaGL.instance.bufferSubData(this._bufferType,bufferOffset *byteCount,data);
		}
		if (this._canRead){
			if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
				var maxLength=this._buffer.length-bufferOffset;
				if (dataCount > maxLength)
					dataCount=maxLength;
				for (var i=0;i < dataCount;i++)
				this._buffer[bufferOffset+i]=data[i];
				}else {
				this._buffer=data;
			}
		}
	}

	/**
	*获取索引数据。
	*@return 索引数据。
	*/
	__proto.getData=function(){
		if (this._canRead)
			return this._buffer;
		else
		throw new Error("Can't read data from VertexBuffer with only write flag!");
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		this._buffer=null;
	}

	/**
	*获取索引类型。
	*@return 索引类型。
	*/
	__getset(0,__proto,'indexType',function(){
		return this._indexType;
	});

	/**
	*获取索引类型字节数量。
	*@return 索引类型字节数量。
	*/
	__getset(0,__proto,'indexTypeByteCount',function(){
		return this._indexTypeByteCount;
	});

	/**
	*获取索引个数。
	*@return 索引个数。
	*/
	__getset(0,__proto,'indexCount',function(){
		return this._indexCount;
	});

	/**
	*获取是否可读。
	*@return 是否可读。
	*/
	__getset(0,__proto,'canRead',function(){
		return this._canRead;
	});

	IndexBuffer3D.INDEXTYPE_UBYTE="ubyte";
	IndexBuffer3D.INDEXTYPE_USHORT="ushort";
	return IndexBuffer3D;
})(Buffer)


/**
*<code>CylinderColliderShape</code> 类用于创建圆柱碰撞器。
*/
//class laya.d3.physics.shape.CylinderColliderShape extends laya.d3.physics.shape.ColliderShape
var CylinderColliderShape=(function(_super){
	function CylinderColliderShape(radius,height,orientation){
		/**@private */
		//this._orientation=0;
		/**@private */
		this._radius=1;
		/**@private */
		this._height=0.5;
		CylinderColliderShape.__super.call(this);
		(radius===void 0)&& (radius=0.5);
		(height===void 0)&& (height=1.0);
		(orientation===void 0)&& (orientation=/*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPY*/1);
		this._radius=radius;
		this._height=height;
		this._orientation=orientation;
		this._type=/*laya.d3.physics.shape.ColliderShape.SHAPETYPES_CYLINDER*/2;
		switch (orientation){
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPX*/0:
				CylinderColliderShape._nativeSize.setValue(height / 2,radius,radius);
				this._nativeShape=new Laya3D._physics3D.btCylinderShapeX(CylinderColliderShape._nativeSize);
				break ;
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPY*/1:
				CylinderColliderShape._nativeSize.setValue(radius,height / 2,radius);
				this._nativeShape=new Laya3D._physics3D.btCylinderShape(CylinderColliderShape._nativeSize);
				break ;
			case /*laya.d3.physics.shape.ColliderShape.SHAPEORIENTATION_UPZ*/2:
				CylinderColliderShape._nativeSize.setValue(radius,radius,height / 2);
				this._nativeShape=new Laya3D._physics3D.btCylinderShapeZ(CylinderColliderShape._nativeSize);
				break ;
			default :
				throw "CapsuleColliderShape:unknown orientation.";
			}
	}

	__class(CylinderColliderShape,'laya.d3.physics.shape.CylinderColliderShape',_super);
	var __proto=CylinderColliderShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto.clone=function(){
		var dest=new CylinderColliderShape(this._radius,this._height,this._orientation);
		this.cloneTo(dest);
		return dest;
	}

	/**
	*获取半径。
	*/
	__getset(0,__proto,'radius',function(){
		return this._radius;
	});

	/**
	*获取高度。
	*/
	__getset(0,__proto,'height',function(){
		return this._height;
	});

	/**
	*获取方向。
	*/
	__getset(0,__proto,'orientation',function(){
		return this._orientation;
	});

	__static(CylinderColliderShape,
	['_nativeSize',function(){return this._nativeSize=new Laya3D._physics3D.btVector3(0,0,0);}
	]);
	return CylinderColliderShape;
})(ColliderShape)


/**
*<code>SphereColliderShape</code> 类用于创建球形碰撞器。
*/
//class laya.d3.physics.shape.SphereColliderShape extends laya.d3.physics.shape.ColliderShape
var SphereColliderShape=(function(_super){
	function SphereColliderShape(radius){
		/**@private */
		//this._radius=NaN;
		SphereColliderShape.__super.call(this);
		(radius===void 0)&& (radius=0.5);
		this._radius=radius;
		this._type=/*laya.d3.physics.shape.ColliderShape.SHAPETYPES_SPHERE*/1;
		this._nativeShape=new Laya3D._physics3D.btSphereShape(radius);
	}

	__class(SphereColliderShape,'laya.d3.physics.shape.SphereColliderShape',_super);
	var __proto=SphereColliderShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto.clone=function(){
		var dest=new SphereColliderShape(this._radius);
		this.cloneTo(dest);
		return dest;
	}

	/**
	*获取半径。
	*/
	__getset(0,__proto,'radius',function(){
		return this._radius;
	});

	return SphereColliderShape;
})(ColliderShape)


/**
*<code>SphereShape</code> 类用于创建球形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.SphereShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var SphereShape=(function(_super){
	function SphereShape(){
		/**发射器半径。*/
		this.radius=NaN;
		/**从外壳发射。*/
		this.emitFromShell=false;
		SphereShape.__super.call(this);
		this.radius=1.0;
		this.emitFromShell=false;
		this.randomDirection=false;
	}

	__class(SphereShape,'laya.d3.core.particleShuriKen.module.shape.SphereShape',_super);
	var __proto=SphereShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=minE[2]=-this.radius;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=maxE[2]=this.radius;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=minE[2]=-1;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=maxE[2]=1;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		if (rand){
			rand.seed=randomSeeds[16];
			if (this.emitFromShell)
				ShapeUtils._randomPointUnitSphere(position,rand);
			else
			ShapeUtils._randomPointInsideUnitSphere(position,rand);
			randomSeeds[16]=rand.seed;
			}else {
			if (this.emitFromShell)
				ShapeUtils._randomPointUnitSphere(position);
			else
			ShapeUtils._randomPointInsideUnitSphere(position);
		}
		Vector3.scale(position,this.radius,position);
		if (this.randomDirection){
			if (rand){
				rand.seed=randomSeeds[17];
				ShapeUtils._randomPointUnitSphere(direction,rand);
				randomSeeds[17]=rand.seed;
				}else {
				ShapeUtils._randomPointUnitSphere(direction);
			}
			}else {
			position.cloneTo(direction);
		}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.radius=this.radius;
		destShape.emitFromShell=this.emitFromShell;
		destShape.randomDirection=this.randomDirection;
	}

	return SphereShape;
})(BaseShape)


/**
*@private
*<code>SubMeshDynamicBatch</code> 类用于网格动态合并。
*/
//class laya.d3.graphics.SubMeshDynamicBatch extends laya.d3.core.GeometryElement
var SubMeshDynamicBatch=(function(_super){
	function SubMeshDynamicBatch(){
		/**@private */
		this._vertices=null;
		/**@private */
		this._indices=null;
		/**@private */
		this._positionOffset=0;
		/**@private */
		this._normalOffset=0;
		/**@private */
		this._colorOffset=0;
		/**@private */
		this._uv0Offset=0;
		/**@private */
		this._uv1Offset=0;
		/**@private */
		this._sTangentOffset=0;
		/**@private */
		this._vertexBuffer=null;
		/**@private */
		this._indexBuffer=null;
		SubMeshDynamicBatch.__super.call(this);
		this._bufferState=new BufferState();
		var maxVerDec=VertexMesh.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
		var maxByteCount=maxVerDec.vertexStride *32000;
		this._vertices=new Float32Array(maxByteCount / 4);
		this._vertexBuffer=new VertexBuffer3D(maxByteCount,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		this._indices=new Int16Array(/*CLASS CONST:laya.d3.graphics.SubMeshDynamicBatch.maxIndicesCount*/32000);
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._indices.length,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
		var memorySize=this._vertexBuffer._byteLength+this._indexBuffer._byteLength;
		Resource._addMemory(memorySize,memorySize);
	}

	__class(SubMeshDynamicBatch,'laya.d3.graphics.SubMeshDynamicBatch',_super);
	var __proto=SubMeshDynamicBatch.prototype;
	/**
	*@private
	*/
	__proto._getBatchVertices=function(vertexDeclaration,batchVertices,batchOffset,transform,element,subMesh){
		var vertexFloatCount=vertexDeclaration.vertexStride / 4;
		var oriVertexes=subMesh._vertexBuffer.getData();
		var lightmapScaleOffset=element.render.lightmapScaleOffset;
		var multiSubMesh=element._dynamicMultiSubMesh;
		var vertexCount=element._dynamicVertexCount;
		element._computeWorldPositionsAndNormals(this._positionOffset,this._normalOffset,multiSubMesh,vertexCount);
		var worldPositions=element._dynamicWorldPositions;
		var worldNormals=element._dynamicWorldNormals;
		var indices=subMesh._indices;
		for (var i=0;i < vertexCount;i++){
			var index=multiSubMesh ? indices[i] :i;
			var oriOffset=index *vertexFloatCount;
			var bakeOffset=(i+batchOffset)*vertexFloatCount;
			var oriOff=i *3;
			var bakOff=bakeOffset+this._positionOffset;
			batchVertices[bakOff]=worldPositions[oriOff];
			batchVertices[bakOff+1]=worldPositions[oriOff+1];
			batchVertices[bakOff+2]=worldPositions[oriOff+2];
			if (this._normalOffset!==-1){
				bakOff=bakeOffset+this._normalOffset;
				batchVertices[bakOff]=worldNormals[oriOff];
				batchVertices[bakOff+1]=worldNormals[oriOff+1];
				batchVertices[bakOff+2]=worldNormals[oriOff+2];
			}
			if (this._colorOffset!==-1){
				bakOff=bakeOffset+this._colorOffset;
				oriOff=oriOffset+this._colorOffset;
				batchVertices[bakOff]=oriVertexes[oriOff];
				batchVertices[bakOff+1]=oriVertexes[oriOff+1];
				batchVertices[bakOff+2]=oriVertexes[oriOff+2];
				batchVertices[bakOff+3]=oriVertexes[oriOff+3];
			}
			if (this._uv0Offset!==-1){
				bakOff=bakeOffset+this._uv0Offset;
				oriOff=oriOffset+this._uv0Offset;
				batchVertices[bakOff]=oriVertexes[oriOff];
				batchVertices[bakOff+1]=oriVertexes[oriOff+1];
			}
			if (this._sTangentOffset!==-1){
				bakOff=bakeOffset+this._sTangentOffset;
				oriOff=oriOffset+this._sTangentOffset;
				batchVertices[bakOff]=oriVertexes[oriOff];
				batchVertices[bakOff+1]=oriVertexes[oriOff+1];
				batchVertices[bakOff+2]=oriVertexes[oriOff+2];
				batchVertices[bakOff+3]=oriVertexes[oriOff+3];
				bakOff=bakeOffset+this._sTangentOffset;
				oriOff=oriOffset+this._sTangentOffset;
				batchVertices[bakOff]=oriVertexes[oriOff];
				batchVertices[bakOff+1]=oriVertexes[oriOff+1];
				batchVertices[bakOff+2]=oriVertexes[oriOff+2];
				batchVertices[bakOff+3]=oriVertexes[oriOff+3];
			}
		}
	}

	/**
	*@private
	*/
	__proto._getBatchIndices=function(batchIndices,batchIndexCount,batchVertexCount,transform,subMesh,multiSubMesh){
		var subIndices=subMesh._indices;
		var k=0,m=0,batchOffset=0;
		var isInvert=transform._isFrontFaceInvert;
		if (multiSubMesh){
			if (isInvert){
				for (k=0,m=subIndices.length;k < m;k+=3){
					batchOffset=batchIndexCount+k;
					var index=batchVertexCount+k;
					batchIndices[batchOffset]=index;
					batchIndices[batchOffset+1]=index+2;
					batchIndices[batchOffset+2]=index+1;
				}
				}else {
				for (k=m,m=subIndices.length;k < m;k+=3){
					batchOffset=batchIndexCount+k;
					index=batchVertexCount+k;
					batchIndices[batchOffset]=index;
					batchIndices[batchOffset+1]=index+1;
					batchIndices[batchOffset+2]=index+2;
				}
			}
			}else {
			if (isInvert){
				for (k=0,m=subIndices.length;k < m;k+=3){
					batchOffset=batchIndexCount+k;
					batchIndices[batchOffset]=batchVertexCount+subIndices[k];
					batchIndices[batchOffset+1]=batchVertexCount+subIndices[k+2];
					batchIndices[batchOffset+2]=batchVertexCount+subIndices[k+1];
				}
				}else {
				for (k=m,m=subIndices.length;k < m;k+=3){
					batchOffset=batchIndexCount+k;
					batchIndices[batchOffset]=batchVertexCount+subIndices[k];
					batchIndices[batchOffset+1]=batchVertexCount+subIndices[k+1];
					batchIndices[batchOffset+2]=batchVertexCount+subIndices[k+2];
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._flush=function(vertexCount,indexCount){
		this._vertexBuffer.setData(this._vertices,0,0,vertexCount *(this._vertexBuffer.vertexDeclaration.vertexStride / 4));
		this._indexBuffer.setData(this._indices,0,0,indexCount);
		LayaGL.instance.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
		Stat.renderBatch++;
		Stat.trianglesFaces+=indexCount / 3;
	}

	/**
	*@inheritDoc
	*/
	__proto._prepareRender=function(state){
		var element=state.renderElement;
		var vertexDeclaration=element.dynamicVertexDeclaration;
		this._bufferState=MeshRenderDynamicBatchManager.instance._getBufferState(vertexDeclaration);
		this._positionOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0).offset / 4;
		var normalElement=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_NORMAL0*/3);
		this._normalOffset=normalElement ? normalElement.offset / 4 :-1;
		var colorElement=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1);
		this._colorOffset=colorElement ? colorElement.offset / 4 :-1;
		var uv0Element=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2);
		this._uv0Offset=uv0Element ? uv0Element.offset / 4 :-1;
		var uv1Element=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE1*/8);
		this._uv1Offset=uv1Element ? uv1Element.offset / 4 :-1;
		var tangentElement=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_TANGENT0*/5);
		this._sTangentOffset=tangentElement ? tangentElement.offset / 4 :-1;
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._render=function(context){
		this._bufferState.bind();
		var element=context.renderElement;
		var vertexDeclaration=element.dynamicVertexDeclaration;
		var batchElements=element.dynamicBatchElementList;
		var batchVertexCount=0;
		var batchIndexCount=0;
		var floatStride=vertexDeclaration.vertexStride / 4;
		for (var i=0,n=batchElements.length;i < n;i++){
			var subElement=batchElements [i];
			var subMesh=subElement._geometry;
			var indexCount=subMesh._indexCount;
			if (batchIndexCount+indexCount > /*CLASS CONST:laya.d3.graphics.SubMeshDynamicBatch.maxIndicesCount*/32000){
				this._flush(batchVertexCount,batchIndexCount);
				batchVertexCount=batchIndexCount=0;
			};
			var transform=subElement._transform;
			this._getBatchVertices(vertexDeclaration,this._vertices,batchVertexCount,transform,subElement,subMesh);
			this._getBatchIndices(this._indices,batchIndexCount,batchVertexCount,transform,subMesh,subElement._dynamicMultiSubMesh);
			batchVertexCount+=subElement._dynamicVertexCount;
			batchIndexCount+=indexCount;
		}
		this._flush(batchVertexCount,batchIndexCount);
	}

	SubMeshDynamicBatch.maxAllowVertexCount=10;
	SubMeshDynamicBatch.maxAllowAttribueCount=900;
	SubMeshDynamicBatch.maxIndicesCount=32000;
	SubMeshDynamicBatch.instance=null;
	return SubMeshDynamicBatch;
})(GeometryElement)


/**
*<code>SkyBox</code> 类用于创建天空盒。
*/
//class laya.d3.resource.models.SkyBox extends laya.d3.resource.models.SkyMesh
var SkyBox=(function(_super){
	/**
	*创建一个 <code>SkyBox</code> 实例。
	*/
	function SkyBox(){
		SkyBox.__super.call(this);
		var halfHeight=0.5;
		var halfWidth=0.5;
		var halfDepth=0.5;
		var vertices=new Float32Array([-halfDepth,halfHeight,-halfWidth,halfDepth,halfHeight,-halfWidth,halfDepth,halfHeight,halfWidth,-halfDepth,halfHeight,halfWidth,
		-halfDepth,-halfHeight,-halfWidth,halfDepth,-halfHeight,-halfWidth,halfDepth,-halfHeight,halfWidth,-halfDepth,-halfHeight,halfWidth]);
		var indices=new Uint8Array([0,1,2,2,3,0,
		4,7,6,6,5,4,
		0,3,7,7,4,0,
		1,5,6,6,2,1,
		3,2,6,6,7,3,
		0,4,5,5,1,0]);
		var verDec=VertexMesh.getVertexDeclaration("POSITION");
		this._vertexBuffer=new VertexBuffer3D(verDec.vertexStride *8,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.vertexDeclaration=verDec;
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte",36,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
		var bufferState=new BufferState();
		bufferState.bind();
		bufferState.applyVertexBuffer(this._vertexBuffer);
		bufferState.applyIndexBuffer(this._indexBuffer);
		bufferState.unBind();
		this._bufferState=bufferState;
	}

	__class(SkyBox,'laya.d3.resource.models.SkyBox',_super);
	var __proto=SkyBox.prototype;
	/**
	*@inheritDoc
	*/
	__proto._render=function(state){
		LayaGL.instance.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,36,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,0);
		Stat.trianglesFaces+=12;
		Stat.renderBatch++;
	}

	SkyBox.__init__=function(){
		SkyBox.instance=new SkyBox();
	}

	SkyBox.instance=null;
	return SkyBox;
})(SkyMesh)


/**
*<code>CircleShape</code> 类用于创建环形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.CircleShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var CircleShape=(function(_super){
	function CircleShape(){
		/**发射器半径。*/
		this.radius=NaN;
		/**环形弧度。*/
		this.arc=NaN;
		/**从边缘发射。*/
		this.emitFromEdge=false;
		CircleShape.__super.call(this);
		this.radius=1.0;
		this.arc=360.0 / 180.0 *Math.PI;
		this.emitFromEdge=false;
		this.randomDirection=false;
	}

	__class(CircleShape,'laya.d3.core.particleShuriKen.module.shape.CircleShape',_super);
	var __proto=CircleShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[2]=-this.radius;
		minE[1]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[2]=this.radius;
		maxE[1]=0;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=-1;
		minE[2]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=1;
		maxE[2]=0;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		var rpE=position.elements;
		var positionPointE=CircleShape._tempPositionPoint.elements;
		if (rand){
			rand.seed=randomSeeds[16];
			if (this.emitFromEdge)
				ShapeUtils._randomPointUnitArcCircle(this.arc,CircleShape._tempPositionPoint,rand);
			else
			ShapeUtils._randomPointInsideUnitArcCircle(this.arc,CircleShape._tempPositionPoint,rand);
			randomSeeds[16]=rand.seed;
			}else {
			if (this.emitFromEdge)
				ShapeUtils._randomPointUnitArcCircle(this.arc,CircleShape._tempPositionPoint);
			else
			ShapeUtils._randomPointInsideUnitArcCircle(this.arc,CircleShape._tempPositionPoint);
		}
		rpE[0]=-positionPointE[0];
		rpE[1]=positionPointE[1];
		rpE[2]=0;
		Vector3.scale(position,this.radius,position);
		if (this.randomDirection){
			if (rand){
				rand.seed=randomSeeds[17];
				ShapeUtils._randomPointUnitSphere(direction,rand);
				randomSeeds[17]=rand.seed;
				}else {
				ShapeUtils._randomPointUnitSphere(direction);
			}
			}else {
			position.cloneTo(direction);
		}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.radius=this.radius;
		destShape.arc=this.arc;
		destShape.emitFromEdge=this.emitFromEdge;
		destShape.randomDirection=this.randomDirection;
	}

	__static(CircleShape,
	['_tempPositionPoint',function(){return this._tempPositionPoint=new Vector2();}
	]);
	return CircleShape;
})(BaseShape)


/**
*@private
*<code>SubMeshStaticBatch</code> 类用于网格静态合并。
*/
//class laya.d3.graphics.SubMeshStaticBatch extends laya.d3.core.GeometryElement
var SubMeshStaticBatch=(function(_super){
	function SubMeshStaticBatch(batchOwner,number,vertexDeclaration){
		/**@private */
		//this._currentBatchVertexCount=0;
		/**@private */
		//this._currentBatchIndexCount=0;
		/**@private */
		//this._vertexDeclaration=null;
		/**@private */
		//this._vertexBuffer=null;
		/**@private */
		//this._indexBuffer=null;
		/**@private */
		//this._batchElements=null;
		/**@private */
		//this._batchID=0;
		/**@private [只读]*/
		//this.batchOwner=null;
		/**@private [只读]*/
		//this.number=0;
		SubMeshStaticBatch.__super.call(this);
		this._bufferState=new BufferState();
		this._batchID=SubMeshStaticBatch._batchIDCounter++;
		this._batchElements=[];
		this._currentBatchVertexCount=0;
		this._currentBatchIndexCount=0;
		this._vertexDeclaration=vertexDeclaration;
		this.batchOwner=batchOwner;
		this.number=number;
	}

	__class(SubMeshStaticBatch,'laya.d3.graphics.SubMeshStaticBatch',_super);
	var __proto=SubMeshStaticBatch.prototype;
	Laya.imps(__proto,{"laya.resource.IDispose":true})
	/**
	*@private
	*/
	__proto._getStaticBatchBakedVertexs=function(batchVertices,batchOffset,batchOwnerTransform,transform,render,mesh){
		var vertexBuffer=mesh._vertexBuffers[0];
		var vertexDeclaration=vertexBuffer.vertexDeclaration;
		var positionOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0).offset / 4;
		var normalElement=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_NORMAL0*/3);
		var normalOffset=normalElement ? normalElement.offset / 4 :-1;
		var colorElement=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1);
		var colorOffset=colorElement ? colorElement.offset / 4 :-1;
		var uv0Element=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2);
		var uv0Offset=uv0Element ? uv0Element.offset / 4 :-1;
		var uv1Element=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE1*/8);
		var uv1Offset=uv1Element ? uv1Element.offset / 4 :-1;
		var tangentElement=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_TANGENT0*/5);
		var sTangentOffset=tangentElement ? tangentElement.offset / 4 :-1;
		var bakeVertexFloatCount=18;
		var oriVertexFloatCount=vertexDeclaration.vertexStride / 4;
		var oriVertexes=vertexBuffer.getData();
		var worldMat;
		if (batchOwnerTransform){
			var rootMat=batchOwnerTransform.worldMatrix;
			rootMat.invert(SubMeshStaticBatch._tempMatrix4x40);
			worldMat=SubMeshStaticBatch._tempMatrix4x41;
			Matrix4x4.multiply(SubMeshStaticBatch._tempMatrix4x40,transform.worldMatrix,worldMat);
			}else {
			worldMat=transform.worldMatrix;
		};
		var rotation=SubMeshStaticBatch._tempQuaternion0;
		worldMat.decomposeTransRotScale(SubMeshStaticBatch._tempVector30,rotation,SubMeshStaticBatch._tempVector31);
		var lightmapScaleOffset=render.lightmapScaleOffset;
		var vertexCount=mesh.vertexCount;
		for (var i=0;i < vertexCount;i++){
			var oriOffset=i *oriVertexFloatCount;
			var bakeOffset=(i+batchOffset)*bakeVertexFloatCount;
			Utils3D.transformVector3ArrayToVector3ArrayCoordinate(oriVertexes,oriOffset+positionOffset,worldMat,batchVertices,bakeOffset+0);
			if (normalOffset!==-1)
				Utils3D.transformVector3ArrayByQuat(oriVertexes,oriOffset+normalOffset,rotation,batchVertices,bakeOffset+3);
			var j=0,m=0;
			var bakOff=bakeOffset+6;
			if (colorOffset!==-1){
				var oriOff=oriOffset+colorOffset;
				for (j=0,m=4;j < m;j++)
				batchVertices[bakOff+j]=oriVertexes[oriOff+j];
				}else {
				for (j=0,m=4;j < m;j++)
				batchVertices[bakOff+j]=1.0;
			}
			if (uv0Offset!==-1){
				var absUv0Offset=oriOffset+uv0Offset;
				batchVertices[bakeOffset+10]=oriVertexes[absUv0Offset];
				batchVertices[bakeOffset+11]=oriVertexes[absUv0Offset+1];
			}
			if (lightmapScaleOffset){
				if (uv1Offset!==-1)
					Utils3D.transformLightingMapTexcoordArray(oriVertexes,oriOffset+uv1Offset,lightmapScaleOffset,batchVertices,bakeOffset+12);
				else
				Utils3D.transformLightingMapTexcoordArray(oriVertexes,oriOffset+uv0Offset,lightmapScaleOffset,batchVertices,bakeOffset+12);
			}
			if (sTangentOffset!==-1){
				var absSTanegntOffset=oriOffset+sTangentOffset;
				batchVertices[bakeOffset+14]=oriVertexes[absSTanegntOffset];
				batchVertices[bakeOffset+15]=oriVertexes[absSTanegntOffset+1];
				batchVertices[bakeOffset+16]=oriVertexes[absSTanegntOffset+2];
				batchVertices[bakeOffset+17]=oriVertexes[absSTanegntOffset+3];
			}
		}
		return vertexCount;
	}

	/**
	*@private
	*/
	__proto.addTest=function(sprite){
		var vertexCount=0;
		var subMeshVertexCount=((sprite).meshFilter.sharedMesh).vertexCount;
		vertexCount=this._currentBatchVertexCount+subMeshVertexCount;
		if (vertexCount > 65535)
			return false;
		return true;
	}

	/**
	*@private
	*/
	__proto.add=function(sprite){
		var oldStaticBatch=sprite._render._staticBatch;
		(oldStaticBatch)&& (oldStaticBatch.remove(sprite));
		var mesh=(sprite).meshFilter.sharedMesh;
		var subMeshVertexCount=mesh.vertexCount;
		this._batchElements.push(sprite);
		var render=sprite._render;
		render._isPartOfStaticBatch=true;
		render._staticBatch=this;
		var renderElements=render._renderElements;
		for (var i=0,n=renderElements.length;i < n;i++)
		renderElements[i].staticBatch=this;
		this._currentBatchIndexCount+=mesh._indexBuffer.indexCount;
		this._currentBatchVertexCount+=subMeshVertexCount;
	}

	/**
	*@private
	*/
	__proto.remove=function(sprite){
		var mesh=(sprite).meshFilter.sharedMesh;
		var index=this._batchElements.indexOf(sprite);
		if (index!==-1){
			this._batchElements.splice(index,1);
			var render=sprite._render;
			var renderElements=sprite._render._renderElements;
			for (var i=0,n=renderElements.length;i < n;i++)
			renderElements[i].staticBatch=null;
			var meshVertexCount=mesh.vertexCount;
			this._currentBatchIndexCount=this._currentBatchIndexCount-mesh._indexBuffer.indexCount;
			this._currentBatchVertexCount=this._currentBatchVertexCount-meshVertexCount;
			sprite._render._isPartOfStaticBatch=false;
		}
	}

	/**
	*@private
	*/
	__proto.finishInit=function(){
		if (this._vertexBuffer){
			this._vertexBuffer.destroy();
			this._indexBuffer.destroy();
		};
		var batchVertexCount=0;
		var batchIndexCount=0;
		var rootOwner=this.batchOwner._owner;
		var floatStride=this._vertexDeclaration.vertexStride / 4;
		var vertexDatas=new Float32Array(floatStride *this._currentBatchVertexCount);
		var indexDatas=new Uint16Array(this._currentBatchIndexCount);
		this._vertexBuffer=new VertexBuffer3D(this._vertexDeclaration.vertexStride *this._currentBatchVertexCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		this._vertexBuffer.vertexDeclaration=this._vertexDeclaration;
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._currentBatchIndexCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
		for (var i=0,n=this._batchElements.length;i < n;i++){
			var sprite=this._batchElements [i];
			var mesh=sprite.meshFilter.sharedMesh;
			var meshVerCount=this._getStaticBatchBakedVertexs(vertexDatas,batchVertexCount,rootOwner ? rootOwner._transform :null,sprite._transform,(sprite._render),mesh);
			var indices=mesh._indexBuffer.getData();
			var indexOffset=batchVertexCount;
			var indexEnd=batchIndexCount+indices.length;
			var elements=sprite._render._renderElements;
			for (var j=0,m=mesh.subMeshCount;j < m;j++){
				var subMesh=mesh._subMeshes[j];
				var start=batchIndexCount+subMesh._indexStart;
				var element=elements [j];
				element.staticBatchIndexStart=start;
				element.staticBatchIndexEnd=start+subMesh._indexCount;
			}
			indexDatas.set(indices,batchIndexCount);
			var k=0;
			var isInvert=rootOwner ? (sprite._transform._isFrontFaceInvert!==rootOwner.transform._isFrontFaceInvert):sprite._transform._isFrontFaceInvert;
			if (isInvert){
				for (k=batchIndexCount;k < indexEnd;k+=3){
					indexDatas[k]=indexOffset+indexDatas[k];
					var index1=indexDatas[k+1];
					var index2=indexDatas[k+2];
					indexDatas[k+1]=indexOffset+index2;
					indexDatas[k+2]=indexOffset+index1;
				}
				}else {
				for (k=batchIndexCount;k < indexEnd;k+=3){
					indexDatas[k]=indexOffset+indexDatas[k];
					indexDatas[k+1]=indexOffset+indexDatas[k+1];
					indexDatas[k+2]=indexOffset+indexDatas[k+2];
				}
			}
			batchIndexCount+=indices.length;
			batchVertexCount+=meshVerCount;
		}
		this._vertexBuffer.setData(vertexDatas);
		this._indexBuffer.setData(indexDatas);
		var memorySize=this._vertexBuffer._byteLength+this._indexBuffer._byteLength;
		Resource._addGPUMemory(memorySize);
		this._bufferState.bind();
		this._bufferState.applyVertexBuffer(this._vertexBuffer);
		this._bufferState.applyIndexBuffer(this._indexBuffer);
		this._bufferState.unBind();
	}

	/**
	*@inheritDoc
	*/
	__proto._render=function(state){
		this._bufferState.bind();
		var element=state.renderElement;
		var batchElementList=(element).staticBatchElementList;
		var from=0;
		var end=0;
		for (var i=1,n=batchElementList.length;i < n;i++){
			var lastElement=batchElementList[i-1];
			if (lastElement.staticBatchIndexEnd===batchElementList[i].staticBatchIndexStart){
				end++;
				continue ;
				}else {
				var start=batchElementList[from].staticBatchIndexStart;
				var indexCount=batchElementList[end].staticBatchIndexEnd-start;
				LayaGL.instance.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,start *2);
				from=++end;
				Stat.renderBatch++;
				Stat.trianglesFaces+=indexCount / 3;
			}
		}
		start=batchElementList[from].staticBatchIndexStart;
		indexCount=batchElementList[end].staticBatchIndexEnd-start;
		LayaGL.instance.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,start *2);
		Stat.renderBatch++;
		Stat.trianglesFaces+=indexCount / 3;
	}

	/**
	*@private
	*/
	__proto.dispose=function(){
		var memorySize=this._vertexBuffer._byteLength+this._indexBuffer._byteLength;
		Resource._addGPUMemory(-memorySize);
		this._batchElements=null;
		this.batchOwner=null;
		this._vertexDeclaration=null;
		this._bufferState.destroy();
		this._vertexBuffer.destroy();
		this._indexBuffer.destroy();
		this._vertexBuffer=null;
		this._indexBuffer=null;
		this._bufferState=null;
	}

	SubMeshStaticBatch.maxBatchVertexCount=65535;
	SubMeshStaticBatch._batchIDCounter=0;
	__static(SubMeshStaticBatch,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempMatrix4x41',function(){return this._tempMatrix4x41=new Matrix4x4();}
	]);
	return SubMeshStaticBatch;
})(GeometryElement)


/**
*<code>TrailGeometry</code> 类用于创建拖尾渲染单元。
*/
//class laya.d3.core.trail.TrailGeometry extends laya.d3.core.GeometryElement
var TrailGeometry=(function(_super){
	function TrailGeometry(owner){
		/**@private */
		this._floatCountPerVertices1=8;
		/**@private */
		this._floatCountPerVertices2=1;
		/**@private */
		this._increaseSegementCount=128;
		/**@private */
		this._activeIndex=0;
		/**@private */
		this._endIndex=0;
		/**@private */
		this._needAddFirstVertex=false;
		/**@private */
		this._isTempEndVertex=false;
		/**@private */
		this._subBirthTime=null;
		/**@private */
		this._subDistance=null;
		/**@private */
		this._segementCount=0;
		/**@private */
		this._vertices1=null;
		/**@private */
		this._vertices2=null;
		/**@private */
		this._vertexBuffer1=null;
		/**@private */
		this._vertexBuffer2=null;
		/**@private */
		this._owner=null;
		TrailGeometry.__super.call(this);
		this._lastFixedVertexPosition=new Vector3();
		this._bufferState=new BufferState();
		this._owner=owner;;
		this._resizeData(this._increaseSegementCount,this._bufferState);
	}

	__class(TrailGeometry,'laya.d3.core.trail.TrailGeometry',_super);
	var __proto=TrailGeometry.prototype;
	/**
	*@private
	*/
	__proto._resizeData=function(segementCount,bufferState){
		this._segementCount=this._increaseSegementCount;
		this._subBirthTime=new Float32Array(segementCount);
		this._subDistance=new Float32Array(segementCount);
		var vertexCount=segementCount *2;
		var vertexDeclaration1=VertexTrail.vertexDeclaration1;
		var vertexDeclaration2=VertexTrail.vertexDeclaration2;
		var vertexBuffers=[];
		var vertexbuffer1Size=vertexCount *vertexDeclaration1.vertexStride;
		var vertexbuffer2Size=vertexCount *vertexDeclaration2.vertexStride;
		var memorySize=vertexbuffer1Size+vertexbuffer2Size;
		this._vertices1=new Float32Array(vertexCount *this._floatCountPerVertices1);
		this._vertexBuffer1=new VertexBuffer3D(vertexbuffer1Size,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer1.vertexDeclaration=vertexDeclaration1;
		this._vertices2=new Float32Array(vertexCount *this._floatCountPerVertices2);
		this._vertexBuffer2=new VertexBuffer3D(vertexbuffer2Size,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8,false);
		this._vertexBuffer2.vertexDeclaration=vertexDeclaration2;
		vertexBuffers.push(this._vertexBuffer1);
		vertexBuffers.push(this._vertexBuffer2);
		bufferState.bind();
		bufferState.applyVertexBuffers(vertexBuffers);
		bufferState.unBind();
		Resource._addMemory(memorySize,memorySize);
	}

	/**
	*@private
	*/
	__proto._resetData=function(){
		var count=this._endIndex-this._activeIndex;
		if (count==this._segementCount){
			this._vertexBuffer1.destroy();
			this._vertexBuffer2.destroy();
			this._segementCount+=this._increaseSegementCount;
			this._resizeData(this._segementCount,this._bufferState);
		}
		this._vertexBuffer1.setData(this._vertices1,0,this._floatCountPerVertices1 *2 *this._activeIndex,this._floatCountPerVertices1 *2 *count);
		this._vertexBuffer2.setData(this._vertices2,0,this._floatCountPerVertices2 *2 *this._activeIndex,this._floatCountPerVertices2 *2 *count);
		var offset=this._activeIndex *4;
		var rightSubDistance=new Float32Array(this._subDistance.buffer,offset,count);
		var rightSubBirthTime=new Float32Array(this._subBirthTime.buffer,offset,count);
		this._subDistance.set(rightSubDistance,0);
		this._subBirthTime.set(rightSubBirthTime,0);
		this._endIndex=count;
		this._activeIndex=0;
	}

	/**
	*@private
	*更新Trail数据
	*/
	__proto._updateTrail=function(camera,lastPosition,position){
		if (!Vector3.equals(lastPosition,position)){
			if ((this._endIndex-this._activeIndex)===0)
				this._addTrailByFirstPosition(camera,position);
			else
			this._addTrailByNextPosition(camera,position);
		}
	}

	/**
	*@private
	*通过起始位置添加TrailRenderElement起始数据
	*/
	__proto._addTrailByFirstPosition=function(camera,position){
		(this._endIndex===this._segementCount)&& (this._resetData());
		this._subDistance[this._endIndex]=0;
		this._subBirthTime[this._endIndex]=this._owner._curtime;
		this._endIndex++;
		position.cloneTo(this._lastFixedVertexPosition);
		this._needAddFirstVertex=true;
	}

	/**
	*@private
	*通过位置更新TrailRenderElement数据
	*/
	__proto._addTrailByNextPosition=function(camera,position){
		var delVector3=TrailGeometry._tempVector30;
		var pointAtoBVector3=TrailGeometry._tempVector31;
		Vector3.subtract(position,this._lastFixedVertexPosition,delVector3);
		switch (this._owner.alignment){
			case /*laya.d3.core.trail.TrailFilter.ALIGNMENT_VIEW*/0:
				Vector3.cross(delVector3,camera.transform.forward,pointAtoBVector3);
				break ;
			case /*laya.d3.core.trail.TrailFilter.ALIGNMENT_TRANSFORM_Z*/1:
				Vector3.cross(delVector3,this._owner._owner.transform.forward,pointAtoBVector3);
				break ;
			}
		Vector3.normalize(pointAtoBVector3,pointAtoBVector3);
		Vector3.scale(pointAtoBVector3,this._owner.widthMultiplier / 2,pointAtoBVector3);
		var delLength=Vector3.scalarLength(delVector3);
		var tempEndIndex=0;
		var offset=NaN;
		if (this._needAddFirstVertex){
			this._updateVerticesByPositionData(position,pointAtoBVector3,this._endIndex-1);
			this._needAddFirstVertex=false;
		}
		if (delLength-this._owner.minVertexDistance >=MathUtils3D.zeroTolerance){
			if (this._isTempEndVertex){
				tempEndIndex=this._endIndex-1;
				offset=delLength-this._subDistance[tempEndIndex];
				this._updateVerticesByPosition(position,pointAtoBVector3,delLength,tempEndIndex);
				this._owner._totalLength+=offset;
				}else {
				(this._endIndex===this._segementCount)&& (this._resetData());
				this._updateVerticesByPosition(position,pointAtoBVector3,delLength,this._endIndex);
				this._owner._totalLength+=delLength;
				this._endIndex++;
			}
			position.cloneTo(this._lastFixedVertexPosition);
			this._isTempEndVertex=false;
			}else {
			if (this._isTempEndVertex){
				tempEndIndex=this._endIndex-1;
				offset=delLength-this._subDistance[tempEndIndex];
				this._updateVerticesByPosition(position,pointAtoBVector3,delLength,tempEndIndex);
				this._owner._totalLength+=offset;
				}else {
				(this._endIndex===this._segementCount)&& (this._resetData());
				this._updateVerticesByPosition(position,pointAtoBVector3,delLength,this._endIndex);
				this._owner._totalLength+=delLength;
				this._endIndex++;
			}
			this._isTempEndVertex=true;
		}
	}

	/**
	*@private
	*通过位置更新顶点数据
	*/
	__proto._updateVerticesByPositionData=function(position,pointAtoBVector3,index){
		var vertexOffset=this._floatCountPerVertices1 *2 *index;
		var pointE=position.elements;
		var pointAtoBVector3E=pointAtoBVector3.elements;
		var curtime=this._owner._curtime;
		this._vertices1[vertexOffset]=pointE[0];
		this._vertices1[vertexOffset+1]=pointE[1];
		this._vertices1[vertexOffset+2]=pointE[2];
		this._vertices1[vertexOffset+3]=-pointAtoBVector3E[0];
		this._vertices1[vertexOffset+4]=-pointAtoBVector3E[1];
		this._vertices1[vertexOffset+5]=-pointAtoBVector3E[2];
		this._vertices1[vertexOffset+6]=curtime;
		this._vertices1[vertexOffset+7]=1.0;
		this._vertices1[vertexOffset+8]=pointE[0];
		this._vertices1[vertexOffset+9]=pointE[1];
		this._vertices1[vertexOffset+10]=pointE[2];
		this._vertices1[vertexOffset+11]=pointAtoBVector3E[0];
		this._vertices1[vertexOffset+12]=pointAtoBVector3E[1];
		this._vertices1[vertexOffset+13]=pointAtoBVector3E[2];
		this._vertices1[vertexOffset+14]=curtime;
		this._vertices1[vertexOffset+15]=0.0;
		var floatCount=this._floatCountPerVertices1 *2;
		this._vertexBuffer1.setData(this._vertices1,vertexOffset,vertexOffset,floatCount);
	}

	/**
	*@private
	*通过位置更新顶点数据、距离、出生时间
	*/
	__proto._updateVerticesByPosition=function(position,pointAtoBVector3,delDistance,index){
		this._updateVerticesByPositionData(position,pointAtoBVector3,index);
		this._subDistance[index]=delDistance;
		this._subBirthTime[index]=this._owner._curtime;
	}

	/**
	*@private
	*更新VertexBuffer2数据
	*/
	__proto._updateVertexBufferUV=function(){
		var vertexCount=this._endIndex;
		var curLength=0;
		for (var i=this._activeIndex,j=vertexCount;i < j;i++){
			(i!==this._activeIndex)&& (curLength+=this._subDistance[i]);
			var uvX=NaN;
			if (this._owner.textureMode==/*laya.d3.core.TextureMode.Stretch*/0)
				uvX=1.0-curLength / this._owner._totalLength;
			else
			uvX=1.0-(this._owner._totalLength-curLength);
			this._vertices2[i *2]=uvX;
			this._vertices2[i *2+1]=uvX;
		};
		var offset=this._activeIndex *2;
		this._vertexBuffer2.setData(this._vertices2,offset,offset,vertexCount *2-offset);
	}

	/**
	*@private
	*/
	__proto._updateDisappear=function(){
		var count=this._endIndex;
		for (var i=this._activeIndex;i < count;i++){
			if (this._owner._curtime-this._subBirthTime[i] >=this._owner.time+MathUtils3D.zeroTolerance){
				var nextIndex=i+1;
				if (nextIndex!==count)
					this._owner._totalLength-=this._subDistance[nextIndex];
				if (this._isTempEndVertex && (nextIndex===count-1)){
					var offset=this._floatCountPerVertices1 *i *2;
					var fixedPosE=this._lastFixedVertexPosition.elements;
					fixedPosE[0]=this._vertices1[0];
					fixedPosE[1]=this._vertices1[1];
					fixedPosE[2]=this._vertices1[2];
					this._isTempEndVertex=false;
				}
				this._activeIndex++;
				}else {
				break ;
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._getType=function(){
		return TrailGeometry._type;
	}

	/**
	*@inheritDoc
	*/
	__proto._prepareRender=function(state){
		return this._endIndex-this._activeIndex > 1;
	}

	/**
	*@inheritDoc
	*/
	__proto._render=function(state){
		this._bufferState.bind();
		var start=this._activeIndex *2;
		var count=this._endIndex *2-start;
		LayaGL.instance.drawArrays(/*laya.webgl.WebGLContext.TRIANGLE_STRIP*/0x0005,start,count);
		Stat.renderBatch++;
		Stat.trianglesFaces+=count-2;
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		var memorySize=this._vertexBuffer1._byteLength+this._vertexBuffer2._byteLength;
		Resource._addMemory(-memorySize,-memorySize);
		this._bufferState.destroy();
		this._vertexBuffer1.destroy();
		this._vertexBuffer2.destroy();
		this._bufferState=null;
		this._vertices1=null;
		this._vertexBuffer1=null;
		this._vertices2=null;
		this._vertexBuffer2=null;
		this._subBirthTime=null;
		this._subDistance=null;
		this._lastFixedVertexPosition=null;
	}

	__static(TrailGeometry,
	['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_type',function(){return this._type=GeometryElement._typeCounter++;}
	]);
	return TrailGeometry;
})(GeometryElement)


/**
*<code>ConeShape</code> 类用于创建锥形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.ConeShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var ConeShape=(function(_super){
	function ConeShape(){
		/**发射角度。*/
		this.angle=NaN;
		/**发射器半径。*/
		this.radius=NaN;
		/**椎体长度。*/
		this.length=NaN;
		/**发射类型,0为Base,1为BaseShell,2为Volume,3为VolumeShell。*/
		this.emitType=0;
		ConeShape.__super.call(this);
		this.angle=25.0 / 180.0 *Math.PI;
		this.radius=1.0;
		this.length=5.0;
		this.emitType=0;
		this.randomDirection=false;
	}

	__class(ConeShape,'laya.d3.core.particleShuriKen.module.shape.ConeShape',_super);
	var __proto=ConeShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var coneRadius2=this.radius+this.length *Math.sin(this.angle);
		var coneLength=this.length *Math.cos(this.angle);
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=-coneRadius2;
		minE[2]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=maxE[1]=coneRadius2;
		maxE[2]=coneLength;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var sinA=Math.sin(this.angle);
		var minE=boundBox.min.elements;
		minE[0]=minE[1]=-sinA;
		minE[2]=0;
		var maxE=boundBox.max.elements;
		maxE[0]=minE[1]=sinA;
		maxE[2]=1;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		var rpE=position.elements;
		var rdE=direction.elements;
		var positionPointE=ConeShape._tempPositionPoint.elements;
		var positionX=NaN;
		var positionY=NaN;
		var directionPointE;
		var dirCosA=Math.cos(this.angle);
		var dirSinA=Math.sin(this.angle);
		switch (this.emitType){
			case 0:
				if (rand){
					rand.seed=randomSeeds[16];
					ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint,rand);
					randomSeeds[16]=rand.seed;
					}else {
					ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
				}
				positionX=positionPointE[0];
				positionY=positionPointE[1];
				rpE[0]=positionX *this.radius;
				rpE[1]=positionY *this.radius;
				rpE[2]=0;
				if (this.randomDirection){
					if (rand){
						rand.seed=randomSeeds[17];
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,rand);
						randomSeeds[17]=rand.seed;
						}else {
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
					}
					directionPointE=ConeShape._tempDirectionPoint.elements;
					rdE[0]=directionPointE[0] *dirSinA;
					rdE[1]=directionPointE[1] *dirSinA;
					}else {
					rdE[0]=positionX *dirSinA;
					rdE[1]=positionY *dirSinA;
				}
				rdE[2]=dirCosA;
				break ;
			case 1:
				if (rand){
					rand.seed=randomSeeds[16];
					ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint,rand);
					randomSeeds[16]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
				}
				positionX=positionPointE[0];
				positionY=positionPointE[1];
				rpE[0]=positionX *this.radius;
				rpE[1]=positionY *this.radius;
				rpE[2]=0;
				if (this.randomDirection){
					if (rand){
						rand.seed=randomSeeds[17];
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,rand);
						randomSeeds[17]=rand.seed;
						}else {
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
					}
					directionPointE=ConeShape._tempDirectionPoint.elements;
					rdE[0]=directionPointE[0] *dirSinA;
					rdE[1]=directionPointE[1] *dirSinA;
					}else {
					rdE[0]=positionX *dirSinA;
					rdE[1]=positionY *dirSinA;
				}
				rdE[2]=dirCosA;
				break ;
			case 2:
				if (rand){
					rand.seed=randomSeeds[16];
					ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint,rand);
					}else {
					ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
				}
				positionX=positionPointE[0];
				positionY=positionPointE[1];
				rpE[0]=positionX *this.radius;
				rpE[1]=positionY *this.radius;
				rpE[2]=0;
				rdE[0]=positionX *dirSinA;
				rdE[1]=positionY *dirSinA;
				rdE[2]=dirCosA;
				Vector3.normalize(direction,direction);
				if (rand){
					Vector3.scale(direction,this.length *rand.getFloat(),direction);
					randomSeeds[16]=rand.seed;
					}else {
					Vector3.scale(direction,this.length *Math.random(),direction);
				}
				Vector3.add(position,direction,position);
				if (this.randomDirection){
					if (rand){
						rand.seed=randomSeeds[17];
						ShapeUtils._randomPointUnitSphere(direction,rand);
						randomSeeds[17]=rand.seed;
						}else {
						ShapeUtils._randomPointUnitSphere(direction);
					}
				}
				break ;
			case 3:
				if (rand){
					rand.seed=randomSeeds[16];
					ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint,rand);
					}else {
					ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
				}
				positionX=positionPointE[0];
				positionY=positionPointE[1];
				rpE[0]=positionX *this.radius;
				rpE[1]=positionY *this.radius;
				rpE[2]=0;
				rdE[0]=positionX *dirSinA;
				rdE[1]=positionY *dirSinA;
				rdE[2]=dirCosA;
				Vector3.normalize(direction,direction);
				if (rand){
					Vector3.scale(direction,this.length *rand.getFloat(),direction);
					randomSeeds[16]=rand.seed;
					}else {
					Vector3.scale(direction,this.length *Math.random(),direction);
				}
				Vector3.add(position,direction,position);
				if (this.randomDirection){
					if (rand){
						rand.seed=randomSeeds[17];
						ShapeUtils._randomPointUnitSphere(direction,rand);
						randomSeeds[17]=rand.seed;
						}else {
						ShapeUtils._randomPointUnitSphere(direction);
					}
				}
				break ;
			default :
				throw new Error("ConeShape:emitType is invalid.");
			}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.angle=this.angle;
		destShape.radius=this.radius;
		destShape.length=this.length;
		destShape.emitType=this.emitType;
		destShape.randomDirection=this.randomDirection;
	}

	__static(ConeShape,
	['_tempPositionPoint',function(){return this._tempPositionPoint=new Vector2();},'_tempDirectionPoint',function(){return this._tempDirectionPoint=new Vector2();}
	]);
	return ConeShape;
})(BaseShape)


/**
*<code>BoxShape</code> 类用于创建球形粒子形状。
*/
//class laya.d3.core.particleShuriKen.module.shape.BoxShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
var BoxShape=(function(_super){
	function BoxShape(){
		/**发射器X轴长度。*/
		this.x=NaN;
		/**发射器Y轴长度。*/
		this.y=NaN;
		/**发射器Z轴长度。*/
		this.z=NaN;
		BoxShape.__super.call(this);
		this.x=1.0;
		this.y=1.0;
		this.z=1.0;
		this.randomDirection=false;
	}

	__class(BoxShape,'laya.d3.core.particleShuriKen.module.shape.BoxShape',_super);
	var __proto=BoxShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto._getShapeBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=-this.x *0.5;
		minE[1]=-this.y *0.5;
		minE[2]=-this.z *0.5;
		var maxE=boundBox.max.elements;
		maxE[0]=this.x *0.5;
		maxE[1]=this.y *0.5;
		maxE[2]=this.z *0.5;
	}

	/**
	*@inheritDoc
	*/
	__proto._getSpeedBoundBox=function(boundBox){
		var minE=boundBox.min.elements;
		minE[0]=0.0;
		minE[1]=0.0;
		minE[2]=0.0;
		var maxE=boundBox.max.elements;
		maxE[0]=0.0;
		maxE[1]=1.0;
		maxE[2]=0.0;
	}

	/**
	*用于生成粒子初始位置和方向。
	*@param position 粒子位置。
	*@param direction 粒子方向。
	*/
	__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
		var rpE=position.elements;
		var rdE=direction.elements;
		if (rand){
			rand.seed=randomSeeds[16];
			ShapeUtils._randomPointInsideHalfUnitBox(position,rand);
			randomSeeds[16]=rand.seed;
			}else {
			ShapeUtils._randomPointInsideHalfUnitBox(position);
		}
		rpE[0]=this.x *rpE[0];
		rpE[1]=this.y *rpE[1];
		rpE[2]=this.z *rpE[2];
		if (this.randomDirection){
			if (rand){
				rand.seed=randomSeeds[17];
				ShapeUtils._randomPointUnitSphere(direction,rand);
				randomSeeds[17]=rand.seed;
				}else {
				ShapeUtils._randomPointUnitSphere(direction);
			}
			}else {
			rdE[0]=0.0;
			rdE[1]=0.0;
			rdE[2]=1.0;
		}
	}

	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destShape=destObject;
		destShape.x=this.x;
		destShape.y=this.y;
		destShape.z=this.z;
		destShape.randomDirection=this.randomDirection;
	}

	return BoxShape;
})(BaseShape)


/**
*<code>StaticPlaneColliderShape</code> 类用于创建静态平面碰撞器。
*/
//class laya.d3.physics.shape.StaticPlaneColliderShape extends laya.d3.physics.shape.ColliderShape
var StaticPlaneColliderShape=(function(_super){
	function StaticPlaneColliderShape(normal,offset){
		/**@private */
		//this._offset=NaN;
		/**@private */
		//this._normal=null;
		StaticPlaneColliderShape.__super.call(this);
		this._normal=normal;
		this._offset=offset;
		this._type=/*laya.d3.physics.shape.ColliderShape.SHAPETYPES_STATICPLANE*/6;
		StaticPlaneColliderShape._nativeNormal.setValue(-normal.x,normal.y,normal.z);
		this._nativeShape=new Laya3D._physics3D.btStaticPlaneShape(StaticPlaneColliderShape._nativeNormal,offset);
	}

	__class(StaticPlaneColliderShape,'laya.d3.physics.shape.StaticPlaneColliderShape',_super);
	var __proto=StaticPlaneColliderShape.prototype;
	/**
	*@inheritDoc
	*/
	__proto.clone=function(){
		var dest=new StaticPlaneColliderShape(this._normal,this._offset);
		this.cloneTo(dest);
		return dest;
	}

	__static(StaticPlaneColliderShape,
	['_nativeNormal',function(){return this._nativeNormal=new Laya3D._physics3D.btVector3(0,0,0);}
	]);
	return StaticPlaneColliderShape;
})(ColliderShape)


/**
*<code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
*/
//class laya.d3.graphics.Vertex.VertexShurikenParticleMesh extends laya.d3.graphics.Vertex.VertexShuriKenParticle
var VertexShurikenParticleMesh=(function(_super){
	function VertexShurikenParticleMesh(cornerTextureCoordinate,positionStartLifeTime,velocity,startColor,startSize,startRotation0,startRotation1,startRotation2,ageAddScale,time,startSpeed,randoms0,randoms1,simulationWorldPostion){
		/**@private */
		this._cornerTextureCoordinate=null;
		/**@private */
		this._positionStartLifeTime=null;
		/**@private */
		this._velocity=null;
		/**@private */
		this._startColor=null;
		/**@private */
		this._startSize=null;
		/**@private */
		this._startRotation0=null;
		/**@private */
		this._startRotation1=null;
		/**@private */
		this._startRotation2=null;
		/**@private */
		this._startLifeTime=NaN;
		/**@private */
		this._time=NaN;
		/**@private */
		this._startSpeed=NaN;
		/**@private */
		this._randoms0=null;
		/**@private */
		this._randoms1=null;
		/**@private */
		this._simulationWorldPostion=null;
		VertexShurikenParticleMesh.__super.call(this);
		this._cornerTextureCoordinate=cornerTextureCoordinate;
		this._positionStartLifeTime=positionStartLifeTime;
		this._velocity=velocity;
		this._startColor=startColor;
		this._startSize=startSize;
		this._startRotation0=startRotation0;
		this._startRotation1=startRotation1;
		this._startRotation2=startRotation2;
		this._startLifeTime=ageAddScale;
		this._time=time;
		this._startSpeed=startSpeed;
		this._randoms0=this.random0;
		this._randoms1=this.random1;
		this._simulationWorldPostion=simulationWorldPostion;
	}

	__class(VertexShurikenParticleMesh,'laya.d3.graphics.Vertex.VertexShurikenParticleMesh',_super);
	var __proto=VertexShurikenParticleMesh.prototype;
	__getset(0,__proto,'cornerTextureCoordinate',function(){
		return this._cornerTextureCoordinate;
	});

	__getset(0,__proto,'velocity',function(){
		return this._velocity;
	});

	__getset(0,__proto,'position',function(){
		return this._positionStartLifeTime;
	});

	__getset(0,__proto,'random0',function(){
		return this._randoms0;
	});

	__getset(0,__proto,'startSize',function(){
		return this._startSize;
	});

	__getset(0,__proto,'startColor',function(){
		return this._startColor;
	});

	__getset(0,__proto,'startRotation0',function(){
		return this._startRotation0;
	});

	__getset(0,__proto,'startRotation1',function(){
		return this._startRotation1;
	});

	__getset(0,__proto,'random1',function(){
		return this._randoms1;
	});

	__getset(0,__proto,'startRotation2',function(){
		return this._startRotation2;
	});

	__getset(0,__proto,'startLifeTime',function(){
		return this._startLifeTime;
	});

	__getset(0,__proto,'time',function(){
		return this._time;
	});

	__getset(0,__proto,'startSpeed',function(){
		return this._startSpeed;
	});

	__getset(0,__proto,'simulationWorldPostion',function(){
		return this._simulationWorldPostion;
	});

	__getset(1,VertexShurikenParticleMesh,'vertexDeclaration',function(){
		return VertexShurikenParticleMesh._vertexDeclaration;
	},laya.d3.graphics.Vertex.VertexShuriKenParticle._$SET_vertexDeclaration);

	__static(VertexShurikenParticleMesh,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(172,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_POSITION0*/1),
		new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_COLOR0*/2),
		new VertexElement(28,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0*/3),
		new VertexElement(36,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME*/4),
		new VertexElement(52,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_DIRECTIONTIME*/5),
		new VertexElement(68,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTCOLOR0*/6),
		new VertexElement(84,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTSIZE*/8),
		new VertexElement(96,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTROTATION*/9),
		new VertexElement(108,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTSPEED*/10),
		new VertexElement(112,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_RANDOM0*/11),
		new VertexElement(128,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_RANDOM1*/12),
		new VertexElement(144,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION*/13),
		new VertexElement(156,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION*/14)]);}
	]);
	return VertexShurikenParticleMesh;
})(VertexShuriKenParticle)


/**
*<code>SkyDome</code> 类用于创建天空盒。
*/
//class laya.d3.resource.models.SkyDome extends laya.d3.resource.models.SkyMesh
var SkyDome=(function(_super){
	function SkyDome(stacks,slices){
		/**@private */
		this._stacks=0;
		/**@private */
		this._slices=0;
		SkyDome.__super.call(this);
		(stacks===void 0)&& (stacks=48);
		(slices===void 0)&& (slices=48);
		this._stacks=stacks;
		this._slices=slices;
		var vertexDeclaration=VertexPositionTexture0.vertexDeclaration;
		var vertexFloatCount=vertexDeclaration.vertexStride / 4;
		var numberVertices=(this._stacks+1)*(this._slices+1);
		var numberIndices=(3 *this._stacks *(this._slices+1))*2;
		var vertices=new Float32Array(numberVertices *vertexFloatCount);
		var indices=new Uint16Array(numberIndices);
		var stackAngle=Math.PI / this._stacks;
		var sliceAngle=(Math.PI *2.0)/ this._slices;
		var vertexIndex=0;
		var vertexCount=0;
		var indexCount=0;
		for (var stack=0;stack < (this._stacks+1);stack++){
			var r=Math.sin(stack *stackAngle);
			var y=Math.cos(stack *stackAngle);
			for (var slice=0;slice < (this._slices+1);slice++){
				var x=r *Math.sin(slice *sliceAngle);
				var z=r *Math.cos(slice *sliceAngle);
				vertices[vertexCount+0]=x *SkyDome._radius;
				vertices[vertexCount+1]=y *SkyDome._radius;
				vertices[vertexCount+2]=z *SkyDome._radius;
				vertices[vertexCount+3]=-(slice / this._slices)+0.75;
				vertices[vertexCount+4]=stack / this._stacks;
				vertexCount+=vertexFloatCount;
				if (stack !=(this._stacks-1)){
					indices[indexCount++]=vertexIndex+1;
					indices[indexCount++]=vertexIndex;
					indices[indexCount++]=vertexIndex+(this._slices+1);
					indices[indexCount++]=vertexIndex+(this._slices+1);
					indices[indexCount++]=vertexIndex;
					indices[indexCount++]=vertexIndex+(this._slices);
					vertexIndex++;
				}
			}
		}
		this._vertexBuffer=new VertexBuffer3D(vertices.length *4,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.vertexDeclaration=vertexDeclaration;
		this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",indices.length,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
		this._vertexBuffer.setData(vertices);
		this._indexBuffer.setData(indices);
		var bufferState=new BufferState();
		bufferState.bind();
		bufferState.applyVertexBuffer(this._vertexBuffer);
		bufferState.applyIndexBuffer(this._indexBuffer);
		bufferState.unBind();
		this._bufferState=bufferState;
	}

	__class(SkyDome,'laya.d3.resource.models.SkyDome',_super);
	var __proto=SkyDome.prototype;
	__proto._render=function(state){
		var indexCount=this._indexBuffer.indexCount;
		LayaGL.instance.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
		Stat.trianglesFaces+=indexCount / 3;
		Stat.renderBatch++;
	}

	/**
	*获取堆数。
	*/
	__getset(0,__proto,'stacks',function(){
		return this._stacks;
	});

	/**
	*获取层数。
	*/
	__getset(0,__proto,'slices',function(){
		return this._slices;
	});

	SkyDome.__init__=function(){
		SkyDome.instance=new SkyDome();
	}

	SkyDome._radius=1;
	SkyDome.instance=null;
	return SkyDome;
})(SkyMesh)


/**
*<code>FloatArrayKeyframe</code> 类用于创建浮点数组关键帧实例。
*/
//class laya.d3.core.FloatArrayKeyframe extends laya.d3.core.Keyframe
var FloatArrayKeyframe=(function(_super){
	function FloatArrayKeyframe(){
		//this.data=null;
		FloatArrayKeyframe.__super.call(this);
	}

	__class(FloatArrayKeyframe,'laya.d3.core.FloatArrayKeyframe',_super);
	var __proto=FloatArrayKeyframe.prototype;
	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destKeyFrame=destObject;
		destKeyFrame.data=this.data.slice();
	}

	return FloatArrayKeyframe;
})(Keyframe)


/**
*@private
*<code>MeshSprite3DDynamicBatchManager</code> 类用于网格精灵动态批处理管理。
*/
//class laya.d3.graphics.MeshRenderDynamicBatchManager extends laya.d3.graphics.DynamicBatchManager
var MeshRenderDynamicBatchManager=(function(_super){
	function MeshRenderDynamicBatchManager(){
		/**@private [只读]*/
		//this._updateCountMark=0;
		this._cacheBatchRender=[];
		this._cacheBufferStates=[];
		this._opaqueBatchMarks=[];
		MeshRenderDynamicBatchManager.__super.call(this);
		SubMeshDynamicBatch.instance=new SubMeshDynamicBatch();
		this._updateCountMark=0;
	}

	__class(MeshRenderDynamicBatchManager,'laya.d3.graphics.MeshRenderDynamicBatchManager',_super);
	var __proto=MeshRenderDynamicBatchManager.prototype;
	/**
	*@private
	*/
	__proto._getBufferState=function(vertexDeclaration){
		var bufferState=this._cacheBufferStates[vertexDeclaration.id];
		if (!bufferState){
			var instance=SubMeshDynamicBatch.instance;
			bufferState=new BufferState();
			bufferState.bind();
			var vertexBuffer=instance._vertexBuffer;
			vertexBuffer.vertexDeclaration=vertexDeclaration;
			bufferState.applyVertexBuffer(vertexBuffer);
			bufferState.applyIndexBuffer(instance._indexBuffer);
			bufferState.unBind();
			this._cacheBufferStates[vertexDeclaration.id]=bufferState;
		}
		return bufferState;
	}

	/**
	*@private
	*/
	__proto._getBatchRender=function(lightMapIndex,receiveShadow){
		var lightRenders=this._cacheBatchRender[lightMapIndex];
		(lightRenders)|| (lightRenders=this._cacheBatchRender[lightMapIndex]=__newvec(2,null));
		var render=lightRenders[receiveShadow ? 1 :0];
		if (!render){
			render=new MeshRenderer(null);
			render.lightmapIndex=lightMapIndex;
			render.receiveShadow=receiveShadow;
			lightRenders[receiveShadow ? 1 :0]=render;
		}
		return render;
	}

	/**
	*@inheritDoc
	*/
	__proto._getBatchRenderElementFromPool=function(){
		var renderElement=this._batchRenderElementPool [this._batchRenderElementPoolIndex++];
		if (!renderElement){
			renderElement=new SubMeshRenderElement();
			this._batchRenderElementPool[this._batchRenderElementPoolIndex-1]=renderElement;
			renderElement.dynamicBatchElementList=[];
		}
		return renderElement;
	}

	/**
	*@inheritDoc
	*/
	__proto._clear=function(){
		_super.prototype._clear.call(this);
		this._updateCountMark++;
	}

	__static(MeshRenderDynamicBatchManager,
	['instance',function(){return this.instance=new MeshRenderDynamicBatchManager();}
	]);
	return MeshRenderDynamicBatchManager;
})(DynamicBatchManager)


/**
*<code>Vector4</code> 类用于创建四维向量。
*/
//class laya.d3.math.Vector4 extends laya.d3.math.BaseVector
var Vector4=(function(_super){
	/**
	*创建一个 <code>Vector4</code> 实例。
	*@param x X轴坐标。
	*@param y Y轴坐标。
	*@param z Z轴坐标。
	*@param w W轴坐标。
	*/
	function Vector4(x,y,z,w){
		Vector4.__super.call(this);
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(z===void 0)&& (z=0);
		(w===void 0)&& (w=0);
		var v=this.elements=new Float32Array(4);
		v[0]=x;
		v[1]=y;
		v[2]=z;
		v[3]=w;
	}

	__class(Vector4,'laya.d3.math.Vector4',_super);
	var __proto=Vector4.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*从Array数组拷贝值。
	*@param array 数组。
	*@param offset 数组偏移。
	*/
	__proto.fromArray=function(array,offset){
		(offset===void 0)&& (offset=0);
		this.elements[0]=array[offset+0];
		this.elements[1]=array[offset+1];
		this.elements[2]=array[offset+2];
		this.elements[3]=array[offset+3];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destVector4=destObject;
		var destE=destVector4.elements;
		var s=this.elements;
		destE[0]=s[0];
		destE[1]=s[1];
		destE[2]=s[2];
		destE[3]=s[3];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destVector4=/*__JS__ */new this.constructor();
		this.cloneTo(destVector4);
		return destVector4;
	}

	/**
	*求四维向量的长度。
	*@return 长度。
	*/
	__proto.length=function(){
		return Math.sqrt(this.x *this.x+this.y *this.y+this.z *this.z+this.w *this.w);
	}

	/**
	*求四维向量长度的平方。
	*@return 长度的平方。
	*/
	__proto.lengthSquared=function(){
		return this.x *this.x+this.y *this.y+this.z *this.z+this.w *this.w;
	}

	/**
	*设置X轴坐标。
	*@param value X轴坐标。
	*/
	/**
	*获取X轴坐标。
	*@return X轴坐标。
	*/
	__getset(0,__proto,'x',function(){
		return this.elements[0];
		},function(value){
		this.elements[0]=value;
	});

	/**
	*设置Y轴坐标。
	*@param value Y轴坐标。
	*/
	/**
	*获取Y轴坐标。
	*@return Y轴坐标。
	*/
	__getset(0,__proto,'y',function(){
		return this.elements[1];
		},function(value){
		this.elements[1]=value;
	});

	/**
	*设置Z轴坐标。
	*@param value Z轴坐标。
	*/
	/**
	*获取Z轴坐标。
	*@return Z轴坐标。
	*/
	__getset(0,__proto,'z',function(){
		return this.elements[2];
		},function(value){
		this.elements[2]=value;
	});

	/**
	*设置W轴坐标。
	*@param value W轴坐标。
	*/
	/**
	*获取W轴坐标。
	*@return W轴坐标。
	*/
	__getset(0,__proto,'w',function(){
		return this.elements[3];
		},function(value){
		this.elements[3]=value;
	});

	Vector4.lerp=function(a,b,t,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements;
		var ax=f[0],ay=f[1],az=f[2],aw=f[3];
		e[0]=ax+t *(g[0]-ax);
		e[1]=ay+t *(g[1]-ay);
		e[2]=az+t *(g[2]-az);
		e[3]=aw+t *(g[3]-aw);
	}

	Vector4.transformByM4x4=function(vector4,m4x4,out){
		var ve=vector4.elements;
		var vx=ve[0];
		var vy=ve[1];
		var vz=ve[2];
		var vw=ve[3];
		var me=m4x4.elements;
		var oe=out.elements;
		oe[0]=vx *me[0]+vy *me[4]+vz *me[8]+vw *me[12];
		oe[1]=vx *me[1]+vy *me[5]+vz *me[9]+vw *me[13];
		oe[2]=vx *me[2]+vy *me[6]+vz *me[10]+vw *me[14];
		oe[3]=vx *me[3]+vy *me[7]+vz *me[11]+vw *me[15];
	}

	Vector4.equals=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		return MathUtils3D.nearEqual(Math.abs(ae[0]),Math.abs(be[0]))&& MathUtils3D.nearEqual(Math.abs(ae[1]),Math.abs(be[1]))&& MathUtils3D.nearEqual(Math.abs(ae[2]),Math.abs(be[2]))&& MathUtils3D.nearEqual(Math.abs(ae[3]),Math.abs(be[3]));
	}

	Vector4.normalize=function(s,out){
		var se=s.elements;
		var oe=out.elements;
		var len=/*if err,please use iflash.method.xmlLength()*/s.length();
		if (len > 0){
			oe[0]=se[0] *len;
			oe[1]=se[1] *len;
			oe[2]=se[2] *len;
			oe[3]=se[3] *len;
		}
	}

	Vector4.add=function(a,b,out){
		var oe=out.elements;
		var ae=a.elements;
		var be=b.elements;
		oe[0]=ae[0]+be[0];
		oe[1]=ae[1]+be[1];
		oe[2]=ae[2]+be[2];
		oe[3]=ae[3]+be[3];
	}

	Vector4.subtract=function(a,b,out){
		var oe=out.elements;
		var ae=a.elements;
		var be=b.elements;
		oe[0]=ae[0]-be[0];
		oe[1]=ae[1]-be[1];
		oe[2]=ae[2]-be[2];
		oe[3]=ae[3]-be[3];
	}

	Vector4.multiply=function(a,b,out){
		var oe=out.elements;
		var ae=a.elements;
		var be=b.elements;
		oe[0]=ae[0] *be[0];
		oe[1]=ae[1] *be[1];
		oe[2]=ae[2] *be[2];
		oe[3]=ae[3] *be[3];
	}

	Vector4.scale=function(a,b,out){
		var oe=out.elements;
		var ae=a.elements;
		oe[0]=ae[0] *b;
		oe[1]=ae[1] *b;
		oe[2]=ae[2] *b;
		oe[3]=ae[3] *b;
	}

	Vector4.Clamp=function(value,min,max,out){
		var valuee=value.elements;
		var x=valuee[0];
		var y=valuee[1];
		var z=valuee[2];
		var w=valuee[3];
		var mine=min.elements;
		var mineX=mine[0];
		var mineY=mine[1];
		var mineZ=mine[2];
		var mineW=mine[3];
		var maxe=max.elements;
		var maxeX=maxe[0];
		var maxeY=maxe[1];
		var maxeZ=maxe[2];
		var maxeW=maxe[3];
		var oute=out.elements;
		x=(x > maxeX)? maxeX :x;
		x=(x < mineX)? mineX :x;
		y=(y > maxeY)? maxeY :y;
		y=(y < mineY)? mineY :y;
		z=(z > maxeZ)? maxeZ :z;
		z=(z < mineZ)? mineZ :z;
		w=(w > maxeW)? maxeW :w;
		w=(w < mineW)? mineW :w;
		oute[0]=x;
		oute[1]=y;
		oute[2]=z;
		oute[3]=w;
	}

	Vector4.distanceSquared=function(value1,value2){
		var value1e=value1.elements;
		var value2e=value2.elements;
		var x=value1e[0]-value2e[0];
		var y=value1e[1]-value2e[1];
		var z=value1e[2]-value2e[2];
		var w=value1e[3]-value2e[3];
		return (x *x)+(y *y)+(z *z)+(w *w);
	}

	Vector4.distance=function(value1,value2){
		var value1e=value1.elements;
		var value2e=value2.elements;
		var x=value1e[0]-value2e[0];
		var y=value1e[1]-value2e[1];
		var z=value1e[2]-value2e[2];
		var w=value1e[3]-value2e[3];
		return Math.sqrt((x *x)+(y *y)+(z *z)+(w *w));
	}

	Vector4.dot=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2])+(ae[3] *be[3]);
		return r;
	}

	Vector4.min=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=Math.min(f[0],g[0]);
		e[1]=Math.min(f[1],g[1]);
		e[2]=Math.min(f[2],g[2]);
		e[3]=Math.min(f[3],g[3]);
	}

	Vector4.max=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=Math.max(f[0],g[0]);
		e[1]=Math.max(f[1],g[1]);
		e[2]=Math.max(f[2],g[2]);
		e[3]=Math.max(f[3],g[3]);
	}

	__static(Vector4,
	['ZERO',function(){return this.ZERO=new Vector4();},'ONE',function(){return this.ONE=new Vector4(1.0,1.0,1.0,1.0);},'UnitX',function(){return this.UnitX=new Vector4(1.0,0.0,0.0,0.0);},'UnitY',function(){return this.UnitY=new Vector4(0.0,1.0,0.0,0.0);},'UnitZ',function(){return this.UnitZ=new Vector4(0.0,0.0,1.0,0.0);},'UnitW',function(){return this.UnitW=new Vector4(0.0,0.0,0.0,1.0);}
	]);
	return Vector4;
})(BaseVector)


/**
*<code>Vector3</code> 类用于创建三维向量。
*/
//class laya.d3.math.Vector3 extends laya.d3.math.BaseVector
var Vector3=(function(_super){
	/**
	*创建一个 <code>Vector3</code> 实例。
	*@param x X轴坐标。
	*@param y Y轴坐标。
	*@param z Z轴坐标。
	*/
	function Vector3(x,y,z,nativeElements){
		Vector3.__super.call(this);
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		(z===void 0)&& (z=0);
		var v;
		if (nativeElements){
			v=nativeElements;
			}else {
			v=new Float32Array(3);
		}
		this.elements=v;
		v[0]=x;
		v[1]=y;
		v[2]=z;
	}

	__class(Vector3,'laya.d3.math.Vector3',_super);
	var __proto=Vector3.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*设置xyz值。
	*@param x X值。
	*@param y Y值。
	*@param z Z值。
	*/
	__proto.setValue=function(x,y,z){
		this.elements[0]=x;
		this.elements[1]=y;
		this.elements[2]=z;
	}

	/**
	*从Array数组拷贝值。
	*@param array 数组。
	*@param offset 数组偏移。
	*/
	__proto.fromArray=function(array,offset){
		(offset===void 0)&& (offset=0);
		this.elements[0]=array[offset+0];
		this.elements[1]=array[offset+1];
		this.elements[2]=array[offset+2];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destVector3=destObject;
		var destE=destVector3.elements;
		var s=this.elements;
		destE[0]=s[0];
		destE[1]=s[1];
		destE[2]=s[2];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destVector3=/*__JS__ */new this.constructor();
		this.cloneTo(destVector3);
		return destVector3;
	}

	__proto.toDefault=function(){
		this.elements[0]=0;
		this.elements[1]=0;
		this.elements[2]=0;
	}

	/**
	*设置X轴坐标。
	*@param value X轴坐标。
	*/
	/**
	*获取X轴坐标。
	*@return X轴坐标。
	*/
	__getset(0,__proto,'x',function(){
		return this.elements[0];
		},function(value){
		this.elements[0]=value;
	});

	/**
	*设置Y轴坐标。
	*@param value Y轴坐标。
	*/
	/**
	*获取Y轴坐标。
	*@return Y轴坐标。
	*/
	__getset(0,__proto,'y',function(){
		return this.elements[1];
		},function(value){
		this.elements[1]=value;
	});

	/**
	*设置Z轴坐标。
	*@param value Z轴坐标。
	*/
	/**
	*获取Z轴坐标。
	*@return Z轴坐标。
	*/
	__getset(0,__proto,'z',function(){
		return this.elements[2];
		},function(value){
		this.elements[2]=value;
	});

	Vector3.distanceSquared=function(value1,value2){
		var value1e=value1.elements;
		var value2e=value2.elements;
		var x=value1e[0]-value2e[0];
		var y=value1e[1]-value2e[1];
		var z=value1e[2]-value2e[2];
		return (x *x)+(y *y)+(z *z);
	}

	Vector3.distance=function(value1,value2){
		var value1e=value1.elements;
		var value2e=value2.elements;
		var x=value1e[0]-value2e[0];
		var y=value1e[1]-value2e[1];
		var z=value1e[2]-value2e[2];
		return Math.sqrt((x *x)+(y *y)+(z *z));
	}

	Vector3.min=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=Math.min(f[0],g[0]);
		e[1]=Math.min(f[1],g[1]);
		e[2]=Math.min(f[2],g[2]);
	}

	Vector3.max=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=Math.max(f[0],g[0]);
		e[1]=Math.max(f[1],g[1]);
		e[2]=Math.max(f[2],g[2]);
	}

	Vector3.transformQuat=function(source,rotation,out){
		var destination=out.elements;
		var se=source.elements;
		var re=rotation.elements;
		var x=se[0],y=se[1],z=se[2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
		ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
		destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
		destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
		destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
	}

	Vector3.scalarLength=function(a){
		var f=a.elements;
		var x=f[0],y=f[1],z=f[2];
		return Math.sqrt(x *x+y *y+z *z);
	}

	Vector3.scalarLengthSquared=function(a){
		var f=a.elements;
		var x=f[0],y=f[1],z=f[2];
		return x *x+y *y+z *z;
	}

	Vector3.normalize=function(s,out){
		var se=s.elements;
		var oe=out.elements;
		var x=se[0],y=se[1],z=se[2];
		var len=x *x+y *y+z *z;
		if (len > 0){
			len=1 / Math.sqrt(len);
			oe[0]=se[0] *len;
			oe[1]=se[1] *len;
			oe[2]=se[2] *len;
		}
	}

	Vector3.multiply=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=f[0] *g[0];
		e[1]=f[1] *g[1];
		e[2]=f[2] *g[2];
	}

	Vector3.scale=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		e[0]=f[0] *b;
		e[1]=f[1] *b;
		e[2]=f[2] *b;
	}

	Vector3.lerp=function(a,b,t,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements;
		var ax=f[0],ay=f[1],az=f[2];
		e[0]=ax+t *(g[0]-ax);
		e[1]=ay+t *(g[1]-ay);
		e[2]=az+t *(g[2]-az);
	}

	Vector3.transformV3ToV3=function(vector,transform,result){
		var intermediate=Vector3._tempVector4;
		Vector3.transformV3ToV4(vector,transform,intermediate);
		var intermediateElem=intermediate.elements;
		var resultElem=result.elements;
		resultElem[0]=intermediateElem[0];
		resultElem[1]=intermediateElem[1];
		resultElem[2]=intermediateElem[2];
	}

	Vector3.transformV3ToV4=function(vector,transform,result){
		var vectorElem=vector.elements;
		var vectorX=vectorElem[0];
		var vectorY=vectorElem[1];
		var vectorZ=vectorElem[2];
		var transformElem=transform.elements;
		var resultElem=result.elements;
		resultElem[0]=(vectorX *transformElem[0])+(vectorY *transformElem[4])+(vectorZ *transformElem[8])+transformElem[12];
		resultElem[1]=(vectorX *transformElem[1])+(vectorY *transformElem[5])+(vectorZ *transformElem[9])+transformElem[13];
		resultElem[2]=(vectorX *transformElem[2])+(vectorY *transformElem[6])+(vectorZ *transformElem[10])+transformElem[14];
		resultElem[3]=(vectorX *transformElem[3])+(vectorY *transformElem[7])+(vectorZ *transformElem[11])+transformElem[15];
	}

	Vector3.TransformNormal=function(normal,transform,result){
		var normalElem=normal.elements;
		var normalX=normalElem[0];
		var normalY=normalElem[1];
		var normalZ=normalElem[2];
		var transformElem=transform.elements;
		var resultElem=result.elements;
		resultElem[0]=(normalX *transformElem[0])+(normalY *transformElem[4])+(normalZ *transformElem[8]);
		resultElem[1]=(normalX *transformElem[1])+(normalY *transformElem[5])+(normalZ *transformElem[9]);
		resultElem[2]=(normalX *transformElem[2])+(normalY *transformElem[6])+(normalZ *transformElem[10]);
	}

	Vector3.transformCoordinate=function(coordinate,transform,result){
		var coordinateElem=coordinate.elements;
		var coordinateX=coordinateElem[0];
		var coordinateY=coordinateElem[1];
		var coordinateZ=coordinateElem[2];
		var transformElem=transform.elements;
		var w=((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
		var resultElem=result.elements;
		resultElem[0]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12] / w;
		resultElem[1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13] / w;
		resultElem[2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14] / w;
	}

	Vector3.Clamp=function(value,min,max,out){
		var valuee=value.elements;
		var x=valuee[0];
		var y=valuee[1];
		var z=valuee[2];
		var mine=min.elements;
		var mineX=mine[0];
		var mineY=mine[1];
		var mineZ=mine[2];
		var maxe=max.elements;
		var maxeX=maxe[0];
		var maxeY=maxe[1];
		var maxeZ=maxe[2];
		var oute=out.elements;
		x=(x > maxeX)? maxeX :x;
		x=(x < mineX)? mineX :x;
		y=(y > maxeY)? maxeY :y;
		y=(y < mineY)? mineY :y;
		z=(z > maxeZ)? maxeZ :z;
		z=(z < mineZ)? mineZ :z;
		oute[0]=x;
		oute[1]=y;
		oute[2]=z;
	}

	Vector3.add=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		var g=b.elements
		e[0]=f[0]+g[0];
		e[1]=f[1]+g[1];
		e[2]=f[2]+g[2];
	}

	Vector3.subtract=function(a,b,o){
		var oe=o.elements;
		var ae=a.elements;
		var be=b.elements;
		oe[0]=ae[0]-be[0];
		oe[1]=ae[1]-be[1];
		oe[2]=ae[2]-be[2];
	}

	Vector3.cross=function(a,b,o){
		var ae=a.elements;
		var be=b.elements;
		var oe=o.elements;
		var ax=ae[0],ay=ae[1],az=ae[2],bx=be[0],by=be[1],bz=be[2];
		oe[0]=ay *bz-az *by;
		oe[1]=az *bx-ax *bz;
		oe[2]=ax *by-ay *bx;
	}

	Vector3.dot=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2]);
		return r;
	}

	Vector3.equals=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		return MathUtils3D.nearEqual(ae[0],be[0])&& MathUtils3D.nearEqual(ae[1],be[1])&& MathUtils3D.nearEqual(ae[2],be[2]);
	}

	Vector3.ZERO=new Vector3(0.0,0.0,0.0);
	Vector3.ONE=new Vector3(1.0,1.0,1.0);
	Vector3.NegativeUnitX=new Vector3(-1,0,0);
	Vector3.UnitX=new Vector3(1,0,0);
	Vector3.UnitY=new Vector3(0,1,0);
	Vector3.UnitZ=new Vector3(0,0,1);
	Vector3.ForwardRH=new Vector3(0,0,-1);
	Vector3.ForwardLH=new Vector3(0,0,1);
	Vector3.Up=new Vector3(0,1,0);
	Vector3.NAN=new Vector3(NaN,NaN,NaN);
	__static(Vector3,
	['_tempVector4',function(){return this._tempVector4=new Vector4();}
	]);
	return Vector3;
})(BaseVector)


/**
*<code>Vector2</code> 类用于创建二维向量。
*/
//class laya.d3.math.Vector2 extends laya.d3.math.BaseVector
var Vector2=(function(_super){
	/**
	*创建一个 <code>Vector2</code> 实例。
	*@param x X轴坐标。
	*@param y Y轴坐标。
	*/
	function Vector2(x,y){
		Vector2.__super.call(this);
		(x===void 0)&& (x=0);
		(y===void 0)&& (y=0);
		var v=this.elements=new Float32Array(2);
		v[0]=x;
		v[1]=y;
	}

	__class(Vector2,'laya.d3.math.Vector2',_super);
	var __proto=Vector2.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*从Array数组拷贝值。
	*@param array 数组。
	*@param offset 数组偏移。
	*/
	__proto.fromArray=function(array,offset){
		(offset===void 0)&& (offset=0);
		this.elements[0]=array[offset+0];
		this.elements[1]=array[offset+1];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destVector2=destObject;
		var destE=destVector2.elements;
		var s=this.elements;
		destE[0]=s[0];
		destE[1]=s[1];
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destVector2=/*__JS__ */new this.constructor();
		this.cloneTo(destVector2);
		return destVector2;
	}

	/**
	*设置X轴坐标。
	*@param value X轴坐标。
	*/
	/**
	*获取X轴坐标。
	*@return X轴坐标。
	*/
	__getset(0,__proto,'x',function(){
		return this.elements[0];
		},function(value){
		this.elements[0]=value;
	});

	/**
	*设置Y轴坐标。
	*@param value Y轴坐标。
	*/
	/**
	*获取Y轴坐标。
	*@return Y轴坐标。
	*/
	__getset(0,__proto,'y',function(){
		return this.elements[1];
		},function(value){
		this.elements[1]=value;
	});

	Vector2.scale=function(a,b,out){
		var e=out.elements;
		var f=a.elements;
		e[0]=f[0] *b;
		e[1]=f[1] *b;
	}

	Vector2.dot=function(a,b){
		var ae=a.elements;
		var be=b.elements;
		var r=(ae[0] *be[0])+(ae[1] *be[1]);
		return r;
	}

	Vector2.normalize=function(s,out){
		var se=s.elements;
		var oe=out.elements;
		var x=se[0],y=se[1];
		var len=x *x+y *y;
		if (len > 0){
			len=1 / Math.sqrt(len);
			oe[0]=se[0] *len;
			oe[1]=se[1] *len;
		}
	}

	Vector2.scalarLength=function(a){
		var f=a.elements;
		var x=f[0],y=f[1];
		return Math.sqrt(x *x+y *y);
	}

	__static(Vector2,
	['ZERO',function(){return this.ZERO=new Vector2(0.0,0.0);},'ONE',function(){return this.ONE=new Vector2(1.0,1.0);}
	]);
	return Vector2;
})(BaseVector)


/**
*@private
*<code>MeshSprite3DStaticBatchManager</code> 类用于网格精灵静态批处理管理。
*/
//class laya.d3.graphics.MeshRenderStaticBatchManager extends laya.d3.graphics.StaticBatchManager
var MeshRenderStaticBatchManager=(function(_super){
	function MeshRenderStaticBatchManager(){
		/**@private [只读]*/
		//this._updateCountMark=0;
		this._opaqueBatchMarks=[];
		MeshRenderStaticBatchManager.__super.call(this);
		this._updateCountMark=0;
	}

	__class(MeshRenderStaticBatchManager,'laya.d3.graphics.MeshRenderStaticBatchManager',_super);
	var __proto=MeshRenderStaticBatchManager.prototype;
	/**
	*@inheritDoc
	*/
	__proto._compare=function(left,right){
		var lRender=left._render,rRender=right._render;
		var leftGeo=(left).meshFilter.sharedMesh,rightGeo=(right).meshFilter.sharedMesh;
		var lightOffset=lRender.lightmapIndex-rRender.lightmapIndex;
		if (lightOffset===0){
			var receiveShadowOffset=(lRender.receiveShadow ? 1 :0)-(rRender.receiveShadow ? 1 :0);
			if (receiveShadowOffset===0){
				var materialOffset=lRender.sharedMaterial.id-rRender.sharedMaterial.id;
				if (materialOffset===0){
					var verDec=leftGeo._vertexBuffers[0].vertexDeclaration.id-rightGeo._vertexBuffers[0].vertexDeclaration.id;
					if (verDec===0){
						return rightGeo._indexBuffer.indexCount-leftGeo._indexBuffer.indexCount;
						}else {
						return verDec;
					}
					}else {
					return materialOffset;
				}
				}else {
				return receiveShadowOffset;
			}
			}else {
			return lightOffset;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._getBatchRenderElementFromPool=function(){
		var renderElement=this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
		if (!renderElement){
			renderElement=new SubMeshRenderElement();
			this._batchRenderElementPool[this._batchRenderElementPoolIndex-1]=renderElement;
			renderElement.staticBatchElementList=[];
		}
		return renderElement;
	}

	/**
	*@private
	*/
	__proto._getStaticBatch=function(rootOwner,number){
		var key=rootOwner ? rootOwner.id :0;
		var batchOwner=this._staticBatches[key];
		(batchOwner)|| (batchOwner=this._staticBatches[key]=new MeshRenderStaticBatchOwner(rootOwner));
		var batches=batchOwner._batches;
		return (batches[number])|| (batches[number]=new SubMeshStaticBatch(batchOwner,number,MeshRenderStaticBatchManager._verDec));
	}

	/**
	*@inheritDoc
	*/
	__proto._initStaticBatchs=function(rootOwner){
		this._quickSort(this._initBatchSprites,0,this._initBatchSprites.length-1);
		var lastCanMerage=false;
		var curStaticBatch;
		var batchNumber=0;
		for (var i=0,n=this._initBatchSprites.length;i < n;i++){
			var sprite=this._initBatchSprites[i];
			if (lastCanMerage){
				if (curStaticBatch.addTest(sprite)){
					curStaticBatch.add(sprite);
					}else {
					lastCanMerage=false;
					batchNumber++;
				}
				}else {
				var lastIndex=n-1;
				if (i!==lastIndex){
					curStaticBatch=this._getStaticBatch(rootOwner,batchNumber);
					curStaticBatch.add(sprite);
					lastCanMerage=true;
				}
			}
		}
		for (var key in this._staticBatches){
			var batches=this._staticBatches[key]._batches;
			for (i=0,n=batches.length;i < n;i++)
			batches[i].finishInit();
		}
		this._initBatchSprites.length=0;
	}

	/**
	*@private
	*/
	__proto._destroyRenderSprite=function(sprite){
		var staticBatch=sprite._render._staticBatch;
		staticBatch.remove(sprite);
		if (staticBatch._batchElements.length===0){
			var owner=staticBatch.batchOwner._owner;
			var ownerID=owner ? owner.id :0;
			var batches=this._staticBatches[ownerID]._batches;
			batches.splice(staticBatch.number,1)
			if (batches.length===0)
				delete this._staticBatches[ownerID];
			staticBatch.dispose();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._clear=function(){
		_super.prototype._clear.call(this);
		this._updateCountMark++;
	}

	/**
	*@inheritDoc
	*/
	__proto._garbageCollection=function(){
		for (var key in this._staticBatches){
			var batches=this._staticBatches[key]._batches;
			for (var i=0,n=batches.length;i < n;i++){
				var staticBatch=batches[i];
				if (staticBatch._batchElements.length===0){
					staticBatch.dispose();
					batches.splice(i,1);
					i--,n--;
					if (n===0)
						delete this._staticBatches[key];
				}
			}
		}
	}

	__static(MeshRenderStaticBatchManager,
	['_verDec',function(){return this._verDec=VertexMesh.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");},'instance',function(){return this.instance=new MeshRenderStaticBatchManager();}
	]);
	return MeshRenderStaticBatchManager;
})(StaticBatchManager)


/**
*<code>ShurikenParticleSystem</code> 类用于创建3D粒子数据模板。
*/
//class laya.d3.core.particleShuriKen.ShurikenParticleSystem extends laya.d3.core.GeometryElement
var ShurikenParticleSystem=(function(_super){
	function ShurikenParticleSystem(owner){
		/**@private */
		//this._boundingSphere=null;
		/**@private */
		//this._boundingBox=null;
		/**@private */
		//this._boundingBoxCorners=null;
		/**@private */
		//this._owner=null;
		/**@private */
		//this._ownerRender=null;
		/**@private */
		//this._vertices=null;
		/**@private */
		//this._floatCountPerVertex=0;
		/**@private */
		//this._startLifeTimeIndex=0;
		/**@private */
		//this._timeIndex=0;
		/**@private */
		//this._simulateUpdate=false;
		/**@private */
		//this._firstActiveElement=0;
		/**@private */
		//this._firstNewElement=0;
		/**@private */
		//this._firstFreeElement=0;
		/**@private */
		//this._firstRetiredElement=0;
		/**@private */
		//this._drawCounter=0;
		/**@private */
		//this._bufferMaxParticles=0;
		/**@private */
		//this._emission=null;
		/**@private */
		//this._shape=null;
		/**@private */
		//this._isEmitting=false;
		/**@private */
		//this._isPlaying=false;
		/**@private */
		//this._isPaused=false;
		/**@private */
		//this._playStartDelay=NaN;
		/**@private 发射的累计时间。*/
		//this._frameRateTime=NaN;
		/**@private 一次循环内的累计时间。*/
		//this._emissionTime=NaN;
		/**@private */
		//this._totalDelayTime=NaN;
		/**@private */
		//this._burstsIndex=0;
		/**@private */
		//this._velocityOverLifetime=null;
		/**@private */
		//this._colorOverLifetime=null;
		/**@private */
		//this._sizeOverLifetime=null;
		/**@private */
		//this._rotationOverLifetime=null;
		/**@private */
		//this._textureSheetAnimation=null;
		/**@private */
		//this._startLifetimeType=0;
		/**@private */
		//this._startLifetimeConstant=NaN;
		/**@private */
		//this._startLifeTimeGradient=null;
		/**@private */
		//this._startLifetimeConstantMin=NaN;
		/**@private */
		//this._startLifetimeConstantMax=NaN;
		/**@private */
		//this._startLifeTimeGradientMin=null;
		/**@private */
		//this._startLifeTimeGradientMax=null;
		/**@private */
		//this._maxStartLifetime=NaN;
		/**@private */
		//this._vertexStride=0;
		/**@private */
		//this._indexStride=0;
		/**@private */
		//this._vertexBuffer=null;
		/**@private */
		//this._indexBuffer=null;
		/**@private */
		//this._currentTime=NaN;
		/**@private */
		//this._startUpdateLoopCount=0;
		/**@private */
		//this._rand=null;
		/**@private */
		//this._randomSeeds=null;
		/**粒子运行的总时长，单位为秒。*/
		//this.duration=NaN;
		/**是否循环。*/
		//this.looping=false;
		/**是否预热。暂不支持*/
		//this.prewarm=false;
		/**开始延迟类型，0为常量模式,1为随机随机双常量模式，不能和prewarm一起使用。*/
		//this.startDelayType=0;
		/**开始播放延迟，不能和prewarm一起使用。*/
		//this.startDelay=NaN;
		/**开始播放最小延迟，不能和prewarm一起使用。*/
		//this.startDelayMin=NaN;
		/**开始播放最大延迟，不能和prewarm一起使用。*/
		//this.startDelayMax=NaN;
		/**开始速度模式，0为恒定速度，2为两个恒定速度的随机插值。缺少1、3模式*/
		//this.startSpeedType=0;
		/**开始速度,0模式。*/
		//this.startSpeedConstant=NaN;
		/**最小开始速度,1模式。*/
		//this.startSpeedConstantMin=NaN;
		/**最大开始速度,1模式。*/
		//this.startSpeedConstantMax=NaN;
		/**开始尺寸是否为3D模式。*/
		//this.threeDStartSize=false;
		/**开始尺寸模式,0为恒定尺寸，2为两个恒定尺寸的随机插值。缺少1、3模式和对应的二种3D模式*/
		//this.startSizeType=0;
		/**开始尺寸，0模式。*/
		//this.startSizeConstant=NaN;
		/**开始三维尺寸，0模式。*/
		//this.startSizeConstantSeparate=null;
		/**最小开始尺寸，2模式。*/
		//this.startSizeConstantMin=NaN;
		/**最大开始尺寸，2模式。*/
		//this.startSizeConstantMax=NaN;
		/**最小三维开始尺寸，2模式。*/
		//this.startSizeConstantMinSeparate=null;
		/**最大三维开始尺寸，2模式。*/
		//this.startSizeConstantMaxSeparate=null;
		/**3D开始旋转，暂不支持*/
		//this.threeDStartRotation=false;
		/**开始旋转模式,0为恒定尺寸，2为两个恒定旋转的随机插值,缺少2种模式,和对应的四种3D模式。*/
		//this.startRotationType=0;
		/**开始旋转，0模式。*/
		//this.startRotationConstant=NaN;
		/**开始三维旋转，0模式。*/
		//this.startRotationConstantSeparate=null;
		/**最小开始旋转，1模式。*/
		//this.startRotationConstantMin=NaN;
		/**最大开始旋转，1模式。*/
		//this.startRotationConstantMax=NaN;
		/**最小开始三维旋转，1模式。*/
		//this.startRotationConstantMinSeparate=null;
		/**最大开始三维旋转，1模式。*/
		//this.startRotationConstantMaxSeparate=null;
		/**随机旋转方向，范围为0.0到1.0*/
		//this.randomizeRotationDirection=NaN;
		/**开始颜色模式，0为恒定颜色，2为两个恒定颜色的随机插值,缺少2种模式。*/
		//this.startColorType=0;
		/**开始颜色，0模式。*/
		//this.startColorConstant=null;
		/**最小开始颜色，1模式。*/
		//this.startColorConstantMin=null;
		/**最大开始颜色，1模式。*/
		//this.startColorConstantMax=null;
		/**重力敏感度。*/
		//this.gravityModifier=NaN;
		/**模拟器空间,0为World,1为Local。暂不支持Custom。*/
		//this.simulationSpace=0;
		/**缩放模式，0为Hiercachy,1为Local,2为World。*/
		//this.scaleMode=0;
		/**激活时是否自动播放。*/
		//this.playOnAwake=false;
		/**随机种子,注:play()前设置有效。*/
		//this.randomSeed=null;
		/**是否使用随机种子。 */
		//this.autoRandomSeed=false;
		/**是否为性能模式,性能模式下会延迟粒子释放。*/
		//this.isPerformanceMode=false;
		ShurikenParticleSystem.__super.call(this);
		this._tempRotationMatrix=new Matrix4x4();
		this._uvLength=new Vector2();
		this._bufferState=new BufferState();
		this._firstActiveElement=0;
		this._firstNewElement=0;
		this._firstFreeElement=0;
		this._firstRetiredElement=0;
		this._owner=owner;
		this._ownerRender=owner.particleRenderer;
		this._boundingBoxCorners=__newvec(8,null);
		this._boundingSphere=new BoundSphere(new Vector3(),Number.MAX_VALUE);
		this._boundingBox=new BoundBox(new Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),new Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE));
		this._currentTime=0;
		this._isEmitting=false;
		this._isPlaying=false;
		this._isPaused=false;
		this._burstsIndex=0;
		this._frameRateTime=0;
		this._emissionTime=0;
		this._totalDelayTime=0;
		this._simulateUpdate=false;
		this._bufferMaxParticles=1;
		this.duration=5.0;
		this.looping=true;
		this.prewarm=false;
		this.startDelayType=0;
		this.startDelay=0.0;
		this.startDelayMin=0.0;
		this.startDelayMax=0.0;
		this._startLifetimeType=0;
		this._startLifetimeConstant=5.0;
		this._startLifeTimeGradient=new GradientDataNumber();
		this._startLifetimeConstantMin=0.0;
		this._startLifetimeConstantMax=5.0;
		this._startLifeTimeGradientMin=new GradientDataNumber();
		this._startLifeTimeGradientMax=new GradientDataNumber();
		this._maxStartLifetime=5.0;
		this.startSpeedType=0;
		this.startSpeedConstant=5.0;
		this.startSpeedConstantMin=0.0;
		this.startSpeedConstantMax=5.0;
		this.threeDStartSize=false;
		this.startSizeType=0;
		this.startSizeConstant=1;
		this.startSizeConstantSeparate=new Vector3(1,1,1);
		this.startSizeConstantMin=0;
		this.startSizeConstantMax=1;
		this.startSizeConstantMinSeparate=new Vector3(0,0,0);
		this.startSizeConstantMaxSeparate=new Vector3(1,1,1);
		this.threeDStartRotation=false;
		this.startRotationType=0;
		this.startRotationConstant=0;
		this.startRotationConstantSeparate=new Vector3(0,0,0);
		this.startRotationConstantMin=0.0;
		this.startRotationConstantMax=0.0;
		this.startRotationConstantMinSeparate=new Vector3(0,0,0);
		this.startRotationConstantMaxSeparate=new Vector3(0,0,0);
		this.randomizeRotationDirection=0.0;
		this.startColorType=0;
		this.startColorConstant=new Vector4(1,1,1,1);
		this.startColorConstantMin=new Vector4(1,1,1,1);
		this.startColorConstantMax=new Vector4(1,1,1,1);
		this.gravityModifier=0.0;
		this.simulationSpace=1;
		this.scaleMode=0;
		this.playOnAwake=true;
		this._rand=new Rand(0);
		this.autoRandomSeed=true;
		this.randomSeed=new Uint32Array(1);
		this._randomSeeds=new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length);
		this.isPerformanceMode=true;
		this._emission=new Emission();
		this._emission.enbale=true;
	}

	__class(ShurikenParticleSystem,'laya.d3.core.particleShuriKen.ShurikenParticleSystem',_super);
	var __proto=ShurikenParticleSystem.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	__proto._getVertexBuffer=function(index){
		(index===void 0)&& (index=0);
		if (index===0)
			return this._vertexBuffer;
		else
		return null;
	}

	__proto._getIndexBuffer=function(){
		return this._indexBuffer;
	}

	/**
	*@private
	*/
	__proto._generateBoundingSphere=function(){
		var centerE=this._boundingSphere.center.elements;
		centerE[0]=0;
		centerE[1]=0;
		centerE[2]=0;
		this._boundingSphere.radius=Number.MAX_VALUE;
	}

	/**
	*@private
	*/
	__proto._generateBoundingBox=function(){
		var particle=this._owner;
		var particleRender=particle.particleRenderer;
		var boundMin=this._boundingBox.min;
		var boundMax=this._boundingBox.max;
		var i=0,n=0;
		var maxStartLifeTime=NaN;
		switch (this.startLifetimeType){
			case 0:
				maxStartLifeTime=this.startLifetimeConstant;
				break ;
			case 1:
				maxStartLifeTime=-Number.MAX_VALUE;
				var startLifeTimeGradient=startLifeTimeGradient;
				for (i=0,n=startLifeTimeGradient.gradientCount;i < n;i++)
				maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradient.getValueByIndex(i));
				break ;
			case 2:
				maxStartLifeTime=Math.max(this.startLifetimeConstantMin,this.startLifetimeConstantMax);
				break ;
			case 3:
				maxStartLifeTime=-Number.MAX_VALUE;
				var startLifeTimeGradientMin=startLifeTimeGradientMin;
				for (i=0,n=startLifeTimeGradientMin.gradientCount;i < n;i++)
				maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradientMin.getValueByIndex(i));
				var startLifeTimeGradientMax=startLifeTimeGradientMax;
				for (i=0,n=startLifeTimeGradientMax.gradientCount;i < n;i++)
				maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradientMax.getValueByIndex(i));
				break ;
			};
		var minStartSpeed=NaN,maxStartSpeed=NaN;
		switch (this.startSpeedType){
			case 0:
				minStartSpeed=maxStartSpeed=this.startSpeedConstant;
				break ;
			case 1:
				break ;
			case 2:
				minStartSpeed=this.startLifetimeConstantMin;
				maxStartSpeed=this.startLifetimeConstantMax;
				break ;
			case 3:
				break ;
			};
		var minPosition,maxPosition,minDirection,maxDirection;
		if (this._shape && this._shape.enable){
			}else {
			minPosition=maxPosition=Vector3.ZERO;
			minDirection=Vector3.ZERO;
			maxDirection=Vector3.UnitZ;
		};
		var startMinVelocity=new Vector3(minDirection.x *minStartSpeed,minDirection.y *minStartSpeed,minDirection.z *minStartSpeed);
		var startMaxVelocity=new Vector3(maxDirection.x *maxStartSpeed,maxDirection.y *maxStartSpeed,maxDirection.z *maxStartSpeed);
		if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
			var lifeMinVelocity;
			var lifeMaxVelocity;
			var velocity=this._velocityOverLifetime.velocity;
			switch (velocity.type){
				case 0:
					lifeMinVelocity=lifeMaxVelocity=velocity.constant;
					break ;
				case 1:
					lifeMinVelocity=lifeMaxVelocity=new Vector3(velocity.gradientX.getAverageValue(),velocity.gradientY.getAverageValue(),velocity.gradientZ.getAverageValue());
					break ;
				case 2:
					lifeMinVelocity=velocity.constantMin;
					lifeMaxVelocity=velocity.constantMax;
					break ;
				case 3:
					lifeMinVelocity=new Vector3(velocity.gradientXMin.getAverageValue(),velocity.gradientYMin.getAverageValue(),velocity.gradientZMin.getAverageValue());
					lifeMaxVelocity=new Vector3(velocity.gradientXMax.getAverageValue(),velocity.gradientYMax.getAverageValue(),velocity.gradientZMax.getAverageValue());
					break ;
				}
		};
		var positionScale,velocityScale;
		var transform=this._owner.transform;
		var worldPosition=transform.position;
		var sizeScale=ShurikenParticleSystem._tempVector39;
		var sizeScaleE=sizeScale.elements;
		var renderMode=particleRender.renderMode;
		switch (this.scaleMode){
			case 0:;
				var scale=transform.scale;
				positionScale=scale;
				sizeScaleE[0]=scale.x;
				sizeScaleE[1]=scale.z;
				sizeScaleE[2]=scale.y;
				(renderMode===1)&& (velocityScale=scale);
				break ;
			case 1:;
				var localScale=transform.localScale;
				positionScale=localScale;
				sizeScaleE[0]=localScale.x;
				sizeScaleE[1]=localScale.z;
				sizeScaleE[2]=localScale.y;
				(renderMode===1)&& (velocityScale=localScale);
				break ;
			case 2:
				positionScale=transform.scale;
				sizeScaleE[0]=sizeScaleE[1]=sizeScaleE[2]=1;
				(renderMode===1)&& (velocityScale=Vector3.ONE);
				break ;
			};
		var minStratPosition,maxStratPosition;
		if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
			}else {
			minStratPosition=new Vector3(startMinVelocity.x *maxStartLifeTime,startMinVelocity.y *maxStartLifeTime,startMinVelocity.z *maxStartLifeTime);
			maxStratPosition=new Vector3(startMaxVelocity.x *maxStartLifeTime,startMaxVelocity.y *maxStartLifeTime,startMaxVelocity.z *maxStartLifeTime);
			if (this.scaleMode !=2){
				Vector3.add(minPosition,minStratPosition,boundMin);
				Vector3.multiply(positionScale,boundMin,boundMin);
				Vector3.add(maxPosition,maxStratPosition,boundMax);
				Vector3.multiply(positionScale,boundMax,boundMax);
				}else {
				Vector3.multiply(positionScale,minPosition,boundMin);
				Vector3.add(boundMin,minStratPosition,boundMin);
				Vector3.multiply(positionScale,maxPosition,boundMax);
				Vector3.add(boundMax,maxStratPosition,boundMax);
			}
		}
		switch (this.simulationSpace){
			case 0:
				break ;
			case 1:
				Vector3.add(boundMin,worldPosition,boundMin);
				Vector3.add(boundMax,worldPosition,boundMax);
				break ;
			};
		var maxSize=NaN,maxSizeY=NaN;
		switch (this.startSizeType){
			case 0:
				if (this.threeDStartSize){
					var startSizeConstantSeparate=startSizeConstantSeparate;
					maxSize=Math.max(startSizeConstantSeparate.x,startSizeConstantSeparate.y);
					if (renderMode===1)
						maxSizeY=startSizeConstantSeparate.y;
					}else {
					maxSize=this.startSizeConstant;
					if (renderMode===1)
						maxSizeY=this.startSizeConstant;
				}
				break ;
			case 1:
				break ;
			case 2:
				if (this.threeDStartSize){
					var startSizeConstantMaxSeparate=startSizeConstantMaxSeparate;
					maxSize=Math.max(startSizeConstantMaxSeparate.x,startSizeConstantMaxSeparate.y);
					if (renderMode===1)
						maxSizeY=startSizeConstantMaxSeparate.y;
					}else {
					maxSize=this.startSizeConstantMax;
					if (renderMode===1)
						maxSizeY=this.startSizeConstantMax;
				}
				break ;
			case 3:
				break ;
			}
		if (this._sizeOverLifetime && this._sizeOverLifetime.enbale){
			var size=this._sizeOverLifetime.size;
			maxSize *=this._sizeOverLifetime.size.getMaxSizeInGradient();
		};
		var threeDMaxSize=ShurikenParticleSystem._tempVector30;
		var threeDMaxSizeE=threeDMaxSize.elements;
		var rotSize=NaN,nonRotSize=NaN;
		switch (renderMode){
			case 0:
				rotSize=maxSize *ShurikenParticleSystem.halfKSqrtOf2;
				Vector3.scale(sizeScale,maxSize,threeDMaxSize);
				Vector3.subtract(boundMin,threeDMaxSize,boundMin);
				Vector3.add(boundMax,threeDMaxSize,boundMax);
				break ;
			case 1:;
				var maxStretchPosition=ShurikenParticleSystem._tempVector31;
				var maxStretchVelocity=ShurikenParticleSystem._tempVector32;
				var minStretchVelocity=ShurikenParticleSystem._tempVector33;
				var minStretchPosition=ShurikenParticleSystem._tempVector34;
				if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
					}else {
					Vector3.multiply(velocityScale,startMaxVelocity,maxStretchVelocity);
					Vector3.multiply(velocityScale,startMinVelocity,minStretchVelocity);
				};
				var sizeStretch=maxSizeY *particleRender.stretchedBillboardLengthScale;
				var maxStretchLength=Vector3.scalarLength(maxStretchVelocity)*particleRender.stretchedBillboardSpeedScale+sizeStretch;
				var minStretchLength=Vector3.scalarLength(minStretchVelocity)*particleRender.stretchedBillboardSpeedScale+sizeStretch;
				var norMaxStretchVelocity=ShurikenParticleSystem._tempVector35;
				var norMinStretchVelocity=ShurikenParticleSystem._tempVector36;
				Vector3.normalize(maxStretchVelocity,norMaxStretchVelocity);
				Vector3.scale(norMaxStretchVelocity,maxStretchLength,minStretchPosition);
				Vector3.subtract(maxStratPosition,minStretchPosition,minStretchPosition);
				Vector3.normalize(minStretchVelocity,norMinStretchVelocity);
				Vector3.scale(norMinStretchVelocity,minStretchLength,maxStretchPosition);
				Vector3.add(minStratPosition,maxStretchPosition,maxStretchPosition);
				rotSize=maxSize *ShurikenParticleSystem.halfKSqrtOf2;
				Vector3.scale(sizeScale,rotSize,threeDMaxSize);
				var halfNorMaxStretchVelocity=ShurikenParticleSystem._tempVector37;
				var halfNorMinStretchVelocity=ShurikenParticleSystem._tempVector38;
				Vector3.scale(norMaxStretchVelocity,0.5,halfNorMaxStretchVelocity);
				Vector3.scale(norMinStretchVelocity,0.5,halfNorMinStretchVelocity);
				Vector3.multiply(halfNorMaxStretchVelocity,sizeScale,halfNorMaxStretchVelocity);
				Vector3.multiply(halfNorMinStretchVelocity,sizeScale,halfNorMinStretchVelocity);
				Vector3.add(boundMin,halfNorMinStretchVelocity,boundMin);
				Vector3.min(boundMin,minStretchPosition,boundMin);
				Vector3.subtract(boundMin,threeDMaxSize,boundMin);
				Vector3.subtract(boundMax,halfNorMaxStretchVelocity,boundMax);
				Vector3.max(boundMax,maxStretchPosition,boundMax);
				Vector3.add(boundMax,threeDMaxSize,boundMax);
				break ;
			case 2:
				maxSize *=Math.cos(0.78539816339744830961566084581988);
				nonRotSize=maxSize *0.5;
				threeDMaxSizeE[0]=sizeScale.x *nonRotSize;
				threeDMaxSizeE[1]=sizeScale.z *nonRotSize;
				Vector3.subtract(boundMin,threeDMaxSize,boundMin);
				Vector3.add(boundMax,threeDMaxSize,boundMax);
				break ;
			case 3:
				maxSize *=Math.cos(0.78539816339744830961566084581988);
				nonRotSize=maxSize *0.5;
				Vector3.scale(sizeScale,nonRotSize,threeDMaxSize);
				Vector3.subtract(boundMin,threeDMaxSize,boundMin);
				Vector3.add(boundMax,threeDMaxSize,boundMax);
				break ;
			}
		this._boundingBox.getCorners(this._boundingBoxCorners);
	}

	/**
	*@private
	*/
	__proto._updateEmission=function(){
		if (!this.isAlive)
			return;
		if (this._simulateUpdate){
			this._simulateUpdate=false;
		}
		else{
			var elapsedTime=(this._startUpdateLoopCount!==Stat.loopCount && !this._isPaused)?(this._owner._scene).timer._delta / 1000.0:0;
			elapsedTime=Math.min(ShurikenParticleSystem._maxElapsedTime,elapsedTime);
			this._updateParticles(elapsedTime);
		}
	}

	/**
	*@private
	*/
	__proto._updateParticles=function(elapsedTime){
		if (this._ownerRender.renderMode===4 && !this._ownerRender.mesh)
			return;
		this._currentTime+=elapsedTime;
		this._retireActiveParticles();
		this._freeRetiredParticles();
		this._totalDelayTime+=elapsedTime;
		if (this._totalDelayTime < this._playStartDelay){
			return;
		}
		if (this._emission.enbale&&this._isEmitting &&!this._isPaused)
			this._advanceTime(elapsedTime,this._currentTime);
	}

	/**
	*@private
	*/
	__proto._updateParticlesSimulationRestart=function(time){
		this._firstActiveElement=0;
		this._firstNewElement=0;
		this._firstFreeElement=0;
		this._firstRetiredElement=0;
		this._burstsIndex=0;
		this._frameRateTime=time;
		this._emissionTime=0;
		this._totalDelayTime=0;
		this._currentTime=time;
		var delayTime=time;
		if (delayTime < this._playStartDelay){
			this._totalDelayTime=delayTime;
			return;
		}
		if (this._emission.enbale)
			this._advanceTime(time,time);
	}

	/**
	*@private
	*/
	__proto._retireActiveParticles=function(){
		var epsilon=0.0001;
		while (this._firstActiveElement !=this._firstNewElement){
			var index=this._firstActiveElement *this._floatCountPerVertex *this._vertexStride;
			var timeIndex=index+this._timeIndex;
			var particleAge=this._currentTime-this._vertices[timeIndex];
			if (particleAge+epsilon < this._vertices[index+this._startLifeTimeIndex])
				break ;
			this._vertices[timeIndex]=this._drawCounter;
			this._firstActiveElement++;
			if (this._firstActiveElement >=this._bufferMaxParticles)
				this._firstActiveElement=0;
		}
	}

	/**
	*@private
	*/
	__proto._freeRetiredParticles=function(){
		while (this._firstRetiredElement !=this._firstActiveElement){
			var age=this._drawCounter-this._vertices[this._firstRetiredElement *this._floatCountPerVertex *this._vertexStride+this._timeIndex];
			if (this.isPerformanceMode)
				if (age < 3)
			break ;
			this._firstRetiredElement++;
			if (this._firstRetiredElement >=this._bufferMaxParticles)
				this._firstRetiredElement=0;
		}
	}

	/**
	*@private
	*/
	__proto._burst=function(fromTime,toTime){
		var totalEmitCount=0;
		var bursts=this._emission._bursts;
		for (var n=bursts.length;this._burstsIndex < n;this._burstsIndex++){
			var burst=bursts[this._burstsIndex];
			var burstTime=burst.time;
			if (fromTime<=burstTime && burstTime < toTime){
				var emitCount=0;
				if (this.autoRandomSeed){
					emitCount=MathUtil.lerp(burst.minCount,burst.maxCount,Math.random());
					}else {
					this._rand.seed=this._randomSeeds[0];
					emitCount=MathUtil.lerp(burst.minCount,burst.maxCount,this._rand.getFloat());
					this._randomSeeds[0]=this._rand.seed;
				}
				totalEmitCount+=emitCount;
				}else {
				break ;
			}
		}
		return totalEmitCount;
	}

	/**
	*@private
	*/
	__proto._advanceTime=function(elapsedTime,emitTime){
		var i=0;
		var lastEmissionTime=this._emissionTime;
		this._emissionTime+=elapsedTime;
		var totalEmitCount=0;
		if (this._emissionTime > this.duration){
			if (this.looping){
				totalEmitCount+=this._burst(lastEmissionTime,this._emissionTime);
				this._emissionTime-=this.duration;
				this._burstsIndex=0;
				totalEmitCount+=this._burst(0,this._emissionTime);
				}else {
				totalEmitCount=Math.min(this.maxParticles-this.aliveParticleCount,totalEmitCount);
				for (i=0;i < totalEmitCount;i++)
				this.emit(emitTime);
				this._isPlaying=false;
				this.stop();
				return;
			}
			}else {
			totalEmitCount+=this._burst(lastEmissionTime,this._emissionTime);
		}
		totalEmitCount=Math.min(this.maxParticles-this.aliveParticleCount,totalEmitCount);
		for (i=0;i < totalEmitCount;i++)
		this.emit(emitTime);
		var emissionRate=this.emission.emissionRate;
		if (emissionRate>0){
			var minEmissionTime=1/emissionRate;
			this._frameRateTime+=minEmissionTime;
			this._frameRateTime=this._currentTime-(this._currentTime-this._frameRateTime)% this._maxStartLifetime;
			while (this._frameRateTime <=emitTime){
				if (this.emit(this._frameRateTime))
					this._frameRateTime+=minEmissionTime;
				else
				break ;
			}
			this._frameRateTime=Math.floor(emitTime / minEmissionTime)*minEmissionTime;
		}
	}

	/**
	*@private
	*/
	__proto._initBufferDatas=function(){
		if (this._vertexBuffer){
			this._vertexBuffer.destroy();
			this._indexBuffer.destroy();
		};
		var render=this._ownerRender;
		var renderMode=render.renderMode;
		if (renderMode!==-1 && this.maxParticles > 0){
			var indices,i=0,j=0,m=0,indexOffset=0,perPartOffset=0,vertexDeclaration;;
			var vbMemorySize=0,memorySize=0;
			var mesh=render.mesh;
			if (renderMode===4){
				if(mesh){
					var vertexBufferCount=mesh._vertexBuffers.length;
					if (vertexBufferCount > 1){
						throw new Error("ShurikenParticleSystem: submesh Count mesh be One or all subMeshes have the same vertexDeclaration.");
						}else {
						vertexDeclaration=VertexShurikenParticleMesh.vertexDeclaration;
						this._floatCountPerVertex=vertexDeclaration.vertexStride/4;
						this._startLifeTimeIndex=12;
						this._timeIndex=16;
						this._vertexStride=mesh._vertexBuffers[0].vertexCount;
						var totalVertexCount=this._bufferMaxParticles *this._vertexStride;
						var vbCount=Math.floor(totalVertexCount / 65535)+1;
						var lastVBVertexCount=totalVertexCount % 65535;
						if (vbCount > 1){
							throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
						}
						vbMemorySize=vertexDeclaration.vertexStride *lastVBVertexCount;
						this._vertexBuffer=new VertexBuffer3D(vbMemorySize,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
						this._vertexBuffer.vertexDeclaration=vertexDeclaration;
						this._vertices=new Float32Array(this._floatCountPerVertex *lastVBVertexCount);
						this._indexStride=mesh._indexBuffer.indexCount;
						var indexDatas=mesh._indexBuffer.getData();
						var indexCount=this._bufferMaxParticles *this._indexStride;
						this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",indexCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
						indices=new Uint16Array(indexCount);
						memorySize=vbMemorySize+indexCount *2;
						indexOffset=0;
						for (i=0;i < this._bufferMaxParticles;i++){
							var indexValueOffset=i *this._vertexStride;
							for (j=0,m=indexDatas.length;j < m;j++)
							indices[indexOffset++]=indexValueOffset+indexDatas[j];
						}
						this._indexBuffer.setData(indices);
						this._bufferState.bind();
						this._bufferState.applyVertexBuffer(this._vertexBuffer);
						this._bufferState.applyIndexBuffer(this._indexBuffer);
						this._bufferState.unBind();
					}
				}
				}else {
				vertexDeclaration=VertexShurikenParticleBillboard.vertexDeclaration;
				this._floatCountPerVertex=vertexDeclaration.vertexStride/4;
				this._startLifeTimeIndex=7;
				this._timeIndex=11;
				this._vertexStride=4;
				vbMemorySize=vertexDeclaration.vertexStride *this._bufferMaxParticles *this._vertexStride;
				this._vertexBuffer=new VertexBuffer3D(vbMemorySize,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
				this._vertexBuffer.vertexDeclaration=vertexDeclaration;
				this._vertices=new Float32Array(this._floatCountPerVertex *this._bufferMaxParticles *this._vertexStride);
				for (i=0;i < this._bufferMaxParticles;i++){
					perPartOffset=i *this._floatCountPerVertex *this._vertexStride;
					this._vertices[perPartOffset]=-0.5;
					this._vertices[perPartOffset+1]=-0.5;
					this._vertices[perPartOffset+2]=0;
					this._vertices[perPartOffset+3]=1;
					perPartOffset+=this._floatCountPerVertex;
					this._vertices[perPartOffset]=0.5;
					this._vertices[perPartOffset+1]=-0.5;
					this._vertices[perPartOffset+2]=1;
					this._vertices[perPartOffset+3]=1;
					perPartOffset+=this._floatCountPerVertex
					this._vertices[perPartOffset]=0.5;
					this._vertices[perPartOffset+1]=0.5;
					this._vertices[perPartOffset+2]=1;
					this._vertices[perPartOffset+3]=0;
					perPartOffset+=this._floatCountPerVertex
					this._vertices[perPartOffset]=-0.5;
					this._vertices[perPartOffset+1]=0.5;
					this._vertices[perPartOffset+2]=0;
					this._vertices[perPartOffset+3]=0;
				}
				this._indexStride=6;
				this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._bufferMaxParticles *6,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
				indices=new Uint16Array(this._bufferMaxParticles *6);
				for (i=0;i < this._bufferMaxParticles;i++){
					indexOffset=i *6;
					var firstVertex=i *this._vertexStride,secondVertex=firstVertex+2;
					indices[indexOffset++]=firstVertex;
					indices[indexOffset++]=secondVertex;
					indices[indexOffset++]=firstVertex+1;
					indices[indexOffset++]=firstVertex;
					indices[indexOffset++]=firstVertex+3;
					indices[indexOffset++]=secondVertex;
				}
				this._indexBuffer.setData(indices);
				memorySize=vbMemorySize+this._bufferMaxParticles *6 *2;
				this._bufferState.bind();
				this._bufferState.applyVertexBuffer(this._vertexBuffer);
				this._bufferState.applyIndexBuffer(this._indexBuffer);
				this._bufferState.unBind();
			}
			Resource._addMemory(memorySize,memorySize);
		}
	}

	/**
	*@private
	*/
	__proto.destroy=function(){
		_super.prototype.destroy.call(this);
		var memorySize=this._vertexBuffer._byteLength+this._indexBuffer.indexCount *2;
		Resource._addMemory(-memorySize,-memorySize);
		this._bufferState.destroy();
		this._vertexBuffer.destroy();
		this._indexBuffer.destroy();
		this._emission.destroy();
		this._bufferState=null;
		this._vertexBuffer=null;
		this._indexBuffer=null;
		this._owner=null;
		this._vertices=null;
		this._indexBuffer=null;
		this._emission=null;
		this._shape=null;
		this.startLifeTimeGradient=null;
		this.startLifeTimeGradientMin=null;
		this.startLifeTimeGradientMax=null;
		this.startSizeConstantSeparate=null;
		this.startSizeConstantMinSeparate=null;
		this.startSizeConstantMaxSeparate=null;
		this.startRotationConstantSeparate=null;
		this.startRotationConstantMinSeparate=null;
		this.startRotationConstantMaxSeparate=null;
		this.startColorConstant=null;
		this.startColorConstantMin=null;
		this.startColorConstantMax=null;
		this._velocityOverLifetime=null;
		this._colorOverLifetime=null;
		this._sizeOverLifetime=null;
		this._rotationOverLifetime=null;
		this._textureSheetAnimation=null;
	}

	/**
	*发射一个粒子。
	*/
	__proto.emit=function(time){
		var position=ShurikenParticleSystem._tempPosition;
		var direction=ShurikenParticleSystem._tempDirection;
		if (this._shape&&this._shape.enable){
			if (this.autoRandomSeed)
				this._shape.generatePositionAndDirection(position,direction);
			else
			this._shape.generatePositionAndDirection(position,direction,this._rand,this._randomSeeds);
			}else {
			var positionE=position.elements;
			var directionE=direction.elements;
			positionE[0]=positionE[1]=positionE[2]=0;
			directionE[0]=directionE[1]=0;
			directionE[2]=1;
		}
		return this.addParticle(position,direction,time);
	}

	//TODO:提前判断优化
	__proto.addParticle=function(position,direction,time){
		Vector3.normalize(direction,direction);
		var nextFreeParticle=this._firstFreeElement+1;
		if (nextFreeParticle >=this._bufferMaxParticles)
			nextFreeParticle=0;
		if (nextFreeParticle===this._firstRetiredElement)
			return false;
		ShurikenParticleData.create(this,this._ownerRender,this._owner.transform);
		var particleAge=this._currentTime-time;
		if (particleAge >=ShurikenParticleData.startLifeTime)
			return true;
		var randomVelocityX=NaN,randomVelocityY=NaN,randomVelocityZ=NaN,randomColor=NaN,randomSize=NaN,randomRotation=NaN,randomTextureAnimation=NaN;
		var needRandomVelocity=this._velocityOverLifetime && this._velocityOverLifetime.enbale;
		if (needRandomVelocity){
			var velocityType=this._velocityOverLifetime.velocity.type;
			if (velocityType===2 || velocityType===3){
				if (this.autoRandomSeed){
					randomVelocityX=Math.random();
					randomVelocityY=Math.random();
					randomVelocityZ=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[9];
					randomVelocityX=this._rand.getFloat();
					randomVelocityY=this._rand.getFloat();
					randomVelocityZ=this._rand.getFloat();
					this._randomSeeds[9]=this._rand.seed;
				}
				}else {
				needRandomVelocity=false;
			}
			}else {
			needRandomVelocity=false;
		};
		var needRandomColor=this._colorOverLifetime && this._colorOverLifetime.enbale;
		if (needRandomColor){
			var colorType=this._colorOverLifetime.color.type;
			if (colorType===3){
				if (this.autoRandomSeed){
					randomColor=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[10];
					randomColor=this._rand.getFloat();
					this._randomSeeds[10]=this._rand.seed;
				}
				}else {
				needRandomColor=false;
			}
			}else {
			needRandomColor=false;
		};
		var needRandomSize=this._sizeOverLifetime && this._sizeOverLifetime.enbale;
		if (needRandomSize){
			var sizeType=this._sizeOverLifetime.size.type;
			if (sizeType===3){
				if (this.autoRandomSeed){
					randomSize=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[11];
					randomSize=this._rand.getFloat();
					this._randomSeeds[11]=this._rand.seed;
				}
				}else {
				needRandomSize=false;
			}
			}else {
			needRandomSize=false;
		};
		var needRandomRotation=this._rotationOverLifetime && this._rotationOverLifetime.enbale;
		if (needRandomRotation){
			var rotationType=this._rotationOverLifetime.angularVelocity.type;
			if (rotationType===2 || rotationType===3){
				if (this.autoRandomSeed){
					randomRotation=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[12];
					randomRotation=this._rand.getFloat();
					this._randomSeeds[12]=this._rand.seed;
				}
				}else {
				needRandomRotation=false;
			}
			}else {
			needRandomRotation=false;
		};
		var needRandomTextureAnimation=this._textureSheetAnimation && this._textureSheetAnimation.enable;
		if (needRandomTextureAnimation){
			var textureAnimationType=this._textureSheetAnimation.frame.type;
			if (textureAnimationType===3){
				if (this.autoRandomSeed){
					randomTextureAnimation=Math.random();
					}else {
					this._rand.seed=this._randomSeeds[15];
					randomTextureAnimation=this._rand.getFloat();
					this._randomSeeds[15]=this._rand.seed;
				}
				}else {
				needRandomTextureAnimation=false;
			}
			}else {
			needRandomTextureAnimation=false;
		};
		var startIndex=this._firstFreeElement *this._floatCountPerVertex *this._vertexStride;
		var subU=ShurikenParticleData.startUVInfo[0];
		var subV=ShurikenParticleData.startUVInfo[1];
		var startU=ShurikenParticleData.startUVInfo[2];
		var startV=ShurikenParticleData.startUVInfo[3];
		var positionE=position.elements;
		var directionE=direction.elements;
		var meshVertices,meshVertexStride=0,meshPosOffset=0,meshCorOffset=0,meshUVOffset=0,meshVertexIndex=0;
		var render=this._ownerRender;
		if (render.renderMode===4){
			var meshVB=render.mesh._vertexBuffers[0];
			meshVertices=meshVB.getData();
			var meshVertexDeclaration=meshVB.vertexDeclaration;
			meshPosOffset=meshVertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0).offset / 4;
			var colorElement=meshVertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_COLOR0*/1);
			meshCorOffset=colorElement?colorElement.offset / 4:-1;
			var uvElement=meshVertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.Vertex.VertexMesh.MESH_TEXTURECOORDINATE0*/2);
			meshUVOffset=uvElement?uvElement.offset / 4:-1;
			meshVertexStride=meshVertexDeclaration.vertexStride / 4;
			meshVertexIndex=0;
			}else {
			this._vertices[startIndex+2]=startU;
			this._vertices[startIndex+3]=startV+subV;
			var secondOffset=startIndex+this._floatCountPerVertex;
			this._vertices[secondOffset+2]=startU+subU;
			this._vertices[secondOffset+3]=startV+subV;
			var thirdOffset=secondOffset+this._floatCountPerVertex;
			this._vertices[thirdOffset+2]=startU+subU;
			this._vertices[thirdOffset+3]=startV;
			var fourthOffset=thirdOffset+this._floatCountPerVertex;
			this._vertices[fourthOffset+2]=startU;
			this._vertices[fourthOffset+3]=startV;
		}
		for (var i=startIndex,n=startIndex+this._floatCountPerVertex *this._vertexStride;i < n;i+=this._floatCountPerVertex){
			var offset=0;
			if (render.renderMode===4){
				offset=i;
				var vertexOffset=meshVertexStride *(meshVertexIndex++);
				var meshOffset=vertexOffset+meshPosOffset;
				this._vertices[offset++]=meshVertices[meshOffset++];
				this._vertices[offset++]=meshVertices[meshOffset++];
				this._vertices[offset++]=meshVertices[meshOffset];
				if (meshCorOffset===-1){
					this._vertices[offset++]=1.0;
					this._vertices[offset++]=1.0;
					this._vertices[offset++]=1.0;
					this._vertices[offset++]=1.0;
				}
				else{
					meshOffset=vertexOffset+meshCorOffset;
					this._vertices[offset++]=meshVertices[meshOffset++];
					this._vertices[offset++]=meshVertices[meshOffset++];
					this._vertices[offset++]=meshVertices[meshOffset++];
					this._vertices[offset++]=meshVertices[meshOffset];
				}
				if (meshUVOffset===-1){
					this._vertices[offset++]=0.0;
					this._vertices[offset++]=0.0;
				}
				else{
					meshOffset=vertexOffset+meshUVOffset;
					this._vertices[offset++]=startU+meshVertices[meshOffset++] *subU;
					this._vertices[offset++]=startV+meshVertices[meshOffset] *subV;
				}
				}else {
				offset=i+4;
			}
			this._vertices[offset++]=positionE[0];
			this._vertices[offset++]=positionE[1];
			this._vertices[offset++]=positionE[2];
			this._vertices[offset++]=ShurikenParticleData.startLifeTime;
			this._vertices[offset++]=directionE[0];
			this._vertices[offset++]=directionE[1];
			this._vertices[offset++]=directionE[2];
			this._vertices[offset++]=time;
			this._vertices[offset++]=ShurikenParticleData.startColor[0];
			this._vertices[offset++]=ShurikenParticleData.startColor[1];
			this._vertices[offset++]=ShurikenParticleData.startColor[2];
			this._vertices[offset++]=ShurikenParticleData.startColor[3];
			this._vertices[offset++]=ShurikenParticleData.startSize[0];
			this._vertices[offset++]=ShurikenParticleData.startSize[1];
			this._vertices[offset++]=ShurikenParticleData.startSize[2];
			this._vertices[offset++]=ShurikenParticleData.startRotation[0];
			this._vertices[offset++]=ShurikenParticleData.startRotation[1];
			this._vertices[offset++]=ShurikenParticleData.startRotation[2];
			this._vertices[offset++]=ShurikenParticleData.startSpeed;
			needRandomColor && (this._vertices[offset+1]=randomColor);
			needRandomSize && (this._vertices[offset+2]=randomSize);
			needRandomRotation && (this._vertices[offset+3]=randomRotation);
			needRandomTextureAnimation && (this._vertices[offset+4]=randomTextureAnimation);
			if (needRandomVelocity){
				this._vertices[offset+5]=randomVelocityX;
				this._vertices[offset+6]=randomVelocityY;
				this._vertices[offset+7]=randomVelocityZ;
			}
			switch(this.simulationSpace){
				case 0:
					offset+=8;
					this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[0];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[1];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldPostion[2];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[0];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[1];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[2];
					this._vertices[offset++]=ShurikenParticleData.simulationWorldRotation[3];
					break ;
				case 1:
					break ;
				default :
					throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
				}
		}
		this._firstFreeElement=nextFreeParticle;
		return true;
	}

	__proto.addNewParticlesToVertexBuffer=function(){
		var start=0;
		if (this._firstNewElement < this._firstFreeElement){
			start=this._firstNewElement *this._vertexStride *this._floatCountPerVertex;
			this._vertexBuffer.setData(this._vertices,start,start,(this._firstFreeElement-this._firstNewElement)*this._vertexStride *this._floatCountPerVertex);
			}else {
			start=this._firstNewElement *this._vertexStride *this._floatCountPerVertex;
			this._vertexBuffer.setData(this._vertices,start,start,(this._bufferMaxParticles-this._firstNewElement)*this._vertexStride *this._floatCountPerVertex);
			if (this._firstFreeElement > 0){
				this._vertexBuffer.setData(this._vertices,0,0,this._firstFreeElement *this._vertexStride *this._floatCountPerVertex);
			}
		}
		this._firstNewElement=this._firstFreeElement;
	}

	/**
	*@inheritDoc
	*/
	__proto._getType=function(){
		return ShurikenParticleSystem._type;
	}

	/**
	*@inheritDoc
	*/
	__proto._prepareRender=function(state){
		this._updateEmission();
		if (this._firstNewElement !=this._firstFreeElement)
			this.addNewParticlesToVertexBuffer();
		this._drawCounter++;
		if (this._firstActiveElement !=this._firstFreeElement)
			return true;
		else
		return false;
	}

	/**
	*@private
	*/
	__proto._render=function(state){
		this._bufferState.bind();
		var indexCount=0;
		var gl=LayaGL.instance;
		if (this._firstActiveElement < this._firstFreeElement){
			indexCount=(this._firstFreeElement-this._firstActiveElement)*this._indexStride;
			gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,2 *this._firstActiveElement *this._indexStride);
			Stat.trianglesFaces+=indexCount / 3;
			Stat.renderBatch++;
			}else {
			indexCount=(this._bufferMaxParticles-this._firstActiveElement)*this._indexStride;
			gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,2 *this._firstActiveElement *this._indexStride);
			Stat.trianglesFaces+=indexCount / 3;
			Stat.renderBatch++;
			if (this._firstFreeElement > 0){
				indexCount=this._firstFreeElement *this._indexStride;
				gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
				Stat.trianglesFaces+=indexCount / 3;
				Stat.renderBatch++;
			}
		}
	}

	/**
	*开始发射粒子。
	*/
	__proto.play=function(){
		this._burstsIndex=0;
		this._isEmitting=true;
		this._isPlaying=true;
		this._isPaused=false;
		this._emissionTime=0;
		this._totalDelayTime=0;
		if (!this.autoRandomSeed){
			for (var i=0,n=this._randomSeeds.length;i < n;i++)
			this._randomSeeds[i]=this.randomSeed[0]+ShurikenParticleSystem._RANDOMOFFSET[i];
		}
		switch (this.startDelayType){
			case 0:
				this._playStartDelay=this.startDelay;
				break ;
			case 1:
				if (this.autoRandomSeed){
					this._playStartDelay=MathUtil.lerp(this.startDelayMin,this.startDelayMax,Math.random());
					}else {
					this._rand.seed=this._randomSeeds[2];
					this._playStartDelay=MathUtil.lerp(this.startDelayMin,this.startDelayMax,this._rand.getFloat());
					this._randomSeeds[2]=this._rand.seed;
				}
				break ;
			default :
				throw new Error("Utils3D: startDelayType is invalid.");
			}
		this._frameRateTime=this._currentTime+this._playStartDelay;
		this._startUpdateLoopCount=Stat.loopCount;
	}

	/**
	*暂停发射粒子。
	*/
	__proto.pause=function(){
		this._isPaused=true;
	}

	/**
	*通过指定时间增加粒子播放进度，并暂停播放。
	*@param time 进度时间.如果restart为true,粒子播放时间会归零后再更新进度。
	*@param restart 是否重置播放状态。
	*/
	__proto.simulate=function(time,restart){
		(restart===void 0)&& (restart=true);
		this._simulateUpdate=true;
		if (restart){
			this._updateParticlesSimulationRestart(time);
		}
		else{
			this._isPaused=false;
			this._updateParticles(time);
		}
		this.pause();
	}

	/**
	*停止发射粒子。
	*/
	__proto.stop=function(){
		this._burstsIndex=0;
		this._isEmitting=false;
		this._emissionTime=0;
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var dest=destObject;
		dest.duration=this.duration;
		dest.looping=this.looping;
		dest.prewarm=this.prewarm;
		dest.startDelayType=this.startDelayType;
		dest.startDelay=this.startDelay;
		dest.startDelayMin=this.startDelayMin;
		dest.startDelayMax=this.startDelayMax;
		dest._maxStartLifetime=this._maxStartLifetime;
		dest.startLifetimeType=this.startLifetimeType;
		dest.startLifetimeConstant=this.startLifetimeConstant;
		this.startLifeTimeGradient.cloneTo(dest.startLifeTimeGradient);
		dest.startLifetimeConstantMin=this.startLifetimeConstantMin;
		dest.startLifetimeConstantMax=this.startLifetimeConstantMax;
		this.startLifeTimeGradientMin.cloneTo(dest.startLifeTimeGradientMin);
		this.startLifeTimeGradientMax.cloneTo(dest.startLifeTimeGradientMax);
		dest.startSpeedType=this.startSpeedType;
		dest.startSpeedConstant=this.startSpeedConstant;
		dest.startSpeedConstantMin=this.startSpeedConstantMin;
		dest.startSpeedConstantMax=this.startSpeedConstantMax;
		dest.threeDStartSize=this.threeDStartSize;
		dest.startSizeType=this.startSizeType;
		dest.startSizeConstant=this.startSizeConstant;
		this.startSizeConstantSeparate.cloneTo(dest.startSizeConstantSeparate);
		dest.startSizeConstantMin=this.startSizeConstantMin;
		dest.startSizeConstantMax=this.startSizeConstantMax;
		this.startSizeConstantMinSeparate.cloneTo(dest.startSizeConstantMinSeparate);
		this.startSizeConstantMaxSeparate.cloneTo(dest.startSizeConstantMaxSeparate);
		dest.threeDStartRotation=this.threeDStartRotation;
		dest.startRotationType=this.startRotationType;
		dest.startRotationConstant=this.startRotationConstant;
		this.startRotationConstantSeparate.cloneTo(dest.startRotationConstantSeparate);
		dest.startRotationConstantMin=this.startRotationConstantMin;
		dest.startRotationConstantMax=this.startRotationConstantMax;
		this.startRotationConstantMinSeparate.cloneTo(dest.startRotationConstantMinSeparate);
		this.startRotationConstantMaxSeparate.cloneTo(dest.startRotationConstantMaxSeparate);
		dest.randomizeRotationDirection=this.randomizeRotationDirection;
		dest.startColorType=this.startColorType;
		this.startColorConstant.cloneTo(dest.startColorConstant);
		this.startColorConstantMin.cloneTo(dest.startColorConstantMin);
		this.startColorConstantMax.cloneTo(dest.startColorConstantMax);
		dest.gravityModifier=this.gravityModifier;
		dest.simulationSpace=this.simulationSpace;
		dest.scaleMode=this.scaleMode;
		dest.playOnAwake=this.playOnAwake;
		dest.maxParticles=this.maxParticles;
		(this._emission)&& (dest._emission=this._emission.clone());
		(this.shape)&& (dest.shape=this.shape.clone());
		(this.velocityOverLifetime)&& (dest.velocityOverLifetime=this.velocityOverLifetime.clone());
		(this.colorOverLifetime)&& (dest.colorOverLifetime=this.colorOverLifetime.clone());
		(this.sizeOverLifetime)&& (dest.sizeOverLifetime=this.sizeOverLifetime.clone());
		(this.rotationOverLifetime)&& (dest.rotationOverLifetime=this.rotationOverLifetime.clone());
		(this.textureSheetAnimation)&& (dest.textureSheetAnimation=this.textureSheetAnimation.clone());
		dest.isPerformanceMode=this.isPerformanceMode;
		dest._isEmitting=this._isEmitting;
		dest._isPlaying=this._isPlaying;
		dest._isPaused=this._isPaused;
		dest._playStartDelay=this._playStartDelay;
		dest._frameRateTime=this._frameRateTime;
		dest._emissionTime=this._emissionTime;
		dest._totalDelayTime=this._totalDelayTime;
		dest._burstsIndex=this._burstsIndex;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**设置最大粒子数,注意:谨慎修改此属性，有性能损耗。*/
	/**获取最大粒子数。*/
	__getset(0,__proto,'maxParticles',function(){
		return this._bufferMaxParticles-1;
		},function(value){
		var newMaxParticles=value+1;
		if (newMaxParticles!==this._bufferMaxParticles){
			this._bufferMaxParticles=newMaxParticles;
			this._initBufferDatas();
		}
	});

	/**
	*是否正在发射。
	*/
	__getset(0,__proto,'isEmitting',function(){
		return this._isEmitting;
	});

	/**
	*是否存活。
	*/
	__getset(0,__proto,'isAlive',function(){
		if (this._isPlaying || this.aliveParticleCount > 0)
			return true;
		return false;
	});

	/**
	*设置形状。
	*/
	/**
	*获取形状。
	*/
	__getset(0,__proto,'shape',function(){
		return this._shape;
		},function(value){
		if (this._shape!==value){
			if (value&&value.enable)
				this._owner._render._defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_SHAPE);
			else
			this._owner._render._defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_SHAPE);
			this._shape=value;
		}
	});

	/**
	*设置生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期旋转。
	*/
	/**
	*获取生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期旋转。
	*/
	__getset(0,__proto,'rotationOverLifetime',function(){
		return this._rotationOverLifetime;
		},function(value){
		var defDat=this._owner._render._defineDatas;
		var shaDat=this._owner._render._shaderValues;
		if (value){
			var rotation=value.angularVelocity;
			if (!rotation)
				return;
			var rotationSeparate=rotation.separateAxes;
			var rotationType=rotation.type;
			if (value.enbale){
				if (rotationSeparate)
					defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
				else
				defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
				switch (rotationType){
					case 0:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
						break ;
					case 1:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
						break ;
					case 2:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
						break ;
					case 3:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
			}
			switch (rotationType){
				case 0:
					if (rotationSeparate){
						shaDat.setVector(ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE,rotation.constantSeparate);
						}else {
						shaDat.setNumber(ShuriKenParticle3D.ROLANGULARVELOCITYCONST,rotation.constant);
					}
					break ;
				case 1:
					if (rotationSeparate){
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX,rotation.gradientX._elements);
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY,rotation.gradientY._elements);
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ,rotation.gradientZ._elements);
						}else {
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT,rotation.gradient._elements);
					}
					break ;
				case 2:
					if (rotationSeparate){
						shaDat.setVector(ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE,rotation.constantMinSeparate);
						shaDat.setVector(ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE,rotation.constantMaxSeparate);
						}else {
						shaDat.setNumber(ShuriKenParticle3D.ROLANGULARVELOCITYCONST,rotation.constantMin);
						shaDat.setNumber(ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX,rotation.constantMax);
					}
					break ;
				case 3:
					if (rotationSeparate){
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX,rotation.gradientXMin._elements);
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX,rotation.gradientXMax._elements);
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY,rotation.gradientYMin._elements);
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX,rotation.gradientYMax._elements);
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ,rotation.gradientZMin._elements);
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX,rotation.gradientZMax._elements);
						}else {
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT,rotation.gradientMin._elements);
						shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX,rotation.gradientMax._elements);
					}
					break ;
				}
			}else {
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
			shaDat.setVector(ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE,null);
			shaDat.setVector(ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE,null);
			shaDat.setNumber(ShuriKenParticle3D.ROLANGULARVELOCITYCONST,undefined);
			shaDat.setNumber(ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX,undefined);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX,null);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY,null);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ,null);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTWMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT,null);
			shaDat.setBuffer(ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX,null);
		}
		this._rotationOverLifetime=value;
	});

	/**
	*获取发射器。
	*/
	__getset(0,__proto,'emission',function(){
		return this._emission;
	});

	/**
	*获取一次循环内的累计时间。
	*@return 一次循环内的累计时间。
	*/
	__getset(0,__proto,'emissionTime',function(){
		return this._emissionTime > this.duration ? this.duration :this._emissionTime;
	});

	/**
	*粒子存活个数。
	*/
	__getset(0,__proto,'aliveParticleCount',function(){
		if (this._firstNewElement >=this._firstRetiredElement)
			return this._firstNewElement-this._firstRetiredElement;
		else
		return this._bufferMaxParticles-this._firstRetiredElement+this._firstNewElement;
	});

	/**
	*是否正在播放。
	*/
	__getset(0,__proto,'isPlaying',function(){
		return this._isPlaying;
	});

	/**
	*是否已暂停。
	*/
	__getset(0,__proto,'isPaused',function(){
		return this._isPaused;
	});

	/**
	*设置开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
	*/
	/**
	*获取开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
	*/
	__getset(0,__proto,'startLifetimeType',function(){
		return this._startLifetimeType;
		},function(value){
		var i=0,n=0;
		switch (this.startLifetimeType){
			case 0:
				this._maxStartLifetime=this.startLifetimeConstant;
				break ;
			case 1:
				this._maxStartLifetime=-Number.MAX_VALUE;
				var startLifeTimeGradient=startLifeTimeGradient;
				for (i=0,n=startLifeTimeGradient.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradient.getValueByIndex(i));
				break ;
			case 2:
				this._maxStartLifetime=Math.max(this.startLifetimeConstantMin,this.startLifetimeConstantMax);
				break ;
			case 3:
				this._maxStartLifetime=-Number.MAX_VALUE;
				var startLifeTimeGradientMin=startLifeTimeGradientMin;
				for (i=0,n=startLifeTimeGradientMin.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradientMin.getValueByIndex(i));
				var startLifeTimeGradientMax=startLifeTimeGradientMax;
				for (i=0,n=startLifeTimeGradientMax.gradientCount;i < n;i++)
				this._maxStartLifetime=Math.max(this._maxStartLifetime,startLifeTimeGradientMax.getValueByIndex(i));
				break ;
			}
		this._startLifetimeType=value;
	});

	/**
	*设置开始生命周期，0模式,单位为秒。
	*/
	/**
	*获取开始生命周期，0模式,单位为秒。
	*/
	__getset(0,__proto,'startLifetimeConstant',function(){
		return this._startLifetimeConstant;
		},function(value){
		if(this._startLifetimeType===0)
			this._maxStartLifetime=value;
		this._startLifetimeConstant=value;
	});

	/**
	*设置最小开始生命周期，2模式,单位为秒。
	*/
	/**
	*获取最小开始生命周期，2模式,单位为秒。
	*/
	__getset(0,__proto,'startLifetimeConstantMin',function(){
		return this._startLifetimeConstantMin;
		},function(value){
		if (this._startLifetimeType===2)
			this._maxStartLifetime=Math.max(value,this._startLifetimeConstantMax);
		this._startLifetimeConstantMin=value;
	});

	/**
	*设置开始渐变生命周期，1模式,单位为秒。
	*/
	/**
	*获取开始渐变生命周期，1模式,单位为秒。
	*/
	__getset(0,__proto,'startLifeTimeGradient',function(){
		return this._startLifeTimeGradient;
		},function(value){
		if (this._startLifetimeType===1){
			this._maxStartLifetime=-Number.MAX_VALUE;
			for (var i=0,n=value.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
		}
		this._startLifeTimeGradient=value;
	});

	/**
	*设置最大开始生命周期，2模式,单位为秒。
	*/
	/**
	*获取最大开始生命周期，2模式,单位为秒。
	*/
	__getset(0,__proto,'startLifetimeConstantMax',function(){
		return this._startLifetimeConstantMax;
		},function(value){
		if (this._startLifetimeType===2)
			this._maxStartLifetime=Math.max(this._startLifetimeConstantMin,value);
		this._startLifetimeConstantMax=value;
	});

	/**
	*设置开始渐变最小生命周期，3模式,单位为秒。
	*/
	/**
	*获取开始渐变最小生命周期，3模式,单位为秒。
	*/
	__getset(0,__proto,'startLifeTimeGradientMin',function(){
		return this._startLifeTimeGradientMin;
		},function(value){
		if (this._startLifetimeType===3){
			var i=0,n=0;
			this._maxStartLifetime=-Number.MAX_VALUE;
			for (i=0,n=value.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
			for (i=0,n=this._startLifeTimeGradientMax.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,this._startLifeTimeGradientMax.getValueByIndex(i));
		}
		this._startLifeTimeGradientMin=value;
	});

	/**
	*设置开始渐变最大生命周期，3模式,单位为秒。
	*/
	/**
	*获取开始渐变最大生命周期，3模式,单位为秒。
	*/
	__getset(0,__proto,'startLifeTimeGradientMax',function(){
		return this._startLifeTimeGradientMax;
		},function(value){
		if (this._startLifetimeType===3){
			var i=0,n=0;
			this._maxStartLifetime=-Number.MAX_VALUE;
			for (i=0,n=this._startLifeTimeGradientMin.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,this._startLifeTimeGradientMin.getValueByIndex(i));
			for (i=0,n=value.gradientCount;i < n;i++)
			this._maxStartLifetime=Math.max(this._maxStartLifetime,value.getValueByIndex(i));
		}
		this._startLifeTimeGradientMax=value;
	});

	/**
	*设置生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期速度.
	*/
	/**
	*获取生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期速度.
	*/
	__getset(0,__proto,'velocityOverLifetime',function(){
		return this._velocityOverLifetime;
		},function(value){
		var defDat=this._owner._render._defineDatas;
		var shaDat=this._owner._render._shaderValues;
		if (value){
			var velocity=value.velocity;
			var velocityType=velocity.type;
			if (value.enbale){
				switch (velocityType){
					case 0:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
						break ;
					case 1:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
						break ;
					case 2:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
						break ;
					case 3:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
			}
			switch (velocityType){
				case 0:
					shaDat.setVector(ShuriKenParticle3D.VOLVELOCITYCONST,velocity.constant);
					break ;
				case 1:
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTX,velocity.gradientX._elements);
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTY,velocity.gradientY._elements);
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTZ,velocity.gradientZ._elements);
					break ;
				case 2:
					shaDat.setVector(ShuriKenParticle3D.VOLVELOCITYCONST,velocity.constantMin);
					shaDat.setVector(ShuriKenParticle3D.VOLVELOCITYCONSTMAX,velocity.constantMax);
					break ;
				case 3:
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTX,velocity.gradientXMin._elements);
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX,velocity.gradientXMax._elements);
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTY,velocity.gradientYMin._elements);
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX,velocity.gradientYMax._elements);
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTZ,velocity.gradientZMin._elements);
					shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX,velocity.gradientZMax._elements);
					break ;
				}
			shaDat.setInt(ShuriKenParticle3D.VOLSPACETYPE,value.space);
			}else {
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
			shaDat.setVector(ShuriKenParticle3D.VOLVELOCITYCONST,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTX,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTY,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTZ,null);
			shaDat.setVector(ShuriKenParticle3D.VOLVELOCITYCONST,null);
			shaDat.setVector(ShuriKenParticle3D.VOLVELOCITYCONSTMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTX,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTY,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTZ,null);
			shaDat.setBuffer(ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX,null);
			shaDat.setInt(ShuriKenParticle3D.VOLSPACETYPE,undefined);
		}
		this._velocityOverLifetime=value;
	});

	/**
	*设置生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期颜色
	*/
	/**
	*获取生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期颜色
	*/
	__getset(0,__proto,'colorOverLifetime',function(){
		return this._colorOverLifetime;
		},function(value){
		var defDat=this._owner._render._defineDatas;
		var shaDat=this._owner._render._shaderValues;
		if (value){
			var color=value.color;
			if (value.enbale){
				switch (color.type){
					case 1:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
						break ;
					case 3:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
			}
			switch (color.type){
				case 1:;
					var gradientColor=color.gradient;
					shaDat.setBuffer(ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS,gradientColor._alphaElements);
					shaDat.setBuffer(ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS,gradientColor._rgbElements);
					break ;
				case 3:;
					var minGradientColor=color.gradientMin;
					var maxGradientColor=color.gradientMax;
					shaDat.setBuffer(ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS,minGradientColor._alphaElements);
					shaDat.setBuffer(ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS,minGradientColor._rgbElements);
					shaDat.setBuffer(ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS,maxGradientColor._alphaElements);
					shaDat.setBuffer(ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS,maxGradientColor._rgbElements);
					break ;
				}
			}else {
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
			shaDat.setBuffer(ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS,gradientColor._alphaElements);
			shaDat.setBuffer(ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS,gradientColor._rgbElements);
			shaDat.setBuffer(ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS,minGradientColor._alphaElements);
			shaDat.setBuffer(ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS,minGradientColor._rgbElements);
			shaDat.setBuffer(ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS,maxGradientColor._alphaElements);
			shaDat.setBuffer(ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS,maxGradientColor._rgbElements);
		}
		this._colorOverLifetime=value;
	});

	/**
	*设置生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期尺寸
	*/
	/**
	*获取生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期尺寸
	*/
	__getset(0,__proto,'sizeOverLifetime',function(){
		return this._sizeOverLifetime;
		},function(value){
		var defDat=this._owner._render._defineDatas;
		var shaDat=this._owner._render._shaderValues;
		if (value){
			var size=value.size;
			var sizeSeparate=size.separateAxes;
			var sizeType=size.type;
			if (value.enbale){
				switch (sizeType){
					case 0:
						if (sizeSeparate)
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
						else
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
						break ;
					case 2:
						if (sizeSeparate)
							defDat.add(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
						else
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
			}
			switch (sizeType){
				case 0:
					if (sizeSeparate){
						shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTX,size.gradientX._elements);
						shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTY,size.gradientY._elements);
						shaDat.setBuffer(ShuriKenParticle3D.SOLSizeGradientZ,size.gradientZ._elements);
						}else {
						shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENT,size.gradient._elements);
					}
					break ;
				case 2:
					if (sizeSeparate){
						shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTX,size.gradientXMin._elements);
						shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTXMAX,size.gradientXMax._elements);
						shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTY,size.gradientYMin._elements);
						shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTYMAX,size.gradientYMax._elements);
						shaDat.setBuffer(ShuriKenParticle3D.SOLSizeGradientZ,size.gradientZMin._elements);
						shaDat.setBuffer(ShuriKenParticle3D.SOLSizeGradientZMAX,size.gradientZMax._elements);
						}else {
						shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENT,size.gradientMin._elements);
						shaDat.setBuffer(ShuriKenParticle3D.SOLSizeGradientMax,size.gradientMax._elements);
					}
					break ;
				}
			}else {
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
			shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTX,null);
			shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTXMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTY,null);
			shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENTYMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.SOLSizeGradientZ,null);
			shaDat.setBuffer(ShuriKenParticle3D.SOLSizeGradientZMAX,null);
			shaDat.setBuffer(ShuriKenParticle3D.SOLSIZEGRADIENT,null);
			shaDat.setBuffer(ShuriKenParticle3D.SOLSizeGradientMax,null);
		}
		this._sizeOverLifetime=value;
	});

	/**
	*设置生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@param value 生命周期纹理动画。
	*/
	/**
	*获取生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
	*@return 生命周期纹理动画。
	*/
	__getset(0,__proto,'textureSheetAnimation',function(){
		return this._textureSheetAnimation;
		},function(value){
		var defDat=this._owner._render._defineDatas;
		var shaDat=this._owner._render._shaderValues;
		if (value){
			var frameOverTime=value.frame;
			var textureAniType=frameOverTime.type;
			if (value.enable){
				switch (textureAniType){
					case 1:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
						break ;
					case 3:
						defDat.add(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
						break ;
					}
				}else {
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
				defDat.remove(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
			}
			if (textureAniType===1 || textureAniType===3){
				shaDat.setNumber(ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES,value.cycles);
				var title=value.tiles;
				var _uvLengthE=this._uvLength.elements;
				_uvLengthE[0]=1.0 / title.x;
				_uvLengthE[1]=1.0 / title.y;
				shaDat.setVector(ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH,this._uvLength);
			}
			switch (textureAniType){
				case 1:
					shaDat.setBuffer(ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS,frameOverTime.frameOverTimeData._elements);
					break ;
				case 3:
					shaDat.setBuffer(ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS,frameOverTime.frameOverTimeDataMin._elements);
					shaDat.setBuffer(ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS,frameOverTime.frameOverTimeDataMax._elements);
					break ;
				}
			}else {
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
			defDat.remove(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
			shaDat.setNumber(ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES,undefined);
			shaDat.setVector(ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH,null);
			shaDat.setBuffer(ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS,null);
			shaDat.setBuffer(ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS,null);
		}
		this._textureSheetAnimation=value;
	});

	ShurikenParticleSystem.halfKSqrtOf2=1.42 *0.5;
	__static(ShurikenParticleSystem,
	['_RANDOMOFFSET',function(){return this._RANDOMOFFSET=new Uint32Array([0x23571a3e,0xc34f56fe,0x13371337,0x12460f3b,0x6aed452e,0xdec4aea1,0x96aa4de3,0x8d2c8431,0xf3857f6f,0xe0fbd834,0x13740583,0x591bc05c,0x40eb95e4,0xbc524e5f,0xaf502044,0xa614b381,0x1034e524,0xfc524e5f]);},'_maxElapsedTime',function(){return this._maxElapsedTime=1.0 / 3.0;},'_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempVector34',function(){return this._tempVector34=new Vector3();},'_tempVector35',function(){return this._tempVector35=new Vector3();},'_tempVector36',function(){return this._tempVector36=new Vector3();},'_tempVector37',function(){return this._tempVector37=new Vector3();},'_tempVector38',function(){return this._tempVector38=new Vector3();},'_tempVector39',function(){return this._tempVector39=new Vector3();},'_tempPosition',function(){return this._tempPosition=new Vector3();},'_tempDirection',function(){return this._tempDirection=new Vector3();},'_type',function(){return this._type=GeometryElement._typeCounter++;}
	]);
	return ShurikenParticleSystem;
})(GeometryElement)


/**
*<code>VertexShurikenParticle</code> 类用于创建粒子顶点结构。
*/
//class laya.d3.graphics.Vertex.VertexShurikenParticleBillboard extends laya.d3.graphics.Vertex.VertexShuriKenParticle
var VertexShurikenParticleBillboard=(function(_super){
	function VertexShurikenParticleBillboard(cornerTextureCoordinate,positionStartLifeTime,velocity,startColor,startSize,startRotation0,startRotation1,startRotation2,ageAddScale,time,startSpeed,randoms0,randoms1,simulationWorldPostion){
		/**@private */
		this._cornerTextureCoordinate=null;
		/**@private */
		this._positionStartLifeTime=null;
		/**@private */
		this._velocity=null;
		/**@private */
		this._startColor=null;
		/**@private */
		this._startSize=null;
		/**@private */
		this._startRotation0=null;
		/**@private */
		this._startRotation1=null;
		/**@private */
		this._startRotation2=null;
		/**@private */
		this._startLifeTime=NaN;
		/**@private */
		this._time=NaN;
		/**@private */
		this._startSpeed=NaN;
		/**@private */
		this._randoms0=null;
		/**@private */
		this._randoms1=null;
		/**@private */
		this._simulationWorldPostion=null;
		VertexShurikenParticleBillboard.__super.call(this);
		this._cornerTextureCoordinate=cornerTextureCoordinate;
		this._positionStartLifeTime=positionStartLifeTime;
		this._velocity=velocity;
		this._startColor=startColor;
		this._startSize=startSize;
		this._startRotation0=startRotation0;
		this._startRotation1=startRotation1;
		this._startRotation2=startRotation2;
		this._startLifeTime=ageAddScale;
		this._time=time;
		this._startSpeed=startSpeed;
		this._randoms0=this.random0;
		this._randoms1=this.random1;
		this._simulationWorldPostion=simulationWorldPostion;
	}

	__class(VertexShurikenParticleBillboard,'laya.d3.graphics.Vertex.VertexShurikenParticleBillboard',_super);
	var __proto=VertexShurikenParticleBillboard.prototype;
	__getset(0,__proto,'cornerTextureCoordinate',function(){
		return this._cornerTextureCoordinate;
	});

	__getset(0,__proto,'random1',function(){
		return this._randoms1;
	});

	__getset(0,__proto,'startRotation2',function(){
		return this._startRotation2;
	});

	__getset(0,__proto,'positionStartLifeTime',function(){
		return this._positionStartLifeTime;
	});

	__getset(0,__proto,'velocity',function(){
		return this._velocity;
	});

	__getset(0,__proto,'random0',function(){
		return this._randoms0;
	});

	__getset(0,__proto,'startSize',function(){
		return this._startSize;
	});

	__getset(0,__proto,'startColor',function(){
		return this._startColor;
	});

	__getset(0,__proto,'startRotation0',function(){
		return this._startRotation0;
	});

	__getset(0,__proto,'startRotation1',function(){
		return this._startRotation1;
	});

	__getset(0,__proto,'startLifeTime',function(){
		return this._startLifeTime;
	});

	__getset(0,__proto,'time',function(){
		return this._time;
	});

	__getset(0,__proto,'startSpeed',function(){
		return this._startSpeed;
	});

	__getset(0,__proto,'simulationWorldPostion',function(){
		return this._simulationWorldPostion;
	});

	__getset(1,VertexShurikenParticleBillboard,'vertexDeclaration',function(){
		return VertexShurikenParticleBillboard._vertexDeclaration;
	},laya.d3.graphics.Vertex.VertexShuriKenParticle._$SET_vertexDeclaration);

	__static(VertexShurikenParticleBillboard,
	['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(152,[
		new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0*/0),
		new VertexElement(16,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME*/4),
		new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_DIRECTIONTIME*/5),
		new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTCOLOR0*/6),
		new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTSIZE*/8),
		new VertexElement(76,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTROTATION*/9),
		new VertexElement(88,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_STARTSPEED*/10),
		new VertexElement(92,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_RANDOM0*/11),
		new VertexElement(108,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_RANDOM1*/12),
		new VertexElement(124,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION*/13),
		new VertexElement(136,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.Vertex.VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION*/14)]);}
	]);
	return VertexShurikenParticleBillboard;
})(VertexShuriKenParticle)


/**
*<code>CastShadowList</code> 类用于实现产生阴影者队列。
*/
//class laya.d3.CastShadowList extends laya.d3.component.SingletonList
var CastShadowList=(function(_super){
	/**
	*创建一个新的 <code>CastShadowList</code> 实例。
	*/
	function CastShadowList(){
		CastShadowList.__super.call(this);
	}

	__class(CastShadowList,'laya.d3.CastShadowList',_super);
	var __proto=CastShadowList.prototype;
	/**
	*@private
	*/
	__proto.add=function(element){
		var index=element._indexInCastShadowList;
		if (index!==-1)
			throw "CastShadowList:element has  in  CastShadowList.";
		this._add(element);
		element._indexInCastShadowList=this.length++;
	}

	/**
	*@private
	*/
	__proto.remove=function(element){
		var index=element._indexInCastShadowList;
		this.length--;
		if (index!==this.length){
			var end=this.elements[this.length];
			this.elements[index]=end;
			end._indexInCastShadowList=index;
		}
		element._indexInCastShadowList=-1;
	}

	return CastShadowList;
})(SingletonList)


/**
*<code>PhysicsUpdateList</code> 类用于实现物理更新队列。
*/
//class laya.d3.physics.PhysicsUpdateList extends laya.d3.component.SingletonList
var PhysicsUpdateList=(function(_super){
	/**
	*创建一个新的 <code>PhysicsUpdateList</code> 实例。
	*/
	function PhysicsUpdateList(){
		PhysicsUpdateList.__super.call(this);
	}

	__class(PhysicsUpdateList,'laya.d3.physics.PhysicsUpdateList',_super);
	var __proto=PhysicsUpdateList.prototype;
	/**
	*@private
	*/
	__proto.add=function(element){
		var index=element._inPhysicUpdateListIndex;
		if (index!==-1)
			throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
		this._add(element);
		element._inPhysicUpdateListIndex=this.length++;
	}

	return PhysicsUpdateList;
})(SingletonList)


/**
*<code>SimpleSingletonList</code> 类用于实现单例队列。
*/
//class laya.d3.component.SimpleSingletonList extends laya.d3.component.SingletonList
var SimpleSingletonList=(function(_super){
	/**
	*创建一个新的 <code>SimpleSingletonList</code> 实例。
	*/
	function SimpleSingletonList(){
		SimpleSingletonList.__super.call(this);
	}

	__class(SimpleSingletonList,'laya.d3.component.SimpleSingletonList',_super);
	var __proto=SimpleSingletonList.prototype;
	/**
	*@private
	*/
	__proto.add=function(element){
		var index=element._getIndexInList();
		if (index!==-1)
			throw "SimpleSingletonList:"+element+" has  in  SingletonList.";
		this._add(element);
		element._setIndexInList(this.length++);
	}

	/**
	*@private
	*/
	__proto.remove=function(element){
		var index=element._getIndexInList();
		this.length--;
		if (index!==this.length){
			var end=this.elements[this.length];
			this.elements[index]=end;
			end._setIndexInList(index);
		}
		element._setIndexInList(-1);
	}

	return SimpleSingletonList;
})(SingletonList)


/**
*<code>Sprite3D</code> 类用于实现3D精灵。
*/
//class laya.d3.core.Sprite3D extends laya.display.Node
var Sprite3D=(function(_super){
	function Sprite3D(name,isStatic){
		/**@private */
		//this._id=0;
		/**@private */
		//this._url=null;
		/**@private */
		//this._isStatic=false;
		/**@private */
		//this._layer=0;
		/**@private */
		//this._scripts=null;
		/**@private */
		//this._transform=null;
		/**@private */
		//this._hierarchyAnimator=null;
		/**@private */
		this._needProcessCollisions=false;
		/**@private */
		this._needProcessTriggers=false;
		Sprite3D.__super.call(this);
		(isStatic===void 0)&& (isStatic=false);
		this._id=++Sprite3D._uniqueIDCounter;
		this._transform=new Transform3D(this);
		this._isStatic=isStatic;
		this.layer=0;
		this.name=name ? name :"New Sprite3D";
	}

	__class(Sprite3D,'laya.d3.core.Sprite3D',_super);
	var __proto=Sprite3D.prototype;
	Laya.imps(__proto,{"laya.resource.ICreateResource":true,"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._setCreateURL=function(url){
		this._url=url;
	}

	/**
	*@private
	*/
	__proto._changeAnimatorsToLinkSprite3D=function(sprite3D,isLink,path){
		var animator=this.getComponent(Animator);
		if (animator){
			if (!animator.avatar)
				sprite3D._changeAnimatorToLinkSprite3DNoAvatar(animator,isLink,path);
		}
		if (this._parent && (this._parent instanceof laya.d3.core.Sprite3D )){
			path.unshift(this._parent.name);
			var p=this._parent;
			(p._hierarchyAnimator)&& (p._changeAnimatorsToLinkSprite3D(sprite3D,isLink,path));
		}
	}

	/**
	*@private
	*/
	__proto._setHierarchyAnimator=function(animator,parentAnimator){
		this._changeHierarchyAnimator(animator);
		this._changeAnimatorAvatar(animator.avatar);
		for (var i=0,n=this._children.length;i < n;i++){
			var child=this._children[i];
			(child._hierarchyAnimator==parentAnimator)&& (child._setHierarchyAnimator(animator,parentAnimator));
		}
	}

	/**
	*@private
	*/
	__proto._clearHierarchyAnimator=function(animator,parentAnimator){
		this._changeHierarchyAnimator(parentAnimator);
		this._changeAnimatorAvatar(parentAnimator ? parentAnimator.avatar :null);
		for (var i=0,n=this._children.length;i < n;i++){
			var child=this._children[i];
			(child._hierarchyAnimator==animator)&& (child._clearHierarchyAnimator(animator,parentAnimator));
		}
	}

	/**
	*@private
	*/
	__proto._changeHierarchyAnimatorAvatar=function(animator,avatar){
		this._changeAnimatorAvatar(avatar);
		for (var i=0,n=this._children.length;i < n;i++){
			var child=this._children[i];
			(child._hierarchyAnimator==animator)&& (child._changeHierarchyAnimatorAvatar(animator,avatar));
		}
	}

	/**
	*@private
	*/
	__proto._changeAnimatorToLinkSprite3DNoAvatar=function(animator,isLink,path){
		animator._handleSpriteOwnersBySprite(isLink,path,this);
		for (var i=0,n=this._children.length;i < n;i++){
			var child=this._children[i];
			var index=path.length;
			path.push(child.name);
			child._changeAnimatorToLinkSprite3DNoAvatar(animator,isLink,path);
			path.splice(index,1);
		}
	}

	/**
	*@private
	*/
	__proto._changeHierarchyAnimator=function(animator){
		this._hierarchyAnimator=animator;
	}

	/**
	*@private
	*/
	__proto._changeAnimatorAvatar=function(avatar){}
	/**
	*@inheritDoc
	*/
	__proto._onAdded=function(){
		if ((this._parent instanceof laya.d3.core.Sprite3D )){
			var parent3D=this._parent;
			this.transform._setParent(parent3D.transform);
			if (parent3D._hierarchyAnimator){
				(!this._hierarchyAnimator)&& (this._setHierarchyAnimator(parent3D._hierarchyAnimator,null));
				parent3D._changeAnimatorsToLinkSprite3D(this,true,/*new vector.<>*/[this.name]);
			}
		}
		_super.prototype._onAdded.call(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._onRemoved=function(){
		_super.prototype._onRemoved.call(this);
		if ((this._parent instanceof laya.d3.core.Sprite3D )){
			var parent3D=this._parent;
			this.transform._setParent(null);
			if (parent3D._hierarchyAnimator){
				(this._hierarchyAnimator==parent3D._hierarchyAnimator)&& (this._clearHierarchyAnimator(parent3D._hierarchyAnimator,null));
				parent3D._changeAnimatorsToLinkSprite3D(this,false,/*new vector.<>*/[this.name]);
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		(data.isStatic!==undefined)&& (this._isStatic=data.isStatic);
		(data.active!==undefined)&& (this.active=data.active);
		(data.name !=undefined)&& (this.name=data.name);
		if (data.position!==undefined){
			var loccalPosition=this.transform.localPosition;
			loccalPosition.fromArray(data.position);
			this.transform.localPosition=loccalPosition;
		}
		if (data.rotationEuler!==undefined){
			var localRotationEuler=this.transform.localRotationEuler;
			localRotationEuler.fromArray(data.rotationEuler);
			this.transform.localRotationEuler=localRotationEuler;
		}
		if (data.rotation!==undefined){
			var localRotation=this.transform.localRotation;
			localRotation.fromArray(data.rotation);
			this.transform.localRotation=localRotation;
		}
		if (data.scale!==undefined){
			var localScale=this.transform.localScale;
			localScale.fromArray(data.scale);
			this.transform.localScale=localScale;
		}
		(data.layer !=undefined)&& (this.layer=data.layer);
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		if (this.destroyed)
			throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
		var destSprite3D=destObject;
		for (var i=0,n=this._children.length;i < n;i++)
		destSprite3D.addChild(this._children[i].clone());
		destSprite3D.name=this.name;
		destSprite3D.destroyed=this.destroyed;
		destSprite3D.active=this.active;
		var destLocalPosition=destSprite3D.transform.localPosition;
		this.transform.localPosition.cloneTo(destLocalPosition);
		destSprite3D.transform.localPosition=destLocalPosition;
		var destLocalRotation=destSprite3D.transform.localRotation;
		this.transform.localRotation.cloneTo(destLocalRotation);
		destSprite3D.transform.localRotation=destLocalRotation;
		var destLocalScale=destSprite3D.transform.localScale;
		this.transform.localScale.cloneTo(destLocalScale);
		destSprite3D.transform.localScale=destLocalScale;
		destSprite3D._isStatic=this._isStatic;
		destSprite3D.layer=this.layer;
		this._cloneTo(destSprite3D);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var destSprite3D=/*__JS__ */new this.constructor();
		this.cloneTo(destSprite3D);
		return destSprite3D;
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		this._transform=null;
		this._scripts=null;
		this._url && Loader.clearRes(this._url);
	}

	/**
	*获取唯一标识ID。
	*@return 唯一标识ID。
	*/
	__getset(0,__proto,'id',function(){
		return this._id;
	});

	/**
	*获取资源的URL地址。
	*@return URL地址。
	*/
	__getset(0,__proto,'url',function(){
		return this._url;
	});

	/**
	*设置蒙版。
	*@param value 蒙版。
	*/
	/**
	*获取蒙版。
	*@return 蒙版。
	*/
	__getset(0,__proto,'layer',function(){
		return this._layer;
		},function(value){
		if (this._layer!==value){
			if (value >=0 && value <=30){
				this._layer=value;
				}else {
				throw new Error("Layer value must be 0-30.");
			}
		}
	});

	/**
	*获取精灵变换。
	*@return 精灵变换。
	*/
	__getset(0,__proto,'transform',function(){
		return this._transform;
	});

	/**
	*获取是否为静态。
	*@return 是否为静态。
	*/
	__getset(0,__proto,'isStatic',function(){
		return this._isStatic;
	});

	Sprite3D._parse=function(data,propertyParams,constructParams){
		var json=data.data;
		var outBatchSprits=[];
		var sprite=Utils3D._createNodeByJson(json,outBatchSprits);
		StaticBatchManager.combine(sprite,outBatchSprits);
		return sprite;
	}

	Sprite3D.__init__=function(){}
	Sprite3D.instantiate=function(original,parent,worldPositionStays,position,rotation){
		(worldPositionStays===void 0)&& (worldPositionStays=true);
		var destSprite3D=original.clone();
		(parent)&& (parent.addChild(destSprite3D));
		var transform=destSprite3D.transform;
		if (worldPositionStays){
			var worldMatrix=transform.worldMatrix;
			original.transform.worldMatrix.cloneTo(worldMatrix);
			transform.worldMatrix=worldMatrix;
			}else {
			(position)&& (transform.position=position);
			(rotation)&& (transform.rotation=rotation);
		}
		return destSprite3D;
	}

	Sprite3D.load=function(url,complete){
		Laya.loader.create(url,complete,null,/*Laya3D.HIERARCHY*/"HIERARCHY");
	}

	Sprite3D._uniqueIDCounter=0;
	__static(Sprite3D,
	['WORLDMATRIX',function(){return this.WORLDMATRIX=Shader3D.propertyNameToID("u_WorldMat");},'MVPMATRIX',function(){return this.MVPMATRIX=Shader3D.propertyNameToID("u_MvpMatrix");}
	]);
	return Sprite3D;
})(Node)


/**
*<code>BaseMaterial</code> 类用于创建材质,抽象类,不允许实例。
*/
//class laya.d3.core.material.BaseMaterial extends laya.resource.Resource
var BaseMaterial=(function(_super){
	function BaseMaterial(){
		/**@private */
		//this._alphaTest=false;
		/**@private */
		//this._renderStates=null;
		/**@private */
		//this._defineDatas=null;
		/**@private */
		//this._disablePublicDefineDatas=null;
		/**@private */
		//this._shader=null;
		/**@private */
		//this._shaderValues=null;
		/**所属渲染队列. */
		//this.renderQueue=0;
		BaseMaterial.__super.call(this);
		this._defineDatas=new DefineDatas();
		this._disablePublicDefineDatas=new DefineDatas();
		this._shaderValues=new ShaderData(this);
		this.renderQueue=/*CLASS CONST:laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
		this._alphaTest=false;
		this._renderStates=[];
	}

	__class(BaseMaterial,'laya.d3.core.material.BaseMaterial',_super);
	var __proto=BaseMaterial.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._removeTetxureReference=function(){
		var data=this._shaderValues._data;
		for (var k in data){
			var value=data[k];
			if (value && (value instanceof laya.webgl.resource.BaseTexture ))
				(value)._removeReference();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._addReference=function(count){
		(count===void 0)&& (count=1);
		_super.prototype._addReference.call(this,count);
		var data=this._shaderValues._data;
		for (var k in data){
			var value=data[k];
			if (value && (value instanceof laya.webgl.resource.BaseTexture ))
				(value)._addReference();
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._removeReference=function(count){
		(count===void 0)&& (count=1);
		_super.prototype._removeReference.call(this,count);
		this._removeTetxureReference();
	}

	/**
	*@inheritDoc
	*/
	__proto._disposeResource=function(){
		if (this._referenceCount > 0)
			this._removeTetxureReference();
		this._shaderValues=null;
	}

	/**
	*设置使用Shader名字。
	*@param name 名称。
	*/
	__proto.setShaderName=function(name){
		this._shader=Shader3D._preCompileShader[name];
		if (!this._shader)
			throw new Error("BaseMaterial: unknown shader name.");
		var passCount=this._shader.getSubShaderAt(0)._passes.length;
		this._renderStates.length=passCount;
		for (var i=0;i < passCount;i++)
		(this._renderStates[i])|| (this._renderStates[i]=new RenderState());
	}

	/**
	*获取渲染状态。
	*@param passIndex 所关联Shader的pass索引。
	*/
	__proto.getRenderState=function(passIndex){
		(passIndex===void 0)&& (passIndex=0);
		return this._renderStates[passIndex];
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destBaseMaterial=destObject;
		destBaseMaterial.name=this.name;
		destBaseMaterial.renderQueue=this.renderQueue;
		this._disablePublicDefineDatas.cloneTo(destBaseMaterial._disablePublicDefineDatas);
		this._defineDatas.cloneTo(destBaseMaterial._defineDatas);
		this._shaderValues.cloneTo(destBaseMaterial._shaderValues);
		var destRenderStates=destObject._renderStates;
		for (var i=0,n=this._renderStates.length;i < n;i++)
		this._renderStates[i].cloneTo(destRenderStates[i]);
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*设置透明测试模式裁剪值。
	*@param value 透明测试模式裁剪值。
	*/
	/**
	*获取透明测试模式裁剪值。
	*@return 透明测试模式裁剪值。
	*/
	__getset(0,__proto,'alphaTestValue',function(){
		return this._shaderValues.getNumber(BaseMaterial.ALPHATESTVALUE);
		},function(value){
		this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE,value);
	});

	/**
	*设置是否透明裁剪。
	*@param value 是否透明裁剪。
	*/
	/**
	*获取是否透明裁剪。
	*@return 是否透明裁剪。
	*/
	__getset(0,__proto,'alphaTest',function(){
		return this._alphaTest;
		},function(value){
		this._alphaTest=value;
		if (value)
			this._defineDatas.add(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
		else
		this._defineDatas.remove(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
	});

	BaseMaterial.load=function(url,complete){
		Laya.loader.create(url,complete,null,/*Laya3D.MATERIAL*/"MATERIAL");
	}

	BaseMaterial.__init__=function(){
		BaseMaterial.SHADERDEFINE_ALPHATEST=BaseMaterial.shaderDefines.registerDefine("ALPHATEST");
	}

	BaseMaterial._parse=function(data,propertyParams,constructParams){
		var jsonData=data;
		var props=jsonData.props;
		var material;
		var classType=props.type;
		var clasPaths=classType.split('.');
		var clas=Browser.window;
		clasPaths.forEach(function(cls){
			clas=clas[cls];
		});
		if (typeof(clas)=='function')
			material=new clas();
		else
		throw('_getSprite3DHierarchyInnerUrls 错误: '+data.type+' 不是类');
		switch (jsonData.version){
			case "LAYAMATERIAL:01":
				props=jsonData.props;
				for (key in props){
				switch (key){
					case "vectors":
						vectors=props[key];
						for (i=0,n=vectors.length;i < n;i++){
							vector=vectors[i];
							vectorValue=vector.value;
						switch (vectorValue.length){
							case 2:
								material[vector.name]=new Vector2(vectorValue[0],vectorValue[1]);
								break ;
							case 3:
								material[vector.name]=new Vector3(vectorValue[0],vectorValue[1],vectorValue[2]);
								break ;
							case 4:
								material[vector.name]=new Vector4(vectorValue[0],vectorValue[1],vectorValue[2],vectorValue[3]);
								break ;
							default :
								throw new Error("BaseMaterial:unkonwn color length.");
							}
					}
					break ;
					case "textures":
					textures=props[key];
					for (i=0,n=textures.length;i < n;i++){
						texture=textures[i];
						path=texture.path;
						(path)&& (material[texture.name]=Loader.getRes(path));
					}
					break ;
					case "defines":
					defineNames=props[key];
					for (i=0,n=defineNames.length;i < n;i++){
						define=material._shader.getSubShaderAt(0).getMaterialDefineByName(defineNames[i]);
						material._defineDatas.add(define);
					}
					break ;
					case "cull":
					case "blend":
					case "srcBlend":
					case "dstBlend":
					case "depthWrite":;
					var value=props[key];
					for (i=0,n=material._renderStates.length;i < n;i++)
					material._renderStates[i][key]=value;
					break ;
					case "renderQueue":;
					var queue=props[key];
					switch (queue){
						case 1:
							material.renderQueue=2000;
							break ;
						case 2:
							material.renderQueue=3000;
							break ;
						default :
							material[key]=props[key];
						}
					break ;
					default :
					material[key]=props[key];
				}
			}
			break ;
			case "LAYAMATERIAL:02":;
			var i=0,n=0;
			for (var key in props){
				switch (key){
					case "vectors":;
						var vectors=props[key];
						for (i=0,n=vectors.length;i < n;i++){
							var vector=vectors[i];
							var vectorValue=vector.value;
						switch (vectorValue.length){
							case 2:
								material[vector.name]=new Vector2(vectorValue[0],vectorValue[1]);
								break ;
							case 3:
								material[vector.name]=new Vector3(vectorValue[0],vectorValue[1],vectorValue[2]);
								break ;
							case 4:
								material[vector.name]=new Vector4(vectorValue[0],vectorValue[1],vectorValue[2],vectorValue[3]);
								break ;
							default :
								throw new Error("BaseMaterial:unkonwn color length.");
							}
					}
					break ;
					case "textures":;
					var textures=props[key];
					for (i=0,n=textures.length;i < n;i++){
						var texture=textures[i];
						var path=texture.path;
						(path)&& (material[texture.name]=Loader.getRes(path));
					}
					break ;
					case "defines":;
					var defineNames=props[key];
					for (i=0,n=defineNames.length;i < n;i++){
						var define=material._shader.getSubShaderAt(0).getMaterialDefineByName(defineNames[i]);
						material._defineDatas.add(define);
					}
					break ;
					case "renderStates":;
					var renderStatesData=props[key];
					for (i=0,n=renderStatesData.length;i < n;i++){
						var renderStateData=renderStatesData[i];
						var renderState=material._renderStates[i];
						for (var stateKey in renderStateData)
						renderState[stateKey]=renderStateData[stateKey];
					}
					break ;
					default :
					material[key]=props[key];
				}
			}
			break ;
			default :
			throw new Error("BaseMaterial:unkonwn version.");
		}
		return material;
	}

	BaseMaterial.RENDERQUEUE_OPAQUE=2000;
	BaseMaterial.RENDERQUEUE_ALPHATEST=2450;
	BaseMaterial.RENDERQUEUE_TRANSPARENT=3000;
	BaseMaterial.SHADERDEFINE_ALPHATEST=0;
	__static(BaseMaterial,
	['ALPHATESTVALUE',function(){return this.ALPHATESTVALUE=Shader3D.propertyNameToID("u_AlphaTestValue");},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines();}
	]);
	return BaseMaterial;
})(Resource)


/**
*<code>TerrainHeightData</code> 类用于描述地形高度信息。
*/
//class laya.d3.terrain.TerrainHeightData extends laya.resource.Resource
var TerrainHeightData=(function(_super){
	function TerrainHeightData(width,height,bitType,value){
		this._terrainHeightData=null;
		this._width=0;
		this._height=0;
		this._bitType=0;
		this._value=NaN;
		TerrainHeightData.__super.call(this);
		this._width=width;
		this._height=height;
		this._bitType=bitType;
		this._value=value;
	}

	__class(TerrainHeightData,'laya.d3.terrain.TerrainHeightData',_super);
	TerrainHeightData._pharse=function(data,propertyParams,constructParams){
		var terrainHeightData=new TerrainHeightData(constructParams[0],constructParams[1],constructParams[2],constructParams[3]);
		var buffer;
		var ratio=NaN;
		if (terrainHeightData._bitType==8){
			buffer=new Uint8Array(data);
			ratio=1.0 / 255.0;
			}else if (terrainHeightData._bitType==16){
			buffer=new Int16Array(data);
			ratio=1.0 / 32766.0;
		}
		terrainHeightData._terrainHeightData=new Float32Array(terrainHeightData._height *terrainHeightData._width);
		for (var i=0,n=terrainHeightData._height *terrainHeightData._width;i < n;i++){
			terrainHeightData._terrainHeightData[i]=(buffer[i] *ratio *terrainHeightData._value)/ 2;
		}
	}

	TerrainHeightData.load=function(url,complete,widht,height,bitType,value){
		Laya.loader.create(url,complete,null,/*Laya3D.TERRAINHEIGHTDATA*/"TERRAINHEIGHTDATA",[widht,height,bitType,value],null,1,false);
	}

	return TerrainHeightData;
})(Resource)


/**
*<code>Avatar</code> 类用于创建Avatar。
*/
//class laya.d3.core.Avatar extends laya.resource.Resource
var Avatar=(function(_super){
	function Avatar(){
		/**@private */
		this._rootNode=null;
		/**@private [NATIVE]*/
		this._nativeNodeCount=0;
		/**@private [NATIVE]*/
		this._nativeCurCloneCount=0;
		Avatar.__super.call(this);
	}

	__class(Avatar,'laya.d3.core.Avatar',_super);
	var __proto=Avatar.prototype;
	Laya.imps(__proto,{"laya.d3.core.IClone":true})
	/**
	*@private
	*/
	__proto._initCloneToAnimator=function(destNode,destAnimator){
		destAnimator._avatarNodeMap[destNode.name]=destNode;
		for (var i=0,n=destNode.getChildCount();i < n;i++)
		this._initCloneToAnimator(destNode.getChildByIndex(i),destAnimator);
	}

	/**
	*@private
	*/
	__proto._parseNode=function(nodaData,node){
		var name=nodaData.props.name;
		node.name=name;
		var props=nodaData.props;
		var transform=node.transform;
		var pos=transform.localPosition;
		var rot=transform.localRotation;
		var sca=transform.localScale;
		pos.fromArray(props.translate);
		rot.fromArray(props.rotation);
		sca.fromArray(props.scale);
		transform.localPosition=pos;
		transform.localRotation=rot;
		transform.localScale=sca;
		var childrenData=nodaData.child;
		for (var j=0,n=childrenData.length;j < n;j++){
			var childData=childrenData[j];
			var childBone=new AnimationNode(new Float32Array(3),new Float32Array(4),new Float32Array(3),new Float32Array(16));
			node.addChild(childBone);
			if (Render.isConchApp)
				this._nativeNodeCount++;
			this._parseNode(childData,childBone);
		}
	}

	/**
	*克隆数据到Avatr。
	*@param destObject 克隆源。
	*/
	__proto._cloneDatasToAnimator=function(destAnimator){
		var destRoot;
		destRoot=this._rootNode.clone();
		var transform=this._rootNode.transform;
		var destTransform=destRoot.transform;
		var destPosition=destTransform.localPosition;
		var destRotation=destTransform.localRotation;
		var destScale=destTransform.localScale;
		transform.localPosition.cloneTo(destPosition);
		transform.localRotation.cloneTo(destRotation);
		transform.localScale.cloneTo(destScale);
		destTransform.localPosition=destPosition;
		destTransform.localRotation=destRotation;
		destTransform.localScale=destScale;
		destAnimator._avatarNodeMap={};
		this._initCloneToAnimator(destRoot,destAnimator);
	}

	/**
	*克隆。
	*@param destObject 克隆源。
	*/
	__proto.cloneTo=function(destObject){
		var destAvatar=destObject;
		var destRoot=this._rootNode.clone();
		destAvatar._rootNode=destRoot;
	}

	/**
	*克隆。
	*@return 克隆副本。
	*/
	__proto.clone=function(){
		var dest=/*__JS__ */new this.constructor();
		this.cloneTo(dest);
		return dest;
	}

	/**
	*@private [NATIVE]
	*/
	__proto._cloneDatasToAnimatorNative=function(destAnimator){
		var animationNodeLocalPositions=new Float32Array(this._nativeNodeCount *3);
		var animationNodeLocalRotations=new Float32Array(this._nativeNodeCount *4);
		var animationNodeLocalScales=new Float32Array(this._nativeNodeCount *3);
		var animationNodeWorldMatrixs=new Float32Array(this._nativeNodeCount *16);
		var animationNodeParentIndices=new Int16Array(this._nativeNodeCount);
		destAnimator._animationNodeLocalPositions=animationNodeLocalPositions;
		destAnimator._animationNodeLocalRotations=animationNodeLocalRotations;
		destAnimator._animationNodeLocalScales=animationNodeLocalScales;
		destAnimator._animationNodeWorldMatrixs=animationNodeWorldMatrixs;
		destAnimator._animationNodeParentIndices=animationNodeParentIndices;
		this._nativeCurCloneCount=0;
		var destRoot=this._rootNode._cloneNative(animationNodeLocalPositions,animationNodeLocalRotations,animationNodeLocalScales,animationNodeWorldMatrixs,animationNodeParentIndices,-1,this);
		var transform=this._rootNode.transform;
		var destTransform=destRoot.transform;
		var destPosition=destTransform.localPosition;
		var destRotation=destTransform.localRotation;
		var destScale=destTransform.localScale;
		transform.localPosition.cloneTo(destPosition);
		transform.localRotation.cloneTo(destRotation);
		transform.localScale.cloneTo(destScale);
		destTransform.localPosition=destPosition;
		destTransform.localRotation=destRotation;
		destTransform.localScale=destScale;
		destAnimator._avatarNodeMap={};
		this._initCloneToAnimator(destRoot,destAnimator);
	}

	Avatar._parse=function(data,propertyParams,constructParams){
		var avatar=new Avatar();
		avatar._rootNode=new AnimationNode(new Float32Array(3),new Float32Array(4),new Float32Array(3),new Float32Array(16));
		if (Render.isConchApp)
			avatar._nativeNodeCount++;
		if (data.version){
			var rootNode=data.rootNode;
			(rootNode)&& (avatar._parseNode(rootNode,avatar._rootNode));
		}
		return avatar;
	}

	Avatar.load=function(url,complete){
		Laya.loader.create(url,complete,null,/*Laya3D.AVATAR*/"AVATAR");
	}

	return Avatar;
})(Resource)


/**
*@private
*<code>ShaderInstance</code> 类用于实现ShaderInstance。
*/
//class laya.d3.shader.ShaderInstance extends laya.resource.Resource
var ShaderInstance=(function(_super){
	function ShaderInstance(vs,ps,attributeMap,uniformMap){
		/**@private */
		//this._attributeMap=null;
		/**@private */
		//this._uniformMap=null;
		/**@private */
		//this._vs=null;
		/**@private */
		//this._ps=null;
		/**@private */
		//this._curActTexIndex=0;
		/**@private */
		//this._vshader=null;
		/**@private */
		//this._pshader=null;
		/**@private */
		//this._program=null;
		/**@private */
		//this._sceneUniformParamsMap=null;
		/**@private */
		//this._cameraUniformParamsMap=null;
		/**@private */
		//this._spriteUniformParamsMap=null;
		/**@private */
		//this._materialUniformParamsMap=null;
		/**@private */
		//this._customUniformParamsMap=null;
		/**@private */
		//this._uploadLoopCount=0;
		/**@private */
		//this._uploadMaterial=null;
		/**@private */
		//this._uploadRender=null;
		/**@private */
		//this._uploadCamera=null;
		/**@private */
		//this._uploadScene=null;
		ShaderInstance.__super.call(this);
		this._vs=vs;
		this._ps=ps;
		this._attributeMap=attributeMap;
		this._uniformMap=uniformMap;
		this._create();
		this.lock=true;
	}

	__class(ShaderInstance,'laya.d3.shader.ShaderInstance',_super);
	var __proto=ShaderInstance.prototype;
	/**
	*@private
	*/
	__proto._create=function(){
		var gl=LayaGL.instance;
		this._program=gl.createProgram();
		this._vshader=this._createShader(gl,this._vs,/*laya.webgl.WebGLContext.VERTEX_SHADER*/0x8B31);
		this._pshader=this._createShader(gl,this._ps,/*laya.webgl.WebGLContext.FRAGMENT_SHADER*/0x8B30);
		gl.attachShader(this._program,this._vshader);
		gl.attachShader(this._program,this._pshader);
		for (var k in this._attributeMap)
		gl.bindAttribLocation(this._program,this._attributeMap[k],k);
		gl.linkProgram(this._program);
		if (!Render.isConchApp && Shader3D.debugMode && !gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.LINK_STATUS*/0x8B82))
			throw gl.getProgramInfoLog(this._program);
		var sceneParms=[];
		var cameraParms=[];
		var spriteParms=[];
		var materialParms=[];
		var customParms=[];
		this._customUniformParamsMap=[];
		var nUniformNum=0;
		if (Render.isConchApp){
			nUniformNum=(gl).getProgramParameterEx(this._vs,this._ps,"",/*laya.webgl.WebGLContext.ACTIVE_UNIFORMS*/0x8B86);
			}else {
			nUniformNum=gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_UNIFORMS*/0x8B86);
		}
		WebGLContext.useProgram(gl,this._program);
		this._curActTexIndex=0;
		var one,i=0,n=0;
		for (i=0;i < nUniformNum;i++){
			var uniformData=null;
			if (Render.isConchApp){
				uniformData=(gl).getActiveUniformEx(this._vs,this._ps,"",i);
				}else {
				uniformData=gl.getActiveUniform(this._program,i);
			};
			var uniName=uniformData.name;
			one=new ShaderVariable();
			one.location=gl.getUniformLocation(this._program,uniName);
			if (uniName.indexOf('[0]')> 0){
				one.name=uniName=uniName.substr(0,uniName.length-3);
				one.isArray=true;
				}else {
				one.name=uniName;
				one.isArray=false;
			}
			one.type=uniformData.type;
			this._addShaderUnifiormFun(one);
			var uniformPeriod=this._uniformMap[uniName];
			if (uniformPeriod !=null){
				one.dataOffset=Shader3D.propertyNameToID(uniName);
				switch (uniformPeriod){
					case /*laya.d3.shader.Shader3D.PERIOD_CUSTOM*/0:
						customParms.push(one);
						break ;
					case /*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1:
						materialParms.push(one);
						break ;
					case /*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2:
						spriteParms.push(one);
						break ;
					case /*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3:
						cameraParms.push(one);
						break ;
					case /*laya.d3.shader.Shader3D.PERIOD_SCENE*/4:
						sceneParms.push(one);
						break ;
					default :
						throw new Error("Shader3D: period is unkonw.");
					}
			}
		}
		this._sceneUniformParamsMap=LayaGL.instance.createCommandEncoder(sceneParms.length *4 *5+4,64,true);
		for (i=0,n=sceneParms.length;i < n;i++)
		this._sceneUniformParamsMap.addShaderUniform(sceneParms[i]);
		this._cameraUniformParamsMap=LayaGL.instance.createCommandEncoder(cameraParms.length *4 *5+4,64,true);
		for (i=0,n=cameraParms.length;i < n;i++)
		this._cameraUniformParamsMap.addShaderUniform(cameraParms[i]);
		this._spriteUniformParamsMap=LayaGL.instance.createCommandEncoder(spriteParms.length *4 *5+4,64,true);
		for (i=0,n=spriteParms.length;i < n;i++)
		this._spriteUniformParamsMap.addShaderUniform(spriteParms[i]);
		this._materialUniformParamsMap=LayaGL.instance.createCommandEncoder(materialParms.length *4 *5+4,64,true);
		for (i=0,n=materialParms.length;i < n;i++)
		this._materialUniformParamsMap.addShaderUniform(materialParms[i]);
		this._customUniformParamsMap.length=customParms.length;
		for (i=0,n=customParms.length;i < n;i++){
			var custom=customParms[i];
			this._customUniformParamsMap[custom.dataOffset]=custom;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._disposeResource=function(){
		LayaGL.instance.deleteShader(this._vshader);
		LayaGL.instance.deleteShader(this._pshader);
		LayaGL.instance.deleteProgram(this._program);
		this._vshader=this._pshader=this._program=null;
		this._setGPUMemory(0);
		this._curActTexIndex=0;
	}

	/**
	*@private
	*/
	__proto._addShaderUnifiormFun=function(one){
		var gl=LayaGL.instance;
		one.caller=this;
		var isArray=one.isArray;
		switch (one.type){
			case /*laya.webgl.WebGLContext.BOOL*/0x8B56:
				one.fun=this._uniform1i;
				one.uploadedValue=new Array(1);
				break ;
			case /*laya.webgl.WebGLContext.INT*/0x1404:
				one.fun=isArray ? this._uniform1iv :this._uniform1i;
				one.uploadedValue=new Array(1);
				break ;
			case /*laya.webgl.WebGLContext.FLOAT*/0x1406:
				one.fun=isArray ? this._uniform1fv :this._uniform1f;
				one.uploadedValue=new Array(1);
				break ;
			case /*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50:
				one.fun=isArray ? this._uniform_vec2v :this._uniform_vec2;
				one.uploadedValue=new Array(2);
				break ;
			case /*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51:
				one.fun=isArray ? this._uniform_vec3v :this._uniform_vec3;
				one.uploadedValue=new Array(3);
				break ;
			case /*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52:
				one.fun=isArray ? this._uniform_vec4v :this._uniform_vec4;
				one.uploadedValue=new Array(4);
				break ;
			case /*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A:
				one.fun=this._uniformMatrix2fv;
				break ;
			case /*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B:
				one.fun=this._uniformMatrix3fv;
				break ;
			case /*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C:
				one.fun=isArray ? this._uniformMatrix4fv :this._uniformMatrix4f;
				break ;
			case /*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E:
				gl.uniform1i(one.location,this._curActTexIndex);
				one.textureID=WebGLContext._glTextureIDs[this._curActTexIndex++];
				one.fun=this._uniform_sampler2D;
				break ;
			case 0x8b5f:
				gl.uniform1i(one.location,this._curActTexIndex);
				one.textureID=WebGLContext._glTextureIDs[this._curActTexIndex++];
				one.fun=this._uniform_sampler3D;
				break ;
			case /*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60:
				gl.uniform1i(one.location,this._curActTexIndex);
				one.textureID=WebGLContext._glTextureIDs[this._curActTexIndex++];
				one.fun=this._uniform_samplerCube;
				break ;
			default :
				throw new Error("compile shader err!");
				break ;
			}
	}

	/**
	*@private
	*/
	__proto._createShader=function(gl,str,type){
		var shader=gl.createShader(type);
		gl.shaderSource(shader,str);
		gl.compileShader(shader);
		if (Shader3D.debugMode && !gl.getShaderParameter(shader,/*laya.webgl.WebGLContext.COMPILE_STATUS*/0x8B81))
			throw gl.getShaderInfoLog(shader);
		return shader;
	}

	/**
	*@private
	*/
	__proto._uniform1f=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value){
			LayaGL.instance.uniform1f(one.location,uploadedValue[0]=value);
			return 1;
		}
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform1fv=function(one,value){
		if (value.length < 4){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				LayaGL.instance.uniform1fv(one.location,value);
				uploadedValue[0]=value[0];
				uploadedValue[1]=value[1];
				uploadedValue[2]=value[2];
				uploadedValue[3]=value[3];
				return 1;
			}
			return 0;
			}else {
			LayaGL.instance.uniform1fv(one.location,value);
			return 1;
		}
	}

	/**
	*@private
	*/
	__proto._uniform_vec2=function(one,v){
		var value=v.elements;
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
			LayaGL.instance.uniform2f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
			return 1;
		}
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform_vec2v=function(one,value){
		if (value.length < 2){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				LayaGL.instance.uniform2fv(one.location,value);
				uploadedValue[0]=value[0];
				uploadedValue[1]=value[1];
				uploadedValue[2]=value[2];
				uploadedValue[3]=value[3];
				return 1;
			}
			return 0;
			}else {
			LayaGL.instance.uniform2fv(one.location,value);
			return 1;
		}
	}

	/**
	*@private
	*/
	__proto._uniform_vec3=function(one,v){
		var value=v.elements;
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
			LayaGL.instance.uniform3f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
			return 1;
		}
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform_vec3v=function(one,v){
		LayaGL.instance.uniform3fv(one.location,v);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniform_vec4=function(one,v){
		var value=v.elements;
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
			LayaGL.instance.uniform4f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
			return 1;
		}
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform_vec4v=function(one,v){
		LayaGL.instance.uniform4fv(one.location,v);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniformMatrix2fv=function(one,value){
		LayaGL.instance.uniformMatrix2fv(one.location,false,value);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniformMatrix3fv=function(one,value){
		LayaGL.instance.uniformMatrix3fv(one.location,false,value);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniformMatrix4f=function(one,m){
		var value=m.elements;
		LayaGL.instance.uniformMatrix4fv(one.location,false,value);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniformMatrix4fv=function(one,m){
		LayaGL.instance.uniformMatrix4fv(one.location,false,m);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniform1i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value){
			LayaGL.instance.uniform1i(one.location,uploadedValue[0]=value);
			return 1;
		}
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform1iv=function(one,value){
		LayaGL.instance.uniform1iv(one.location,value);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniform_ivec2=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
			LayaGL.instance.uniform2i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
			return 1;
		}
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform_ivec2v=function(one,value){
		LayaGL.instance.uniform2iv(one.location,value);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniform_vec3i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
			LayaGL.instance.uniform3i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
			return 1;
		}
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform_vec3vi=function(one,value){
		LayaGL.instance.uniform3iv(one.location,value);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniform_vec4i=function(one,value){
		var uploadedValue=one.uploadedValue;
		if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
			LayaGL.instance.uniform4i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
			return 1;
		}
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform_vec4vi=function(one,value){
		LayaGL.instance.uniform4iv(one.location,value);
		return 1;
	}

	/**
	*@private
	*/
	__proto._uniform_sampler2D=function(one,texture){
		var value=texture._getSource()|| texture.defaulteTexture._getSource();
		var gl=LayaGL.instance;
		WebGLContext.activeTexture(gl,one.textureID);
		WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
		return 0;
	}

	__proto._uniform_sampler3D=function(one,texture){
		var value=texture._getSource()|| texture.defaulteTexture._getSource();
		var gl=LayaGL.instance;
		WebGLContext.activeTexture(gl,one.textureID);
		WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_3D*/0x806f,value);
		return 0;
	}

	/**
	*@private
	*/
	__proto._uniform_samplerCube=function(one,texture){
		var value=texture._getSource()|| texture.defaulteTexture._getSource();
		var gl=LayaGL.instance;
		WebGLContext.activeTexture(gl,one.textureID);
		WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,value);
		return 0;
	}

	/**
	*@private
	*/
	__proto.bind=function(){
		return WebGLContext.useProgram(LayaGL.instance,this._program);
	}

	/**
	*@private
	*/
	__proto.uploadUniforms=function(shaderUniform,shaderDatas,uploadUnTexture){
		Stat.shaderCall+=LayaGLRunner.uploadShaderUniforms(LayaGL.instance,shaderUniform,shaderDatas,uploadUnTexture);
	}

	/**
	*@private
	*/
	__proto.uploadCustomUniform=function(index,data){
		Stat.shaderCall+=LayaGLRunner.uploadCustomUniform(LayaGL.instance,this._customUniformParamsMap,index,data);
	}

	/**
	*@private
	*[NATIVE]
	*/
	__proto._uniformMatrix2fvForNative=function(one,value){
		LayaGL.instance.uniformMatrix2fvEx(one.location,false,value);
		return 1;
	}

	/**
	*@private
	*[NATIVE]
	*/
	__proto._uniformMatrix3fvForNative=function(one,value){
		LayaGL.instance.uniformMatrix3fvEx(one.location,false,value);
		return 1;
	}

	/**
	*@private
	*[NATIVE]
	*/
	__proto._uniformMatrix4fvForNative=function(one,m){
		LayaGL.instance.uniformMatrix4fvEx(one.location,false,m);
		return 1;
	}

	return ShaderInstance;
})(Resource)


/**
*<code>AnimationClip</code> 类用于动画片段资源。
*/
//class laya.d3.animation.AnimationClip extends laya.resource.Resource
var AnimationClip=(function(_super){
	function AnimationClip(){
		/**@private */
		//this._version=null;
		/**@private */
		//this._duration=NaN;
		/**@private */
		//this._frameRate=0;
		/**@private */
		//this._nodesDic=null;
		/**@private */
		//this._nodesMap=null;
		/**@private */
		//this._events=null;
		/**是否循环。*/
		//this.islooping=false;
		AnimationClip.__super.call(this);
		this._nodes=new KeyframeNodeList();
		this._events=[];
	}

	__class(AnimationClip,'laya.d3.animation.AnimationClip',_super);
	var __proto=AnimationClip.prototype;
	/**
	*获取动画片段时长。
	*/
	__proto.duration=function(){
		return this._duration;
	}

	/**
	*@private
	*/
	__proto._hermiteInterpolate=function(frame,nextFrame,t,dur){
		var t0=frame.outTangent,t1=nextFrame.inTangent;
		if (/*__JS__ */Number.isFinite(t0)&& Number.isFinite(t1)){
			var t2=t *t;
			var t3=t2 *t;
			var a=2.0 *t3-3.0 *t2+1.0;
			var b=t3-2.0 *t2+t;
			var c=t3-t2;
			var d=-2.0 *t3+3.0 *t2;
			return a *frame.value+b *t0 *dur+c *t1 *dur+d *nextFrame.value;
		}else
		return frame.value;
	}

	/**
	*@private
	*/
	__proto._hermiteInterpolateArray=function(frame,nextFrame,t,dur,out){
		var d0=frame.data;
		var d1=nextFrame.data;
		var outTanOffset=out.length;
		var pOffset=outTanOffset *2;
		var a=NaN,b=NaN,c=NaN,d=NaN;
		for (var i=0,n=out.length;i < n;i++){
			var t0=d0[outTanOffset+i],t1=d1[i];
			if (/*__JS__ */Number.isFinite(t0)&& Number.isFinite(t1)){
				if (i===0){
					var t2=t *t;
					var t3=t2 *t;
					a=2.0 *t3-3.0 *t2+1.0;
					b=t3-2.0 *t2+t;
					c=t3-t2;
					d=-2.0 *t3+3.0 *t2;
				}
				out[i]=a *d0[pOffset+i]+b *t0 *dur+c *t1 *dur+d *d1[pOffset+i];
			}else
			out[i]=d0[pOffset+i];
		}
	}

	/**
	*@private
	*/
	__proto._evaluateClipDatasRealTime=function(nodes,playCurTime,realTimeCurrentFrameIndexes,addtive,frontPlay){
		for (var i=0,n=nodes.count;i < n;i++){
			var node=nodes.getNodeByIndex(i);
			var type=node.type;
			var nextFrameIndex=0;
			var keyFrames=node._keyFrames;
			var keyFramesCount=keyFrames.length;
			var frameIndex=realTimeCurrentFrameIndexes[i];
			if (frontPlay){
				if ((frameIndex!==-1)&& (playCurTime < keyFrames[frameIndex].time)){
					frameIndex=-1;
					realTimeCurrentFrameIndexes[i]=frameIndex;
				}
				nextFrameIndex=frameIndex+1;
				while (nextFrameIndex < keyFramesCount){
					if (keyFrames[nextFrameIndex].time > playCurTime)
						break ;
					frameIndex++;
					nextFrameIndex++;
					realTimeCurrentFrameIndexes[i]=frameIndex;
				}
				}else {
				nextFrameIndex=frameIndex+1;
				if ((nextFrameIndex!==keyFramesCount)&& (playCurTime > keyFrames[nextFrameIndex].time)){
					frameIndex=keyFramesCount-1;
					realTimeCurrentFrameIndexes[i]=frameIndex;
				}
				nextFrameIndex=frameIndex+1;
				while (frameIndex >-1){
					if (keyFrames[frameIndex].time < playCurTime)
						break ;
					frameIndex--;
					nextFrameIndex--;
					realTimeCurrentFrameIndexes[i]=frameIndex;
				}
			};
			var isEnd=nextFrameIndex===keyFramesCount;
			switch (type){
				case 0:
					if (frameIndex!==-1){
						var frame=keyFrames [frameIndex];
						if (isEnd){
							node.data=frame.value;
							}else {
							var nextFarme=keyFrames [nextFrameIndex];
							var d=nextFarme.time-frame.time;
							var t=NaN;
							if (d!==0)
								t=(playCurTime-frame.time)/ d;
							else
							t=0;
							node.data=this._hermiteInterpolate(frame,nextFarme,t,d);
						}
						}else {
						node.data=(keyFrames [0]).value;
					}
					if (addtive)
						node.data-=(keyFrames [0]).value;
					break ;
				case 1:
				case 4:;
					var clipData=node.data;
					this._evaluateFrameNodeArrayDatasRealTime(keyFrames,frameIndex,isEnd,playCurTime,3,clipData);
					if (addtive){
						var firstFrameValue=(keyFrames [0]).data;
						clipData[0]-=firstFrameValue[6];
						clipData[1]-=firstFrameValue[7];
						clipData[2]-=firstFrameValue[8];
					}
					break ;
				case 2:
					clipData=node.data;
					this._evaluateFrameNodeArrayDatasRealTime(keyFrames,frameIndex,isEnd,playCurTime,4,clipData);
					if (addtive){
						var tempQuat=AnimationClip._tempQuaternionArray0;
						firstFrameValue=(keyFrames [0]).data;
						Utils3D.quaternionConjugate(firstFrameValue,8,tempQuat);
						Utils3D.quaternionMultiply(tempQuat,clipData,clipData);
					}
					break ;
				case 3:
					clipData=node.data;
					this._evaluateFrameNodeArrayDatasRealTime(keyFrames,frameIndex,isEnd,playCurTime,3,clipData);
					if (addtive){
						firstFrameValue=(keyFrames [0]).data;
						clipData[0] /=firstFrameValue[6];
						clipData[1] /=firstFrameValue[7];
						clipData[2] /=firstFrameValue[8];
					}
					break ;
				default :
					throw "AnimationClip:unknown node type.";
				}
		}
	}

	__proto._evaluateClipDatasRealTimeForNative=function(nodes,playCurTime,realTimeCurrentFrameIndexes,addtive){
		LayaGL.instance.evaluateClipDatasRealTime(nodes._nativeObj,playCurTime,realTimeCurrentFrameIndexes,addtive);
	}

	/**
	*@private
	*/
	__proto._evaluateFrameNodeArrayDatasRealTime=function(keyFrames,frameIndex,isEnd,playCurTime,width,outDatas){
		var dataOffset=width *2;
		if (frameIndex!==-1){
			var frame=keyFrames[frameIndex];
			if (isEnd){
				var frameData=frame.data;
				for (var j=0;j < width;j++)
				outDatas[j]=frameData[dataOffset+j];
				}else {
				var nextKeyFrame=keyFrames[frameIndex+1];
				var t=NaN;
				var startTime=frame.time;
				var d=nextKeyFrame.time-startTime;
				if (d!==0)
					t=(playCurTime-startTime)/ d;
				else
				t=0;
				this._hermiteInterpolateArray(frame,nextKeyFrame,t,d,outDatas);
			}
			}else {
			var firstFrameDatas=keyFrames[0].data;
			for (j=0;j < width;j++)
			outDatas[j]=firstFrameDatas[dataOffset+j];
		}
	}

	/**
	*@private
	*/
	__proto._binarySearchEventIndex=function(time){
		var start=0;
		var end=this._events.length-1;
		var mid=0;
		while (start <=end){
			mid=Math.floor((start+end)/ 2);
			var midValue=this._events[mid].time;
			if (midValue==time)
				return mid;
			else if (midValue > time)
			end=mid-1;
			else
			start=mid+1;
		}
		return start;
	}

	/**
	*添加动画事件。
	*/
	__proto.addEvent=function(event){
		var index=this._binarySearchEventIndex(event.time);
		this._events.splice(index,0,event);
	}

	/**
	*@inheritDoc
	*/
	__proto._disposeResource=function(){
		this._version=null;
		this._nodes=null;
		this._nodesMap=null;
	}

	AnimationClip._parse=function(data,propertyParams,constructParams){
		var clip=new AnimationClip();
		var reader=new Byte(data);
		clip._version=reader.readUTFString();
		switch (clip._version){
			case "LAYAANIMATION:03":
				AnimationClipParser03.parse(clip,reader);
				break ;
			default :
				throw "unknown animationClip version.";
			}
		return clip;
	}

	AnimationClip.load=function(url,complete){
		Laya.loader.create(url,complete,null,/*Laya3D.ANIMATIONCLIP*/"ANIMATIONCLIP");
	}

	__static(AnimationClip,
	['_tempQuaternionArray0',function(){return this._tempQuaternionArray0=new Float32Array(4);}
	]);
	return AnimationClip;
})(Resource)


/**
*<code>TerrainRes</code> 类用于描述地形信息。
*/
//class laya.d3.terrain.TerrainRes extends laya.resource.Resource
var TerrainRes=(function(_super){
	function TerrainRes(){
		this._version=NaN;
		this._cameraCoordinateInverse=false;
		this._gridSize=NaN;
		this._chunkNumX=0;
		this._chunkNumZ=0;
		this._heightDataX=0;
		this._heightDataZ=0;
		this._heightDataBitType=0;
		this._heightDataValue=NaN;
		this._heightDataUrl=null;
		this._detailTextureInfos=null;
		this._chunkInfos=null;
		this._heightData=null;
		this._materialInfo=null;
		this._alphaMaps=null;
		this._normalMaps=null;
		TerrainRes.__super.call(this);
	}

	__class(TerrainRes,'laya.d3.terrain.TerrainRes',_super);
	var __proto=TerrainRes.prototype;
	__proto.parseData=function(data){
		var json=data[0];
		var resouMap=data[1];
		this._version=json.version;
		if (this._version==1.0){
			this._cameraCoordinateInverse=json.cameraCoordinateInverse;
			this._gridSize=json.gridSize;
			this._chunkNumX=json.chunkNumX;
			this._chunkNumZ=json.chunkNumZ;
			var heightData=json.heightData;
			this._heightDataX=heightData.numX;
			this._heightDataZ=heightData.numZ;
			this._heightDataBitType=heightData.bitType;
			this._heightDataValue=heightData.value;
			this._heightDataUrl=resouMap[heightData.url];
			this._materialInfo=new MaterialInfo();
			if (json.material){
				var ambient=json.material.ambient;
				var diffuse=json.material.diffuse;
				var specular=json.material.specular;
				this._materialInfo.ambientColor=new Vector3(ambient[0],ambient[1],ambient[2]);
				this._materialInfo.diffuseColor=new Vector3(diffuse[0],diffuse[1],diffuse[2]);
				this._materialInfo.specularColor=new Vector4(specular[0],specular[1],specular[2],specular[3]);
			};
			var detailTextures=json.detailTexture;
			this._detailTextureInfos=__newvec(detailTextures.length);
			for (var i=0;i < detailTextures.length;i++){
				var detail=detailTextures[i];
				var info=new DetailTextureInfo();
				info.diffuseTexture=resouMap[detail.diffuse];
				info.normalTexture=detail.normal ? resouMap[detail.normal] :null;
				if (detail.scale){
					info.scale=new Vector2(detail.scale[0],detail.scale[1]);
					}else {
					info.scale=new Vector2(1,1);
				}
				if (detail.offset){
					info.offset=new Vector2(detail.offset[0],detail.offset[1]);
					}else {
					info.offset=new Vector2(0,0);
				}
				this._detailTextureInfos[i]=info;
			};
			var alphaMaps=json.alphaMap;
			this._alphaMaps=__newvec(alphaMaps.length);
			for (i=0;i < this._alphaMaps.length;i++){
				this._alphaMaps[i]=json.alphaMap[i];
			};
			var normalMaps=json.normalMap;
			this._normalMaps=__newvec(normalMaps.length);
			for (i=0;i < this._normalMaps.length;i++){
				this._normalMaps[i]=json.normalMap[i];
			};
			var jchunks=json.chunkInfo;
			if (this._chunkNumX *this._chunkNumZ !=jchunks.length){
				alert("terrain data error");
				return false;
			}
			this._chunkInfos=__newvec(jchunks.length);
			for (i=0;i < jchunks.length;i++){
				var jchunk=jchunks[i];
				var chunkinfo=new ChunkInfo();
				var nAlphaMapNum=jchunk.alphaMap.length;
				var nDetailIDNum=jchunk.detailID.length;
				if (nAlphaMapNum !=nDetailIDNum){
					alert("terrain chunk data error");
					return false;
				}
				chunkinfo.alphaMap=__newvec(nAlphaMapNum);
				chunkinfo.detailID=__newvec(nDetailIDNum);
				chunkinfo.normalMap=resouMap[this._normalMaps[jchunk.normalMap]];
				for (var j=0;j < nAlphaMapNum;j++){
					chunkinfo.alphaMap[j]=resouMap[this._alphaMaps[jchunk.alphaMap[j]]];
					var jid=jchunk.detailID[j];
					var nIDNum=jid.length;
					chunkinfo.detailID[j]=new Uint8Array(nIDNum);
					for (var k=0;k < nIDNum;k++){
						chunkinfo.detailID[j][k]=jid[k];
					}
				}
				this._chunkInfos[i]=chunkinfo;
			}
			this._heightData=Loader.getRes(this._heightDataUrl);
			this.onLoadTerrainComplete(this._heightData);
		}
		return true;
	}

	__proto.onLoadTerrainComplete=function(heightData){}
	TerrainRes._parse=function(data,propertyParams,constructParams){
		var terrainRes=new TerrainRes();
		terrainRes.parseData(data);
		return terrainRes;
	}

	TerrainRes.load=function(url,complete){
		Laya.loader.create(url,complete,null,/*Laya3D.TERRAINRES*/"TERRAIN",null,null,1,false);
	}

	return TerrainRes;
})(Resource)


/**
*<code>Mesh</code> 类用于创建文件网格数据模板。
*/
//class laya.d3.resource.models.Mesh extends laya.resource.Resource
var Mesh=(function(_super){
	function Mesh(){
		/**@private */
		this._nativeTriangleMesh=null;
		/**@private */
		this._boundingBox=null;
		/**@private */
		this._boundingSphere=null;
		/**@private */
		this._boundingBoxCorners=null;
		/**@private */
		this._subMeshCount=0;
		/**@private 只读,不允许修改。*/
		this._positions=null;
		/**@private */
		this._subMeshes=null;
		/**@private */
		this._vertexBuffers=null;
		/**@private */
		this._indexBuffer=null;
		/**@private */
		this._boneNames=null;
		/**@private */
		this._inverseBindPoses=null;
		/**@private */
		this._inverseBindPosesBuffer=null;
		/**@private */
		this._bindPoseIndices=null;
		/**@private */
		this._skinDataPathMarks=null;
		/**@private */
		this._vertexCount=0;
		Mesh.__super.call(this);
		this._subMeshes=[];
		this._vertexBuffers=[];
		this._skinDataPathMarks=[];
		this._boundingBoxCorners=__newvec(8,null);
	}

	__class(Mesh,'laya.d3.resource.models.Mesh',_super);
	var __proto=Mesh.prototype;
	/**
	*@private
	*/
	__proto._generateBoundingObject=function(){
		this._boundingSphere=new BoundSphere(new Vector3(),0);
		BoundSphere.createfromPoints(this._positions,this._boundingSphere);
		this._boundingBox=new BoundBox(new Vector3(),new Vector3());
		BoundBox.createfromPoints(this._positions,this._boundingBox);
		this._boundingBox.getCorners(this._boundingBoxCorners);
	}

	/**
	*获取网格顶点，并产生数据
	*@return 网格顶点。
	*/
	__proto._getPositions=function(){
		var vertices=[];
		var i=0,j=0,vertexBuffer,positionElement,vertexElements,vertexElement,ofset=0,verticesData;
		var vertexBufferCount=this._vertexBuffers.length;
		for (i=0;i < vertexBufferCount;i++){
			vertexBuffer=this._vertexBuffers[i];
			vertexElements=vertexBuffer.vertexDeclaration.vertexElements;
			for (j=0;j < vertexElements.length;j++){
				vertexElement=vertexElements[j];
				if (vertexElement.elementFormat===/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3" && vertexElement.elementUsage===/*laya.d3.graphics.Vertex.VertexMesh.MESH_POSITION0*/0){
					positionElement=vertexElement;
					break ;
				}
			}
			verticesData=vertexBuffer.getData();
			for (j=0;j < verticesData.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
				ofset=j+positionElement.offset / 4;
				vertices.push(new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]));
			}
		}
		return vertices;
	}

	/**
	*@private
	*/
	__proto._setSubMeshes=function(subMeshes){
		this._subMeshes=subMeshes
		this._subMeshCount=subMeshes.length;
		for (var i=0;i < this._subMeshCount;i++)
		subMeshes[i]._indexInMesh=i;
		this._positions=this._getPositions();
		this._generateBoundingObject();
	}

	/**
	*@inheritDoc
	*/
	__proto._getSubMesh=function(index){
		return this._subMeshes[index];
	}

	/**
	*@inheritDoc
	*/
	__proto._disposeResource=function(){
		for (var i=0,n=this._subMeshes.length;i < n;i++)
		this._subMeshes[i].destroy();
		this._nativeTriangleMesh && Laya3D._physics3D.destroy(this._nativeTriangleMesh);
		for (i=0,n=this._vertexBuffers.length;i < n;i++)
		this._vertexBuffers[i].destroy();
		this._indexBuffer.destroy();
		this._setCPUMemory(0);
		this._setGPUMemory(0);
		this._vertexBuffers=null;
		this._indexBuffer=null;
		this._subMeshes=null;
		this._nativeTriangleMesh=null;
		this._vertexBuffers=null;
		this._indexBuffer=null;
		this._boneNames=null;
		this._inverseBindPoses=null;
	}

	/**
	*@private
	*/
	__proto._getPhysicMesh=function(){
		if (!this._nativeTriangleMesh){
			var physics3D=Laya3D._physics3D;
			var triangleMesh=new physics3D.btTriangleMesh();
			var nativePositio0=Mesh._nativeTempVector30;
			var nativePositio1=Mesh._nativeTempVector31;
			var nativePositio2=Mesh._nativeTempVector32;
			var positions=this._getPositions();
			var indices=this._indexBuffer.getData();
			for (var i=0,n=indices.length;i < n;i+=3){
				var position0=positions[indices[i]];
				var position1=positions[indices[i+1]];
				var position2=positions[indices[i+2]];
				Utils3D._convertToBulletVec3(position0,nativePositio0,true);
				Utils3D._convertToBulletVec3(position1,nativePositio1,true);
				Utils3D._convertToBulletVec3(position2,nativePositio2,true);
				triangleMesh.addTriangle(nativePositio0,nativePositio1,nativePositio2,true);
			}
			this._nativeTriangleMesh=triangleMesh;
		}
		return this._nativeTriangleMesh;
	}

	/**
	*获取网格的全局默认绑定动作逆矩阵。
	*@return 网格的全局默认绑定动作逆矩阵。
	*/
	__getset(0,__proto,'inverseAbsoluteBindPoses',function(){
		return this._inverseBindPoses;
	});

	/**
	*获取顶点个数
	*/
	__getset(0,__proto,'vertexCount',function(){
		return this._vertexCount;
	});

	/**
	*获取SubMesh的个数。
	*@return SubMesh的个数。
	*/
	__getset(0,__proto,'subMeshCount',function(){
		return this._subMeshCount;
	});

	/**
	*获取AABB包围盒,禁止修改其数据。
	*@return AABB包围盒。
	*/
	__getset(0,__proto,'boundingBox',function(){
		return this._boundingBox;
	});

	/**
	*获取包围球顶点,禁止修改其数据。
	*@return 包围球。
	*/
	__getset(0,__proto,'boundingBoxCorners',function(){
		return this._boundingBoxCorners;
	});

	/**
	*获取包围球,禁止修改其数据。
	*@return 包围球。
	*/
	__getset(0,__proto,'boundingSphere',function(){
		return this._boundingSphere;
	});

	Mesh._parse=function(data,propertyParams,constructParams){
		var mesh=new Mesh();
		MeshReader.read(data,mesh,mesh._subMeshes);
		return mesh;
	}

	Mesh.load=function(url,complete){
		Laya.loader.create(url,complete,null,/*Laya3D.MESH*/"MESH");
	}

	__static(Mesh,
	['_nativeTempVector30',function(){return this._nativeTempVector30=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeTempVector31',function(){return this._nativeTempVector31=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeTempVector32',function(){return this._nativeTempVector32=new Laya3D._physics3D.btVector3(0,0,0);}
	]);
	return Mesh;
})(Resource)


/**
*<code>MeshRender</code> 类用于网格渲染器。
*/
//class laya.d3.terrain.TerrainRender extends laya.d3.core.render.BaseRender
var TerrainRender=(function(_super){
	function TerrainRender(owner){
		/**@private */
		this._terrainSprite3DOwner=null;
		/**@private */
		this._projectionViewWorldMatrix=null;
		TerrainRender.__super.call(this,owner);
		this._terrainSprite3DOwner=owner;
		this._projectionViewWorldMatrix=new Matrix4x4();
	}

	__class(TerrainRender,'laya.d3.terrain.TerrainRender',_super);
	var __proto=TerrainRender.prototype;
	__proto._calculateBoundingSphere=function(){
		var terrainFilter=this._terrainSprite3DOwner.terrainFilter;
		if (terrainFilter==null){
			this._boundingSphere.toDefault();
			}else {
			var meshBoundingSphere=terrainFilter._boundingSphere;
			var maxScale=NaN;
			var transform=this._terrainSprite3DOwner.transform;
			var scale=transform.scale;
			if (scale.x >=scale.y && scale.x >=scale.z)
				maxScale=scale.x;
			else
			maxScale=scale.y >=scale.z ? scale.y :scale.z;
			Vector3.transformCoordinate(meshBoundingSphere.center,transform.worldMatrix,this._boundingSphere.center);
			this._boundingSphere.radius=meshBoundingSphere.radius *maxScale;
			terrainFilter.calcLeafBoudingSphere(transform.worldMatrix,maxScale);
			if (Render.isConchApp){
				var centerE=this._boundingSphere.center.elements;
				var buffer=FrustumCulling._cullingBuffer;
				buffer[this._cullingBufferIndex+1]=centerE[0];
				buffer[this._cullingBufferIndex+2]=centerE[1];
				buffer[this._cullingBufferIndex+3]=centerE[2];
				buffer[this._cullingBufferIndex+4]=this._boundingSphere.radius;
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._needRender=function(boundFrustum){
		if (boundFrustum)
			return boundFrustum.containsBoundSphere(this.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0;
		else
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		var terrainFilter=this._terrainSprite3DOwner.terrainFilter;
		if (terrainFilter==null){
			this._boundingBox.toDefault();
			}else {
			var worldMat=this._terrainSprite3DOwner.transform.worldMatrix;
			var corners=terrainFilter._boundingBoxCorners;
			for (var i=0;i < 8;i++)
			Vector3.transformCoordinate(corners[i],worldMat,BaseRender._tempBoundBoxCorners[i]);
			BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
			terrainFilter.calcLeafBoudingBox(worldMat);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdate=function(context,transform){
		this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX,transform.worldMatrix);
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdateWithCamera=function(context,transform){
		var projectionView=context.projectionViewMatrix;
		Matrix4x4.multiply(projectionView,transform.worldMatrix,this._projectionViewWorldMatrix);
		this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX,this._projectionViewWorldMatrix);
	}

	/**
	*@private
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		this._terrainSprite3DOwner=null;
	}

	return TerrainRender;
})(BaseRender)


/**
*<code>PixelLineRenderer</code> 类用于线渲染器。
*/
//class laya.d3.core.pixelLine.PixelLineRenderer extends laya.d3.core.render.BaseRender
var PixelLineRenderer=(function(_super){
	function PixelLineRenderer(owner){
		/**@private */
		this._projectionViewWorldMatrix=null;
		PixelLineRenderer.__super.call(this,owner);
		this._projectionViewWorldMatrix=new Matrix4x4();
	}

	__class(PixelLineRenderer,'laya.d3.core.pixelLine.PixelLineRenderer',_super);
	var __proto=PixelLineRenderer.prototype;
	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		var minE=this._boundingBox.min.elements;
		minE[0]=-Number.MAX_VALUE;
		minE[1]=-Number.MAX_VALUE;
		minE[2]=-Number.MAX_VALUE;
		var maxE=this._boundingBox.min.elements;
		maxE[0]=Number.MAX_VALUE;
		maxE[1]=Number.MAX_VALUE;
		maxE[2]=Number.MAX_VALUE;
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingSphere=function(){
		var centerE=this._boundingSphere.center.elements;
		centerE[0]=0;
		centerE[1]=0;
		centerE[2]=0;
		this._boundingSphere.radius=Number.MAX_VALUE;
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdateWithCamera=function(context,transform){
		var projectionView=context.projectionViewMatrix;
		var sv=this._shaderValues;
		if (transform){
			var worldMat=transform.worldMatrix;
			sv.setMatrix4x4(Sprite3D.WORLDMATRIX,worldMat);
			Matrix4x4.multiply(projectionView,worldMat,this._projectionViewWorldMatrix);
			sv.setMatrix4x4(Sprite3D.MVPMATRIX,this._projectionViewWorldMatrix);
			}else {
			sv.setMatrix4x4(Sprite3D.WORLDMATRIX,Matrix4x4.DEFAULT);
			sv.setMatrix4x4(Sprite3D.MVPMATRIX,projectionView);
		}
	}

	return PixelLineRenderer;
})(BaseRender)


/**
*<code>TrailRenderer</code> 类用于创建拖尾渲染器。
*/
//class laya.d3.core.trail.TrailRenderer extends laya.d3.core.render.BaseRender
var TrailRenderer=(function(_super){
	function TrailRenderer(owner){
		this._projectionViewWorldMatrix=new Matrix4x4();
		TrailRenderer.__super.call(this,owner);
	}

	__class(TrailRenderer,'laya.d3.core.trail.TrailRenderer',_super);
	var __proto=TrailRenderer.prototype;
	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		var minE=this._boundingBox.min.elements;
		minE[0]=-Number.MAX_VALUE;
		minE[1]=-Number.MAX_VALUE;
		minE[2]=-Number.MAX_VALUE;
		var maxE=this._boundingBox.min.elements;
		maxE[0]=Number.MAX_VALUE;
		maxE[1]=Number.MAX_VALUE;
		maxE[2]=Number.MAX_VALUE;
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingSphere=function(){
		this._owner.transform.position.cloneTo(this._boundingSphere.center);
		this._boundingSphere.radius=Number.MAX_VALUE;
	}

	/**
	*@inheritDoc
	*/
	__proto._needRender=function(boundFrustum){
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdate=function(state,transform){
		_super.prototype._renderUpdate.call(this,state,transform);
		(this._owner).trailFilter._update(state);
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdateWithCamera=function(context,transform){
		var projectionView=context.projectionViewMatrix;
		if (transform){
			Matrix4x4.multiply(projectionView,transform.worldMatrix,this._projectionViewWorldMatrix);
			this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX,this._projectionViewWorldMatrix);
			}else {
			this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX,projectionView);
		}
		if (Laya3D.debugMode)
			this._renderRenderableBoundBox();
	}

	return TrailRenderer;
})(BaseRender)


/**
*<code>MeshRenderer</code> 类用于网格渲染器。
*/
//class laya.d3.core.MeshRenderer extends laya.d3.core.render.BaseRender
var MeshRenderer=(function(_super){
	function MeshRenderer(owner){
		/**@private */
		//this._projectionViewWorldMatrix=null;
		MeshRenderer.__super.call(this,owner);
		this._projectionViewWorldMatrix=new Matrix4x4();
	}

	__class(MeshRenderer,'laya.d3.core.MeshRenderer',_super);
	var __proto=MeshRenderer.prototype;
	/**
	*@private
	*/
	__proto._onMeshChange=function(mesh){
		this._boundingSphereNeedChange=true;
		this._boundingBoxNeedChange=true;
		this._boundingBoxCenterNeedChange=true;
		this._octreeNodeNeedChange=true;
	}

	/**
	*@private
	*/
	__proto._calculateBoundingSphereByInitSphere=function(boundSphere){
		var maxScale=NaN;
		var transform=this._owner.transform;
		var scaleE=transform.scale.elements;
		var scaleX=scaleE[0];
		scaleX || (scaleX=-scaleX);
		var scaleY=scaleE[1];
		scaleY || (scaleY=-scaleY);
		var scaleZ=scaleE[2];
		scaleZ || (scaleZ=-scaleZ);
		if (scaleX >=scaleY && scaleX >=scaleZ)
			maxScale=scaleX;
		else
		maxScale=scaleY >=scaleZ ? scaleY :scaleZ;
		Vector3.transformCoordinate(boundSphere.center,transform.worldMatrix,this._boundingSphere.center);
		this._boundingSphere.radius=boundSphere.radius *maxScale;
		if (Render.isConchApp){
			var centerE=this._boundingSphere.center.elements;
			var buffer=FrustumCulling._cullingBuffer;
			buffer[this._cullingBufferIndex+1]=centerE[0];
			buffer[this._cullingBufferIndex+2]=centerE[1];
			buffer[this._cullingBufferIndex+3]=centerE[2];
			buffer[this._cullingBufferIndex+4]=this._boundingSphere.radius;
		}
	}

	/**
	*@private
	*/
	__proto._calculateBoundBoxByInitCorners=function(corners){
		var worldMat=(this._owner).transform.worldMatrix;
		for (var i=0;i < 8;i++)
		BoundBox.createfromPoints(BaseRender._tempBoundBoxCorners,this._boundingBox);
		Vector3.transformCoordinate(corners[i],worldMat,BaseRender._tempBoundBoxCorners[i]);
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingSphere=function(){
		var sharedMesh=(this._owner).meshFilter.sharedMesh;
		if (sharedMesh==null || sharedMesh.boundingSphere==null)
			this._boundingSphere.toDefault();
		else
		this._calculateBoundingSphereByInitSphere(sharedMesh.boundingSphere);
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		var sharedMesh=(this._owner).meshFilter.sharedMesh;
		if (sharedMesh==null || sharedMesh.boundingBox==null)
			this._boundingBox.toDefault();
		else
		this._calculateBoundBoxByInitCorners(sharedMesh.boundingBoxCorners);
	}

	/**
	*@inheritDoc
	*/
	__proto._needRender=function(boundFrustum){
		if (boundFrustum)
			return boundFrustum.containsBoundSphere(this.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0;
		else
		return true;
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdate=function(context,transform){
		if (transform)
			this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX,transform.worldMatrix);
		else
		this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX,Matrix4x4.DEFAULT);
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdateWithCamera=function(context,transform){
		var projectionView=context.projectionViewMatrix;
		if (transform){
			Matrix4x4.multiply(projectionView,transform.worldMatrix,this._projectionViewWorldMatrix);
			this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX,this._projectionViewWorldMatrix);
			}else {
			this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX,projectionView);
		}
		if (Laya3D.debugMode)
			this._renderRenderableBoundBox();
	}

	/**
	*@inheritDoc
	*/
	__proto._destroy=function(){
		(this._isPartOfStaticBatch)&& (MeshRenderStaticBatchManager.instance._destroyRenderSprite(this._owner));
		_super.prototype._destroy.call(this);
	}

	return MeshRenderer;
})(BaseRender)


/**
*<code>PhysicsTriggerComponent</code> 类用于创建物理触发器组件。
*/
//class laya.d3.physics.PhysicsTriggerComponent extends laya.d3.physics.PhysicsComponent
var PhysicsTriggerComponent=(function(_super){
	function PhysicsTriggerComponent(collisionGroup,canCollideWith){
		/**@private */
		this._isTrigger=false;
		PhysicsTriggerComponent.__super.call(this,collisionGroup,canCollideWith);
	}

	__class(PhysicsTriggerComponent,'laya.d3.physics.PhysicsTriggerComponent',_super);
	var __proto=PhysicsTriggerComponent.prototype;
	/**
	*@inheritDoc
	*/
	__proto._onAdded=function(){
		_super.prototype._onAdded.call(this);
		this.isTrigger=this._isTrigger;
	}

	/**
	*@inheritDoc
	*/
	__proto._cloneTo=function(dest){
		_super.prototype._cloneTo.call(this,dest);
		(dest).isTrigger=this._isTrigger;
	}

	/**
	*设置是否为触发器。
	*@param value 是否为触发器。
	*/
	/**
	*获取是否为触发器。
	*@return 是否为触发器。
	*/
	__getset(0,__proto,'isTrigger',function(){
		return this._isTrigger;
		},function(value){
		this._isTrigger=value;
		if (this._nativeColliderObject){
			if (this._enabled && value){
				var flags=this._nativeColliderObject.getCollisionFlags();
				if ((flags & 4)===0)
					this._nativeColliderObject.setCollisionFlags(flags | 4);
			}
		}
	});

	return PhysicsTriggerComponent;
})(PhysicsComponent)


/**
*<code>ShurikenParticleRender</code> 类用于创建3D粒子渲染器。
*/
//class laya.d3.core.particleShuriKen.ShurikenParticleRenderer extends laya.d3.core.render.BaseRender
var ShurikenParticleRenderer=(function(_super){
	function ShurikenParticleRenderer(owner){
		/**@private */
		//this._defaultBoundBox=null;
		/**@private */
		//this._renderMode=0;
		/**@private */
		//this._mesh=null;
		/**拉伸广告牌模式摄像机速度缩放,暂不支持。*/
		//this.stretchedBillboardCameraSpeedScale=NaN;
		/**拉伸广告牌模式速度缩放。*/
		//this.stretchedBillboardSpeedScale=NaN;
		/**拉伸广告牌模式长度缩放。*/
		//this.stretchedBillboardLengthScale=NaN;
		this._finalGravity=new Vector3();
		this._tempRotationMatrix=new Matrix4x4();
		ShurikenParticleRenderer.__super.call(this,owner);
		this._defaultBoundBox=new BoundBox(new Vector3(),new Vector3());
		this._renderMode=-1;
		this.stretchedBillboardCameraSpeedScale=0.0;
		this.stretchedBillboardSpeedScale=0.0;
		this.stretchedBillboardLengthScale=1.0;
	}

	__class(ShurikenParticleRenderer,'laya.d3.core.particleShuriKen.ShurikenParticleRenderer',_super);
	var __proto=ShurikenParticleRenderer.prototype;
	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		var minE=this._boundingBox.min.elements;
		minE[0]=-Number.MAX_VALUE;
		minE[1]=-Number.MAX_VALUE;
		minE[2]=-Number.MAX_VALUE;
		var maxE=this._boundingBox.min.elements;
		maxE[0]=Number.MAX_VALUE;
		maxE[1]=Number.MAX_VALUE;
		maxE[2]=Number.MAX_VALUE;
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingSphere=function(){
		var oriBoundSphere=(this._owner).particleSystem._boundingSphere;
		var maxScale=NaN;
		var transform=this._owner.transform;
		var scaleE=transform.scale.elements;
		var scaleX=Math.abs(scaleE[0]);
		var scaleY=Math.abs(scaleE[1]);
		var scaleZ=Math.abs(scaleE[2]);
		if (scaleX >=scaleY && scaleX >=scaleZ)
			maxScale=scaleX;
		else
		maxScale=scaleY >=scaleZ ? scaleY :scaleZ;
		Vector3.transformCoordinate(oriBoundSphere.center,transform.worldMatrix,this._boundingSphere.center);
		this._boundingSphere.radius=oriBoundSphere.radius *maxScale;
		if (Render.isConchApp){
			var centerE=this._boundingSphere.center.elements;
			var buffer=FrustumCulling._cullingBuffer;
			buffer[this._cullingBufferIndex+1]=centerE[0];
			buffer[this._cullingBufferIndex+2]=centerE[1];
			buffer[this._cullingBufferIndex+3]=centerE[2];
			buffer[this._cullingBufferIndex+4]=this._boundingSphere.radius;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._needRender=function(boundFrustum){
		if (boundFrustum){
			if (boundFrustum.containsBoundSphere(this.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
				if ((this._owner).particleSystem.isAlive)
					return true;
				else
				return false;
				}else {
				return false;
			}
			}else {
			return true;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdate=function(context,transfrom){
		var particleSystem=(this._owner).particleSystem;
		var sv=this._shaderValues;
		var transform=this._owner.transform;
		switch (particleSystem.simulationSpace){
			case 0:
				break ;
			case 1:
				sv.setVector(ShuriKenParticle3D.WORLDPOSITION,transform.position);
				sv.setQuaternion(ShuriKenParticle3D.WORLDROTATION,transform.rotation);
				break ;
			default :
				throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
			}
		switch (particleSystem.scaleMode){
			case 0:;
				var scale=transform.scale;
				sv.setVector(ShuriKenParticle3D.POSITIONSCALE,scale);
				sv.setVector(ShuriKenParticle3D.SIZESCALE,scale);
				break ;
			case 1:;
				var localScale=transform.localScale;
				sv.setVector(ShuriKenParticle3D.POSITIONSCALE,localScale);
				sv.setVector(ShuriKenParticle3D.SIZESCALE,localScale);
				break ;
			case 2:
				sv.setVector(ShuriKenParticle3D.POSITIONSCALE,transform.scale);
				sv.setVector(ShuriKenParticle3D.SIZESCALE,Vector3.ONE);
				break ;
			}
		Vector3.scale(Physics3DUtils.gravity,particleSystem.gravityModifier,this._finalGravity);
		sv.setVector(ShuriKenParticle3D.GRAVITY,this._finalGravity);
		sv.setInt(ShuriKenParticle3D.SIMULATIONSPACE,particleSystem.simulationSpace);
		sv.setBool(ShuriKenParticle3D.THREEDSTARTROTATION,particleSystem.threeDStartRotation);
		sv.setInt(ShuriKenParticle3D.SCALINGMODE,particleSystem.scaleMode);
		sv.setNumber(ShuriKenParticle3D.STRETCHEDBILLBOARDLENGTHSCALE,this.stretchedBillboardLengthScale);
		sv.setNumber(ShuriKenParticle3D.STRETCHEDBILLBOARDSPEEDSCALE,this.stretchedBillboardSpeedScale);
		sv.setNumber(ShuriKenParticle3D.CURRENTTIME,particleSystem._currentTime);
		if (Laya3D.debugMode)
			this._renderRenderableBoundBox();
	}

	/**
	*@inheritDoc
	*/
	__proto._destroy=function(){
		_super.prototype._destroy.call(this);
		(this._mesh)&& (this._mesh._removeReference(),this._mesh=null);
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'boundingBox',function(){
		if (!(this._owner).particleSystem.isAlive){
			return this._defaultBoundBox;
			}else {
			if (this._boundingBoxNeedChange){
				this._calculateBoundingBox();
				this._boundingBoxNeedChange=false;
			}
			return this._boundingBox;
		}
	});

	/**
	*设置渲染模式,0为BILLBOARD、1为STRETCHEDBILLBOARD、2为HORIZONTALBILLBOARD、3为VERTICALBILLBOARD、4为MESH。
	*@param value 渲染模式。
	*/
	/**
	*获取渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',function(){
		return this._renderMode;
		},function(value){
		if (this._renderMode!==value){
			var defineDatas=this._defineDatas;
			switch (this._renderMode){
				case 0:
					defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD);
					break ;
				case 1:
					defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
					break ;
				case 2:
					defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
					break ;
				case 3:
					defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
					break ;
				case 4:
					defineDatas.remove(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH);
					break ;
				}
			this._renderMode=value;
			switch (value){
				case 0:
					defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD);
					break ;
				case 1:
					defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
					break ;
				case 2:
					defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
					break ;
				case 3:
					defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
					break ;
				case 4:
					defineDatas.add(ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH);
					break ;
				default :
					throw new Error("ShurikenParticleRender: unknown renderMode Value.");
				}
			(this._owner).particleSystem._initBufferDatas();
		}
	});

	/**
	*设置网格渲染模式所使用的Mesh,rendderMode为4时生效。
	*@param value 网格模式所使用Mesh。
	*/
	/**
	*获取网格渲染模式所使用的Mesh,rendderMode为4时生效。
	*@return 网格模式所使用Mesh。
	*/
	__getset(0,__proto,'mesh',function(){
		return this._mesh
		},function(value){
		if (this._mesh!==value){
			(this._mesh)&& (this._mesh._removeReference());
			this._mesh=value;
			(value)&& (value._addReference());
			(this._owner).particleSystem._initBufferDatas();
		}
	});

	return ShurikenParticleRenderer;
})(BaseRender)


/**
*<code>CharacterController</code> 类用于创建角色控制器。
*/
//class laya.d3.physics.CharacterController extends laya.d3.physics.PhysicsComponent
var CharacterController=(function(_super){
	function CharacterController(stepheight,upAxis,collisionGroup,canCollideWith){
		/**@private */
		//this._stepHeight=NaN;
		/**@private */
		this._maxSlope=45.0;
		/**@private */
		this._jumpSpeed=10.0;
		/**@private */
		this._fallSpeed=55.0;
		/**@private */
		//this._nativeKinematicCharacter=null;
		this._upAxis=new Vector3(0,1,0);
		this._gravity=new Vector3(0,-9.8 *3,0);
		(stepheight===void 0)&& (stepheight=0.1);
		(collisionGroup===void 0)&& (collisionGroup=/*laya.d3.utils.Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER*/0x1);
		(canCollideWith===void 0)&& (canCollideWith=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		this._stepHeight=stepheight;
		(upAxis)&& (this._upAxis=upAxis);
		CharacterController.__super.call(this,collisionGroup,canCollideWith);
	}

	__class(CharacterController,'laya.d3.physics.CharacterController',_super);
	var __proto=CharacterController.prototype;
	/**
	*@private
	*/
	__proto._constructCharacter=function(){
		var physics3D=Laya3D._physics3D;
		if (this._nativeKinematicCharacter)
			physics3D.destroy(this._nativeKinematicCharacter);
		var nativeUpAxis=CharacterController._nativeTempVector30;
		nativeUpAxis.setValue(this._upAxis.x,this._upAxis.y,this._upAxis.z);
		this._nativeKinematicCharacter=new physics3D.btKinematicCharacterController(this._nativeColliderObject,this._colliderShape._nativeShape,this._stepHeight,nativeUpAxis);
		this.fallSpeed=this._fallSpeed;
		this.maxSlope=this._maxSlope;
		this.jumpSpeed=this._jumpSpeed;
		this.gravity=this._gravity;
	}

	/**
	*@inheritDoc
	*/
	__proto._onShapeChange=function(colShape){
		_super.prototype._onShapeChange.call(this,colShape);
		this._constructCharacter();
	}

	/**
	*@inheritDoc
	*/
	__proto._onAdded=function(){
		var physics3D=Laya3D._physics3D;
		var ghostObject=new physics3D.btPairCachingGhostObject();
		ghostObject.setUserIndex(this.id);
		ghostObject.setCollisionFlags(16);
		this._nativeColliderObject=ghostObject;
		if (this._colliderShape)
			this._constructCharacter();
		_super.prototype._onAdded.call(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._addToSimulation=function(){
		this._simulation._characters.push(this);
		this._simulation._addCharacter(this,this._collisionGroup,this._canCollideWith);
	}

	/**
	*@inheritDoc
	*/
	__proto._removeFromSimulation=function(){
		this._simulation._removeCharacter(this);
		var characters=this._simulation._characters;
		characters.splice(characters.indexOf(this),1);
	}

	/**
	*@inheritDoc
	*/
	__proto._cloneTo=function(dest){
		_super.prototype._cloneTo.call(this,dest);
		var destCharacterController=dest;
		destCharacterController.stepHeight=this._stepHeight;
		destCharacterController.upAxis=this._upAxis;
		destCharacterController.maxSlope=this._maxSlope;
		destCharacterController.jumpSpeed=this._jumpSpeed;
		destCharacterController.fallSpeed=this._fallSpeed;
		destCharacterController.gravity=this._gravity;
	}

	/**
	*@inheritDoc
	*/
	__proto._onDestroy=function(){
		Laya3D._physics3D.destroy(this._nativeKinematicCharacter);
		_super.prototype._onDestroy.call(this);
		this._nativeKinematicCharacter=null;
	}

	/**
	*通过指定移动向量移动角色。
	*@param movement 移动向量。
	*/
	__proto.move=function(movement){
		var movementE=movement.elements;
		var nativeMovement=PhysicsComponent._nativeVector30;
		nativeMovement.setValue(-movementE[0],movementE[1],movementE[2]);
		this._nativeKinematicCharacter.setWalkDirection(nativeMovement);
	}

	/**
	*跳跃。
	*@param velocity 跳跃速度。
	*/
	__proto.jump=function(velocity){
		if (velocity){
			var nativeVelocity=PhysicsComponent._nativeVector30;
			Utils3D._convertToBulletVec3(velocity,nativeVelocity,true);
			this._nativeKinematicCharacter.jump(nativeVelocity);
			}else {
			this._nativeKinematicCharacter.jump();
		}
	}

	/**
	*设置角色降落速度。
	*@param value 角色降落速度。
	*/
	/**
	*获取角色降落速度。
	*@return 角色降落速度。
	*/
	__getset(0,__proto,'fallSpeed',function(){
		return this._fallSpeed;
		},function(value){
		this._fallSpeed=value;
		this._nativeKinematicCharacter.setFallSpeed(value);
	});

	/**
	*设置角色行走的脚步高度，表示可跨越的最大高度。
	*@param value 脚步高度。
	*/
	/**
	*获取角色行走的脚步高度，表示可跨越的最大高度。
	*@return 脚步高度。
	*/
	__getset(0,__proto,'stepHeight',function(){
		return this._stepHeight;
		},function(value){
		this._stepHeight=value;
		this._constructCharacter();
	});

	/**
	*设置角色跳跃速度。
	*@param value 角色跳跃速度。
	*/
	/**
	*获取角色跳跃速度。
	*@return 角色跳跃速度。
	*/
	__getset(0,__proto,'jumpSpeed',function(){
		return this._jumpSpeed;
		},function(value){
		this._jumpSpeed=value;
		this._nativeKinematicCharacter.setJumpSpeed(value);
	});

	/**
	*设置重力。
	*@param value 重力。
	*/
	/**
	*获取重力。
	*@return 重力。
	*/
	__getset(0,__proto,'gravity',function(){
		return this._gravity;
		},function(value){
		this._gravity=value;
		var nativeGravity=CharacterController._nativeTempVector30;
		nativeGravity.setValue(-value.x,value.y,value.z);
		this._nativeKinematicCharacter.setGravity(nativeGravity);
	});

	/**
	*设置最大坡度。
	*@param value 最大坡度。
	*/
	/**
	*获取最大坡度。
	*@return 最大坡度。
	*/
	__getset(0,__proto,'maxSlope',function(){
		return this._maxSlope;
		},function(value){
		this._maxSlope=value;
		this._nativeKinematicCharacter.setMaxSlope((value / 180)*Math.PI);
	});

	/**
	*获取角色是否在地表。
	*/
	__getset(0,__proto,'isGrounded',function(){
		return this._nativeKinematicCharacter.onGround();
	});

	/**
	*设置角色的Up轴。
	*@return 角色的Up轴。
	*/
	/**
	*获取角色的Up轴。
	*@return 角色的Up轴。
	*/
	__getset(0,__proto,'upAxis',function(){
		return this._upAxis;
		},function(value){
		this._upAxis=value;
		this._constructCharacter();
	});

	CharacterController.UPAXIS_X=0;
	CharacterController.UPAXIS_Y=1;
	CharacterController.UPAXIS_Z=2;
	__static(CharacterController,
	['_nativeTempVector30',function(){return this._nativeTempVector30=new Laya3D._physics3D.btVector3(0,0,0);}
	]);
	return CharacterController;
})(PhysicsComponent)


/**
*<code>Scene3D</code> 类用于实现场景。
*/
//class laya.d3.core.scene.Scene3D extends laya.display.Sprite
var Scene3D=(function(_super){
	function Scene3D(){
		/**@private */
		//this._url=null;
		/**@private */
		//this._group=null;
		/**@private */
		//this._lightmaps=null;
		/**@private */
		this._reflectionMode=1;
		/**@private */
		this._enableLightCount=3;
		/**@private */
		//this._renderTargetTexture=null;
		/**@private */
		//this._enableFog=false;
		/**@private */
		//this._physicsSimulation=null;
		/**@private */
		//this._shaderValues=null;
		/**@private */
		//this._defineDatas=null;
		/**是否启用灯光。*/
		this.enableLight=true;
		/**四/八叉树的根节点。*/
		//this.treeRoot=null;
		/**四/八叉树的尺寸。*/
		//this.treeSize=null;
		/**四/八叉树的层数。*/
		//this.treeLevel=0;
		//阴影相关变量
		//this.parallelSplitShadowMaps=null;
		this._time=0;
		/**@private [NATIVE]*/
		//this._glCommandEncoder=null;
		/**@private [NATIVE]*/
		//this._cullingBufferIndices=null;
		/**@private [NATIVE]*/
		//this._cullingBufferResult=null;
		Scene3D.__super.call(this);
		this._lights=[];
		this._skyRenderer=new SkyRenderer();
		this._input=new Input3D();
		this._timer=Laya.timer;
		this._collsionTestList=[];
		this._renders=new SimpleSingletonList();
		this._opaqueQueue=new RenderQueue(false);
		this._transparentQueue=new RenderQueue(true);
		this._cameraPool=[];
		this._animatorPool=new SimpleSingletonList();
		this._scriptPool=new SimpleSingletonList();
		this._castShadowRenders=new CastShadowList();
		this.currentCreationLayer=Math.pow(2,0);
		this._key=new SubmitKey();
		this._pickIdToSprite=new Object();
		if (Render.isConchApp){
			this._glCommandEncoder=LayaGL.instance.createCommandEncoder(102400,2560,false);
			this._conchData._int32Data[ /*laya.display.SpriteConst.POSLAYAGL3D*/26]=this._glCommandEncoder.getPtrID();
			this._renderType |=/*laya.display.SpriteConst.LAYAGL3D*/0x400;
			this._setRenderType(this._renderType);
			var callback=/*__JS__ */this._callbackFuncObj;
			if (!callback){
				callback=/*__JS__ */this._callbackFuncObj=new CallbackFuncObj();
			}
			this._conchData._int32Data[ /*laya.display.SpriteConst.POSCALLBACK_OBJ_ID*/54]=callback.id;
			callback.addCallbackFunc(3,(this.renderCallbackFromNative).bind(this));
			this._conchData._int32Data[ /*laya.display.SpriteConst.POSLAYA3D_FUN_ID*/62]=3;
		}
		if (Laya3D._enbalePhysics)
			this._physicsSimulation=new PhysicsSimulation(Laya3D.physicsSettings);
		this._lightmaps=[];
		this._defineDatas=new DefineDatas();
		this._shaderValues=new ShaderData(null);
		this.parallelSplitShadowMaps=[];
		this.enableFog=false;
		this.fogStart=300;
		this.fogRange=1000;
		this.fogColor=new Vector3(0.7,0.7,0.7);
		this.ambientColor=new Vector3(0.212,0.227,0.259);
		this.reflectionIntensity=1.0;
		(WebGL.shaderHighPrecision)&& (this._defineDatas.add(Shader3D.SHADERDEFINE_HIGHPRECISION));
		if (Render.isConchApp){
			this._cullingBufferIndices=new Int32Array(1024);
			this._cullingBufferResult=new Int32Array(1024);
		}
		this._shaderValues.setTexture(laya.d3.core.scene.Scene3D.RANGEATTENUATIONTEXTURE,ShaderInit3D._rangeAttenTex);
		this._scene=this;
		if (Laya3D._enbalePhysics && !PhysicsSimulation.disableSimulation)
			this._input.__init__(Render.canvas,this);
	}

	__class(Scene3D,'laya.d3.core.scene.Scene3D',_super);
	var __proto=Scene3D.prototype;
	Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true,"laya.resource.ICreateResource":true})
	/**
	*@private
	*[Editer]
	*/
	__proto._allotPickColorByID=function(id,pickColor){
		var pickColorR=Math.floor(id / (255 *255));
		id-=pickColorR *255 *255;
		var pickColorG=Math.floor(id / 255);
		id-=pickColorG *255;
		var pickColorB=id;
		var pickColore=pickColor.elements;
		pickColore[0]=pickColorR / 255;
		pickColore[1]=pickColorG / 255;
		pickColore[2]=pickColorB / 255;
		pickColore[3]=1.0;
	}

	/**
	*@private
	*[Editer]
	*/
	__proto._searchIDByPickColor=function(pickColor){
		var pickColore=pickColor.elements;
		var id=pickColore[0] *255 *255+pickColore[1] *255+pickColore[2];
		return id;
	}

	/**
	*@private
	*/
	__proto._setLightmapToChildNode=function(sprite){
		if ((sprite instanceof laya.d3.core.RenderableSprite3D ))
			(sprite)._render._applyLightMapParams();
		var children=sprite._children;
		for (var i=0,n=children.length;i < n;i++)
		this._setLightmapToChildNode(children[i]);
	}

	/**
	*@private
	*/
	__proto._update=function(){
		var delta=this.timer._delta / 1000;
		this._time+=delta;
		this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.TIME,this._time);
		var simulation=this._physicsSimulation;
		if (Laya3D._enbalePhysics && !PhysicsSimulation.disableSimulation){
			simulation._updatePhysicsTransformFromRender();
			PhysicsComponent._addUpdateList=false;
			simulation._simulate(delta);
			simulation._updateCharacters();
			PhysicsComponent._addUpdateList=true;
			simulation._updateCollisions();
			simulation._eventScripts();
			this._input._update();
		}
		this._updateScript();
		Animator._update(this);
		this._lateUpdateScript();
	}

	/**
	*@private
	*/
	__proto._binarySearchIndexInCameraPool=function(camera){
		var start=0;
		var end=this._cameraPool.length-1;
		var mid=0;
		while (start <=end){
			mid=Math.floor((start+end)/ 2);
			var midValue=this._cameraPool[mid]._renderingOrder;
			if (midValue==camera._renderingOrder)
				return mid;
			else if (midValue > camera._renderingOrder)
			end=mid-1;
			else
			start=mid+1;
		}
		return start;
	}

	/**
	*@private
	*/
	__proto._setCreateURL=function(url){
		this._url=url;
	}

	/**
	*@private
	*/
	__proto._getGroup=function(){
		return this._group;
	}

	/**
	*@private
	*/
	__proto._setGroup=function(value){
		this._group=value;
	}

	/**
	*@private
	*/
	__proto._updateScript=function(){
		var pool=this._scriptPool;
		var elements=pool.elements;
		for (var i=0,n=pool.length;i < n;i++){
			var script=elements [i];
			(script && script.enabled)&& (script.onUpdate());
		}
	}

	/**
	*@private
	*/
	__proto._lateUpdateScript=function(){
		var pool=this._scriptPool;
		var elements=pool.elements;
		for (var i=0,n=pool.length;i < n;i++){
			var script=elements [i];
			(script && script.enabled)&& (script.onLateUpdate());
		}
	}

	/**
	*@private
	*/
	__proto._preRenderScript=function(){
		var pool=this._scriptPool;
		var elements=pool.elements;
		for (var i=0,n=pool.length;i < n;i++){
			var script=elements [i];
			(script && script.enabled)&& (script.onPreRender());
		}
	}

	/**
	*@private
	*/
	__proto._postRenderScript=function(){
		var pool=this._scriptPool;
		var elements=pool.elements;
		for (var i=0,n=pool.length;i < n;i++){
			var script=elements [i];
			(script && script.enabled)&& (script.onPostRender());
		}
	}

	/**
	*初始化八叉树。
	*@param width 八叉树宽度。
	*@param height 八叉树高度。
	*@param depth 八叉树深度。
	*@param center 八叉树中心点
	*@param level 八叉树层级。
	*/
	__proto.initOctree=function(width,height,depth,center,level){
		(level===void 0)&& (level=6);
		this.treeSize=new Vector3(width,height,depth);
		this.treeLevel=level;
		this.treeRoot=new OctreeNode(this,0);
		this.treeRoot.initRoot(center,this.treeSize);
	}

	/**
	*@private
	*/
	__proto._prepareSceneToRender=function(){
		var lightCount=this._lights.length;
		if (lightCount > 0){
			var renderLightCount=0;
			for (var i=0;i < lightCount;i++){
				if (!this._lights[i]._prepareToScene())
					continue ;
				renderLightCount++;
				if (renderLightCount >=this._enableLightCount)
					break ;
			}
		}
	}

	/**
	*@private
	*/
	__proto._addCamera=function(camera){
		var index=this._binarySearchIndexInCameraPool(camera);
		var order=camera._renderingOrder;
		var count=this._cameraPool.length;
		while (index < count && this._cameraPool[index]._renderingOrder <=order)
		index++;
		this._cameraPool.splice(index,0,camera);
	}

	/**
	*@private
	*/
	__proto._removeCamera=function(camera){
		this._cameraPool.splice(this._cameraPool.indexOf(camera),1);
	}

	/**
	*@private
	*/
	__proto._preCulling=function(context,camera){
		if (camera.useOcclusionCulling){
			FrustumCulling.renderObjectCulling(camera,this,context,this._renders);
			}else {
			FrustumCulling.renderObjectCulling(null,this,context,this._renders);
		}
	}

	/**
	*@private
	*/
	__proto._clear=function(gl,state){
		var viewport=state.viewport;
		var camera=state.camera;
		var renderTarget=camera.renderTarget;
		var vpW=viewport.width;
		var vpH=viewport.height;
		var vpX=viewport.x;
		var vpY=camera._canvasHeight-viewport.y-vpH;
		gl.viewport(vpX,vpY,vpW,vpH);
		var flag=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
		var clearFlag=camera.clearFlag;
		if (clearFlag===/*laya.d3.core.BaseCamera.CLEARFLAG_SKY*/1 && !(camera.skyRenderer._isAvailable()|| this._skyRenderer._isAvailable()))
			clearFlag=/*laya.d3.core.BaseCamera.CLEARFLAG_SOLIDCOLOR*/0;
		switch (clearFlag){
			case /*laya.d3.core.BaseCamera.CLEARFLAG_SOLIDCOLOR*/0:;
				var clearColor=camera.clearColor;
				if (clearColor){
					gl.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
					gl.scissor(vpX,vpY,vpW,vpH);
					var clearColorE=clearColor.elements;
					gl.clearColor(clearColorE[0],clearColorE[1],clearColorE[2],clearColorE[3]);
					flag |=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000;
				}
				if (renderTarget){
					(clearColor)|| (flag=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000);
				switch (renderTarget.depthStencilFormat){
					case /*laya.webgl.resource.BaseTexture.FORMAT_DEPTH_16*/0:
						flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
						break ;
					case /*laya.webgl.resource.BaseTexture.FORMAT_STENCIL_8*/1:
						flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
						break ;
					case /*laya.webgl.resource.BaseTexture.FORMAT_DEPTHSTENCIL_16_8*/2:
						flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
						flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
						break ;
					}
			}
			gl.clear(flag);
			if (clearColor)
				gl.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			break ;
			case /*laya.d3.core.BaseCamera.CLEARFLAG_SKY*/1:
			case /*laya.d3.core.BaseCamera.CLEARFLAG_DEPTHONLY*/2:
			if (renderTarget){
				flag=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000;
				switch (renderTarget.depthStencilFormat){
					case /*laya.webgl.resource.BaseTexture.FORMAT_DEPTH_16*/0:
						flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
						break ;
					case /*laya.webgl.resource.BaseTexture.FORMAT_STENCIL_8*/1:
						flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
						break ;
					case /*laya.webgl.resource.BaseTexture.FORMAT_DEPTHSTENCIL_16_8*/2:
						flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
						flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400
						break ;
					}
			}
			gl.clear(flag);
			break ;
			case /*laya.d3.core.BaseCamera.CLEARFLAG_NONE*/3:
			break ;
			default :
			throw new Error("BaseScene:camera clearFlag invalid.");
		}
	}

	/**
	*@private
	*/
	__proto._renderScene=function(gl,state,customShader,replacementTag){
		var camera=state.camera;
		var position=camera.transform.position;
		camera.renderTarget ? this._opaqueQueue._render(state,true,customShader,replacementTag):this._opaqueQueue._render(state,false,customShader,replacementTag);
		if (camera.clearFlag===/*laya.d3.core.BaseCamera.CLEARFLAG_SKY*/1){
			if (camera.skyRenderer._isAvailable())
				camera.skyRenderer._render(state);
			else if (this._skyRenderer._isAvailable())
			this._skyRenderer._render(state);
		}
		camera.renderTarget ? this._transparentQueue._render(state,true,customShader,replacementTag):this._transparentQueue._render(state,false,customShader,replacementTag);
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		var lightMapsData=data.lightmaps;
		if (lightMapsData){
			var lightMapCount=lightMapsData.length;
			var lightmaps=this._lightmaps;
			lightmaps.length=lightMapCount;
			for (var i=0;i < lightMapCount;i++)
			lightmaps[i]=Loader.getRes(lightMapsData[i].path);
			this.setlightmaps(lightmaps);
		};
		var ambientColorData=data.ambientColor;
		if (ambientColorData){
			var ambCol=this.ambientColor;
			ambCol.fromArray(ambientColorData);
			this.ambientColor=ambCol;
		};
		var skyData=data.sky;
		if (skyData){
			this._skyRenderer.material=Loader.getRes(skyData.material.path);
			switch (skyData.mesh){
				case "SkyBox":
					this._skyRenderer.mesh=SkyBox.instance;
					break ;
				case "SkyDome":
					this._skyRenderer.mesh=SkyDome.instance;
					break ;
				default :
					this.skyRenderer.mesh=SkyBox.instance;
				}
		};
		var reflectionTextureData=data.reflectionTexture;
		reflectionTextureData && (this.customReflection=Loader.getRes(reflectionTextureData));
		this.enableFog=data.enableFog;
		this.fogStart=data.fogStart;
		this.fogRange=data.fogRange;
		var fogColorData=data.fogColor;
		if (fogColorData){
			var fogCol=this.fogColor;
			fogCol.fromArray(fogColorData);
			this.fogColor=fogCol;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._onActive=function(){
		Laya.stage._scene3Ds.push(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._onInActive=function(){
		var scenes=Laya.stage._scene3Ds;
		scenes.splice(scenes.indexOf(this),1);
	}

	/**
	*@private
	*/
	__proto._addLight=function(light){
		if (this._lights.indexOf(light)< 0)this._lights.push(light);
	}

	/**
	*@private
	*/
	__proto._removeLight=function(light){
		var index=this._lights.indexOf(light);
		index >=0 && (this._lights.splice(index,1));
	}

	/**
	*通过蒙版值获取蒙版是否显示。
	*@param mask 蒙版值。
	*@return 是否显示。
	*/
	__proto.isLayerVisible=function(layer,camera){
		return (Math.pow(2,layer)& camera.cullingMask)!=0;
	}

	/**
	*@private
	*/
	__proto.addTreeNode=function(renderObj){
		this.treeRoot.addTreeNode(renderObj);
	}

	/**
	*@private
	*/
	__proto.removeTreeNode=function(renderObj){
		if (!this.treeSize)return;
		if (renderObj._treeNode){
			renderObj._treeNode.removeObject(renderObj);
		}
	}

	/**
	*@private
	*/
	__proto._addRenderObject=function(render){
		if (this.treeRoot){
			this.addTreeNode(render);
			}else {
			this._renders.add(render);
			if (Render.isConchApp){
				var indexInList=render._getIndexInList();
				var length=this._cullingBufferIndices.length;
				if (indexInList >=length){
					var tempIndices=this._cullingBufferIndices;
					var tempResult=this._cullingBufferResult;
					this._cullingBufferIndices=new Int32Array(length+1024);
					this._cullingBufferResult=new Int32Array(length+1024);
					this._cullingBufferIndices.set(tempIndices,0);
					this._cullingBufferResult.set(tempResult,0);
				}
				this._cullingBufferIndices[indexInList]=render._cullingBufferIndex;
			}
		}
	}

	/**
	*@private
	*/
	__proto._removeRenderObject=function(render){
		if (this.treeRoot){
			this.removeTreeNode(render);
			}else {
			var endRender;
			if (Render.isConchApp){
				endRender=this._renders.elements [this._renders.length-1];
			}
			this._renders.remove(render);
			if (Render.isConchApp){
				this._cullingBufferIndices[endRender._getIndexInList()]=endRender._cullingBufferIndex;
			}
		}
	}

	/**
	*@private
	*/
	__proto._addShadowCastRenderObject=function(render){
		if (this.treeRoot){
			this.addTreeNode(render);
			}else {
			this._castShadowRenders.add(render);
		}
	}

	/**
	*@private
	*/
	__proto._removeShadowCastRenderObject=function(render){
		if (this.treeRoot){
			this.removeTreeNode(render);
			}else {
			this._castShadowRenders.remove(render);
		}
	}

	/**
	*@private
	*/
	__proto._getRenderQueue=function(index){
		if (index < /*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000)
			return this._opaqueQueue;
		else
		return this._transparentQueue;
	}

	/**
	*设置光照贴图。
	*@param value 光照贴图。
	*/
	__proto.setlightmaps=function(value){
		this._lightmaps=value;
		for (var i=0,n=this._children.length;i < n;i++)
		this._setLightmapToChildNode(this._children[i]);
	}

	/**
	*获取光照贴图。
	*@return 获取光照贴图。
	*/
	__proto.getlightmaps=function(){
		return this._lightmaps;
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		this._skyRenderer.destroy();
		this._skyRenderer=null;
		this._lights=null;
		this._lightmaps=null;
		this._renderTargetTexture=null;
		this._shaderValues=null;
		this._renders=null;
		this._castShadowRenders=null;
		this._cameraPool=null;
		this.treeRoot=null;
		this.treeSize=null;
		this.parallelSplitShadowMaps=null;
		this._physicsSimulation && this._physicsSimulation._destroy();
		Loader.clearRes(this.url);
	}

	/**
	*@inheritDoc
	*/
	__proto.render=function(ctx,x,y){
		(ctx)._curSubmit=Submit.RENDERBASE;
		this._children.length > 0 && ctx.addRenderObject(this);
	}

	/**
	*@private
	*/
	__proto.renderSubmit=function(){
		var gl=LayaGL.instance;
		if (Render.isConchApp){
			if (this._glCommandEncoder)
				this._glCommandEncoder.clearEncoding();
			gl.beginCommandEncoding(this._glCommandEncoder);
		}
		this._prepareSceneToRender();
		var i=0,n=0,n1=0;
		for (i=0,n=this._cameraPool.length,n1=n-1;i < n;i++){
			if (Render.isConchApp)
				ShaderData.setRuntimeValueMode((i==n1)? true :false);
			var camera=this._cameraPool [i];
			camera.enableRender && camera.render();
		}
		if (Render.isConchApp){
			gl.endCommandEncoding();
			Buffer._bindedVertexBuffer=null;
			Buffer._bindedIndexBuffer=null;
		}
		WebGLContext2D.set2DRenderConfig();
		return 1;
	}

	/**
	*@private
	*/
	__proto.getRenderType=function(){
		return 0;
	}

	/**
	*@private
	*/
	__proto.releaseRender=function(){}
	/**
	*@private
	*/
	__proto.reUse=function(context,pos){
		return 0;
	}

	__proto.renderCallbackFromNative=function(){
		this._update();
		this.renderSubmit();
	}

	/**
	*@inheritDoc
	*/
	__proto.renderToNative=function(context,x,y){
		context.gl.block(this._conchData);
	}

	/**
	*设置雾化颜色。
	*@param value 雾化颜色。
	*/
	/**
	*获取雾化颜色。
	*@return 雾化颜色。
	*/
	__getset(0,__proto,'fogColor',function(){
		return this._shaderValues.getVector(laya.d3.core.scene.Scene3D.FOGCOLOR);
		},function(value){
		this._shaderValues.setVector(laya.d3.core.scene.Scene3D.FOGCOLOR,value);
	});

	/**
	*设置是否允许雾化。
	*@param value 是否允许雾化。
	*/
	/**
	*获取是否允许雾化。
	*@return 是否允许雾化。
	*/
	__getset(0,__proto,'enableFog',function(){
		return this._enableFog;
		},function(value){
		if (this._enableFog!==value){
			this._enableFog=value;
			if (value){
				this._defineDatas.add(laya.d3.core.scene.Scene3D.SHADERDEFINE_FOG);
			}else
			this._defineDatas.remove(laya.d3.core.scene.Scene3D.SHADERDEFINE_FOG);
		}
	});

	/**
	*获取资源的URL地址。
	*@return URL地址。
	*/
	__getset(0,__proto,'url',function(){
		return this._url;
	});

	/**
	*设置雾化起始位置。
	*@param value 雾化起始位置。
	*/
	/**
	*获取雾化起始位置。
	*@return 雾化起始位置。
	*/
	__getset(0,__proto,'fogStart',function(){
		return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.FOGSTART);
		},function(value){
		this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.FOGSTART,value);
	});

	/**
	*设置反射强度。
	*@param 反射强度。
	*/
	/**
	*获取反射强度。
	*@return 反射强度。
	*/
	__getset(0,__proto,'reflectionIntensity',function(){
		return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.REFLETIONINTENSITY);
		},function(value){
		value=Math.max(Math.min(value,1.0),0.0);
		this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.REFLETIONINTENSITY,value);
	});

	/**
	*获取天空渲染器。
	*@return 天空渲染器。
	*/
	__getset(0,__proto,'skyRenderer',function(){
		return this._skyRenderer;
	});

	/**
	*设置雾化范围。
	*@param value 雾化范围。
	*/
	/**
	*获取雾化范围。
	*@return 雾化范围。
	*/
	__getset(0,__proto,'fogRange',function(){
		return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.FOGRANGE);
		},function(value){
		this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.FOGRANGE,value);
	});

	/**
	*设置环境光颜色。
	*@param value 环境光颜色。
	*/
	/**
	*获取环境光颜色。
	*@return 环境光颜色。
	*/
	__getset(0,__proto,'ambientColor',function(){
		return this._shaderValues.getVector(laya.d3.core.scene.Scene3D.AMBIENTCOLOR);
		},function(value){
		this._shaderValues.setVector(laya.d3.core.scene.Scene3D.AMBIENTCOLOR,value);
	});

	/**
	*设置反射贴图。
	*@param 反射贴图。
	*/
	/**
	*获取反射贴图。
	*@return 反射贴图。
	*/
	__getset(0,__proto,'customReflection',function(){
		return this._shaderValues.getTexture(laya.d3.core.scene.Scene3D.REFLECTIONTEXTURE);
		},function(value){
		this._shaderValues.setTexture(laya.d3.core.scene.Scene3D.REFLECTIONTEXTURE,value);
		if (value)
			this._defineDatas.add(laya.d3.core.scene.Scene3D.SHADERDEFINE_REFLECTMAP);
		else
		this._defineDatas.remove(laya.d3.core.scene.Scene3D.SHADERDEFINE_REFLECTMAP);
	});

	/**
	*获取物理模拟器。
	*@return 物理模拟器。
	*/
	__getset(0,__proto,'physicsSimulation',function(){
		return this._physicsSimulation;
	});

	/**
	*设置反射模式。
	*@param value 反射模式。
	*/
	/**
	*获取反射模式。
	*@return 反射模式。
	*/
	__getset(0,__proto,'reflectionMode',function(){
		return this._reflectionMode;
		},function(value){
		this._reflectionMode=value;
	});

	/**
	*设置场景时钟。
	*/
	/**
	*获取场景时钟。
	*/
	__getset(0,__proto,'timer',function(){
		return this._timer;
		},function(value){
		this._timer=value;
	});

	/**
	*获取输入。
	*@return 输入。
	*/
	__getset(0,__proto,'input',function(){
		return this._input;
	});

	Scene3D._parse=function(data,propertyParams,constructParams){
		var json=data.data;
		var outBatchSprits=[];
		var scene=Utils3D._createNodeByJson(json,outBatchSprits);
		StaticBatchManager.combine(null,outBatchSprits);
		return scene;
	}

	Scene3D.load=function(url,complete){
		Laya.loader.create(url,complete,null,/*Laya3D.HIERARCHY*/"HIERARCHY");
	}

	Scene3D.REFLECTIONMODE_SKYBOX=0;
	Scene3D.REFLECTIONMODE_CUSTOM=1;
	Scene3D.SHADERDEFINE_FOG=0;
	Scene3D.SHADERDEFINE_DIRECTIONLIGHT=0;
	Scene3D.SHADERDEFINE_POINTLIGHT=0;
	Scene3D.SHADERDEFINE_SPOTLIGHT=0;
	Scene3D.SHADERDEFINE_CAST_SHADOW=0;
	Scene3D.SHADERDEFINE_SHADOW_PSSM1=0;
	Scene3D.SHADERDEFINE_SHADOW_PSSM2=0;
	Scene3D.SHADERDEFINE_SHADOW_PSSM3=0;
	Scene3D.SHADERDEFINE_SHADOW_PCF_NO=0;
	Scene3D.SHADERDEFINE_SHADOW_PCF1=0;
	Scene3D.SHADERDEFINE_SHADOW_PCF2=0;
	Scene3D.SHADERDEFINE_SHADOW_PCF3=0;
	Scene3D.SHADERDEFINE_REFLECTMAP=0;
	__static(Scene3D,
	['FOGCOLOR',function(){return this.FOGCOLOR=Shader3D.propertyNameToID("u_FogColor");},'FOGSTART',function(){return this.FOGSTART=Shader3D.propertyNameToID("u_FogStart");},'FOGRANGE',function(){return this.FOGRANGE=Shader3D.propertyNameToID("u_FogRange");},'LIGHTDIRECTION',function(){return this.LIGHTDIRECTION=Shader3D.propertyNameToID("u_DirectionLight.Direction");},'LIGHTDIRCOLOR',function(){return this.LIGHTDIRCOLOR=Shader3D.propertyNameToID("u_DirectionLight.Color");},'POINTLIGHTPOS',function(){return this.POINTLIGHTPOS=Shader3D.propertyNameToID("u_PointLight.Position");},'POINTLIGHTRANGE',function(){return this.POINTLIGHTRANGE=Shader3D.propertyNameToID("u_PointLight.Range");},'POINTLIGHTATTENUATION',function(){return this.POINTLIGHTATTENUATION=Shader3D.propertyNameToID("u_PointLight.Attenuation");},'POINTLIGHTCOLOR',function(){return this.POINTLIGHTCOLOR=Shader3D.propertyNameToID("u_PointLight.Color");},'SPOTLIGHTPOS',function(){return this.SPOTLIGHTPOS=Shader3D.propertyNameToID("u_SpotLight.Position");},'SPOTLIGHTDIRECTION',function(){return this.SPOTLIGHTDIRECTION=Shader3D.propertyNameToID("u_SpotLight.Direction");},'SPOTLIGHTSPOTANGLE',function(){return this.SPOTLIGHTSPOTANGLE=Shader3D.propertyNameToID("u_SpotLight.Spot");},'SPOTLIGHTRANGE',function(){return this.SPOTLIGHTRANGE=Shader3D.propertyNameToID("u_SpotLight.Range");},'SPOTLIGHTCOLOR',function(){return this.SPOTLIGHTCOLOR=Shader3D.propertyNameToID("u_SpotLight.Color");},'SHADOWDISTANCE',function(){return this.SHADOWDISTANCE=Shader3D.propertyNameToID("u_shadowPSSMDistance");},'SHADOWLIGHTVIEWPROJECT',function(){return this.SHADOWLIGHTVIEWPROJECT=Shader3D.propertyNameToID("u_lightShadowVP");},'SHADOWMAPPCFOFFSET',function(){return this.SHADOWMAPPCFOFFSET=Shader3D.propertyNameToID("u_shadowPCFoffset");},'SHADOWMAPTEXTURE1',function(){return this.SHADOWMAPTEXTURE1=Shader3D.propertyNameToID("u_shadowMap1");},'SHADOWMAPTEXTURE2',function(){return this.SHADOWMAPTEXTURE2=Shader3D.propertyNameToID("u_shadowMap2");},'SHADOWMAPTEXTURE3',function(){return this.SHADOWMAPTEXTURE3=Shader3D.propertyNameToID("u_shadowMap3");},'AMBIENTCOLOR',function(){return this.AMBIENTCOLOR=Shader3D.propertyNameToID("u_AmbientColor");},'REFLECTIONTEXTURE',function(){return this.REFLECTIONTEXTURE=Shader3D.propertyNameToID("u_ReflectTexture");},'REFLETIONINTENSITY',function(){return this.REFLETIONINTENSITY=Shader3D.propertyNameToID("u_ReflectIntensity");},'TIME',function(){return this.TIME=Shader3D.propertyNameToID("u_Time");},'ANGLEATTENUATIONTEXTURE',function(){return this.ANGLEATTENUATIONTEXTURE=Shader3D.propertyNameToID("u_AngleTexture");},'RANGEATTENUATIONTEXTURE',function(){return this.RANGEATTENUATIONTEXTURE=Shader3D.propertyNameToID("u_RangeTexture");},'POINTLIGHTMATRIX',function(){return this.POINTLIGHTMATRIX=Shader3D.propertyNameToID("u_PointLightMatrix");},'SPOTLIGHTMATRIX',function(){return this.SPOTLIGHTMATRIX=Shader3D.propertyNameToID("u_SpotLightMatrix");}
	]);
	return Scene3D;
})(Sprite)


/**
*<code>RenderableSprite3D</code> 类用于可渲染3D精灵的父类，抽象类不允许实例。
*/
//class laya.d3.core.RenderableSprite3D extends laya.d3.core.Sprite3D
var RenderableSprite3D=(function(_super){
	function RenderableSprite3D(name){
		this.pickColor=null;
		/**@private */
		this._render=null;
		RenderableSprite3D.__super.call(this,name);
	}

	__class(RenderableSprite3D,'laya.d3.core.RenderableSprite3D',_super);
	var __proto=RenderableSprite3D.prototype;
	/**
	*@inheritDoc
	*/
	__proto._onInActive=function(){
		var scene3D=this._scene;
		scene3D._removeRenderObject(this._render);
		(this._render.castShadow)&& (scene3D._removeShadowCastRenderObject(this._render));
	}

	/**
	*@inheritDoc
	*/
	__proto._onActive=function(){
		laya.display.Node.prototype._onActive.call(this);
		var scene3D=this._scene;
		scene3D._addRenderObject(this._render);
		(this._render.castShadow)&& (scene3D._addShadowCastRenderObject(this._render));
	}

	/**
	*@inheritDoc
	*/
	__proto._onActiveInScene=function(){
		laya.display.Node.prototype._onActiveInScene.call(this);
		if (Laya3D._editerEnvironment){
			var scene=this._scene;
			var pickColor=new Vector4();
			scene._allotPickColorByID(this.id,pickColor);
			scene._pickIdToSprite[this.id]=this;
			this._render._shaderValues.setVector(laya.d3.core.RenderableSprite3D.PICKCOLOR,pickColor);
		}
	}

	/**
	*@private
	*/
	__proto._addToInitStaticBatchManager=function(){}
	/**
	*@inheritDoc
	*/
	__proto._setBelongScene=function(scene){
		laya.display.Node.prototype._setBelongScene.call(this,scene);
		this._render._setBelongScene(scene);
	}

	/**
	*@inheritDoc
	*/
	__proto._setUnBelongScene=function(){
		this._render._defineDatas.remove(laya.d3.core.RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
		laya.display.Node.prototype._setUnBelongScene.call(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._changeHierarchyAnimator=function(animator){
		if (this._hierarchyAnimator){
			var renderableSprites=this._hierarchyAnimator._renderableSprites;
			renderableSprites.splice(renderableSprites.indexOf(this),1);
		}
		if (animator)
			animator._renderableSprites.push(this);
		_super.prototype._changeHierarchyAnimator.call(this,animator);
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		_super.prototype.destroy.call(this,destroyChild);
		this._render._destroy();
		this._render=null;
	}

	RenderableSprite3D.__init__=function(){
		RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW=RenderableSprite3D.shaderDefines.registerDefine("RECEIVESHADOW");
		RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV=RenderableSprite3D.shaderDefines.registerDefine("SCALEOFFSETLIGHTINGMAPUV");
		RenderableSprite3D.SAHDERDEFINE_LIGHTMAP=RenderableSprite3D.shaderDefines.registerDefine("LIGHTMAP");
	}

	RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW=0;
	RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV=0;
	RenderableSprite3D.SAHDERDEFINE_LIGHTMAP=0;
	__static(RenderableSprite3D,
	['LIGHTMAPSCALEOFFSET',function(){return this.LIGHTMAPSCALEOFFSET=Shader3D.propertyNameToID("u_LightmapScaleOffset");},'LIGHTMAP',function(){return this.LIGHTMAP=Shader3D.propertyNameToID("u_LightMap");},'PICKCOLOR',function(){return this.PICKCOLOR=Shader3D.propertyNameToID("u_PickColor");},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines();}
	]);
	return RenderableSprite3D;
})(Sprite3D)


/**
*<code>LightSprite</code> 类用于创建灯光的父类。
*/
//class laya.d3.core.light.LightSprite extends laya.d3.core.Sprite3D
var LightSprite=(function(_super){
	function LightSprite(){
		/**@private */
		this._intensityColor=null;
		/**@private */
		this._intensity=NaN;
		/**@private */
		this._shadow=false;
		/**@private */
		this._shadowFarPlane=0;
		/**@private */
		this._shadowMapSize=0;
		/**@private */
		this._shadowMapCount=0;
		/**@private */
		this._shadowMapPCFType=0;
		/**@private */
		this._parallelSplitShadowMap=null;
		/**@private */
		this._lightmapBakedType=0;
		/**灯光颜色。 */
		this.color=null;
		LightSprite.__super.call(this);
		this._intensity=1.0;
		this._intensityColor=new Vector3();
		this.color=new Vector3(1.0,1.0,1.0);
		this._shadow=false;
		this._shadowFarPlane=8;
		this._shadowMapSize=512;
		this._shadowMapCount=1;
		this._shadowMapPCFType=0;
		this._lightmapBakedType=LightSprite.LIGHTMAPBAKEDTYPE_REALTIME;
	}

	__class(LightSprite,'laya.d3.core.light.LightSprite',_super);
	var __proto=LightSprite.prototype;
	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		_super.prototype._parse.call(this,data);
		var colorData=data.color;
		this.color.fromArray(colorData);
		this.intensity=data.intensity;
		this.lightmapBakedType=data.lightmapBakedType;
	}

	/**
	*@inheritDoc
	*/
	__proto._onActive=function(){
		(this.lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&& ((this._scene)._addLight(this));
	}

	/**
	*@inheritDoc
	*/
	__proto._onInActive=function(){
		(this.lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&& ((this._scene)._removeLight(this));
	}

	/**
	*更新灯光相关渲染状态参数。
	*@param state 渲染状态参数。
	*/
	__proto._prepareToScene=function(){
		return false;
	}

	/**
	*设置灯光烘培类型。
	*/
	/**
	*获取灯光烘培类型。
	*/
	__getset(0,__proto,'lightmapBakedType',function(){
		return this._lightmapBakedType;
		},function(value){
		if (this._lightmapBakedType!==value){
			this._lightmapBakedType=value;
			if (this.activeInHierarchy){
				if (value!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)
					(this._scene)._addLight(this);
				else
				(this._scene)._removeLight(this);
			}
		}
	});

	/**
	*设置阴影PCF类型。
	*@param value PCF类型。
	*/
	/**
	*获取阴影PCF类型。
	*@return PCF类型。
	*/
	__getset(0,__proto,'shadowPCFType',function(){
		return this._shadowMapPCFType;
		},function(value){
		this._shadowMapPCFType=value;
		(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setPCFType(value));
	});

	/**
	*设置灯光强度。
	*@param value 灯光强度
	*/
	/**
	*获取灯光强度。
	*@return 灯光强度
	*/
	__getset(0,__proto,'intensity',function(){
		return this._intensity;
		},function(value){
		this._intensity=value;
	});

	/**
	*设置是否产生阴影。
	*@param value 是否产生阴影。
	*/
	/**
	*获取是否产生阴影。
	*@return 是否产生阴影。
	*/
	__getset(0,__proto,'shadow',function(){
		return this._shadow;
		},function(value){
		throw new Error("LightSprite: must override it.");
	});

	/**
	*设置阴影最远范围。
	*@param value 阴影最远范围。
	*/
	/**
	*获取阴影最远范围。
	*@return 阴影最远范围。
	*/
	__getset(0,__proto,'shadowDistance',function(){
		return this._shadowFarPlane;
		},function(value){
		this._shadowFarPlane=value;
		(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setFarDistance(value));
	});

	/**
	*设置阴影分段数。
	*@param value 阴影分段数。
	*/
	/**
	*获取阴影分段数。
	*@return 阴影分段数。
	*/
	__getset(0,__proto,'shadowPSSMCount',function(){
		return this._shadowMapCount;
		},function(value){
		this._shadowMapCount=value;
		(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.shadowMapCount=value);
	});

	/**
	*设置阴影贴图尺寸。
	*@param value 阴影贴图尺寸。
	*/
	/**
	*获取阴影贴图尺寸。
	*@return 阴影贴图尺寸。
	*/
	__getset(0,__proto,'shadowResolution',function(){
		return this._shadowMapSize;
		},function(value){
		this._shadowMapSize=value;
		(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setShadowMapTextureSize(value));
	});

	/**
	*设置灯光的漫反射颜色。
	*@param value 灯光的漫反射颜色。
	*/
	/**
	*获取灯光的漫反射颜色。
	*@return 灯光的漫反射颜色。
	*/
	__getset(0,__proto,'diffuseColor',function(){
		console.log("LightSprite: discard property,please use color property instead.");
		return this.color;
		},function(value){
		console.log("LightSprite: discard property,please use color property instead.");
		this.color=value;
	});

	LightSprite.LIGHTMAPBAKEDTYPE_REALTIME=0;
	LightSprite.LIGHTMAPBAKEDTYPE_MIXED=1;
	LightSprite.LIGHTMAPBAKEDTYPE_BAKED=2;
	return LightSprite;
})(Sprite3D)


/**
*<code>SkyBoxMaterial</code> 类用于实现SkyBoxMaterial材质。
*/
//class laya.d3.core.material.SkyBoxMaterial extends laya.d3.core.material.BaseMaterial
var SkyBoxMaterial=(function(_super){
	/**
	*创建一个 <code>SkyBoxMaterial</code> 实例。
	*/
	function SkyBoxMaterial(){
		SkyBoxMaterial.__super.call(this);
		this.setShaderName("SkyBox");
	}

	__class(SkyBoxMaterial,'laya.d3.core.material.SkyBoxMaterial',_super);
	var __proto=SkyBoxMaterial.prototype;
	/**
	*设置颜色。
	*@param value 颜色。
	*/
	/**
	*获取颜色。
	*@return 颜色。
	*/
	__getset(0,__proto,'tintColor',function(){
		return this._shaderValues.getVector(SkyBoxMaterial.TINTCOLOR);
		},function(value){
		this._shaderValues.setVector(SkyBoxMaterial.TINTCOLOR,value);
	});

	/**
	*设置曝光强度。
	*@param value 曝光强度。
	*/
	/**
	*获取曝光强度。
	*@return 曝光强度。
	*/
	__getset(0,__proto,'exposure',function(){
		return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE);
		},function(value){
		this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE,value);
	});

	/**
	*设置曝光强度。
	*@param value 曝光强度。
	*/
	/**
	*获取曝光强度。
	*@return 曝光强度。
	*/
	__getset(0,__proto,'rotation',function(){
		return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION);
		},function(value){
		this._shaderValues.setNumber(SkyBoxMaterial.ROTATION,value);
	});

	/**
	*设置天空盒纹理。
	*/
	/**
	*获取天空盒纹理。
	*/
	__getset(0,__proto,'textureCube',function(){
		return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE);
		},function(value){
		return this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE,value);
	});

	__static(SkyBoxMaterial,
	['TINTCOLOR',function(){return this.TINTCOLOR=Shader3D.propertyNameToID("u_TintColor");},'EXPOSURE',function(){return this.EXPOSURE=Shader3D.propertyNameToID("u_Exposure");},'ROTATION',function(){return this.ROTATION=Shader3D.propertyNameToID("u_Rotation");},'TEXTURECUBE',function(){return this.TEXTURECUBE=Shader3D.propertyNameToID("u_CubeTexture");},'defaultMaterial',function(){return this.defaultMaterial=new SkyBoxMaterial();}
	]);
	return SkyBoxMaterial;
})(BaseMaterial)


/**
*<code>ShurikenParticleMaterial</code> 类用于实现粒子材质。
*/
//class laya.d3.core.particleShuriKen.ShurikenParticleMaterial extends laya.d3.core.material.BaseMaterial
var ShurikenParticleMaterial=(function(_super){
	function ShurikenParticleMaterial(){
		/**@private */
		//this._color=null;
		ShurikenParticleMaterial.__super.call(this);
		this.setShaderName("PARTICLESHURIKEN");
		this._color=new Vector4(1.0,1.0,1.0,1.0);
		this.renderMode=0;
	}

	__class(ShurikenParticleMaterial,'laya.d3.core.particleShuriKen.ShurikenParticleMaterial',_super);
	var __proto=ShurikenParticleMaterial.prototype;
	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorB',function(){
		return this._color.elements[2];
		},function(value){
		this._color.elements[2]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STZ',function(){
		return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).elements[2];
		},function(z){
		var tilOff=this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
		tilOff.elements[2]=z;
		this.tilingOffset=tilOff;
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'texture',function(){
		return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
		else
		this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
		this._shaderValues.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorR',function(){
		return this._color.elements[0];
		},function(value){
		this._color.elements[0]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STW',function(){
		return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).elements[3];
		},function(w){
		var tilOff=this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
		tilOff.elements[3]=w;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorG',function(){
		return this._color.elements[1];
		},function(value){
		this._color.elements[1]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_TintColorA',function(){
		return this._color.elements[3];
		},function(value){
		this._color.elements[3]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STY',function(){
		return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).elements[1];
		},function(y){
		var tilOff=this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
		tilOff.elements[1]=y;
		this.tilingOffset=tilOff;
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_NONE*/0;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				this.alphaTest=false;
				this._defineDatas.add(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 0:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_NONE*/0;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE*/1;
				this.alphaTest=false;
				this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			default :
				throw new Error("ShurikenParticleMaterial : renderMode value error.");
			}
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STX',function(){
		return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).elements[0];
		},function(x){
		var tilOff=this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
		tilOff.elements[0]=x;
		this.tilingOffset=tilOff;
	});

	/**
	*设置颜色R分量。
	*@param value 颜色R分量。
	*/
	/**
	*获取颜色R分量。
	*@return 颜色R分量。
	*/
	__getset(0,__proto,'colorR',function(){
		return this._TintColorR;
		},function(value){
		this._TintColorR=value;
	});

	/**
	*设置颜色G分量。
	*@param value 颜色G分量。
	*/
	/**
	*获取颜色G分量。
	*@return 颜色G分量。
	*/
	__getset(0,__proto,'colorG',function(){
		return this._TintColorG;
		},function(value){
		this._TintColorG=value;
	});

	/**
	*设置颜色B分量。
	*@param value 颜色B分量。
	*/
	/**
	*获取颜色B分量。
	*@return 颜色B分量。
	*/
	__getset(0,__proto,'colorB',function(){
		return this._TintColorB;
		},function(value){
		this._TintColorB=value;
	});

	/**
	*设置颜色alpha分量。
	*@param value 颜色alpha分量。
	*/
	/**
	*获取颜色Z分量。
	*@return 颜色Z分量。
	*/
	__getset(0,__proto,'colorA',function(){
		return this._TintColorA;
		},function(value){
		this._TintColorA=value;
	});

	/**
	*设置颜色。
	*@param value 颜色。
	*/
	/**
	*获取颜色。
	*@return 颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._shaderValues.getVector(ShurikenParticleMaterial.TINTCOLOR);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
		else
		this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR);
		this._shaderValues.setVector(ShurikenParticleMaterial.TINTCOLOR,value);
	});

	/**
	*获取纹理平铺和偏移X分量。
	*@param x 纹理平铺和偏移X分量。
	*/
	/**
	*获取纹理平铺和偏移X分量。
	*@return 纹理平铺和偏移X分量。
	*/
	__getset(0,__proto,'tilingOffsetX',function(){
		return this._MainTex_STX;
		},function(x){
		this._MainTex_STX=x;
	});

	/**
	*获取纹理平铺和偏移Y分量。
	*@param y 纹理平铺和偏移Y分量。
	*/
	/**
	*获取纹理平铺和偏移Y分量。
	*@return 纹理平铺和偏移Y分量。
	*/
	__getset(0,__proto,'tilingOffsetY',function(){
		return this._MainTex_STY;
		},function(y){
		this._MainTex_STY=y;
	});

	/**
	*获取纹理平铺和偏移Z分量。
	*@param z 纹理平铺和偏移Z分量。
	*/
	/**
	*获取纹理平铺和偏移Z分量。
	*@return 纹理平铺和偏移Z分量。
	*/
	__getset(0,__proto,'tilingOffsetZ',function(){
		return this._MainTex_STZ;
		},function(z){
		this._MainTex_STZ=z;
	});

	/**
	*获取纹理平铺和偏移W分量。
	*@param w 纹理平铺和偏移W分量。
	*/
	/**
	*获取纹理平铺和偏移W分量。
	*@return 纹理平铺和偏移W分量。
	*/
	__getset(0,__proto,'tilingOffsetW',function(){
		return this._MainTex_STW;
		},function(w){
		this._MainTex_STW=w;
	});

	/**
	*获取纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._shaderValues.setVector(ShurikenParticleMaterial.TILINGOFFSET,value);
	});

	ShurikenParticleMaterial.__init__=function(){
		ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=ShurikenParticleMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
		ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR=ShurikenParticleMaterial.shaderDefines.registerDefine("TINTCOLOR");
		ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG=ShurikenParticleMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
		ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET=ShurikenParticleMaterial.shaderDefines.registerDefine("TILINGOFFSET");
	}

	ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED=0;
	ShurikenParticleMaterial.RENDERMODE_ADDTIVE=1;
	ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=0;
	ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR=0;
	ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET=0;
	ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG=0;
	__static(ShurikenParticleMaterial,
	['DIFFUSETEXTURE',function(){return this.DIFFUSETEXTURE=Shader3D.propertyNameToID("u_texture");},'TINTCOLOR',function(){return this.TINTCOLOR=Shader3D.propertyNameToID("u_Tintcolor");},'TILINGOFFSET',function(){return this.TILINGOFFSET=Shader3D.propertyNameToID("u_TilingOffset");},'defaultMaterial',function(){return this.defaultMaterial=new ShurikenParticleMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return ShurikenParticleMaterial;
})(BaseMaterial)


/**
*<code>SkyProceduralMaterial</code> 类用于实现SkyProceduralMaterial材质。
*/
//class laya.d3.core.material.SkyProceduralMaterial extends laya.d3.core.material.BaseMaterial
var SkyProceduralMaterial=(function(_super){
	function SkyProceduralMaterial(){
		/**@private */
		this._sunDisk=0;
		SkyProceduralMaterial.__super.call(this);
		this.setShaderName("SkyBoxProcedural");
		this.sunDisk=1;
		this.sunSize=0.04;
		this.sunSizeConvergence=5;
		this.atmosphereThickness=1.0;
		this.skyTint=new Vector4(0.5,0.5,0.5,1.0);
		this.groundTint=new Vector4(0.369,0.349,0.341,1.0);
		this.exposure=1.3;
	}

	__class(SkyProceduralMaterial,'laya.d3.core.material.SkyProceduralMaterial',_super);
	var __proto=SkyProceduralMaterial.prototype;
	/**
	*设置曝光强度,范围是0到8。
	*@param value 曝光强度。
	*/
	/**
	*获取曝光强度,范围是0到8。
	*@return 曝光强度。
	*/
	__getset(0,__proto,'exposure',function(){
		return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE);
		},function(value){
		value=Math.min(Math.max(0.0,value),8.0);
		this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE,value);
	});

	/**
	*设置太阳尺寸,范围是0到1。
	*@param value 太阳尺寸。
	*/
	/**
	*获取太阳尺寸,范围是0到1。
	*@return 太阳尺寸。
	*/
	__getset(0,__proto,'sunSize',function(){
		return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE);
		},function(value){
		value=Math.min(Math.max(0.0,value),1.0);
		this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE,value);
	});

	/**
	*设置太阳状态。
	*@param value 太阳状态。
	*/
	/**
	*获取太阳状态。
	*@return 太阳状态。
	*/
	__getset(0,__proto,'sunDisk',function(){
		return this._sunDisk;
		},function(value){
		switch (value){
			case 1:
				this._defineDatas.remove(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
				this._defineDatas.add(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
				break ;
			case 2:
				this._defineDatas.remove(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
				this._defineDatas.add(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
				break ;
			case 0:
				this._defineDatas.remove(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
				this._defineDatas.remove(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
				break ;
			default :
				throw "SkyBoxProceduralMaterial: unknown sun value.";
			}
		this._sunDisk=value;
	});

	/**
	*设置太阳尺寸收缩,范围是0到20。
	*@param value 太阳尺寸收缩。
	*/
	/**
	*获取太阳尺寸收缩,范围是0到20。
	*@return 太阳尺寸收缩。
	*/
	__getset(0,__proto,'sunSizeConvergence',function(){
		return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE);
		},function(value){
		value=Math.min(Math.max(0.0,value),20.0);
		this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE,value);
	});

	/**
	*设置大气厚度,范围是0到5。
	*@param value 大气厚度。
	*/
	/**
	*获取大气厚度,范围是0到5。
	*@return 大气厚度。
	*/
	__getset(0,__proto,'atmosphereThickness',function(){
		return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS);
		},function(value){
		value=Math.min(Math.max(0.0,value),5.0);
		this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS,value);
	});

	/**
	*设置地面颜色。
	*@param value 地面颜色。
	*/
	/**
	*获取地面颜色。
	*@return 地面颜色。
	*/
	__getset(0,__proto,'groundTint',function(){
		return this._shaderValues.getVector(SkyProceduralMaterial.GROUNDTINT);
		},function(value){
		this._shaderValues.setVector(SkyProceduralMaterial.GROUNDTINT,value);
	});

	/**
	*设置天空颜色。
	*@param value 天空颜色。
	*/
	/**
	*获取天空颜色。
	*@return 天空颜色。
	*/
	__getset(0,__proto,'skyTint',function(){
		return this._shaderValues.getVector(SkyProceduralMaterial.SKYTINT);
		},function(value){
		this._shaderValues.setVector(SkyProceduralMaterial.SKYTINT,value);
	});

	SkyProceduralMaterial.__init__=function(){
		SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY=SkyProceduralMaterial.shaderDefines.registerDefine("SUN_HIGH_QUALITY");
		SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE=SkyProceduralMaterial.shaderDefines.registerDefine("SUN_SIMPLE");
	}

	SkyProceduralMaterial.SUN_NODE=0;
	SkyProceduralMaterial.SUN_HIGH_QUALITY=1;
	SkyProceduralMaterial.SUN_SIMPLE=2;
	SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY=0;
	SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE=0;
	__static(SkyProceduralMaterial,
	['SUNSIZE',function(){return this.SUNSIZE=Shader3D.propertyNameToID("u_SunSize");},'SUNSIZECONVERGENCE',function(){return this.SUNSIZECONVERGENCE=Shader3D.propertyNameToID("u_SunSizeConvergence");},'ATMOSPHERETHICKNESS',function(){return this.ATMOSPHERETHICKNESS=Shader3D.propertyNameToID("u_AtmosphereThickness");},'SKYTINT',function(){return this.SKYTINT=Shader3D.propertyNameToID("u_SkyTint");},'GROUNDTINT',function(){return this.GROUNDTINT=Shader3D.propertyNameToID("u_GroundTint");},'EXPOSURE',function(){return this.EXPOSURE=Shader3D.propertyNameToID("u_Exposure");},'defaultMaterial',function(){return this.defaultMaterial=new SkyProceduralMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return SkyProceduralMaterial;
})(BaseMaterial)


/**
*<code>BlinnPhongMaterial</code> 类用于实现Blinn-Phong材质。
*/
//class laya.d3.core.material.BlinnPhongMaterial extends laya.d3.core.material.BaseMaterial
var BlinnPhongMaterial=(function(_super){
	function BlinnPhongMaterial(){
		/**@private */
		//this._albedoColor=null;
		/**@private */
		//this._albedoIntensity=NaN;
		/**@private */
		//this._enableLighting=false;
		/**@private */
		this._enableVertexColor=false;
		BlinnPhongMaterial.__super.call(this);
		this.setShaderName("BLINNPHONG");
		this._albedoIntensity=1.0;
		this._albedoColor=new Vector4(1.0,1.0,1.0,1.0);
		var sv=this._shaderValues;
		sv.setVector(BlinnPhongMaterial.ALBEDOCOLOR,new Vector4(1.0,1.0,1.0,1.0));
		sv.setVector(BlinnPhongMaterial.MATERIALSPECULAR,new Vector4(1.0,1.0,1.0,1.0));
		sv.setNumber(BlinnPhongMaterial.SHININESS,0.078125);
		sv.setNumber(BaseMaterial.ALPHATESTVALUE,0.5);
		sv.setVector(BlinnPhongMaterial.TILINGOFFSET,new Vector4(1.0,1.0,0.0,0.0));
		this._enableLighting=true;
		this.renderMode=0;
	}

	__class(BlinnPhongMaterial,'laya.d3.core.material.BlinnPhongMaterial',_super);
	var __proto=BlinnPhongMaterial.prototype;
	/**
	*禁用雾化。
	*/
	__proto.disableFog=function(){
		this._disablePublicDefineDatas.add(Scene3D.SHADERDEFINE_FOG);
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destMaterial=destObject;
		destMaterial._enableLighting=this._enableLighting;
		destMaterial._albedoIntensity=this._albedoIntensity;
		this._albedoColor.cloneTo(destMaterial._albedoColor);
	}

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_SpecColorG',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).elements[1];
		},function(value){
		this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).elements[1]=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorB',function(){
		return this._albedoColor.elements[2];
		},function(value){
		this._albedoColor.elements[2]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorR',function(){
		return this._albedoColor.elements[0];
		},function(value){
		this._albedoColor.elements[0]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*设置反照率颜色alpha分量。
	*@param value 反照率颜色alpha分量。
	*/
	/**
	*获取反照率颜色Z分量。
	*@return 反照率颜色Z分量。
	*/
	__getset(0,__proto,'albedoColorA',function(){
		return this._ColorA;
		},function(value){
		this._ColorA=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STX',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).elements[0];
		},function(x){
		var tilOff=this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
		tilOff.elements[0]=x;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_SpecColorB',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).elements[2];
		},function(value){
		this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).elements[2]=value;
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 0:
				this.alphaTest=false;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				break ;
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_ALPHATEST*/2450;
				this.alphaTest=true;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				break ;
			default :
				throw new Error("Material:renderMode value error.");
			}
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_SpecColorR',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).elements[0];
		},function(value){
		this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).elements[0]=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorG',function(){
		return this._albedoColor.elements[1];
		},function(value){
		this._albedoColor.elements[1]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_ColorA',function(){
		return this._albedoColor.elements[3];
		},function(value){
		this._albedoColor.elements[3]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*设置高光颜色。
	*@param value 高光颜色。
	*/
	/**
	*获取高光颜色。
	*@return 高光颜色。
	*/
	__getset(0,__proto,'specularColor',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR);
		},function(value){
		this._shaderValues.setVector(BlinnPhongMaterial.MATERIALSPECULAR,value);
	});

	/**
	*设置反照率颜色B分量。
	*@param value 反照率颜色B分量。
	*/
	/**
	*获取反照率颜色B分量。
	*@return 反照率颜色B分量。
	*/
	__getset(0,__proto,'albedoColorB',function(){
		return this._ColorB;
		},function(value){
		this._ColorB=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_SpecColorA',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).elements[3];
		},function(value){
		this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).elements[3]=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STZ',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).elements[2];
		},function(z){
		var tilOff=this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
		tilOff.elements[2]=z;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_AlbedoIntensity',function(){
		return this._albedoIntensity;
		},function(value){
		if (this._albedoIntensity!==value){
			var finalAlbedo=this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
			Vector4.scale(this._albedoColor,value,finalAlbedo);
			this._albedoIntensity=value;
			this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR,finalAlbedo);
		}
	});

	/**
	*设置高光颜色A分量。
	*@param value 高光颜色A分量。
	*/
	/**
	*获取高光颜色A分量。
	*@return 高光颜色A分量。
	*/
	__getset(0,__proto,'specularColorA',function(){
		return this._SpecColorA;
		},function(value){
		this._SpecColorA=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_Shininess',function(){
		return this._shaderValues.getNumber(BlinnPhongMaterial.SHININESS);
		},function(value){
		value=Math.max(0.0,Math.min(1.0,value));
		this._shaderValues.setNumber(BlinnPhongMaterial.SHININESS,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STY',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).elements[1];
		},function(y){
		var tilOff=this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
		tilOff.elements[1]=y;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_Cutoff',function(){
		return this.alphaTestValue;
		},function(value){
		this.alphaTestValue=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STW',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).elements[3];
		},function(w){
		var tilOff=this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
		tilOff.elements[3]=w;
		this.tilingOffset=tilOff;
	});

	/**
	*设置反照率贴图。
	*@param value 反照率贴图。
	*/
	/**
	*获取反照率贴图。
	*@return 反照率贴图。
	*/
	__getset(0,__proto,'albedoTexture',function(){
		return this._shaderValues.getTexture(BlinnPhongMaterial.ALBEDOTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
		else
		this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
		this._shaderValues.setTexture(BlinnPhongMaterial.ALBEDOTEXTURE,value);
	});

	/**
	*设置是否支持顶点色。
	*@param value 是否支持顶点色。
	*/
	/**
	*获取是否支持顶点色。
	*@return 是否支持顶点色。
	*/
	__getset(0,__proto,'enableVertexColor',function(){
		return this._enableVertexColor;
		},function(value){
		this._enableVertexColor=value;
		if (value)
			this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
		else
		this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
	});

	/**
	*设置反照率颜色。
	*@param value 反照率颜色。
	*/
	/**
	*获取反照率颜色。
	*@return 反照率颜色。
	*/
	__getset(0,__proto,'albedoColor',function(){
		return this._albedoColor;
		},function(value){
		var finalAlbedo=this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
		Vector4.scale(value,this._albedoIntensity,finalAlbedo);
		this._albedoColor=value;
		this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR,finalAlbedo);
	});

	/**
	*获取纹理平铺和偏移X分量。
	*@param x 纹理平铺和偏移X分量。
	*/
	/**
	*获取纹理平铺和偏移X分量。
	*@return 纹理平铺和偏移X分量。
	*/
	__getset(0,__proto,'tilingOffsetX',function(){
		return this._MainTex_STX;
		},function(x){
		this._MainTex_STX=x;
	});

	/**
	*获取纹理平铺和偏移Y分量。
	*@param y 纹理平铺和偏移Y分量。
	*/
	/**
	*获取纹理平铺和偏移Y分量。
	*@return 纹理平铺和偏移Y分量。
	*/
	__getset(0,__proto,'tilingOffsetY',function(){
		return this._MainTex_STY;
		},function(y){
		this._MainTex_STY=y;
	});

	/**
	*获取纹理平铺和偏移Z分量。
	*@param z 纹理平铺和偏移Z分量。
	*/
	/**
	*获取纹理平铺和偏移Z分量。
	*@return 纹理平铺和偏移Z分量。
	*/
	__getset(0,__proto,'tilingOffsetZ',function(){
		return this._MainTex_STZ;
		},function(z){
		this._MainTex_STZ=z;
	});

	/**
	*设置是否启用光照。
	*@param value 是否启用光照。
	*/
	/**
	*获取是否启用光照。
	*@return 是否启用光照。
	*/
	__getset(0,__proto,'enableLighting',function(){
		return this._enableLighting;
		},function(value){
		if (this._enableLighting!==value){
			if (value)
				this._disablePublicDefineDatas.remove(Scene3D.SHADERDEFINE_POINTLIGHT | Scene3D.SHADERDEFINE_SPOTLIGHT | Scene3D.SHADERDEFINE_DIRECTIONLIGHT);
			else
			this._disablePublicDefineDatas.add(Scene3D.SHADERDEFINE_POINTLIGHT | Scene3D.SHADERDEFINE_SPOTLIGHT | Scene3D.SHADERDEFINE_DIRECTIONLIGHT);
			this._enableLighting=value;
		}
	});

	/**
	*获取纹理平铺和偏移W分量。
	*@param w 纹理平铺和偏移W分量。
	*/
	/**
	*获取纹理平铺和偏移W分量。
	*@return 纹理平铺和偏移W分量。
	*/
	__getset(0,__proto,'tilingOffsetW',function(){
		return this._MainTex_STW;
		},function(w){
		this._MainTex_STW=w;
	});

	/**
	*获取纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._shaderValues.setVector(BlinnPhongMaterial.TILINGOFFSET,value);
	});

	/**
	*设置反照率颜色R分量。
	*@param value 反照率颜色R分量。
	*/
	/**
	*获取反照率颜色R分量。
	*@return 反照率颜色R分量。
	*/
	__getset(0,__proto,'albedoColorR',function(){
		return this._ColorR;
		},function(value){
		this._ColorR=value;
	});

	/**
	*设置反照率颜色G分量。
	*@param value 反照率颜色G分量。
	*/
	/**
	*获取反照率颜色G分量。
	*@return 反照率颜色G分量。
	*/
	__getset(0,__proto,'albedoColorG',function(){
		return this._ColorG;
		},function(value){
		this._ColorG=value;
	});

	/**
	*设置反照率强度。
	*@param value 反照率强度。
	*/
	/**
	*获取反照率强度。
	*@return 反照率强度。
	*/
	__getset(0,__proto,'albedoIntensity',function(){
		return this._albedoIntensity;
		},function(value){
		this._AlbedoIntensity=value;
	});

	/**
	*设置高光颜色R分量。
	*@param value 高光颜色R分量。
	*/
	/**
	*获取高光颜色R轴分量。
	*@return 高光颜色R轴分量。
	*/
	__getset(0,__proto,'specularColorR',function(){
		return this._SpecColorR;
		},function(value){
		this._SpecColorR=value;
	});

	/**
	*设置高光颜色G分量。
	*@param value 高光颜色G分量。
	*/
	/**
	*获取高光颜色G分量。
	*@return 高光颜色G分量。
	*/
	__getset(0,__proto,'specularColorG',function(){
		return this._SpecColorG;
		},function(value){
		this._SpecColorG=value;
	});

	/**
	*设置高光颜色B分量。
	*@param value 高光颜色B分量。
	*/
	/**
	*获取高光颜色B分量。
	*@return 高光颜色B分量。
	*/
	__getset(0,__proto,'specularColorB',function(){
		return this._SpecColorB;
		},function(value){
		this._SpecColorB=value;
	});

	/**
	*设置高光强度,范围为0到1。
	*@param value 高光强度。
	*/
	/**
	*获取高光强度,范围为0到1。
	*@return 高光强度。
	*/
	__getset(0,__proto,'shininess',function(){
		return this._Shininess;
		},function(value){
		this._Shininess=value;
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._shaderValues.getTexture(BlinnPhongMaterial.NORMALTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
		else
		this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
		this._shaderValues.setTexture(BlinnPhongMaterial.NORMALTEXTURE,value);
	});

	/**
	*设置高光贴图，高光强度则从该贴图RGB值中获取,如果该值为空则从漫反射贴图的Alpha通道获取。
	*@param value 高光贴图。
	*/
	/**
	*获取高光贴图。
	*@return 高光贴图。
	*/
	__getset(0,__proto,'specularTexture',function(){
		return this._shaderValues.getTexture(BlinnPhongMaterial.SPECULARTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
		else
		this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
		this._shaderValues.setTexture(BlinnPhongMaterial.SPECULARTEXTURE,value);
	});

	BlinnPhongMaterial.__init__=function(){
		BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP=BlinnPhongMaterial.shaderDefines.registerDefine("DIFFUSEMAP");
		BlinnPhongMaterial.SHADERDEFINE_NORMALMAP=BlinnPhongMaterial.shaderDefines.registerDefine("NORMALMAP");
		BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP=BlinnPhongMaterial.shaderDefines.registerDefine("SPECULARMAP");
		BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET=BlinnPhongMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR=BlinnPhongMaterial.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
	}

	BlinnPhongMaterial.SPECULARSOURCE_DIFFUSEMAPALPHA=0;
	BlinnPhongMaterial.SPECULARSOURCE_SPECULARMAP=0;
	BlinnPhongMaterial.RENDERMODE_OPAQUE=0;
	BlinnPhongMaterial.RENDERMODE_CUTOUT=1;
	BlinnPhongMaterial.RENDERMODE_TRANSPARENT=2;
	BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP=0;
	BlinnPhongMaterial.SHADERDEFINE_NORMALMAP=0;
	BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP=0;
	BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET=0;
	BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR=0;
	__static(BlinnPhongMaterial,
	['ALBEDOTEXTURE',function(){return this.ALBEDOTEXTURE=Shader3D.propertyNameToID("u_DiffuseTexture");},'NORMALTEXTURE',function(){return this.NORMALTEXTURE=Shader3D.propertyNameToID("u_NormalTexture");},'SPECULARTEXTURE',function(){return this.SPECULARTEXTURE=Shader3D.propertyNameToID("u_SpecularTexture");},'ALBEDOCOLOR',function(){return this.ALBEDOCOLOR=Shader3D.propertyNameToID("u_DiffuseColor");},'MATERIALSPECULAR',function(){return this.MATERIALSPECULAR=Shader3D.propertyNameToID("u_MaterialSpecular");},'SHININESS',function(){return this.SHININESS=Shader3D.propertyNameToID("u_Shininess");},'TILINGOFFSET',function(){return this.TILINGOFFSET=Shader3D.propertyNameToID("u_TilingOffset");},'defaultMaterial',function(){return this.defaultMaterial=new BlinnPhongMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return BlinnPhongMaterial;
})(BaseMaterial)


/**
*<code>Terrain</code> 类用于创建地块。
*/
//class laya.d3.terrain.Terrain extends laya.d3.core.Sprite3D
var Terrain=(function(_super){
	function Terrain(terrainRes){
		//地形资源
		this._terrainRes=null;
		this._lightmapScaleOffset=null;
		Terrain.__super.call(this);
		this._lightmapScaleOffset=new Vector4(1,1,0,0);
		if (terrainRes){
			this._terrainRes=terrainRes;
			this.buildTerrain(terrainRes);
		}
	}

	__class(Terrain,'laya.d3.terrain.Terrain',_super);
	var __proto=Terrain.prototype;
	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		_super.prototype._parse.call(this,data);
		this.terrainRes=Loader.getRes(data.dataPath);
		var lightmapIndex=data.lightmapIndex;
		if (lightmapIndex !=null)
			this.setLightmapIndex(lightmapIndex);
		var lightmapScaleOffsetArray=data.lightmapScaleOffset;
		if (lightmapScaleOffsetArray)
			this.setLightmapScaleOffset(new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
	}

	__proto.setLightmapIndex=function(value){
		for (var i=0;i < this._children.length;i++){
			var terrainChunk=this._children[i];
			terrainChunk.terrainRender.lightmapIndex=value;
		}
	}

	__proto.setLightmapScaleOffset=function(value){
		if (!value)return;
		value.cloneTo(this._lightmapScaleOffset);
		for (var i=0;i < this._children.length;i++){
			var terrainChunk=this._children[i];
			terrainChunk.terrainRender.lightmapScaleOffset=this._lightmapScaleOffset;
		}
	}

	__proto.disableLight=function(){
		for (var i=0,n=this._children.length;i < n;i++){
			var terrainChunk=this._children[i];
			for (var j=0,m=terrainChunk._render.sharedMaterials.length;j < m;j++){
				var terrainMaterial=terrainChunk._render.sharedMaterials [j];
				terrainMaterial.disableLight();
			}
		}
	}

	//建筑地形
	__proto.buildTerrain=function(terrainRes){
		var chunkNumX=terrainRes._chunkNumX;
		var chunkNumZ=terrainRes._chunkNumZ;
		var heightData=terrainRes._heightData;
		var n=0;
		for (var i=0;i < chunkNumZ;i++){
			for (var j=0;j < chunkNumX;j++){
				var terrainChunk=new TerrainChunk(j,i,terrainRes._gridSize,heightData._terrainHeightData,heightData._width,heightData._height,terrainRes._cameraCoordinateInverse);
				var chunkInfo=terrainRes._chunkInfos[n++];
				for (var k=0;k < chunkInfo.alphaMap.length;k++){
					var nNum=chunkInfo.detailID[k].length;
					var sDetialTextureUrl1=(nNum > 0)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][0]].diffuseTexture :null;
					var sDetialTextureUrl2=(nNum > 1)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][1]].diffuseTexture :null;
					var sDetialTextureUrl3=(nNum > 2)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][2]].diffuseTexture :null;
					var sDetialTextureUrl4=(nNum > 3)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][3]].diffuseTexture :null;
					var detialScale1=(nNum > 0)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][0]].scale :null;
					var detialScale2=(nNum > 1)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][1]].scale :null;
					var detialScale3=(nNum > 2)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][2]].scale :null;
					var detialScale4=(nNum > 3)? terrainRes._detailTextureInfos[chunkInfo.detailID[k][3]].scale :null;
					terrainChunk.buildRenderElementAndMaterial(nNum,chunkInfo.normalMap,chunkInfo.alphaMap[k],sDetialTextureUrl1,sDetialTextureUrl2,sDetialTextureUrl3,sDetialTextureUrl4,terrainRes._materialInfo.ambientColor,terrainRes._materialInfo.diffuseColor,terrainRes._materialInfo.specularColor,detialScale1 ? detialScale1.x :1,detialScale1 ? detialScale1.y :1,detialScale2 ? detialScale2.x :1,detialScale2 ? detialScale2.y :1,detialScale3 ? detialScale3.x :1,detialScale3 ? detialScale3.y :1,detialScale4 ? detialScale4.x :1,detialScale4 ? detialScale4.y :1);
				}
				terrainChunk.terrainRender.receiveShadow=true;
				terrainChunk.terrainRender.lightmapScaleOffset=this._lightmapScaleOffset;
				this.addChild(terrainChunk);
			}
		}
	}

	/**
	*获取地形X轴长度。
	*@return 地形X轴长度。
	*/
	__proto.width=function(){
		return this._terrainRes._chunkNumX *TerrainLeaf.CHUNK_GRID_NUM *this._terrainRes._gridSize;
	}

	/**
	*获取地形Z轴长度。
	*@return 地形Z轴长度。
	*/
	__proto.depth=function(){
		return this._terrainRes._chunkNumZ *TerrainLeaf.CHUNK_GRID_NUM *this._terrainRes._gridSize;
	}

	/**
	*获取地形高度。
	*@param x X轴坐标。
	*@param z Z轴坐标。
	*/
	__proto.getHeightXZ=function(x,z){
		if (!this._terrainRes)
			return NaN;
		x-=this.transform.position.x;
		z-=this.transform.position.z;
		if (!Terrain.__VECTOR3__){
			Terrain.__VECTOR3__=new Vector3();
		}
		Terrain.__VECTOR3__.elements[0]=x;
		Terrain.__VECTOR3__.elements[1]=0;
		Terrain.__VECTOR3__.elements[2]=z;
		Vector3.transformV3ToV3(Terrain.__VECTOR3__,TerrainLeaf.__ADAPT_MATRIX_INV__,Terrain.__VECTOR3__);
		x=Terrain.__VECTOR3__.elements[0];
		z=Terrain.__VECTOR3__.elements[2];
		if (x < 0 || x > this.width()|| z < 0 || z > this.depth())
			return NaN;
		var gridSize=this._terrainRes._gridSize;
		var nIndexX=parseInt(""+x / gridSize);
		var nIndexZ=parseInt(""+z / gridSize);
		var offsetX=x-nIndexX *gridSize;
		var offsetZ=z-nIndexZ *gridSize;
		var h1=NaN;
		var h2=NaN;
		var h3=NaN;
		var u=NaN;
		var v=NaN;
		var heightData=this._terrainRes._heightData;
		if (offsetX+offsetZ > gridSize){
			h1=heightData._terrainHeightData[(nIndexZ+1-1)*heightData._width+nIndexX+1];
			h2=heightData._terrainHeightData[(nIndexZ+1-1)*heightData._width+nIndexX];
			h3=heightData._terrainHeightData[(nIndexZ-1)*heightData._width+nIndexX+1];
			u=(gridSize-offsetX)/ gridSize;
			v=(gridSize-offsetZ)/ gridSize;
			return h1+(h2-h1)*u+(h3-h1)*v;
			}else {
			h1=heightData._terrainHeightData[Math.max(0.0,nIndexZ-1)*heightData._width+nIndexX];
			h2=heightData._terrainHeightData[Math.min(heightData._width *heightData._height-1,(nIndexZ+1-1)*heightData._width+nIndexX)];
			h3=heightData._terrainHeightData[Math.min(heightData._width *heightData._height-1,Math.max(0.0,nIndexZ-1)*heightData._width+nIndexX+1)];
			u=offsetX / gridSize;
			v=offsetZ / gridSize;
			return h1+(h2-h1)*v+(h3-h1)*u;
		}
	}

	__getset(0,__proto,'terrainRes',null,function(value){
		if (value){
			this._terrainRes=value;
			this.buildTerrain(value);
		}
	});

	Terrain.load=function(url){
		Laya.loader.create(url,null,null,/*Laya3D.TERRAINRES*/"TERRAIN",null,null,1,false);
	}

	Terrain.RENDER_LINE_MODEL=false;
	Terrain.LOD_TOLERANCE_VALUE=4;
	Terrain.LOD_DISTANCE_FACTOR=2.0;
	Terrain.__VECTOR3__=null;
	return Terrain;
})(Sprite3D)


/**
*<code>PBRSpecularMaterial</code> 类用于实现PBR(Specular)材质。
*/
//class laya.d3.core.material.PBRSpecularMaterial extends laya.d3.core.material.BaseMaterial
var PBRSpecularMaterial=(function(_super){
	function PBRSpecularMaterial(){
		/**@private */
		this._albedoColor=null;
		/**@private */
		this._specularColor=null;
		/**@private */
		this._emissionColor=null;
		PBRSpecularMaterial.__super.call(this);
		this.setShaderName("PBRSpecular");
		this._albedoColor=new Vector4(1.0,1.0,1.0,1.0);
		this._shaderValues.setVector(PBRSpecularMaterial.ALBEDOCOLOR,new Vector4(1.0,1.0,1.0,1.0));
		this._emissionColor=new Vector4(0.0,0.0,0.0,0.0);
		this._shaderValues.setVector(PBRSpecularMaterial.EMISSIONCOLOR,new Vector4(0.0,0.0,0.0,0.0));
		this._specularColor=new Vector4(0.2,0.2,0.2,0.2);
		this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR,new Vector4(0.2,0.2,0.2,0.2));
		this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESS,0.5);
		this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSCALE,1.0);
		this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSOURCE,0);
		this._shaderValues.setNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH,1.0);
		this._shaderValues.setNumber(PBRSpecularMaterial.NORMALSCALE,1.0);
		this._shaderValues.setNumber(PBRSpecularMaterial.PARALLAXSCALE,0.001);
		this._shaderValues.setBool(PBRSpecularMaterial.ENABLEEMISSION,false);
		this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE,0.5);
	}

	__class(PBRSpecularMaterial,'laya.d3.core.material.PBRSpecularMaterial',_super);
	var __proto=PBRSpecularMaterial.prototype;
	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destMaterial=destObject;
		this._albedoColor.cloneTo(destMaterial._albedoColor);
		this._specularColor.cloneTo(destMaterial._specularColor);
		this._emissionColor.cloneTo(destMaterial._emissionColor);
	}

	/**
	*设置放射贴图。
	*@param value 放射贴图。
	*/
	/**
	*获取放射贴图。
	*@return 放射贴图。
	*/
	__getset(0,__proto,'emissionTexture',function(){
		return this._shaderValues.getTexture(PBRSpecularMaterial.EMISSIONTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE);
		else
		this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE);
		this._shaderValues.setTexture(PBRSpecularMaterial.EMISSIONTEXTURE,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_SpecColorG',function(){
		return this._specularColor.elements[1];
		},function(value){
		this._specularColor.elements[1]=value;
		this.specularColor=this._specularColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorB',function(){
		return this._albedoColor.elements[2];
		},function(value){
		this._albedoColor.elements[2]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorR',function(){
		return this._albedoColor.elements[0];
		},function(value){
		this._albedoColor.elements[0]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*设置反射率颜色A分量。
	*@param value 反射率颜色A分量。
	*/
	/**
	*获取反射率颜色A分量。
	*@return 反射率颜色A分量。
	*/
	__getset(0,__proto,'albedoColorA',function(){
		return this._ColorA;
		},function(value){
		this._ColorA=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STX',function(){
		return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).elements[0];
		},function(x){
		var tilOff=this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
		tilOff.elements[0]=x;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_SpecColorB',function(){
		return this._specularColor.elements[2];
		},function(value){
		this._specularColor.elements[2]=value;
		this.specularColor=this._specularColor;
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 0:
				this.alphaTest=false;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.remove(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
				break ;
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_ALPHATEST*/2450;
				this.alphaTest=true;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.remove(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.remove(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
				break ;
				break ;
			case 3:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE*/1;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.add(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
				break ;
			default :
				throw new Error("PBRSpecularMaterial : renderMode value error.");
			}
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_SpecColorR',function(){
		return this._specularColor.elements[0];
		},function(value){
		this._specularColor.elements[0]=value;
		this.specularColor=this._specularColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorG',function(){
		return this._albedoColor.elements[1];
		},function(value){
		this._albedoColor.elements[1]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_Glossiness',function(){
		return this._shaderValues.getNumber(PBRSpecularMaterial.SMOOTHNESS);
		},function(value){
		this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESS,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorA',function(){
		return this._albedoColor.elements[3];
		},function(value){
		this._albedoColor.elements[3]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*设置高光颜色。
	*@param value 高光颜色。
	*/
	/**
	*获取高光颜色。
	*@return 高光颜色。
	*/
	__getset(0,__proto,'specularColor',function(){
		return this._shaderValues.getVector(PBRSpecularMaterial.SPECULARCOLOR);
		},function(value){
		this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR,value);
	});

	/**
	*设置反射率颜色B分量。
	*@param value 反射率颜色B分量。
	*/
	/**
	*获取反射率颜色B分量。
	*@return 反射率颜色B分量。
	*/
	__getset(0,__proto,'albedoColorB',function(){
		return this._ColorB;
		},function(value){
		this._ColorB=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_SpecColorA',function(){
		return this._specularColor.elements[3];
		},function(value){
		this._specularColor.elements[3]=value;
		this.specularColor=this._specularColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_GlossMapScale',function(){
		return this._shaderValues.getNumber(PBRSpecularMaterial.SMOOTHNESSSCALE);
		},function(value){
		this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSCALE,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_BumpScale',function(){
		return this._shaderValues.getNumber(PBRSpecularMaterial.NORMALSCALE);
		},function(value){
		this._shaderValues.setNumber(PBRSpecularMaterial.NORMALSCALE,value);
	});

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_Parallax',function(){
		return this._shaderValues.getNumber(PBRSpecularMaterial.PARALLAXSCALE);
		},function(value){
		this._shaderValues.setNumber(PBRSpecularMaterial.PARALLAXSCALE,value);
	});

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_OcclusionStrength',function(){
		return this._shaderValues.getNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH);
		},function(value){
		this._shaderValues.setNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_EmissionColorR',function(){
		return this._emissionColor.elements[0];
		},function(value){
		this._emissionColor.elements[0]=value;
		this.emissionColor=this._emissionColor;
	});

	/**
	*获取纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._shaderValues.setVector(PBRSpecularMaterial.TILINGOFFSET,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_EmissionColorG',function(){
		return this._emissionColor.elements[1];
		},function(value){
		this._emissionColor.elements[1]=value;
		this.emissionColor=this._emissionColor;
	});

	/**
	*获取纹理平铺和偏移W分量。
	*@param w 纹理平铺和偏移W分量。
	*/
	/**
	*获取纹理平铺和偏移W分量。
	*@return 纹理平铺和偏移W分量。
	*/
	__getset(0,__proto,'tilingOffsetW',function(){
		return this._MainTex_STW;
		},function(w){
		this._MainTex_STW=w;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_EmissionColorB',function(){
		return this._emissionColor.elements[2];
		},function(value){
		this._emissionColor.elements[2]=value;
		this.emissionColor=this._emissionColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_EmissionColorA',function(){
		return this._emissionColor.elements[3];
		},function(value){
		this._emissionColor.elements[3]=value;
		this.emissionColor=this._emissionColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STY',function(){
		return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).elements[1];
		},function(y){
		var tilOff=this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
		tilOff.elements[1]=y;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STZ',function(){
		return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).elements[2];
		},function(z){
		var tilOff=this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
		tilOff.elements[2]=z;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_Cutoff',function(){
		return this.alphaTestValue;
		},function(value){
		this.alphaTestValue=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STW',function(){
		return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).elements[3];
		},function(w){
		var tilOff=this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
		tilOff.elements[3]=w;
		this.tilingOffset=tilOff;
	});

	/**
	*设置反射率颜色R分量。
	*@param value 反射率颜色R分量。
	*/
	/**
	*获取反射率颜色R分量。
	*@return 反射率颜色R分量。
	*/
	__getset(0,__proto,'albedoColorR',function(){
		return this._ColorR;
		},function(value){
		this._ColorR=value;
	});

	/**
	*设置反射率颜色G分量。
	*@param value 反射率颜色G分量。
	*/
	/**
	*获取反射率颜色G分量。
	*@return 反射率颜色G分量。
	*/
	__getset(0,__proto,'albedoColorG',function(){
		return this._ColorG;
		},function(value){
		this._ColorG=value;
	});

	/**
	*获取纹理平铺和偏移X分量。
	*@param x 纹理平铺和偏移X分量。
	*/
	/**
	*获取纹理平铺和偏移X分量。
	*@return 纹理平铺和偏移X分量。
	*/
	__getset(0,__proto,'tilingOffsetX',function(){
		return this._MainTex_STX;
		},function(x){
		this._MainTex_STX=x;
	});

	/**
	*设置反射率颜色。
	*@param value 反射率颜色。
	*/
	/**
	*获取反射率颜色。
	*@return 反射率颜色。
	*/
	__getset(0,__proto,'albedoColor',function(){
		return this._albedoColor;
		},function(value){
		this._albedoColor=value;
		this._shaderValues.setVector(PBRSpecularMaterial.ALBEDOCOLOR,value);
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'albedoTexture',function(){
		return this._shaderValues.getTexture(PBRSpecularMaterial.ALBEDOTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE);
		}
		this._shaderValues.setTexture(PBRSpecularMaterial.ALBEDOTEXTURE,value);
	});

	/**
	*设置视差贴图。
	*@param value 视察贴图。
	*/
	/**
	*获取视差贴图。
	*@return 视察贴图。
	*/
	__getset(0,__proto,'parallaxTexture',function(){
		return this._shaderValues.getTexture(PBRSpecularMaterial.PARALLAXTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE);
		}
		this._shaderValues.setTexture(PBRSpecularMaterial.PARALLAXTEXTURE,value);
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._shaderValues.getTexture(PBRSpecularMaterial.NORMALTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE);
		}
		this._shaderValues.setTexture(PBRSpecularMaterial.NORMALTEXTURE,value);
	});

	/**
	*设置放射颜色。
	*@param value 放射颜色。
	*/
	/**
	*获取放射颜色。
	*@return 放射颜色。
	*/
	__getset(0,__proto,'emissionColor',function(){
		return this._shaderValues.getVector(PBRSpecularMaterial.EMISSIONCOLOR);
		},function(value){
		this._shaderValues.setVector(PBRSpecularMaterial.EMISSIONCOLOR,value);
	});

	/**
	*设置视差贴图缩放系数。
	*@param value 视差缩放系数。
	*/
	/**
	*获取视差贴图缩放系数。
	*@return 视差缩放系数。
	*/
	__getset(0,__proto,'parallaxTextureScale',function(){
		return this._Parallax;
		},function(value){
		this._Parallax=Math.max(0.005,Math.min(0.08,value));
	});

	/**
	*设置法线贴图缩放系数。
	*@param value 法线贴图缩放系数。
	*/
	/**
	*获取法线贴图缩放系数。
	*@return 法线贴图缩放系数。
	*/
	__getset(0,__proto,'normalTextureScale',function(){
		return this._BumpScale;
		},function(value){
		this._BumpScale=value;
	});

	/**
	*获取纹理平铺和偏移Z分量。
	*@param z 纹理平铺和偏移Z分量。
	*/
	/**
	*获取纹理平铺和偏移Z分量。
	*@return 纹理平铺和偏移Z分量。
	*/
	__getset(0,__proto,'tilingOffsetZ',function(){
		return this._MainTex_STZ;
		},function(z){
		this._MainTex_STZ=z;
	});

	/**
	*设置遮挡贴图。
	*@param value 遮挡贴图。
	*/
	/**
	*获取遮挡贴图。
	*@return 遮挡贴图。
	*/
	__getset(0,__proto,'occlusionTexture',function(){
		return this._shaderValues.getTexture(PBRSpecularMaterial.OCCLUSIONTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
		}
		this._shaderValues.setTexture(PBRSpecularMaterial.OCCLUSIONTEXTURE,value);
	});

	/**
	*设置遮挡贴图强度。
	*@param value 遮挡贴图强度,范围为0到1。
	*/
	/**
	*获取遮挡贴图强度。
	*@return 遮挡贴图强度,范围为0到1。
	*/
	__getset(0,__proto,'occlusionTextureStrength',function(){
		return this._OcclusionStrength;
		},function(value){
		this._OcclusionStrength=Math.max(0.0,Math.min(1.0,value));
	});

	/**
	*设置高光贴图。
	*@param value 高光贴图。
	*/
	/**
	*获取高光贴图。
	*@return 高光贴图。
	*/
	__getset(0,__proto,'specularTexture',function(){
		return this._shaderValues.getTexture(PBRSpecularMaterial.SPECULARTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE);
		}
		this._shaderValues.setTexture(PBRSpecularMaterial.SPECULARTEXTURE,value);
	});

	/**
	*设置高光颜色R分量。
	*@param value 高光颜色R分量。
	*/
	/**
	*获取高光颜色R分量。
	*@return 高光颜色R分量。
	*/
	__getset(0,__proto,'specularColorR',function(){
		return this._SpecColorR;
		},function(value){
		this._SpecColorR=value;
	});

	/**
	*设置光滑度。
	*@param value 光滑度,范围为0到1。
	*/
	/**
	*获取光滑度。
	*@return 光滑度,范围为0到1。
	*/
	__getset(0,__proto,'smoothness',function(){
		return this._Glossiness;
		},function(value){
		this._Glossiness=Math.max(0.0,Math.min(1.0,value));
	});

	/**
	*设置高光颜色G分量。
	*@param value 高光颜色G分量。
	*/
	/**
	*获取高光颜色G分量。
	*@return 高光颜色G分量。
	*/
	__getset(0,__proto,'specularColorG',function(){
		return this._SpecColorG;
		},function(value){
		this._SpecColorG=value;
	});

	/**
	*设置高光颜色B分量。
	*@param value 高光颜色B分量。
	*/
	/**
	*获取高光颜色B分量。
	*@return 高光颜色B分量。
	*/
	__getset(0,__proto,'specularColorB',function(){
		return this._SpecColorB;
		},function(value){
		this._SpecColorB=value;
	});

	/**
	*设置高光颜色A分量。
	*@param value 高光颜色A分量。
	*/
	/**
	*获取高光颜色A分量。
	*@return 高光颜色A分量。
	*/
	__getset(0,__proto,'specularColorA',function(){
		return this._SpecColorA;
		},function(value){
		this._SpecColorA=value;
	});

	/**
	*设置光滑度缩放系数。
	*@param value 光滑度缩放系数,范围为0到1。
	*/
	/**
	*获取光滑度缩放系数。
	*@return 光滑度缩放系数,范围为0到1。
	*/
	__getset(0,__proto,'smoothnessTextureScale',function(){
		return this._GlossMapScale;
		},function(value){
		this._GlossMapScale=Math.max(0.0,Math.min(1.0,value));
	});

	/**
	*设置光滑度数据源。
	*@param value 光滑滑度数据源,0或1。
	*/
	/**
	*获取光滑度数据源
	*@return 光滑滑度数据源,0或1。
	*/
	__getset(0,__proto,'smoothnessSource',function(){
		return this._shaderValues.getInt(PBRSpecularMaterial.SMOOTHNESSSOURCE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
			this._shaderValues.setInt(PBRSpecularMaterial.SMOOTHNESSSOURCE,1);
		}
		else {
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
			this._shaderValues.setInt(PBRSpecularMaterial.SMOOTHNESSSOURCE,0);
		}
	});

	/**
	*设置是否激活放射属性。
	*@param value 是否激活放射属性
	*/
	/**
	*获取是否激活放射属性。
	*@return 是否激活放射属性。
	*/
	__getset(0,__proto,'enableEmission',function(){
		return this._shaderValues.getBool(PBRSpecularMaterial.ENABLEEMISSION);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION);
		else {
			this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION);
		}
		this._shaderValues.setBool(PBRSpecularMaterial.ENABLEEMISSION,value);
	});

	/**
	*设置是否开启反射。
	*@param value 是否开启反射。
	*/
	/**
	*获取是否开启反射。
	*@return 是否开启反射。
	*/
	__getset(0,__proto,'enableReflection',function(){
		return this._shaderValues.getBool(PBRSpecularMaterial.ENABLEREFLECT);
		},function(value){
		this._shaderValues.setBool(PBRSpecularMaterial.ENABLEREFLECT,true);
		if (value)
			this._disablePublicDefineDatas.remove(Scene3D.SHADERDEFINE_REFLECTMAP);
		else
		this._disablePublicDefineDatas.add(Scene3D.SHADERDEFINE_REFLECTMAP);
	});

	/**
	*获取纹理平铺和偏移Y分量。
	*@param y 纹理平铺和偏移Y分量。
	*/
	/**
	*获取纹理平铺和偏移Y分量。
	*@return 纹理平铺和偏移Y分量。
	*/
	__getset(0,__proto,'tilingOffsetY',function(){
		return this._MainTex_STY;
		},function(y){
		this._MainTex_STY=y;
	});

	PBRSpecularMaterial.__init__=function(){
		PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("SPECULARTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA=PBRSpecularMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
		PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_EMISSION=PBRSpecularMaterial.shaderDefines.registerDefine("EMISSION");
		PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE=PBRSpecularMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE");
		PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET=PBRSpecularMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY=PBRSpecularMaterial.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
	}

	PBRSpecularMaterial.SmoothnessSource_SpecularTexture_Alpha=0;
	PBRSpecularMaterial.SmoothnessSource_AlbedoTexture_Alpha=1;
	PBRSpecularMaterial.RENDERMODE_OPAQUE=0;
	PBRSpecularMaterial.RENDERMODE_CUTOUT=1;
	PBRSpecularMaterial.RENDERMODE_FADE=2;
	PBRSpecularMaterial.RENDERMODE_TRANSPARENT=3;
	PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA=0;
	PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_EMISSION=0;
	PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE=0;
	PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET=0;
	PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY=0;
	PBRSpecularMaterial.SMOOTHNESSSOURCE=-1;
	PBRSpecularMaterial.ENABLEEMISSION=-1;
	PBRSpecularMaterial.ENABLEREFLECT=-1;
	__static(PBRSpecularMaterial,
	['ALBEDOTEXTURE',function(){return this.ALBEDOTEXTURE=Shader3D.propertyNameToID("u_AlbedoTexture");},'SPECULARTEXTURE',function(){return this.SPECULARTEXTURE=Shader3D.propertyNameToID("u_SpecularTexture");},'NORMALTEXTURE',function(){return this.NORMALTEXTURE=Shader3D.propertyNameToID("u_NormalTexture");},'PARALLAXTEXTURE',function(){return this.PARALLAXTEXTURE=Shader3D.propertyNameToID("u_ParallaxTexture");},'OCCLUSIONTEXTURE',function(){return this.OCCLUSIONTEXTURE=Shader3D.propertyNameToID("u_OcclusionTexture");},'EMISSIONTEXTURE',function(){return this.EMISSIONTEXTURE=Shader3D.propertyNameToID("u_EmissionTexture");},'ALBEDOCOLOR',function(){return this.ALBEDOCOLOR=Shader3D.propertyNameToID("u_AlbedoColor");},'SPECULARCOLOR',function(){return this.SPECULARCOLOR=Shader3D.propertyNameToID("u_SpecularColor");},'EMISSIONCOLOR',function(){return this.EMISSIONCOLOR=Shader3D.propertyNameToID("u_EmissionColor");},'SMOOTHNESS',function(){return this.SMOOTHNESS=Shader3D.propertyNameToID("u_smoothness");},'SMOOTHNESSSCALE',function(){return this.SMOOTHNESSSCALE=Shader3D.propertyNameToID("u_smoothnessScale");},'OCCLUSIONSTRENGTH',function(){return this.OCCLUSIONSTRENGTH=Shader3D.propertyNameToID("u_occlusionStrength");},'NORMALSCALE',function(){return this.NORMALSCALE=Shader3D.propertyNameToID("u_normalScale");},'PARALLAXSCALE',function(){return this.PARALLAXSCALE=Shader3D.propertyNameToID("u_parallaxScale");},'TILINGOFFSET',function(){return this.TILINGOFFSET=Shader3D.propertyNameToID("u_TilingOffset");},'defaultMaterial',function(){return this.defaultMaterial=new PBRSpecularMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return PBRSpecularMaterial;
})(BaseMaterial)


/**
*<code>UnlitMaterial</code> 类用于实现不受光照影响的材质。
*/
//class laya.d3.core.material.UnlitMaterial extends laya.d3.core.material.BaseMaterial
var UnlitMaterial=(function(_super){
	function UnlitMaterial(){
		/**@private */
		this._albedoIntensity=1.0;
		/**@private */
		this._enableVertexColor=false;
		this._albedoColor=new Vector4(1.0,1.0,1.0,1.0);
		UnlitMaterial.__super.call(this);
		this.setShaderName("Unlit");
		this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR,new Vector4(1.0,1.0,1.0,1.0));
	}

	__class(UnlitMaterial,'laya.d3.core.material.UnlitMaterial',_super);
	var __proto=UnlitMaterial.prototype;
	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorB',function(){
		return this._albedoColor.elements[2];
		},function(value){
		this._albedoColor.elements[2]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorR',function(){
		return this._albedoColor.elements[0];
		},function(value){
		this._albedoColor.elements[0]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*设置反照率颜色alpha分量。
	*@param value 反照率颜色alpha分量。
	*/
	/**
	*获取反照率颜色Z分量。
	*@return 反照率颜色Z分量。
	*/
	__getset(0,__proto,'albedoColorA',function(){
		return this._ColorA;
		},function(value){
		this._ColorA=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STX',function(){
		return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).elements[0];
		},function(x){
		var tilOff=this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
		tilOff.elements[0]=x;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorG',function(){
		return this._albedoColor.elements[1];
		},function(value){
		this._albedoColor.elements[1]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_ColorA',function(){
		return this._albedoColor.elements[3];
		},function(value){
		this._albedoColor.elements[3]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_AlbedoIntensity',function(){
		return this._albedoIntensity;
		},function(value){
		if (this._albedoIntensity!==value){
			var finalAlbedo=this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
			Vector4.scale(this._albedoColor,value,finalAlbedo);
			this._albedoIntensity=value;
			this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR,finalAlbedo);
		}
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STZ',function(){
		return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).elements[2];
		},function(z){
		var tilOff=this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
		tilOff.elements[2]=z;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STY',function(){
		return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).elements[1];
		},function(y){
		var tilOff=this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
		tilOff.elements[1]=y;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_Cutoff',function(){
		return this.alphaTestValue;
		},function(value){
		this.alphaTestValue=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STW',function(){
		return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).elements[3];
		},function(w){
		var tilOff=this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
		tilOff.elements[3]=w;
		this.tilingOffset=tilOff;
	});

	/**
	*设置反照率颜色R分量。
	*@param value 反照率颜色R分量。
	*/
	/**
	*获取反照率颜色R分量。
	*@return 反照率颜色R分量。
	*/
	__getset(0,__proto,'albedoColorR',function(){
		return this._ColorR;
		},function(value){
		this._ColorR=value;
	});

	/**
	*设置反照率颜色G分量。
	*@param value 反照率颜色G分量。
	*/
	/**
	*获取反照率颜色G分量。
	*@return 反照率颜色G分量。
	*/
	__getset(0,__proto,'albedoColorG',function(){
		return this._ColorG;
		},function(value){
		this._ColorG=value;
	});

	/**
	*设置反照率颜色B分量。
	*@param value 反照率颜色B分量。
	*/
	/**
	*获取反照率颜色B分量。
	*@return 反照率颜色B分量。
	*/
	__getset(0,__proto,'albedoColorB',function(){
		return this._ColorB;
		},function(value){
		this._ColorB=value;
	});

	/**
	*获取纹理平铺和偏移X分量。
	*@param x 纹理平铺和偏移X分量。
	*/
	/**
	*获取纹理平铺和偏移X分量。
	*@return 纹理平铺和偏移X分量。
	*/
	__getset(0,__proto,'tilingOffsetX',function(){
		return this._MainTex_STX;
		},function(x){
		this._MainTex_STX=x;
	});

	/**
	*设置反照率颜色。
	*@param value 反照率颜色。
	*/
	/**
	*获取反照率颜色。
	*@return 反照率颜色。
	*/
	__getset(0,__proto,'albedoColor',function(){
		return this._albedoColor;
		},function(value){
		var finalAlbedo=this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
		Vector4.scale(value,this._albedoIntensity,finalAlbedo);
		this._albedoColor=value;
		this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR,finalAlbedo);
	});

	/**
	*设置反照率强度。
	*@param value 反照率强度。
	*/
	/**
	*获取反照率强度。
	*@return 反照率强度。
	*/
	__getset(0,__proto,'albedoIntensity',function(){
		return this._albedoIntensity;
		},function(value){
		this._AlbedoIntensity=value;
	});

	/**
	*设置是否支持顶点色。
	*@param value 是否支持顶点色。
	*/
	/**
	*获取是否支持顶点色。
	*@return 是否支持顶点色。
	*/
	__getset(0,__proto,'enableVertexColor',function(){
		return this._enableVertexColor;
		},function(value){
		this._enableVertexColor=value;
		if (value)
			this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
		else
		this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
	});

	/**
	*设置反照率贴图。
	*@param value 反照率贴图。
	*/
	/**
	*获取反照率贴图。
	*@return 反照率贴图。
	*/
	__getset(0,__proto,'albedoTexture',function(){
		return this._shaderValues.getTexture(UnlitMaterial.ALBEDOTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
		else
		this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
		this._shaderValues.setTexture(UnlitMaterial.ALBEDOTEXTURE,value);
	});

	/**
	*获取纹理平铺和偏移Y分量。
	*@param y 纹理平铺和偏移Y分量。
	*/
	/**
	*获取纹理平铺和偏移Y分量。
	*@return 纹理平铺和偏移Y分量。
	*/
	__getset(0,__proto,'tilingOffsetY',function(){
		return this._MainTex_STY;
		},function(y){
		this._MainTex_STY=y;
	});

	/**
	*获取纹理平铺和偏移Z分量。
	*@param z 纹理平铺和偏移Z分量。
	*/
	/**
	*获取纹理平铺和偏移Z分量。
	*@return 纹理平铺和偏移Z分量。
	*/
	__getset(0,__proto,'tilingOffsetZ',function(){
		return this._MainTex_STZ;
		},function(z){
		this._MainTex_STZ=z;
	});

	/**
	*获取纹理平铺和偏移W分量。
	*@param w 纹理平铺和偏移W分量。
	*/
	/**
	*获取纹理平铺和偏移W分量。
	*@return 纹理平铺和偏移W分量。
	*/
	__getset(0,__proto,'tilingOffsetW',function(){
		return this._MainTex_STW;
		},function(w){
		this._MainTex_STW=w;
	});

	/**
	*获取纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._shaderValues.setVector(UnlitMaterial.TILINGOFFSET,value);
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 0:
				this.alphaTest=false;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				break ;
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_ALPHATEST*/2450;
				this.alphaTest=true;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				break ;
			default :
				throw new Error("UnlitMaterial : renderMode value error.");
			}
	});

	UnlitMaterial.__init__=function(){
		UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE=UnlitMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE");
		UnlitMaterial.SHADERDEFINE_TILINGOFFSET=UnlitMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR=UnlitMaterial.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
	}

	UnlitMaterial.RENDERMODE_OPAQUE=0;
	UnlitMaterial.RENDERMODE_CUTOUT=1;
	UnlitMaterial.RENDERMODE_TRANSPARENT=2;
	UnlitMaterial.RENDERMODE_ADDTIVE=3;
	UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE=0;
	UnlitMaterial.SHADERDEFINE_TILINGOFFSET=0;
	UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR=0;
	__static(UnlitMaterial,
	['ALBEDOTEXTURE',function(){return this.ALBEDOTEXTURE=Shader3D.propertyNameToID("u_AlbedoTexture");},'ALBEDOCOLOR',function(){return this.ALBEDOCOLOR=Shader3D.propertyNameToID("u_AlbedoColor");},'TILINGOFFSET',function(){return this.TILINGOFFSET=Shader3D.propertyNameToID("u_TilingOffset");},'defaultMaterial',function(){return this.defaultMaterial=new UnlitMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return UnlitMaterial;
})(BaseMaterial)


/**
*...
*@author
*/
//class laya.d3.core.pixelLine.PixelLineMaterial extends laya.d3.core.material.BaseMaterial
var PixelLineMaterial=(function(_super){
	function PixelLineMaterial(){
		PixelLineMaterial.__super.call(this);
		this.setShaderName("LineShader");
		this._shaderValues.setVector(PixelLineMaterial.COLOR,new Vector4(1.0,1.0,1.0,1.0));
	}

	__class(PixelLineMaterial,'laya.d3.core.pixelLine.PixelLineMaterial',_super);
	var __proto=PixelLineMaterial.prototype;
	/**
	*设置颜色。
	*@param value 颜色。
	*/
	/**
	*获取颜色。
	*@return 颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._shaderValues.getVector(PixelLineMaterial.COLOR);
		},function(value){
		this._shaderValues.setVector(PixelLineMaterial.COLOR,value);
	});

	PixelLineMaterial.__init__=function(){}
	__static(PixelLineMaterial,
	['COLOR',function(){return this.COLOR=Shader3D.propertyNameToID("u_Color");},'defaultMaterial',function(){return this.defaultMaterial=new PixelLineMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return PixelLineMaterial;
})(BaseMaterial)


/**
*<code>ShurikenParticleMaterial</code> 类用于实现拖尾材质。
*/
//class laya.d3.core.trail.TrailMaterial extends laya.d3.core.material.BaseMaterial
var TrailMaterial=(function(_super){
	function TrailMaterial(){
		/**@private */
		this._color=null;
		TrailMaterial.__super.call(this);
		this.setShaderName("Trail");
		this._color=new Vector4(1.0,1.0,1.0,1.0);
		this._shaderValues.setVector(TrailMaterial.TINTCOLOR,new Vector4(1.0,1.0,1.0,1.0));
		this.renderMode=0;
	}

	__class(TrailMaterial,'laya.d3.core.trail.TrailMaterial',_super);
	var __proto=TrailMaterial.prototype;
	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorB',function(){
		return this._color.elements[2];
		},function(value){
		this._color.elements[2]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STZ',function(){
		return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).elements[2];
		},function(z){
		var tilOff=this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
		tilOff.elements[2]=z;
		this.tilingOffset=tilOff;
	});

	/**
	*设置贴图。
	*@param value 贴图。
	*/
	/**
	*获取贴图。
	*@return 贴图。
	*/
	__getset(0,__proto,'texture',function(){
		return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_MAINTEXTURE);
		else
		this._defineDatas.remove(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_MAINTEXTURE);
		this._shaderValues.setTexture(TrailMaterial.MAINTEXTURE,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorR',function(){
		return this._color.elements[0];
		},function(value){
		this._color.elements[0]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STW',function(){
		return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).elements[3];
		},function(w){
		var tilOff=this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
		tilOff.elements[3]=w;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorG',function(){
		return this._color.elements[1];
		},function(value){
		this._color.elements[1]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_TintColorA',function(){
		return this._color.elements[3];
		},function(value){
		this._color.elements[3]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STY',function(){
		return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).elements[1];
		},function(y){
		var tilOff=this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
		tilOff.elements[1]=y;
		this.tilingOffset=tilOff;
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_NONE*/0;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE*/1;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.add(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 0:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_NONE*/0;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.remove(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			default :
				throw new Error("TrailMaterial : renderMode value error.");
			}
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STX',function(){
		return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).elements[0];
		},function(x){
		var tilOff=this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
		tilOff.elements[0]=x;
		this.tilingOffset=tilOff;
	});

	/**
	*设置颜色R分量。
	*@param value 颜色R分量。
	*/
	/**
	*获取颜色R分量。
	*@return 颜色R分量。
	*/
	__getset(0,__proto,'colorR',function(){
		return this._TintColorR;
		},function(value){
		this._TintColorR=value;
	});

	/**
	*设置颜色G分量。
	*@param value 颜色G分量。
	*/
	/**
	*获取颜色G分量。
	*@return 颜色G分量。
	*/
	__getset(0,__proto,'colorG',function(){
		return this._TintColorG;
		},function(value){
		this._TintColorG=value;
	});

	/**
	*设置颜色B分量。
	*@param value 颜色B分量。
	*/
	/**
	*获取颜色B分量。
	*@return 颜色B分量。
	*/
	__getset(0,__proto,'colorB',function(){
		return this._TintColorB;
		},function(value){
		this._TintColorB=value;
	});

	/**
	*设置颜色alpha分量。
	*@param value 颜色alpha分量。
	*/
	/**
	*获取颜色Z分量。
	*@return 颜色Z分量。
	*/
	__getset(0,__proto,'colorA',function(){
		return this._TintColorA;
		},function(value){
		this._TintColorA=value;
	});

	/**
	*设置颜色。
	*@param value 颜色。
	*/
	/**
	*获取颜色。
	*@return 颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._shaderValues.getVector(TrailMaterial.TINTCOLOR);
		},function(value){
		this._shaderValues.setVector(TrailMaterial.TINTCOLOR,value);
	});

	/**
	*获取纹理平铺和偏移X分量。
	*@param x 纹理平铺和偏移X分量。
	*/
	/**
	*获取纹理平铺和偏移X分量。
	*@return 纹理平铺和偏移X分量。
	*/
	__getset(0,__proto,'tilingOffsetX',function(){
		return this._MainTex_STX;
		},function(x){
		this._MainTex_STX=x;
	});

	/**
	*获取纹理平铺和偏移Y分量。
	*@param y 纹理平铺和偏移Y分量。
	*/
	/**
	*获取纹理平铺和偏移Y分量。
	*@return 纹理平铺和偏移Y分量。
	*/
	__getset(0,__proto,'tilingOffsetY',function(){
		return this._MainTex_STY;
		},function(y){
		this._MainTex_STY=y;
	});

	/**
	*获取纹理平铺和偏移Z分量。
	*@param z 纹理平铺和偏移Z分量。
	*/
	/**
	*获取纹理平铺和偏移Z分量。
	*@return 纹理平铺和偏移Z分量。
	*/
	__getset(0,__proto,'tilingOffsetZ',function(){
		return this._MainTex_STZ;
		},function(z){
		this._MainTex_STZ=z;
	});

	/**
	*获取纹理平铺和偏移W分量。
	*@param w 纹理平铺和偏移W分量。
	*/
	/**
	*获取纹理平铺和偏移W分量。
	*@return 纹理平铺和偏移W分量。
	*/
	__getset(0,__proto,'tilingOffsetW',function(){
		return this._MainTex_STW;
		},function(w){
		this._MainTex_STW=w;
	});

	/**
	*设置纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._defineDatas.add(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._defineDatas.remove(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._defineDatas.remove(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._shaderValues.setVector(TrailMaterial.TILINGOFFSET,value);
	});

	TrailMaterial.__init__=function(){
		TrailMaterial.SHADERDEFINE_MAINTEXTURE=TrailMaterial.shaderDefines.registerDefine("MAINTEXTURE");
		TrailMaterial.SHADERDEFINE_TILINGOFFSET=TrailMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		TrailMaterial.SHADERDEFINE_ADDTIVEFOG=TrailMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
	}

	TrailMaterial.RENDERMODE_ALPHABLENDED=0;
	TrailMaterial.RENDERMODE_ADDTIVE=1;
	TrailMaterial.SHADERDEFINE_MAINTEXTURE=0;
	TrailMaterial.SHADERDEFINE_TILINGOFFSET=0;
	TrailMaterial.SHADERDEFINE_ADDTIVEFOG=0;
	__static(TrailMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new TrailMaterial();},'MAINTEXTURE',function(){return this.MAINTEXTURE=Shader3D.propertyNameToID("u_MainTexture");},'TINTCOLOR',function(){return this.TINTCOLOR=Shader3D.propertyNameToID("u_MainColor");},'TILINGOFFSET',function(){return this.TILINGOFFSET=Shader3D.propertyNameToID("u_TilingOffset");},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return TrailMaterial;
})(BaseMaterial)


/**
*<code>BaseCamera</code> 类用于创建摄像机的父类。
*/
//class laya.d3.core.BaseCamera extends laya.d3.core.Sprite3D
var BaseCamera=(function(_super){
	function BaseCamera(nearPlane,farPlane){
		/**@private 渲染顺序。*/
		//this._renderingOrder=0;
		/**@private 近裁剪面。*/
		//this._nearPlane=NaN;
		/**@private 远裁剪面。*/
		//this._farPlane=NaN;
		/**@private 视野。*/
		//this._fieldOfView=NaN;
		/**@private 正交投影的垂直尺寸。*/
		//this._orthographicVerticalSize=NaN;
		/**@private */
		//this._orthographic=false;
		/**@private 渲染目标。*/
		//this._renderTarget=null;
		/**@private 是否使用用户自定义投影矩阵，如果使用了用户投影矩阵，摄像机投影矩阵相关的参数改变则不改变投影矩阵的值，需调用ResetProjectionMatrix方法。*/
		//this._useUserProjectionMatrix=false;
		/**@private */
		//this._shaderValues=null;
		/**@private [只读] 需先调用viewport保证值正确。*/
		//this._canvasWidth=NaN;
		/**@private [只读] 需先调用viewport保证值正确。*/
		//this._canvasHeight=NaN;
		/**清楚标记。*/
		//this.clearFlag=0;
		/**摄像机的清除颜色。*/
		//this.clearColor=null;
		/**可视层位标记遮罩值,支持混合 例:cullingMask=Math.pow(2,0)|Math.pow(2,1)为第0层和第1层可见。*/
		//this.cullingMask=0;
		/**渲染时是否用遮挡剔除。 */
		//this.useOcclusionCulling=false;
		BaseCamera.__super.call(this);
		this._skyRenderer=new SkyRenderer();
		(nearPlane===void 0)&& (nearPlane=0.3);
		(farPlane===void 0)&& (farPlane=1000);
		this._shaderValues=new ShaderData(null);
		this._fieldOfView=60;
		this._useUserProjectionMatrix=false;
		this._orthographic=false;
		this._orthographicVerticalSize=10;
		this.renderingOrder=0;
		this._nearPlane=nearPlane;
		this._farPlane=farPlane;
		this.cullingMask=2147483647;
		this.clearFlag=/*CLASS CONST:laya.d3.core.BaseCamera.CLEARFLAG_SOLIDCOLOR*/0;
		this.useOcclusionCulling=true;
		this._calculateProjectionMatrix();
		Laya.stage.on(/*laya.events.Event.RESIZE*/"resize",this,this._onScreenSizeChanged);
	}

	__class(BaseCamera,'laya.d3.core.BaseCamera',_super);
	var __proto=BaseCamera.prototype;
	/**
	*通过RenderingOrder属性对摄像机机型排序。
	*/
	__proto._sortCamerasByRenderingOrder=function(){
		if (this.displayedInStage){
			var cameraPool=this.scene._cameraPool;
			var n=cameraPool.length-1;
			for (var i=0;i < n;i++){
				if (cameraPool[i].renderingOrder > cameraPool[n].renderingOrder){
					var tempCamera=cameraPool[i];
					cameraPool[i]=cameraPool[n];
					cameraPool[n]=tempCamera;
				}
			}
		}
	}

	/**
	*@private
	*/
	__proto._calculateProjectionMatrix=function(){}
	/**
	*@private
	*/
	__proto._onScreenSizeChanged=function(){
		this._calculateProjectionMatrix();
	}

	/**
	*@private
	*/
	__proto._prepareCameraToRender=function(){
		var cameraSV=this._shaderValues;
		cameraSV.setVector(laya.d3.core.BaseCamera.CAMERAPOS,this.transform.position);
		cameraSV.setVector(laya.d3.core.BaseCamera.CAMERADIRECTION,this.transform.forward);
		cameraSV.setVector(laya.d3.core.BaseCamera.CAMERAUP,this.transform.up);
	}

	/**
	*@private
	*/
	__proto._prepareCameraViewProject=function(vieMat,proMat,vieProNoTraSca){
		var cameraSV=this._shaderValues;
		cameraSV.setMatrix4x4(laya.d3.core.BaseCamera.VIEWMATRIX,vieMat);
		cameraSV.setMatrix4x4(laya.d3.core.BaseCamera.PROJECTMATRIX,proMat);
		this.transform.worldMatrix.cloneTo(BaseCamera._tempMatrix4x40);
		BaseCamera._tempMatrix4x40.transpose();
		Matrix4x4.multiply(proMat,BaseCamera._tempMatrix4x40,vieProNoTraSca);
		cameraSV.setMatrix4x4(laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE,vieProNoTraSca);
	}

	/**
	*相机渲染。
	*@param shader 着色器。
	*@param replacementTag 着色器替换标记。
	*/
	__proto.render=function(shader,replacementTag){}
	/**
	*增加可视图层,layer值为0到31层。
	*@param layer 图层。
	*/
	__proto.addLayer=function(layer){
		this.cullingMask |=Math.pow(2,layer);
	}

	/**
	*移除可视图层,layer值为0到31层。
	*@param layer 图层。
	*/
	__proto.removeLayer=function(layer){
		this.cullingMask &=~Math.pow(2,layer);
	}

	/**
	*增加所有图层。
	*/
	__proto.addAllLayers=function(){
		this.cullingMask=2147483647;
	}

	/**
	*移除所有图层。
	*/
	__proto.removeAllLayers=function(){
		this.cullingMask=0;
	}

	__proto.resetProjectionMatrix=function(){
		this._useUserProjectionMatrix=false;
		this._calculateProjectionMatrix();
	}

	/**
	*@inheritDoc
	*/
	__proto._onActive=function(){
		(this._scene)._addCamera(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._onInActive=function(){
		(this._scene)._removeCamera(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		_super.prototype._parse.call(this,data);
		var clearFlagData=data.clearFlag;
		(clearFlagData!==undefined)&& (this.clearFlag=clearFlagData);
		this.orthographic=data.orthographic;
		this.fieldOfView=data.fieldOfView;
		this.nearPlane=data.nearPlane;
		this.farPlane=data.farPlane;
		var color=data.clearColor;
		this.clearColor=new Vector4(color[0],color[1],color[2],color[3]);
		var skyboxMaterial=data.skyboxMaterial;
		if (skyboxMaterial){
			this._skyRenderer.material=Loader.getRes(skyboxMaterial.path);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this.renderTarget=null;
		this._skyRenderer.destroy();
		this._skyRenderer=null;
		Laya.stage.off(/*laya.events.Event.RESIZE*/"resize",this,this._onScreenSizeChanged);
		_super.prototype.destroy.call(this,destroyChild);
	}

	__getset(0,__proto,'renderingOrder',function(){
		return this._renderingOrder;
		},function(value){
		this._renderingOrder=value;
		this._sortCamerasByRenderingOrder();
	});

	/**
	*获取天空渲染器。
	*@return 天空渲染器。
	*/
	__getset(0,__proto,'skyRenderer',function(){
		return this._skyRenderer;
	});

	/**
	*设置远裁面。
	*@param value 远裁面。
	*/
	/**
	*获取远裁面。
	*@return 远裁面。
	*/
	__getset(0,__proto,'farPlane',function(){
		return this._farPlane;
		},function(vaule){
		this._farPlane=vaule;
		this._calculateProjectionMatrix();
	});

	/**
	*设置渲染场景的渲染目标。
	*@param value 渲染场景的渲染目标。
	*/
	/**
	*获取渲染场景的渲染目标。
	*@return 渲染场景的渲染目标。
	*/
	__getset(0,__proto,'renderTarget',function(){
		return this._renderTarget;
		},function(value){
		if (this._renderTarget!==value){
			this._renderTarget=value;
			this._calculateProjectionMatrix();
		}
	});

	/**
	*设置是否正交投影矩阵。
	*@param 是否正交投影矩阵。
	*/
	/**
	*获取是否正交投影矩阵。
	*@return 是否正交投影矩阵。
	*/
	__getset(0,__proto,'orthographic',function(){
		return this._orthographic;
		},function(vaule){
		this._orthographic=vaule;
		this._calculateProjectionMatrix();
	});

	/**
	*设置视野。
	*@param value 视野。
	*/
	/**
	*获取视野。
	*@return 视野。
	*/
	__getset(0,__proto,'fieldOfView',function(){
		return this._fieldOfView;
		},function(value){
		this._fieldOfView=value;
		this._calculateProjectionMatrix();
	});

	/**
	*设置近裁面。
	*@param value 近裁面。
	*/
	/**
	*获取近裁面。
	*@return 近裁面。
	*/
	__getset(0,__proto,'nearPlane',function(){
		return this._nearPlane;
		},function(value){
		this._nearPlane=value;
		this._calculateProjectionMatrix();
	});

	/**
	*设置正交投影垂直矩阵尺寸。
	*@param 正交投影垂直矩阵尺寸。
	*/
	/**
	*获取正交投影垂直矩阵尺寸。
	*@return 正交投影垂直矩阵尺寸。
	*/
	__getset(0,__proto,'orthographicVerticalSize',function(){
		return this._orthographicVerticalSize;
		},function(vaule){
		this._orthographicVerticalSize=vaule;
		this._calculateProjectionMatrix();
	});

	BaseCamera.VPMATRIX=3;
	BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING="DEFERREDLIGHTING";
	BaseCamera.RENDERINGTYPE_FORWARDRENDERING="FORWARDRENDERING";
	BaseCamera.CLEARFLAG_SOLIDCOLOR=0;
	BaseCamera.CLEARFLAG_SKY=1;
	BaseCamera.CLEARFLAG_DEPTHONLY=2;
	BaseCamera.CLEARFLAG_NONE=3;
	__static(BaseCamera,
	['_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'CAMERAPOS',function(){return this.CAMERAPOS=Shader3D.propertyNameToID("u_CameraPos");},'VIEWMATRIX',function(){return this.VIEWMATRIX=Shader3D.propertyNameToID("u_View");},'PROJECTMATRIX',function(){return this.PROJECTMATRIX=Shader3D.propertyNameToID("u_Projection");},'VPMATRIX_NO_TRANSLATE',function(){return this.VPMATRIX_NO_TRANSLATE=Shader3D.propertyNameToID("u_MvpMatrix");},'CAMERADIRECTION',function(){return this.CAMERADIRECTION=Shader3D.propertyNameToID("u_CameraDirection");},'CAMERAUP',function(){return this.CAMERAUP=Shader3D.propertyNameToID("u_CameraUp");},'_invertYScaleMatrix',function(){return this._invertYScaleMatrix=new Matrix4x4(1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1);},'_invertYProjectionMatrix',function(){return this._invertYProjectionMatrix=new Matrix4x4();},'_invertYProjectionViewMatrix',function(){return this._invertYProjectionViewMatrix=new Matrix4x4();}
	]);
	return BaseCamera;
})(Sprite3D)


/**
*...
*@author ...
*/
//class laya.d3.core.material.TerrainMaterial extends laya.d3.core.material.BaseMaterial
var TerrainMaterial=(function(_super){
	function TerrainMaterial(){
		this._diffuseScale1=null;
		this._diffuseScale2=null;
		this._diffuseScale3=null;
		this._diffuseScale4=null;
		TerrainMaterial.__super.call(this);
		this.setShaderName("Terrain");
		this.renderMode=1;
		this._diffuseScale1=new Vector2();
		this._diffuseScale2=new Vector2();
		this._diffuseScale3=new Vector2();
		this._diffuseScale4=new Vector2();
		this.ambientColor=new Vector3(0.6,0.6,0.6);
		this.diffuseColor=new Vector3(1.0,1.0,1.0);
		this.specularColor=new Vector4(0.2,0.2,0.2,32.0);
	}

	__class(TerrainMaterial,'laya.d3.core.material.TerrainMaterial',_super);
	var __proto=TerrainMaterial.prototype;
	__proto.setDiffuseScale1=function(x,y){
		this._diffuseScale1.x=x;
		this._diffuseScale1.y=y;
		this._shaderValues.setVector(6,this._diffuseScale1);
	}

	__proto.setDiffuseScale2=function(x,y){
		this._diffuseScale2.x=x;
		this._diffuseScale2.y=y;
		this._shaderValues.setVector(7,this._diffuseScale2);
	}

	__proto.setDiffuseScale3=function(x,y){
		this._diffuseScale3.x=x;
		this._diffuseScale3.y=y;
		this._shaderValues.setVector(8,this._diffuseScale3);
	}

	__proto.setDiffuseScale4=function(x,y){
		this._diffuseScale4.x=x;
		this._diffuseScale4.y=y;
		this._shaderValues.setVector(9,this._diffuseScale4);
	}

	__proto.setDetailNum=function(value){
		switch (value){
			case 1:
				this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				break ;
			case 2:
				this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				break ;
			case 3:
				this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				break ;
			case 4:
				this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				break ;
			}
	}

	__proto.disableLight=function(){
		this._disablePublicDefineDatas.add(Scene3D.SHADERDEFINE_POINTLIGHT | Scene3D.SHADERDEFINE_SPOTLIGHT | Scene3D.SHADERDEFINE_DIRECTIONLIGHT);
	}

	/**
	*@inheritDoc
	*/
	__proto.setShaderName=function(name){
		_super.prototype.setShaderName.call(this,name);
	}

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LEQUAL*/0x0203;
				break ;
			default :
				throw new Error("TerrainMaterial:renderMode value error.");
			}
	});

	/**
	*设置第二层贴图。
	*@param value 第二层贴图。
	*/
	/**
	*获取第二层贴图。
	*@return 第二层贴图。
	*/
	__getset(0,__proto,'diffuseTexture2',function(){
		return this._shaderValues.getTexture(3);
		},function(value){
		this._shaderValues.setTexture(3,value);
	});

	__getset(0,__proto,'ambientColor',function(){
		return this._shaderValues.getVector(10);
		},function(value){
		this._shaderValues.setVector(10,value);
	});

	/**
	*设置第四层贴图。
	*@param value 第四层贴图。
	*/
	/**
	*获取第四层贴图。
	*@return 第四层贴图。
	*/
	__getset(0,__proto,'diffuseTexture4',function(){
		return this._shaderValues.getTexture(5);
		},function(value){
		this._shaderValues.setTexture(5,value);
	});

	__getset(0,__proto,'diffuseColor',function(){
		return this._shaderValues.getVector(11);
		},function(value){
		this._shaderValues.setVector(11,value);
	});

	/**
	*设置第一层贴图。
	*@param value 第一层贴图。
	*/
	/**
	*获取第一层贴图。
	*@return 第一层贴图。
	*/
	__getset(0,__proto,'diffuseTexture1',function(){
		return this._shaderValues.getTexture(2);
		},function(value){
		this._shaderValues.setTexture(2,value);
	});

	__getset(0,__proto,'specularColor',function(){
		return this._shaderValues.getVector(12);
		},function(value){
		this._shaderValues.setVector(12,value);
	});

	/**
	*设置第三层贴图。
	*@param value 第三层贴图。
	*/
	/**
	*获取第三层贴图。
	*@return 第三层贴图。
	*/
	__getset(0,__proto,'diffuseTexture3',function(){
		return this._shaderValues.getTexture(4);
		},function(value){
		this._shaderValues.setTexture(4,value);
	});

	/**
	*设置splatAlpha贴图。
	*@param value splatAlpha贴图。
	*/
	/**
	*获取splatAlpha贴图。
	*@return splatAlpha贴图。
	*/
	__getset(0,__proto,'splatAlphaTexture',function(){
		return this._shaderValues.getTexture(0);
		},function(value){
		this._shaderValues.setTexture(0,value);
	});

	__getset(0,__proto,'normalTexture',function(){
		return this._shaderValues.getTexture(1);
		},function(value){
		this._shaderValues.setTexture(1,value);
	});

	TerrainMaterial.__init__=function(){
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM1");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM2");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM4");
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM3");
	}

	TerrainMaterial.RENDERMODE_OPAQUE=1;
	TerrainMaterial.RENDERMODE_TRANSPARENT=2;
	TerrainMaterial.SPLATALPHATEXTURE=0;
	TerrainMaterial.NORMALTEXTURE=1;
	TerrainMaterial.DIFFUSETEXTURE1=2;
	TerrainMaterial.DIFFUSETEXTURE2=3;
	TerrainMaterial.DIFFUSETEXTURE3=4;
	TerrainMaterial.DIFFUSETEXTURE4=5;
	TerrainMaterial.DIFFUSESCALE1=6;
	TerrainMaterial.DIFFUSESCALE2=7;
	TerrainMaterial.DIFFUSESCALE3=8;
	TerrainMaterial.DIFFUSESCALE4=9;
	TerrainMaterial.MATERIALAMBIENT=10;
	TerrainMaterial.MATERIALDIFFUSE=11;
	TerrainMaterial.MATERIALSPECULAR=12;
	TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=0;
	TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=0;
	TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=0;
	TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=0;
	__static(TerrainMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new TerrainMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return TerrainMaterial;
})(BaseMaterial)


/**
*...
*@author wzy
*/
//class laya.d3.core.material.EffectMaterial extends laya.d3.core.material.BaseMaterial
var EffectMaterial=(function(_super){
	function EffectMaterial(){
		/**@private */
		this._color=null;
		EffectMaterial.__super.call(this);
		this.setShaderName("Effect");
		this._color=new Vector4(1.0,1.0,1.0,1.0);
		this._shaderValues.setVector(EffectMaterial.TINTCOLOR,new Vector4(1.0,1.0,1.0,1.0));
	}

	__class(EffectMaterial,'laya.d3.core.material.EffectMaterial',_super);
	var __proto=EffectMaterial.prototype;
	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorB',function(){
		return this._color.elements[2];
		},function(value){
		this._color.elements[2]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STZ',function(){
		return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).elements[2];
		},function(z){
		var tilOff=this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
		tilOff.elements[2]=z;
		this.tilingOffset=tilOff;
	});

	/**
	*设置贴图。
	*@param value 贴图。
	*/
	/**
	*获取贴图。
	*@return 贴图。
	*/
	__getset(0,__proto,'texture',function(){
		return this._shaderValues.getTexture(EffectMaterial.MAINTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.EffectMaterial.SHADERDEFINE_MAINTEXTURE);
		else
		this._defineDatas.remove(laya.d3.core.material.EffectMaterial.SHADERDEFINE_MAINTEXTURE);
		this._shaderValues.setTexture(EffectMaterial.MAINTEXTURE,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorR',function(){
		return this._color.elements[0];
		},function(value){
		this._color.elements[0]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STW',function(){
		return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).elements[3];
		},function(w){
		var tilOff=this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
		tilOff.elements[3]=w;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_TintColorG',function(){
		return this._color.elements[1];
		},function(value){
		this._color.elements[1]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_TintColorA',function(){
		return this._color.elements[3];
		},function(value){
		this._color.elements[3]=value;
		this.color=this._color;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STY',function(){
		return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).elements[1];
		},function(y){
		var tilOff=this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
		tilOff.elements[1]=y;
		this.tilingOffset=tilOff;
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 0:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_NONE*/0;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE*/1;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.add(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_NONE*/0;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.remove(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
				break ;
			default :
				throw new Error("MeshEffectMaterial : renderMode value error.");
			}
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STX',function(){
		return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).elements[0];
		},function(x){
		var tilOff=this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
		tilOff.elements[0]=x;
		this.tilingOffset=tilOff;
	});

	/**
	*设置颜色R分量。
	*@param value 颜色R分量。
	*/
	/**
	*获取颜色R分量。
	*@return 颜色R分量。
	*/
	__getset(0,__proto,'colorR',function(){
		return this._TintColorR;
		},function(value){
		this._TintColorR=value;
	});

	/**
	*设置颜色G分量。
	*@param value 颜色G分量。
	*/
	/**
	*获取颜色G分量。
	*@return 颜色G分量。
	*/
	__getset(0,__proto,'colorG',function(){
		return this._TintColorG;
		},function(value){
		this._TintColorG=value;
	});

	/**
	*设置颜色B分量。
	*@param value 颜色B分量。
	*/
	/**
	*获取颜色B分量。
	*@return 颜色B分量。
	*/
	__getset(0,__proto,'colorB',function(){
		return this._TintColorB;
		},function(value){
		this._TintColorB=value;
	});

	/**
	*设置颜色alpha分量。
	*@param value 颜色alpha分量。
	*/
	/**
	*获取颜色Z分量。
	*@return 颜色Z分量。
	*/
	__getset(0,__proto,'colorA',function(){
		return this._TintColorA;
		},function(value){
		this._TintColorA=value;
	});

	/**
	*设置颜色。
	*@param value 颜色。
	*/
	/**
	*获取颜色。
	*@return 颜色。
	*/
	__getset(0,__proto,'color',function(){
		return this._shaderValues.getVector(EffectMaterial.TINTCOLOR);
		},function(value){
		this._shaderValues.setVector(EffectMaterial.TINTCOLOR,value);
	});

	/**
	*获取纹理平铺和偏移X分量。
	*@param x 纹理平铺和偏移X分量。
	*/
	/**
	*获取纹理平铺和偏移X分量。
	*@return 纹理平铺和偏移X分量。
	*/
	__getset(0,__proto,'tilingOffsetX',function(){
		return this._MainTex_STX;
		},function(x){
		this._MainTex_STX=x;
	});

	/**
	*获取纹理平铺和偏移Y分量。
	*@param y 纹理平铺和偏移Y分量。
	*/
	/**
	*获取纹理平铺和偏移Y分量。
	*@return 纹理平铺和偏移Y分量。
	*/
	__getset(0,__proto,'tilingOffsetY',function(){
		return this._MainTex_STY;
		},function(y){
		this._MainTex_STY=y;
	});

	/**
	*获取纹理平铺和偏移Z分量。
	*@param z 纹理平铺和偏移Z分量。
	*/
	/**
	*获取纹理平铺和偏移Z分量。
	*@return 纹理平铺和偏移Z分量。
	*/
	__getset(0,__proto,'tilingOffsetZ',function(){
		return this._MainTex_STZ;
		},function(z){
		this._MainTex_STZ=z;
	});

	/**
	*获取纹理平铺和偏移W分量。
	*@param w 纹理平铺和偏移W分量。
	*/
	/**
	*获取纹理平铺和偏移W分量。
	*@return 纹理平铺和偏移W分量。
	*/
	__getset(0,__proto,'tilingOffsetW',function(){
		return this._MainTex_STW;
		},function(w){
		this._MainTex_STW=w;
	});

	/**
	*设置纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0)
				this._defineDatas.add(laya.d3.core.material.EffectMaterial.SHADERDEFINE_TILINGOFFSET);
			else
			this._defineDatas.remove(laya.d3.core.material.EffectMaterial.SHADERDEFINE_TILINGOFFSET);
			}else {
			this._defineDatas.remove(laya.d3.core.material.EffectMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._shaderValues.setVector(EffectMaterial.TILINGOFFSET,value);
	});

	EffectMaterial.__init__=function(){
		EffectMaterial.SHADERDEFINE_MAINTEXTURE=EffectMaterial.shaderDefines.registerDefine("MAINTEXTURE");
		EffectMaterial.SHADERDEFINE_TILINGOFFSET=EffectMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		EffectMaterial.SHADERDEFINE_ADDTIVEFOG=EffectMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
	}

	EffectMaterial.RENDERMODE_ADDTIVE=0;
	EffectMaterial.RENDERMODE_ALPHABLENDED=1;
	EffectMaterial.SHADERDEFINE_MAINTEXTURE=0;
	EffectMaterial.SHADERDEFINE_TILINGOFFSET=0;
	EffectMaterial.SHADERDEFINE_ADDTIVEFOG=0;
	__static(EffectMaterial,
	['defaultMaterial',function(){return this.defaultMaterial=new EffectMaterial();},'MAINTEXTURE',function(){return this.MAINTEXTURE=Shader3D.propertyNameToID("u_AlbedoTexture");},'TINTCOLOR',function(){return this.TINTCOLOR=Shader3D.propertyNameToID("u_AlbedoColor");},'TILINGOFFSET',function(){return this.TILINGOFFSET=Shader3D.propertyNameToID("u_TilingOffset");},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return EffectMaterial;
})(BaseMaterial)


/**
*...
*@author
*/
//class laya.d3.core.material.WaterPrimaryMaterial extends laya.d3.core.material.BaseMaterial
var WaterPrimaryMaterial=(function(_super){
	function WaterPrimaryMaterial(){
		WaterPrimaryMaterial.__super.call(this);
		this.setShaderName("WaterPrimary");
		this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR,new Vector4(0.172 ,0.463 ,0.435 ,0));
		this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE,0.15);
		this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED,new Vector4(19,9,-16,-7));
	}

	__class(WaterPrimaryMaterial,'laya.d3.core.material.WaterPrimaryMaterial',_super);
	var __proto=WaterPrimaryMaterial.prototype;
	/**
	*设置波动速率。
	*@param value 波动速率。
	*/
	/**
	*获取波动速率。
	*@return 波动速率。
	*/
	__getset(0,__proto,'waveSpeed',function(){
		return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED);
		},function(value){
		this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED,value);
	});

	/**
	*设置地平线颜色。
	*@param value 地平线颜色。
	*/
	/**
	*获取地平线颜色。
	*@return 地平线颜色。
	*/
	__getset(0,__proto,'horizonColor',function(){
		return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR);
		},function(value){
		this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR,value);
	});

	/**
	*设置主贴图。
	*@param value 主贴图。
	*/
	/**
	*获取主贴图。
	*@return 主贴图。
	*/
	__getset(0,__proto,'mainTexture',function(){
		return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE);
		else
		this._defineDatas.remove(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE);
		this._shaderValues.setTexture(WaterPrimaryMaterial.MAINTEXTURE,value);
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE);
		},function(value){
		if (value)
			this._defineDatas.add(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE);
		else
		this._defineDatas.remove(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE);
		this._shaderValues.setTexture(WaterPrimaryMaterial.NORMALTEXTURE,value);
	});

	/**
	*设置波动缩放系数。
	*@param value 波动缩放系数。
	*/
	/**
	*获取波动缩放系数。
	*@return 波动缩放系数。
	*/
	__getset(0,__proto,'waveScale',function(){
		return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE);
		},function(value){
		this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE,value);
	});

	WaterPrimaryMaterial.__init__=function(){
		WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE=WaterPrimaryMaterial.shaderDefines.registerDefine("MAINTEXTURE");
		WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE=WaterPrimaryMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
	}

	WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE=0;
	WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE=0;
	__static(WaterPrimaryMaterial,
	['HORIZONCOLOR',function(){return this.HORIZONCOLOR=Shader3D.propertyNameToID("u_HorizonColor");},'MAINTEXTURE',function(){return this.MAINTEXTURE=Shader3D.propertyNameToID("u_MainTexture");},'NORMALTEXTURE',function(){return this.NORMALTEXTURE=Shader3D.propertyNameToID("u_NormalTexture");},'WAVESCALE',function(){return this.WAVESCALE=Shader3D.propertyNameToID("u_WaveScale");},'WAVESPEED',function(){return this.WAVESPEED=Shader3D.propertyNameToID("u_WaveSpeed");},'defaultMaterial',function(){return this.defaultMaterial=new WaterPrimaryMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return WaterPrimaryMaterial;
})(BaseMaterial)


/**
*...
*@author ...
*/
//class laya.d3.core.material.ExtendTerrainMaterial extends laya.d3.core.material.BaseMaterial
var ExtendTerrainMaterial=(function(_super){
	function ExtendTerrainMaterial(){
		/**@private */
		this._enableLighting=true;
		ExtendTerrainMaterial.__super.call(this);
		this.setShaderName("ExtendTerrain");
		this.renderMode=1;
	}

	__class(ExtendTerrainMaterial,'laya.d3.core.material.ExtendTerrainMaterial',_super);
	var __proto=ExtendTerrainMaterial.prototype;
	__proto._setDetailNum=function(value){
		switch (value){
			case 1:
				this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				break ;
			case 2:
				this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				break ;
			case 3:
				this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				break ;
			case 4:
				this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				break ;
			case 5:
				this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
				this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
				break ;
			}
	}

	__getset(0,__proto,'diffuseScaleOffset2',null,function(scaleOffset2){
		this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2,scaleOffset2);
	});

	/**
	*设置splatAlpha贴图。
	*@param value splatAlpha贴图。
	*/
	/**
	*获取splatAlpha贴图。
	*@return splatAlpha贴图。
	*/
	__getset(0,__proto,'splatAlphaTexture',function(){
		return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE);
		},function(value){
		this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE,value);
	});

	__getset(0,__proto,'diffuseScaleOffset3',null,function(scaleOffset3){
		this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3,scaleOffset3);
	});

	/**
	*设置第一层贴图。
	*@param value 第一层贴图。
	*/
	__getset(0,__proto,'diffuseTexture1',null,function(value){
		this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1,value);
		this._setDetailNum(1);
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LEQUAL*/0x0203;
				break ;
			default :
				throw new Error("ExtendTerrainMaterial:renderMode value error.");
			}
	});

	/**
	*设置第二层贴图。
	*@param value 第二层贴图。
	*/
	/**
	*获取第二层贴图。
	*@return 第二层贴图。
	*/
	__getset(0,__proto,'diffuseTexture2',function(){
		return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2);
		},function(value){
		this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2,value);
		this._setDetailNum(2);
	});

	__getset(0,__proto,'diffuseScaleOffset1',null,function(scaleOffset1){
		this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1,scaleOffset1);
	});

	/**
	*设置第三层贴图。
	*@param value 第三层贴图。
	*/
	/**
	*获取第三层贴图。
	*@return 第三层贴图。
	*/
	__getset(0,__proto,'diffuseTexture3',function(){
		return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3);
		},function(value){
		this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3,value);
		this._setDetailNum(3);
	});

	/**
	*设置第四层贴图。
	*@param value 第四层贴图。
	*/
	/**
	*获取第四层贴图。
	*@return 第四层贴图。
	*/
	__getset(0,__proto,'diffuseTexture4',function(){
		return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4);
		},function(value){
		this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4,value);
		this._setDetailNum(4);
	});

	/**
	*设置第五层贴图。
	*@param value 第五层贴图。
	*/
	/**
	*获取第五层贴图。
	*@return 第五层贴图。
	*/
	__getset(0,__proto,'diffuseTexture5',function(){
		return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5);
		},function(value){
		this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5,value);
		this._setDetailNum(5);
	});

	__getset(0,__proto,'diffuseScaleOffset4',null,function(scaleOffset4){
		this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4,scaleOffset4);
	});

	__getset(0,__proto,'diffuseScaleOffset5',null,function(scaleOffset5){
		this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5,scaleOffset5);
	});

	/**
	*设置是否启用光照。
	*@param value 是否启用光照。
	*/
	/**
	*获取是否启用光照。
	*@return 是否启用光照。
	*/
	__getset(0,__proto,'enableLighting',function(){
		return this._enableLighting;
		},function(value){
		if (this._enableLighting!==value){
			if (value)
				this._disablePublicDefineDatas.remove(Scene3D.SHADERDEFINE_POINTLIGHT | Scene3D.SHADERDEFINE_SPOTLIGHT | Scene3D.SHADERDEFINE_DIRECTIONLIGHT);
			else
			this._disablePublicDefineDatas.add(Scene3D.SHADERDEFINE_POINTLIGHT | Scene3D.SHADERDEFINE_SPOTLIGHT | Scene3D.SHADERDEFINE_DIRECTIONLIGHT);
			this._enableLighting=value;
		}
	});

	ExtendTerrainMaterial.__init__=function(){
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM1");
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM2");
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM3");
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM4");
		ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5=ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM5");
	}

	ExtendTerrainMaterial.RENDERMODE_OPAQUE=1;
	ExtendTerrainMaterial.RENDERMODE_TRANSPARENT=2;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1=0;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2=0;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3=0;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4=0;
	ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5=0;
	__static(ExtendTerrainMaterial,
	['SPLATALPHATEXTURE',function(){return this.SPLATALPHATEXTURE=Shader3D.propertyNameToID("u_SplatAlphaTexture");},'DIFFUSETEXTURE1',function(){return this.DIFFUSETEXTURE1=Shader3D.propertyNameToID("u_DiffuseTexture1");},'DIFFUSETEXTURE2',function(){return this.DIFFUSETEXTURE2=Shader3D.propertyNameToID("u_DiffuseTexture2");},'DIFFUSETEXTURE3',function(){return this.DIFFUSETEXTURE3=Shader3D.propertyNameToID("u_DiffuseTexture3");},'DIFFUSETEXTURE4',function(){return this.DIFFUSETEXTURE4=Shader3D.propertyNameToID("u_DiffuseTexture4");},'DIFFUSETEXTURE5',function(){return this.DIFFUSETEXTURE5=Shader3D.propertyNameToID("u_DiffuseTexture5");},'DIFFUSESCALEOFFSET1',function(){return this.DIFFUSESCALEOFFSET1=Shader3D.propertyNameToID("u_DiffuseScaleOffset1");},'DIFFUSESCALEOFFSET2',function(){return this.DIFFUSESCALEOFFSET2=Shader3D.propertyNameToID("u_DiffuseScaleOffset2");},'DIFFUSESCALEOFFSET3',function(){return this.DIFFUSESCALEOFFSET3=Shader3D.propertyNameToID("u_DiffuseScaleOffset3");},'DIFFUSESCALEOFFSET4',function(){return this.DIFFUSESCALEOFFSET4=Shader3D.propertyNameToID("u_DiffuseScaleOffset4");},'DIFFUSESCALEOFFSET5',function(){return this.DIFFUSESCALEOFFSET5=Shader3D.propertyNameToID("u_DiffuseScaleOffset5");},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return ExtendTerrainMaterial;
})(BaseMaterial)


/**
*<code>PBRStandardMaterial</code> 类用于实现PBR(Standard)材质。
*/
//class laya.d3.core.material.PBRStandardMaterial extends laya.d3.core.material.BaseMaterial
var PBRStandardMaterial=(function(_super){
	function PBRStandardMaterial(){
		/**@private */
		this._albedoColor=null;
		/**@private */
		this._emissionColor=null;
		PBRStandardMaterial.__super.call(this);
		this.setShaderName("PBRStandard");
		this._albedoColor=new Vector4(1.0,1.0,1.0,1.0);
		this._shaderValues.setVector(PBRStandardMaterial.ALBEDOCOLOR,new Vector4(1.0,1.0,1.0,1.0));
		this._emissionColor=new Vector4(0.0,0.0,0.0,0.0);
		this._shaderValues.setVector(PBRStandardMaterial.EMISSIONCOLOR,new Vector4(0.0,0.0,0.0,0.0));
		this._shaderValues.setNumber(PBRStandardMaterial.METALLIC,0.0);
		this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESS,0.5);
		this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSCALE,1.0);
		this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSOURCE,0);
		this._shaderValues.setNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH,1.0);
		this._shaderValues.setNumber(PBRStandardMaterial.NORMALSCALE,1.0);
		this._shaderValues.setNumber(PBRStandardMaterial.PARALLAXSCALE,0.001);
		this._shaderValues.setBool(PBRStandardMaterial.ENABLEEMISSION,false);
		this._shaderValues.setBool(PBRStandardMaterial.ENABLEREFLECT,true);
		this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE,0.5);
		this._disablePublicDefineDatas.remove(Scene3D.SHADERDEFINE_REFLECTMAP);
	}

	__class(PBRStandardMaterial,'laya.d3.core.material.PBRStandardMaterial',_super);
	var __proto=PBRStandardMaterial.prototype;
	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		_super.prototype.cloneTo.call(this,destObject);
		var destMaterial=destObject;
		this._albedoColor.cloneTo(destMaterial._albedoColor);
		this._emissionColor.cloneTo(destMaterial._emissionColor);
	}

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_Parallax',function(){
		return this._shaderValues.getNumber(PBRStandardMaterial.PARALLAXSCALE);
		},function(value){
		this._shaderValues.setNumber(PBRStandardMaterial.PARALLAXSCALE,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorB',function(){
		return this._albedoColor.elements[2];
		},function(value){
		this._albedoColor.elements[2]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorR',function(){
		return this._albedoColor.elements[0];
		},function(value){
		this._albedoColor.elements[0]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorG',function(){
		return this._albedoColor.elements[1];
		},function(value){
		this._albedoColor.elements[1]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*设置金属度。
	*@param value 金属度,范围为0到1。
	*/
	/**
	*获取金属度。
	*@return 金属度,范围为0到1。
	*/
	__getset(0,__proto,'metallic',function(){
		return this._Metallic;
		},function(value){
		this._Metallic=Math.max(0.0,Math.min(1.0,value));
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_GlossMapScale',function(){
		return this._shaderValues.getNumber(PBRStandardMaterial.SMOOTHNESSSCALE);
		},function(value){
		this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSCALE,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_Glossiness',function(){
		return this._shaderValues.getNumber(PBRStandardMaterial.SMOOTHNESS);
		},function(value){
		this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESS,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_ColorA',function(){
		return this._albedoColor.elements[3];
		},function(value){
		this._albedoColor.elements[3]=value;
		this.albedoColor=this._albedoColor;
	});

	/**
	*设置是否开启反射。
	*@param value 是否开启反射。
	*/
	/**
	*获取是否开启反射。
	*@return 是否开启反射。
	*/
	__getset(0,__proto,'enableReflection',function(){
		return this._shaderValues.getBool(PBRStandardMaterial.ENABLEREFLECT);
		},function(value){
		this._shaderValues.setBool(PBRStandardMaterial.ENABLEREFLECT,true);
		if (value){
			this._disablePublicDefineDatas.remove(Scene3D.SHADERDEFINE_REFLECTMAP);
		}
		else{
			this._disablePublicDefineDatas.add(Scene3D.SHADERDEFINE_REFLECTMAP);
		}
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_Metallic',function(){
		return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC);
		},function(value){
		this._shaderValues.setNumber(PBRStandardMaterial.METALLIC,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_BumpScale',function(){
		return this._shaderValues.getNumber(PBRStandardMaterial.NORMALSCALE);
		},function(value){
		this._shaderValues.setNumber(PBRStandardMaterial.NORMALSCALE,value);
	});

	/**
	*@private
	*/
	/**@private */
	__getset(0,__proto,'_OcclusionStrength',function(){
		return this._shaderValues.getNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH);
		},function(value){
		this._shaderValues.setNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_EmissionColorR',function(){
		return this._emissionColor.elements[0];
		},function(value){
		this._emissionColor.elements[0]=value;
		this.emissionColor=this._emissionColor;
	});

	/**
	*获取纹理平铺和偏移。
	*@param value 纹理平铺和偏移。
	*/
	/**
	*获取纹理平铺和偏移。
	*@return 纹理平铺和偏移。
	*/
	__getset(0,__proto,'tilingOffset',function(){
		return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
		},function(value){
		if (value){
			var valueE=value.elements;
			if (valueE[0] !=1 || valueE[1] !=1 || valueE[2] !=0 || valueE[3] !=0){
				this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
			}
			else{
				this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
			}
		}
		else {
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET);
		}
		this._shaderValues.setVector(PBRStandardMaterial.TILINGOFFSET,value);
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_EmissionColorG',function(){
		return this._emissionColor.elements[1];
		},function(value){
		this._emissionColor.elements[1]=value;
		this.emissionColor=this._emissionColor;
	});

	/**
	*获取纹理平铺和偏移W分量。
	*@param w 纹理平铺和偏移W分量。
	*/
	/**
	*获取纹理平铺和偏移W分量。
	*@return 纹理平铺和偏移W分量。
	*/
	__getset(0,__proto,'tilingOffsetW',function(){
		return this._MainTex_STW;
		},function(w){
		this._MainTex_STW=w;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_EmissionColorB',function(){
		return this._emissionColor.elements[2];
		},function(value){
		this._emissionColor.elements[2]=value;
		this.emissionColor=this._emissionColor;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_EmissionColorA',function(){
		return this._emissionColor.elements[3];
		},function(value){
		this._emissionColor.elements[3]=value;
		this.emissionColor=this._emissionColor;
	});

	/**
	*设置反射率颜色alpha分量。
	*@param value 反射率颜色alpha分量。
	*/
	/**
	*获取反射率颜色Z分量。
	*@return 反射率颜色Z分量。
	*/
	__getset(0,__proto,'albedoColorA',function(){
		return this._ColorA;
		},function(value){
		this._ColorA=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STX',function(){
		return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).elements[0];
		},function(x){
		var tilOff=this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
		tilOff.elements[0]=x;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STY',function(){
		return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).elements[1];
		},function(y){
		var tilOff=this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
		tilOff.elements[1]=y;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STZ',function(){
		return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).elements[2];
		},function(z){
		var tilOff=this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
		tilOff.elements[2]=z;
		this.tilingOffset=tilOff;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_Cutoff',function(){
		return this.alphaTestValue;
		},function(value){
		this.alphaTestValue=value;
	});

	/**
	*@private
	*/
	/**
	*@private
	*/
	__getset(0,__proto,'_MainTex_STW',function(){
		return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).elements[3];
		},function(w){
		var tilOff=this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
		tilOff.elements[3]=w;
		this.tilingOffset=tilOff;
	});

	/**
	*设置反射率颜色R分量。
	*@param value 反射率颜色R分量。
	*/
	/**
	*获取反射率颜色R分量。
	*@return 反射率颜色R分量。
	*/
	__getset(0,__proto,'albedoColorR',function(){
		return this._ColorR;
		},function(value){
		this._ColorR=value;
	});

	/**
	*设置反射率颜色G分量。
	*@param value 反射率颜色G分量。
	*/
	/**
	*获取反射率颜色G分量。
	*@return 反射率颜色G分量。
	*/
	__getset(0,__proto,'albedoColorG',function(){
		return this._ColorG;
		},function(value){
		this._ColorG=value;
	});

	/**
	*设置反射率颜色B分量。
	*@param value 反射率颜色B分量。
	*/
	/**
	*获取反射率颜色B分量。
	*@return 反射率颜色B分量。
	*/
	__getset(0,__proto,'albedoColorB',function(){
		return this._ColorB;
		},function(value){
		this._ColorB=value;
	});

	/**
	*获取纹理平铺和偏移X分量。
	*@param x 纹理平铺和偏移X分量。
	*/
	/**
	*获取纹理平铺和偏移X分量。
	*@return 纹理平铺和偏移X分量。
	*/
	__getset(0,__proto,'tilingOffsetX',function(){
		return this._MainTex_STX;
		},function(x){
		this._MainTex_STX=x;
	});

	/**
	*设置漫反射颜色。
	*@param value 漫反射颜色。
	*/
	/**
	*获取漫反射颜色。
	*@return 漫反射颜色。
	*/
	__getset(0,__proto,'albedoColor',function(){
		return this._albedoColor;
		},function(value){
		this._albedoColor=value;
		this._shaderValues.setVector(PBRStandardMaterial.ALBEDOCOLOR,value);
	});

	/**
	*设置漫反射贴图。
	*@param value 漫反射贴图。
	*/
	/**
	*获取漫反射贴图。
	*@return 漫反射贴图。
	*/
	__getset(0,__proto,'albedoTexture',function(){
		return this._shaderValues.getTexture(PBRStandardMaterial.ALBEDOTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE);
		}
		this._shaderValues.setTexture(PBRStandardMaterial.ALBEDOTEXTURE,value);
	});

	/**
	*设置视差贴图。
	*@param value 视察贴图。
	*/
	/**
	*获取视差贴图。
	*@return 视察贴图。
	*/
	__getset(0,__proto,'parallaxTexture',function(){
		return this._shaderValues.getTexture(PBRStandardMaterial.PARALLAXTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE);
		}
		this._shaderValues.setTexture(PBRStandardMaterial.PARALLAXTEXTURE,value);
	});

	/**
	*设置法线贴图。
	*@param value 法线贴图。
	*/
	/**
	*获取法线贴图。
	*@return 法线贴图。
	*/
	__getset(0,__proto,'normalTexture',function(){
		return this._shaderValues.getTexture(PBRStandardMaterial.NORMALTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE);
		}
		this._shaderValues.setTexture(PBRStandardMaterial.NORMALTEXTURE,value);
	});

	/**
	*设置放射颜色。
	*@param value 放射颜色。
	*/
	/**
	*获取放射颜色。
	*@return 放射颜色。
	*/
	__getset(0,__proto,'emissionColor',function(){
		return this._shaderValues.getVector(PBRStandardMaterial.EMISSIONCOLOR);
		},function(value){
		this._shaderValues.setVector(PBRStandardMaterial.EMISSIONCOLOR,value);
	});

	/**
	*设置视差贴图缩放系数。
	*@param value 视差缩放系数。
	*/
	/**
	*获取视差贴图缩放系数。
	*@return 视差缩放系数。
	*/
	__getset(0,__proto,'parallaxTextureScale',function(){
		return this._Parallax;
		},function(value){
		this._Parallax=Math.max(0.005,Math.min(0.08,value));
	});

	/**
	*设置法线贴图缩放系数。
	*@param value 法线贴图缩放系数。
	*/
	/**
	*获取法线贴图缩放系数。
	*@return 法线贴图缩放系数。
	*/
	__getset(0,__proto,'normalTextureScale',function(){
		return this._BumpScale;
		},function(value){
		this._BumpScale=value;
	});

	/**
	*获取纹理平铺和偏移Z分量。
	*@param z 纹理平铺和偏移Z分量。
	*/
	/**
	*获取纹理平铺和偏移Z分量。
	*@return 纹理平铺和偏移Z分量。
	*/
	__getset(0,__proto,'tilingOffsetZ',function(){
		return this._MainTex_STZ;
		},function(z){
		this._MainTex_STZ=z;
	});

	/**
	*设置遮挡贴图。
	*@param value 遮挡贴图。
	*/
	/**
	*获取遮挡贴图。
	*@return 遮挡贴图。
	*/
	__getset(0,__proto,'occlusionTexture',function(){
		return this._shaderValues.getTexture(PBRStandardMaterial.OCCLUSIONTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
		}
		this._shaderValues.setTexture(PBRStandardMaterial.OCCLUSIONTEXTURE,value);
	});

	/**
	*设置遮挡贴图强度。
	*@param value 遮挡贴图强度,范围为0到1。
	*/
	/**
	*获取遮挡贴图强度。
	*@return 遮挡贴图强度,范围为0到1。
	*/
	__getset(0,__proto,'occlusionTextureStrength',function(){
		return this._OcclusionStrength;
		},function(value){
		this._OcclusionStrength=Math.max(0.0,Math.min(1.0,value));
	});

	/**
	*设置是否激活放射属性。
	*@param value 是否激活放射属性
	*/
	/**
	*获取是否激活放射属性。
	*@return 是否激活放射属性。
	*/
	__getset(0,__proto,'enableEmission',function(){
		return this._shaderValues.getBool(PBRStandardMaterial.ENABLEEMISSION);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION);
		}
		else {
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION);
		}
		this._shaderValues.setBool(PBRStandardMaterial.ENABLEEMISSION,value);
	});

	/**
	*设置金属光滑度贴图。
	*@param value 金属光滑度贴图。
	*/
	/**
	*获取金属光滑度贴图。
	*@return 金属光滑度贴图。
	*/
	__getset(0,__proto,'metallicGlossTexture',function(){
		return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
		}
		this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE,value);
	});

	/**
	*设置放射颜色A分量。
	*@param value 放射颜色A分量。
	*/
	/**
	*获取放射颜色A分量。
	*@return 放射颜色A分量。
	*/
	__getset(0,__proto,'emissionColorA',function(){
		return this._EmissionColorA;
		},function(value){
		this._EmissionColorA=value;
	});

	/**
	*设置光滑度。
	*@param value 光滑度,范围为0到1。
	*/
	/**
	*获取光滑度。
	*@return 光滑度,范围为0到1。
	*/
	__getset(0,__proto,'smoothness',function(){
		return this._Glossiness;
		},function(value){
		this._Glossiness=Math.max(0.0,Math.min(1.0,value));
	});

	/**
	*设置光滑度缩放系数。
	*@param value 光滑度缩放系数,范围为0到1。
	*/
	/**
	*获取光滑度缩放系数。
	*@return 光滑度缩放系数,范围为0到1。
	*/
	__getset(0,__proto,'smoothnessTextureScale',function(){
		return this._GlossMapScale;
		},function(value){
		this._GlossMapScale=Math.max(0.0,Math.min(1.0,value));
	});

	/**
	*设置光滑度数据源。
	*@param value 光滑滑度数据源,0或1。
	*/
	/**
	*获取光滑度数据源
	*@return 光滑滑度数据源,0或1。
	*/
	__getset(0,__proto,'smoothnessSource',function(){
		return this._shaderValues.getInt(PBRStandardMaterial.SMOOTHNESSSOURCE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
			this._shaderValues.setInt(PBRStandardMaterial.SMOOTHNESSSOURCE,1);
		}
		else {
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
			this._shaderValues.setInt(PBRStandardMaterial.SMOOTHNESSSOURCE,0);
		}
	});

	/**
	*设置放射颜色R分量。
	*@param value 放射颜色R分量。
	*/
	/**
	*获取放射颜色R分量。
	*@return 放射颜色R分量。
	*/
	__getset(0,__proto,'emissionColorR',function(){
		return this._EmissionColorR;
		},function(value){
		this._EmissionColorR=value;
	});

	/**
	*设置放射颜色G分量。
	*@param value 放射颜色G分量。
	*/
	/**
	*获取放射颜色G分量。
	*@return 放射颜色G分量。
	*/
	__getset(0,__proto,'emissionColorG',function(){
		return this._EmissionColorG;
		},function(value){
		this._EmissionColorG=value;
	});

	/**
	*设置放射颜色B分量。
	*@param value 放射颜色B分量。
	*/
	/**
	*获取放射颜色B分量。
	*@return 放射颜色B分量。
	*/
	__getset(0,__proto,'emissionColorB',function(){
		return this._EmissionColorB;
		},function(value){
		this._EmissionColorB=value;
	});

	/**
	*设置放射贴图。
	*@param value 放射贴图。
	*/
	/**
	*获取放射贴图。
	*@return 放射贴图。
	*/
	__getset(0,__proto,'emissionTexture',function(){
		return this._shaderValues.getTexture(PBRStandardMaterial.EMISSIONTEXTURE);
		},function(value){
		if (value){
			this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE);
		}
		else{
			this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE);
		}
		this._shaderValues.setTexture(PBRStandardMaterial.EMISSIONTEXTURE,value);
	});

	/**
	*获取纹理平铺和偏移Y分量。
	*@param y 纹理平铺和偏移Y分量。
	*/
	/**
	*获取纹理平铺和偏移Y分量。
	*@return 纹理平铺和偏移Y分量。
	*/
	__getset(0,__proto,'tilingOffsetY',function(){
		return this._MainTex_STY;
		},function(y){
		this._MainTex_STY=y;
	});

	/**
	*设置渲染模式。
	*@return 渲染模式。
	*/
	__getset(0,__proto,'renderMode',null,function(value){
		var renderState=this.getRenderState();
		switch (value){
			case 0:
				this.alphaTest=false;
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_OPAQUE*/2000;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.remove(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
				break ;
			case 1:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_ALPHATEST*/2450;
				this.alphaTest=true;
				renderState.depthWrite=true;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_DISABLE*/0;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.remove(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
				break ;
			case 2:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_SRC_ALPHA*/0x0302;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.remove(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
				break ;
				break ;
			case 3:
				this.renderQueue=/*laya.d3.core.material.BaseMaterial.RENDERQUEUE_TRANSPARENT*/3000;
				this.alphaTest=false;
				renderState.depthWrite=false;
				renderState.cull=/*laya.d3.core.material.RenderState.CULL_BACK*/2;
				renderState.blend=/*laya.d3.core.material.RenderState.BLEND_ENABLE_ALL*/1;
				renderState.srcBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE*/1;
				renderState.dstBlend=/*laya.d3.core.material.RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA*/0x0303;
				renderState.depthTest=/*laya.d3.core.material.RenderState.DEPTHTEST_LESS*/0x0201;
				this._defineDatas.add(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
				break ;
			default :
				throw new Error("PBRSpecularMaterial : renderMode value error.");
			}
	});

	PBRStandardMaterial.__init__=function(){
		PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("METALLICGLOSSTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA=PBRStandardMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
		PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_EMISSION=PBRStandardMaterial.shaderDefines.registerDefine("EMISSION");
		PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE=PBRStandardMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE");
		PBRStandardMaterial.SHADERDEFINE_REFLECTMAP=PBRStandardMaterial.shaderDefines.registerDefine("REFLECTMAP");
		PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET=PBRStandardMaterial.shaderDefines.registerDefine("TILINGOFFSET");
		PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY=PBRStandardMaterial.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
	}

	PBRStandardMaterial.SmoothnessSource_MetallicGlossTexture_Alpha=0;
	PBRStandardMaterial.SmoothnessSource_AlbedoTexture_Alpha=1;
	PBRStandardMaterial.RENDERMODE_OPAQUE=0;
	PBRStandardMaterial.RENDERMODE_CUTOUT=1;
	PBRStandardMaterial.RENDERMODE_FADE=2;
	PBRStandardMaterial.RENDERMODE_TRANSPARENT=3;
	PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA=0;
	PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_EMISSION=0;
	PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE=0;
	PBRStandardMaterial.SHADERDEFINE_REFLECTMAP=0;
	PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET=0;
	PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY=0;
	PBRStandardMaterial.SMOOTHNESSSOURCE=-1;
	PBRStandardMaterial.ENABLEEMISSION=-1;
	PBRStandardMaterial.ENABLEREFLECT=-1;
	__static(PBRStandardMaterial,
	['ALBEDOTEXTURE',function(){return this.ALBEDOTEXTURE=Shader3D.propertyNameToID("u_AlbedoTexture");},'METALLICGLOSSTEXTURE',function(){return this.METALLICGLOSSTEXTURE=Shader3D.propertyNameToID("u_MetallicGlossTexture");},'NORMALTEXTURE',function(){return this.NORMALTEXTURE=Shader3D.propertyNameToID("u_NormalTexture");},'PARALLAXTEXTURE',function(){return this.PARALLAXTEXTURE=Shader3D.propertyNameToID("u_ParallaxTexture");},'OCCLUSIONTEXTURE',function(){return this.OCCLUSIONTEXTURE=Shader3D.propertyNameToID("u_OcclusionTexture");},'EMISSIONTEXTURE',function(){return this.EMISSIONTEXTURE=Shader3D.propertyNameToID("u_EmissionTexture");},'ALBEDOCOLOR',function(){return this.ALBEDOCOLOR=Shader3D.propertyNameToID("u_AlbedoColor");},'EMISSIONCOLOR',function(){return this.EMISSIONCOLOR=Shader3D.propertyNameToID("u_EmissionColor");},'METALLIC',function(){return this.METALLIC=Shader3D.propertyNameToID("u_metallic");},'SMOOTHNESS',function(){return this.SMOOTHNESS=Shader3D.propertyNameToID("u_smoothness");},'SMOOTHNESSSCALE',function(){return this.SMOOTHNESSSCALE=Shader3D.propertyNameToID("u_smoothnessScale");},'OCCLUSIONSTRENGTH',function(){return this.OCCLUSIONSTRENGTH=Shader3D.propertyNameToID("u_occlusionStrength");},'NORMALSCALE',function(){return this.NORMALSCALE=Shader3D.propertyNameToID("u_normalScale");},'PARALLAXSCALE',function(){return this.PARALLAXSCALE=Shader3D.propertyNameToID("u_parallaxScale");},'TILINGOFFSET',function(){return this.TILINGOFFSET=Shader3D.propertyNameToID("u_TilingOffset");},'defaultMaterial',function(){return this.defaultMaterial=new PBRStandardMaterial();},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(BaseMaterial.shaderDefines);}
	]);
	return PBRStandardMaterial;
})(BaseMaterial)


/**
*<code>SkinMeshRenderer</code> 类用于蒙皮渲染器。
*/
//class laya.d3.core.SkinnedMeshRenderer extends laya.d3.core.MeshRenderer
var SkinnedMeshRenderer=(function(_super){
	function SkinnedMeshRenderer(owner){
		/**@private */
		//this._cacheAvatar=null;
		/**@private */
		//this._cacheMesh=null;
		/**@private */
		//this._cacheAnimationNode=null;
		/**@private */
		//this._skinnedData=null;
		/**@private */
		//this._skinnedDataLoopMarks=null;
		/**@private */
		//this._localBoundingBoxCorners=null;
		/**@private */
		//this._localBoundBox=null;
		/**@private */
		//this._cacheAnimator=null;
		/**@private */
		//this._rootBone=null;
		/**用于裁剪的包围球。 */
		//this.localBoundSphere=null;
		/**@private [NATIVE]*/
		//this._cacheAnimationNodeIndices=null;
		SkinnedMeshRenderer.__super.call(this,owner);
		this._skinnedDataLoopMarks=[];
		this._cacheAnimationNode=[];
		this._localBoundingBoxCorners=__newvec(8,null);
	}

	__class(SkinnedMeshRenderer,'laya.d3.core.SkinnedMeshRenderer',_super);
	var __proto=SkinnedMeshRenderer.prototype;
	/**
	*@private
	*/
	__proto._getCacheAnimationNodes=function(){
		var meshBoneNames=this._cacheMesh._boneNames;
		var bindPoseIndices=this._cacheMesh._bindPoseIndices;
		var innerBindPoseCount=bindPoseIndices.length;
		if (!Render.isConchApp){
			this._cacheAnimationNode.length=innerBindPoseCount;
			var nodeMap=this._cacheAnimator._avatarNodeMap;
			for (var i=0;i < innerBindPoseCount;i++){
				var node=nodeMap[meshBoneNames[bindPoseIndices[i]]];
				this._cacheAnimationNode[i]=node;
			}
			}else {
			this._cacheAnimationNodeIndices=new Uint16Array(innerBindPoseCount);
			var nodeMapC=this._cacheAnimator._avatarNodeMap;
			for (i=0;i < innerBindPoseCount;i++){
				var nodeC=nodeMapC[meshBoneNames[bindPoseIndices[i]]];
				this._cacheAnimationNodeIndices[i]=nodeC._worldMatrixIndex;
			}
		}
	}

	/**
	*@private
	*/
	__proto._computeBoneIndexToMeshWithAsyncAvatar=function(){
		this._computeBoneIndexToMeshWithAsyncMesh();
	}

	/**
	*@private
	*/
	__proto._computeBoneIndexToMeshWithAsyncMesh=function(){
		this._getCacheAnimationNodes();
	}

	/**
	*@private
	*/
	__proto._computeSkinnedData=function(){
		if (this._cacheMesh && this._cacheAvatar){
			var bindPoses=this._cacheMesh._inverseBindPoses;
			var bindPoseInices=this._cacheMesh._bindPoseIndices;
			var pathMarks=this._cacheMesh._skinDataPathMarks;
			for (var i=0,n=this._cacheMesh.subMeshCount;i < n;i++){
				var subBoneIndices=(this._cacheMesh._getSubMesh(i))._boneIndicesList;
				var subData=this._skinnedData[i];
				for (var j=0,m=subBoneIndices.length;j < m;j++){
					var boneIndices=subBoneIndices[j];
					if (Render.isConchApp)
						this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs,this._cacheAnimationNodeIndices,this._cacheMesh._inverseBindPosesBuffer,boneIndices,bindPoseInices,subData[j]);
					else
					this._computeSubSkinnedData(bindPoses,boneIndices,bindPoseInices,subData[j],pathMarks);
				}
				(this._renderElements [i]).skinnedDatas=subData;
			}
		}
	}

	/**
	*@private
	*/
	__proto._computeSubSkinnedData=function(bindPoses,boneIndices,bindPoseInices,data,pathMarks){
		for (var k=0,q=boneIndices.length;k < q;k++){
			var index=boneIndices[k];
			if (this._skinnedDataLoopMarks[index]===Stat.loopCount){
				var p=pathMarks[index];
				var preData=this._skinnedData[p[0]][p[1]];
				var srcIndex=p[2] *16;
				var dstIndex=k *16;
				for (var d=0;d < 16;d++)
				data[dstIndex+d]=preData[srcIndex+d];
				}else {
				Utils3D._mulMatrixArray(this._cacheAnimationNode[index].transform.getWorldMatrix(),bindPoses[bindPoseInices[index]],data,k *16);
				this._skinnedDataLoopMarks[index]=Stat.loopCount;
			}
		}
	}

	/**
	*@private
	*/
	__proto._onMeshChange=function(value){
		_super.prototype._onMeshChange.call(this,value);
		this._cacheMesh=value;
		var subMeshCount=value.subMeshCount;
		this._skinnedData=__newvec(subMeshCount);
		this._skinnedDataLoopMarks.length=(value)._bindPoseIndices.length;
		for (var i=0;i < subMeshCount;i++){
			var subBoneIndices=(value._getSubMesh(i))._boneIndicesList;
			var subCount=subBoneIndices.length;
			var subData=this._skinnedData[i]=__newvec(subCount);
			for (var j=0;j < subCount;j++)
			subData[j]=new Float32Array(subBoneIndices[j].length *16);
		}
		(this._cacheAvatar && value)&& (this._computeBoneIndexToMeshWithAsyncAvatar());
	}

	/**
	*@private
	*/
	__proto._setCacheAnimator=function(animator){
		this._cacheAnimator=animator;
	}

	/**
	*@private
	*/
	__proto._setRootBone=function(name){
		this._rootBone=name;
	}

	/**
	*@private
	*/
	__proto._setCacheAvatar=function(value){
		if (this._cacheAvatar!==value){
			if (this._cacheMesh){
				this._cacheAvatar=value;
				if (value){
					this._defineDatas.add(SkinnedMeshSprite3D.SHADERDEFINE_BONE);
					this._computeBoneIndexToMeshWithAsyncAvatar();
				}
				}else {
				this._cacheAvatar=value;
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingBox=function(){
		if (this._cacheAnimator){
			if (this._localBoundBox==null)
				this._boundingBox.toDefault();
			else
			this._calculateBoundBoxByInitCorners(this._localBoundingBoxCorners);
			}else {
			_super.prototype._calculateBoundingBox.call(this);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateBoundingSphere=function(){
		if (this._cacheAnimator){
			if (this.localBoundSphere==null)
				this._boundingSphere.toDefault();
			else
			this._calculateBoundingSphereByInitSphere(this.localBoundSphere);
			}else {
			_super.prototype._calculateBoundingSphere.call(this);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._updateOctreeNode=function(){
		var treeNode=this._treeNode;
		if (treeNode){
			treeNode.updateObject(this);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdate=function(context,transform){
		if (this._cacheAnimator){
			this._computeSkinnedData();
			var aniOwnerTransParent=(this._cacheAnimator.owner)._transform._parent;
			var worldMat=aniOwnerTransParent ? aniOwnerTransParent.worldMatrix :Matrix4x4.DEFAULT;
			this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX,worldMat);
			}else {
			this._shaderValues.setMatrix4x4(Sprite3D.WORLDMATRIX,transform.worldMatrix);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._renderUpdateWithCamera=function(context,transform){
		var projectionView=context.projectionViewMatrix;
		if (this._cacheAnimator){
			var aniOwnerTransParent=(this._cacheAnimator.owner)._transform._parent;
			var worldMat=aniOwnerTransParent ? aniOwnerTransParent.worldMatrix :Matrix4x4.DEFAULT;
			Matrix4x4.multiply(projectionView,worldMat,this._projectionViewWorldMatrix);
			}else {
			Matrix4x4.multiply(projectionView,transform.worldMatrix,this._projectionViewWorldMatrix);
		}
		this._shaderValues.setMatrix4x4(Sprite3D.MVPMATRIX,this._projectionViewWorldMatrix);
		if (Laya3D.debugMode)
			this._renderRenderableBoundBox();
	}

	/**
	*@private [NATIVE]
	*/
	__proto._computeSubSkinnedDataNative=function(worldMatrixs,cacheAnimationNodeIndices,inverseBindPosesBuffer,boneIndices,bindPoseInices,data){
		LayaGL.instance.computeSubSkinnedData(worldMatrixs,cacheAnimationNodeIndices,inverseBindPosesBuffer,boneIndices,bindPoseInices,data);
	}

	/**
	*设置包围球。
	*@param value
	*/
	/**
	*获取包围球。
	*@return 包围球。
	*/
	__getset(0,__proto,'localBoundBox',function(){
		return this._localBoundBox;
		},function(value){
		this._localBoundBox=value;
		value.getCorners(this._localBoundingBoxCorners);
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'boundingBoxCenter',function(){
		var boundBox=this.boundingBox;
		Vector3.add(boundBox.min,boundBox.max,this._boundingBoxCenter);
		Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
		return this._boundingBoxCenter;
	});

	return SkinnedMeshRenderer;
})(MeshRenderer)


/**
*<code>PhysicsCollider</code> 类用于创建物理碰撞器。
*/
//class laya.d3.physics.PhysicsCollider extends laya.d3.physics.PhysicsTriggerComponent
var PhysicsCollider=(function(_super){
	/**
	*创建一个 <code>PhysicsCollider</code> 实例。
	*@param collisionGroup 所属碰撞组。
	*@param canCollideWith 可产生碰撞的碰撞组。
	*/
	function PhysicsCollider(collisionGroup,canCollideWith){
		(collisionGroup===void 0)&& (collisionGroup=/*laya.d3.utils.Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER*/0x1);
		(canCollideWith===void 0)&& (canCollideWith=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		PhysicsCollider.__super.call(this,collisionGroup,canCollideWith);
	}

	__class(PhysicsCollider,'laya.d3.physics.PhysicsCollider',_super);
	var __proto=PhysicsCollider.prototype;
	/**
	*@inheritDoc
	*/
	__proto._addToSimulation=function(){
		this._simulation._addPhysicsCollider(this,this._collisionGroup,this._canCollideWith);
	}

	/**
	*@inheritDoc
	*/
	__proto._removeFromSimulation=function(){
		this._simulation._removePhysicsCollider(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._onTransformChanged=function(flag){
		flag &=/*laya.d3.core.Transform3D.TRANSFORM_WORLDPOSITION*/0x08 | /*laya.d3.core.Transform3D.TRANSFORM_WORLDQUATERNION*/0x10 | /*laya.d3.core.Transform3D.TRANSFORM_WORLDSCALE*/0x20;
		if (flag){
			this._transformFlag |=flag;
			if (this._isValid()&& this._inPhysicUpdateListIndex===-1)
				this._simulation._physicsUpdateList.add(this);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		(data.friction !=null)&& (this.friction=data.friction);
		(data.rollingFriction !=null)&& (this.rollingFriction=data.rollingFriction);
		(data.restitution !=null)&& (this.restitution=data.restitution);
		(data.isTrigger !=null)&& (this.isTrigger=data.isTrigger);
		laya.d3.physics.PhysicsComponent.prototype._parse.call(this,data);
		this._parseShape(data.shapes);
	}

	/**
	*@inheritDoc
	*/
	__proto._onAdded=function(){
		var physics3D=Laya3D._physics3D;
		var btColObj=new physics3D.btCollisionObject();
		btColObj.setUserIndex(this.id);
		btColObj.forceActivationState(5);
		var flags=btColObj.getCollisionFlags();
		if ((this.owner).isStatic){
			if ((flags & 2)> 0)
				flags=flags ^ 2;
			flags=flags | 1;
			}else {
			if ((flags & 1)> 0)
				flags=flags ^ 1;
			flags=flags | 2;
		}
		btColObj.setCollisionFlags(flags);
		this._nativeColliderObject=btColObj;
		_super.prototype._onAdded.call(this);
	}

	return PhysicsCollider;
})(PhysicsTriggerComponent)


/**
*<code>Rigidbody3D</code> 类用于创建刚体碰撞器。
*/
//class laya.d3.physics.Rigidbody3D extends laya.d3.physics.PhysicsTriggerComponent
var Rigidbody3D=(function(_super){
	function Rigidbody3D(collisionGroup,canCollideWith){
		/**@private */
		//this._nativeMotionState=null;
		/**@private */
		this._isKinematic=false;
		/**@private */
		this._mass=1.0;
		/**@private */
		this._angularDamping=0.0;
		/**@private */
		this._linearDamping=0.0;
		/**@private */
		this._overrideGravity=false;
		/**@private */
		this._detectCollisions=true;
		this._gravity=new Vector3(0,-10,0);
		this._totalTorque=new Vector3(0,0,0);
		this._linearVelocity=new Vector3();
		this._angularVelocity=new Vector3();
		this._linearFactor=new Vector3(1,1,1);
		this._angularFactor=new Vector3(1,1,1);
		(collisionGroup===void 0)&& (collisionGroup=/*laya.d3.utils.Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER*/0x1);
		(canCollideWith===void 0)&& (canCollideWith=Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER);
		Rigidbody3D.__super.call(this,collisionGroup,canCollideWith);
	}

	__class(Rigidbody3D,'laya.d3.physics.Rigidbody3D',_super);
	var __proto=Rigidbody3D.prototype;
	/**
	*@private
	*/
	__proto._updateMass=function(mass){
		if (this._nativeColliderObject && this._colliderShape){
			this._colliderShape._nativeShape.calculateLocalInertia(mass,Rigidbody3D._nativeInertia);
			this._nativeColliderObject.setMassProps(mass,Rigidbody3D._nativeInertia);
			this._nativeColliderObject.updateInertiaTensor();
		}
	}

	/**
	*@private
	*Dynamic刚体,初始化时调用一次。
	*Kinematic刚体,每次物理tick时调用(如果未进入睡眠状态),让物理引擎知道刚体位置。
	*/
	__proto._delegateMotionStateGetWorldTransform=function(worldTransPointer){}
	/**
	*@private
	*Dynamic刚体,物理引擎每帧调用一次,用于更新渲染矩阵。
	*/
	__proto._delegateMotionStateSetWorldTransform=function(worldTransPointer){
		var rigidBody=/*__JS__ */this._rigidbody;
		rigidBody._simulation._updatedRigidbodies++;
		var physics3D=Laya3D._physics3D;
		var worldTrans=physics3D.wrapPointer(worldTransPointer,physics3D.btTransform);
		rigidBody._updateTransformComponent(worldTrans);
	}

	/**
	*@private
	*Dynamic刚体,初始化时调用一次。
	*Kinematic刚体,每次物理tick时调用(如果未进入睡眠状态),让物理引擎知道刚体位置。
	*该函数只有在runtime下调用
	*/
	__proto._delegateMotionStateGetWorldTransformNative=function(ridgidBody3D,worldTransPointer){}
	/**
	*@private
	*Dynamic刚体,物理引擎每帧调用一次,用于更新渲染矩阵。
	*该函数只有在runtime下调用
	*/
	__proto._delegateMotionStateSetWorldTransformNative=function(rigidBody3D,worldTransPointer){
		var rigidBody=rigidBody3D;
		rigidBody._simulation._updatedRigidbodies++;
		var physics3D=Laya3D._physics3D;
		var worldTrans=physics3D.wrapPointer(worldTransPointer,physics3D.btTransform);
		rigidBody._updateTransformComponent(worldTrans);
	}

	/**
	*@inheritDoc
	*/
	__proto._onScaleChange=function(scale){
		laya.d3.physics.PhysicsComponent.prototype._onScaleChange.call(this,scale);
		this._updateMass(this._isKinematic ? 0 :this._mass);
	}

	/**
	*@private
	*/
	__proto._delegateMotionStateClear=function(){
		/*__JS__ */this._rigidbody=null;
	}

	/**
	*@inheritDoc
	*/
	__proto._onAdded=function(){
		var physics3D=Laya3D._physics3D;
		var motionState=new physics3D.LayaMotionState();
		var isConchApp=/*__JS__ */(window.conch !=null);
		if (isConchApp && physics3D.LayaMotionState.prototype.setRigidbody){
			motionState.setRigidbody(this);
			motionState.setNativeGetWorldTransform(this._delegateMotionStateGetWorldTransformNative);
			motionState.setNativeSetWorldTransform(this._delegateMotionStateSetWorldTransformNative);
			}else {
			motionState.getWorldTransform=this._delegateMotionStateGetWorldTransform;
			motionState.setWorldTransform=this._delegateMotionStateSetWorldTransform;
		}
		motionState.clear=this._delegateMotionStateClear;
		motionState._rigidbody=this;
		this._nativeMotionState=motionState;
		var constructInfo=new physics3D.btRigidBodyConstructionInfo(0.0,motionState,null,Rigidbody3D._nativeVector3Zero);
		var btRigid=new physics3D.btRigidBody(constructInfo);
		btRigid.setUserIndex(this.id);
		this._nativeColliderObject=btRigid;
		_super.prototype._onAdded.call(this);
		this.mass=this._mass;
		this.linearFactor=this._linearFactor;
		this.angularFactor=this._angularFactor;
		this.linearDamping=this._linearDamping;
		this.angularDamping=this._angularDamping;
		this.overrideGravity=this._overrideGravity;
		this.gravity=this._gravity;
		this.isKinematic=this._isKinematic;
		physics3D.destroy(constructInfo);
	}

	/**
	*@inheritDoc
	*/
	__proto._onShapeChange=function(colShape){
		laya.d3.physics.PhysicsComponent.prototype._onShapeChange.call(this,colShape);
		if (this._isKinematic){
			this._updateMass(0);
			}else {
			this._nativeColliderObject.setCenterOfMassTransform(this._nativeColliderObject.getWorldTransform());
			this._updateMass(this._mass);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		(data.friction !=null)&& (this.friction=data.friction);
		(data.rollingFriction !=null)&& (this.rollingFriction=data.rollingFriction);
		(data.restitution !=null)&& (this.restitution=data.restitution);
		(data.isTrigger !=null)&& (this.isTrigger=data.isTrigger);
		(data.mass !=null)&& (this.mass=data.mass);
		(data.isKinematic !=null)&& (this.isKinematic=data.isKinematic);
		(data.linearDamping !=null)&& (this.linearDamping=data.linearDamping);
		(data.angularDamping !=null)&& (this.angularDamping=data.angularDamping);
		(data.overrideGravity !=null)&& (this.overrideGravity=data.overrideGravity);
		if (data.gravity){
			this.gravity.fromArray(data.gravity);
			this.gravity=this.gravity;
		}
		laya.d3.physics.PhysicsComponent.prototype._parse.call(this,data);
		this._parseShape(data.shapes);
	}

	/**
	*@inheritDoc
	*/
	__proto._onDestroy=function(){
		var physics3D=Laya3D._physics3D;
		this._nativeMotionState.clear();
		physics3D.destroy(this._nativeMotionState);
		laya.d3.physics.PhysicsComponent.prototype._onDestroy.call(this);
		this._nativeMotionState=null;
		this._gravity=null;
		this._totalTorque=null;
		this._linearVelocity=null;
		this._angularVelocity=null;
		this._linearFactor=null;
		this._angularFactor=null;
	}

	/**
	*@inheritDoc
	*/
	__proto._addToSimulation=function(){
		this._simulation._addRigidBody(this,this._collisionGroup,this._detectCollisions ? this._canCollideWith :0);
	}

	/**
	*@inheritDoc
	*/
	__proto._removeFromSimulation=function(){
		this._simulation._removeRigidBody(this);
	}

	/**
	*@inheritDoc
	*/
	__proto._cloneTo=function(dest){
		_super.prototype._cloneTo.call(this,dest);
		var destRigidbody3D=dest;
		destRigidbody3D.isKinematic=this._isKinematic;
		destRigidbody3D.mass=this._mass;
		destRigidbody3D.gravity=this._gravity;
		destRigidbody3D.angularDamping=this._angularDamping;
		destRigidbody3D.linearDamping=this._linearDamping;
		destRigidbody3D.overrideGravity=this._overrideGravity;
		destRigidbody3D.linearVelocity=this._linearVelocity;
		destRigidbody3D.angularVelocity=this._angularVelocity;
		destRigidbody3D.linearFactor=this._linearFactor;
		destRigidbody3D.angularFactor=this._angularFactor;
		destRigidbody3D.detectCollisions=this._detectCollisions;
	}

	/**
	*应用作用力。
	*@param force 作用力。
	*@param localOffset 偏移,如果为null则为中心点
	*/
	__proto.applyForce=function(force,localOffset){
		if (this._nativeColliderObject==null)
			throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
		var nativeForce=Rigidbody3D._nativeTempVector30;
		var forceE=force.elements;
		nativeForce.setValue(-forceE[0],forceE[1],forceE[2]);
		if (localOffset){
			var localOffsetE=localOffset.elements;
			var nativeOffset=Rigidbody3D._nativeTempVector31;
			nativeOffset.setValue(-localOffsetE[0],localOffsetE[1],localOffsetE[2]);
			this._nativeColliderObject.applyForce(nativeForce,nativeOffset);
			}else {
			this._nativeColliderObject.applyCentralForce(nativeForce);
		}
	}

	/**
	*应用扭转力。
	*@param torque 扭转力。
	*/
	__proto.applyTorque=function(torque){
		if (this._nativeColliderObject==null)
			throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
		var nativeTorque=Rigidbody3D._nativeTempVector30;
		var torqueE=torque.elements;
		nativeTorque.setValue(-torqueE[0],torqueE[1],torqueE[2]);
		this._nativeColliderObject.applyTorque(nativeTorque);
	}

	/**
	*应用冲量。
	*@param impulse 冲量。
	*@param localOffset 偏移,如果为null则为中心点。
	*/
	__proto.applyImpulse=function(impulse,localOffset){
		if (this._nativeColliderObject==null)
			throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
		var impulseE=impulse.elements;
		Rigidbody3D._nativeImpulse.setValue(-impulseE[0],impulseE[1],impulseE[2]);
		if (localOffset){
			var localOffsetE=localOffset.elements;
			Rigidbody3D._nativeImpulseOffset.setValue(-localOffsetE[0],localOffsetE[1],localOffsetE[2]);
			this._nativeColliderObject.applyImpulse(Rigidbody3D._nativeImpulse,Rigidbody3D._nativeImpulseOffset);
			}else {
			this._nativeColliderObject.applyCentralImpulse(Rigidbody3D._nativeImpulse);
		}
	}

	/**
	*应用扭转冲量。
	*@param torqueImpulse
	*/
	__proto.applyTorqueImpulse=function(torqueImpulse){
		if (this._nativeColliderObject==null)
			throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
		var nativeTorqueImpulse=Rigidbody3D._nativeTempVector30;
		var torqueImpulseE=torqueImpulse.elements;
		nativeTorqueImpulse.setValue(-torqueImpulseE[0],torqueImpulseE[1],torqueImpulseE[2]);
		this._nativeColliderObject.applyTorqueImpulse(nativeTorqueImpulse);
	}

	/**
	*唤醒刚体。
	*/
	__proto.wakeUp=function(){
		this._nativeColliderObject && (this._nativeColliderObject.activate(false));
	}

	/**
	*清除应用到刚体上的所有力。
	*/
	__proto.clearForces=function(){
		var rigidBody=this._nativeColliderObject;
		if (rigidBody==null)
			throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
		rigidBody.clearForces();
		var nativeZero=Rigidbody3D._nativeVector3Zero;
		rigidBody.setInterpolationAngularVelocity(nativeZero);
		rigidBody.setLinearVelocity(nativeZero);
		rigidBody.setInterpolationAngularVelocity(nativeZero);
		rigidBody.setAngularVelocity(nativeZero);
	}

	/**
	*设置刚体的角阻力。
	*@param value 角阻力。
	*/
	/**
	*获取刚体的角阻力。
	*@return 角阻力。
	*/
	__getset(0,__proto,'angularDamping',function(){
		return this._angularDamping;
		},function(value){
		this._angularDamping=value;
		if (this._nativeColliderObject)
			this._nativeColliderObject.setDamping(this._linearDamping,value);
	});

	/**
	*设置质量。
	*@param value 质量。
	*/
	/**
	*获取质量。
	*@return 质量。
	*/
	__getset(0,__proto,'mass',function(){
		return this._mass;
		},function(value){
		value=Math.max(value,1e-07);
		this._mass=value;
		(this._isKinematic)|| (this._updateMass(value));
	});

	/**
	*设置刚体的线阻力。
	*@param value 线阻力。
	*/
	/**
	*获取刚体的线阻力。
	*@return 线阻力。
	*/
	__getset(0,__proto,'linearDamping',function(){
		return this._linearDamping;
		},function(value){
		this._linearDamping=value;
		if (this._nativeColliderObject)
			this._nativeColliderObject.setDamping(value,this._angularDamping);
	});

	/**
	*设置是否为运动物体，如果为true仅可通过transform属性移动物体,而非其他力相关属性。
	*@param value 是否为运动物体。
	*/
	/**
	*获取是否为运动物体，如果为true仅可通过transform属性移动物体,而非其他力相关属性。
	*@return 是否为运动物体。
	*/
	__getset(0,__proto,'isKinematic',function(){
		return this._isKinematic;
		},function(value){
		this._isKinematic=value;
		var canInSimulation=!!(this._simulation && this._enabled && this._colliderShape);
		canInSimulation && this._removeFromSimulation();
		var natColObj=this._nativeColliderObject;
		var flags=natColObj.getCollisionFlags();
		if (value){
			flags=flags | 2;
			natColObj.setCollisionFlags(flags);
			this._nativeColliderObject.forceActivationState(4);
			this._enableProcessCollisions=false;
			this._updateMass(0);
			}else {
			if ((flags & 2)> 0)
				flags=flags ^ 2;
			natColObj.setCollisionFlags(flags);
			this._nativeColliderObject.setActivationState(1);
			this._enableProcessCollisions=true;
			this._updateMass(this._mass);
		};
		var nativeZero=Rigidbody3D._nativeVector3Zero;
		natColObj.setInterpolationLinearVelocity(nativeZero);
		natColObj.setLinearVelocity(nativeZero);
		natColObj.setInterpolationAngularVelocity(nativeZero);
		natColObj.setAngularVelocity(nativeZero);
		canInSimulation && this._addToSimulation();
	});

	/**
	*设置重力。
	*@param value 重力。
	*/
	/**
	*获取重力。
	*@return 重力。
	*/
	__getset(0,__proto,'gravity',function(){
		return this._gravity;
		},function(value){
		this._gravity=value;
		Rigidbody3D._nativeGravity.setValue(-value.x,value.y,value.z);
		this._nativeColliderObject.setGravity(Rigidbody3D._nativeGravity);
	});

	/**
	*设置是否重载重力。
	*@param value 是否重载重力。
	*/
	/**
	*获取是否重载重力。
	*@return 是否重载重力。
	*/
	__getset(0,__proto,'overrideGravity',function(){
		return this._overrideGravity;
		},function(value){
		this._overrideGravity=value;
		if (this._nativeColliderObject){
			var flag=this._nativeColliderObject.getFlags();
			if (value){
				if ((flag & 1)===0)
					this._nativeColliderObject.setFlags(flag | 1);
				}else {
				if ((flag & 1)> 0)
					this._nativeColliderObject.setFlags(flag ^ 1);
			}
		}
	});

	/**
	*获取总力。
	*/
	__getset(0,__proto,'totalForce',function(){
		if (this._nativeColliderObject)
			return this._nativeColliderObject.getTotalForce();
		return null;
	});

	/**
	*设置线速度。
	*@param 线速度。
	*/
	/**
	*获取线速度
	*@return 线速度
	*/
	__getset(0,__proto,'linearVelocity',function(){
		if (this._nativeColliderObject)
			Utils3D._convertToLayaVec3(this._nativeColliderObject.getLinearVelocity(),this._linearVelocity,true);
		return this._linearVelocity;
		},function(value){
		this._linearVelocity=value;
		if (this._nativeColliderObject){
			var nativeValue=Rigidbody3D._nativeTempVector30;
			Utils3D._convertToBulletVec3(value,nativeValue,true);
			(this.isSleeping)&& (this.wakeUp());
			this._nativeColliderObject.setLinearVelocity(nativeValue);
		}
	});

	/**
	*设置是否进行碰撞检测。
	*@param value 是否进行碰撞检测。
	*/
	/**
	*获取是否进行碰撞检测。
	*@return 是否进行碰撞检测。
	*/
	__getset(0,__proto,'detectCollisions',function(){
		return this._detectCollisions;
		},function(value){
		if (this._detectCollisions!==value){
			this._detectCollisions=value;
			if (this._colliderShape && this._enabled && this._simulation){
				this._simulation._removeRigidBody(this);
				this._simulation._addRigidBody(this,this._collisionGroup,value ? this._canCollideWith :0);
			}
		}
	});

	/**
	*设置性因子。
	*/
	/**
	*获取性因子。
	*/
	__getset(0,__proto,'linearFactor',function(){
		if (this._nativeColliderObject)
			return this._linearFactor;
		return null;
		},function(value){
		this._linearFactor=value;
		if (this._nativeColliderObject){
			var nativeValue=Rigidbody3D._nativeTempVector30;
			Utils3D._convertToBulletVec3(value,nativeValue,false);
			this._nativeColliderObject.setLinearFactor(nativeValue);
		}
	});

	/**
	*设置角因子。
	*/
	/**
	*获取角因子。
	*/
	__getset(0,__proto,'angularFactor',function(){
		if (this._nativeColliderObject)
			return this._angularFactor;
		return null;
		},function(value){
		this._angularFactor=value;
		if (this._nativeColliderObject){
			var nativeValue=Rigidbody3D._nativeTempVector30;
			Utils3D._convertToBulletVec3(value,nativeValue,false);
			this._nativeColliderObject.setAngularFactor(nativeValue);
		}
	});

	/**
	*设置角速度。
	*@param 角速度
	*/
	/**
	*获取角速度。
	*@return 角速度。
	*/
	__getset(0,__proto,'angularVelocity',function(){
		if (this._nativeColliderObject)
			Utils3D._convertToLayaVec3(this._nativeColliderObject.getAngularVelocity(),this._angularVelocity,true);
		return this._angularVelocity;
		},function(value){
		this._angularVelocity=value;
		if (this._nativeColliderObject){
			var nativeValue=Rigidbody3D._nativeTempVector30;
			Utils3D._convertToBulletVec3(value,nativeValue,true);
			(this.isSleeping)&& (this.wakeUp());
			this._nativeColliderObject.setAngularVelocity(nativeValue);
		}
	});

	/**
	*获取刚体所有扭力。
	*/
	__getset(0,__proto,'totalTorque',function(){
		if (this._nativeColliderObject){
			var nativeTotalTorque=this._nativeColliderObject.getTotalTorque();
			var totalTorqueE=this._totalTorque.elements;
			totalTorqueE[0]=-nativeTotalTorque.x;
			totalTorqueE[1]=nativeTotalTorque.y;
			totalTorqueE[2]=nativeTotalTorque.z;
		}
		return null;
	});

	/**
	*获取是否处于睡眠状态。
	*@return 是否处于睡眠状态。
	*/
	__getset(0,__proto,'isSleeping',function(){
		if (this._nativeColliderObject)
			return this._nativeColliderObject.getActivationState()===/*laya.d3.physics.PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING*/2;
		return false;
	});

	/**
	*设置刚体睡眠的线速度阈值。
	*@param value 刚体睡眠的线速度阈值。
	*/
	/**
	*获取刚体睡眠的线速度阈值。
	*@return 刚体睡眠的线速度阈值。
	*/
	__getset(0,__proto,'sleepLinearVelocity',function(){
		return this._nativeColliderObject.getLinearSleepingThreshold();
		},function(value){
		this._nativeColliderObject.setSleepingThresholds(value,this._nativeColliderObject.getAngularSleepingThreshold());
	});

	/**
	*设置刚体睡眠的角速度阈值。
	*@param value 刚体睡眠的角速度阈值。
	*/
	/**
	*获取刚体睡眠的角速度阈值。
	*@return 刚体睡眠的角速度阈值。
	*/
	__getset(0,__proto,'sleepAngularVelocity',function(){
		return this._nativeColliderObject.getAngularSleepingThreshold();
		},function(value){
		this._nativeColliderObject.setSleepingThresholds(this._nativeColliderObject.getLinearSleepingThreshold(),value);
	});

	Rigidbody3D.TYPE_STATIC=0;
	Rigidbody3D.TYPE_DYNAMIC=1;
	Rigidbody3D.TYPE_KINEMATIC=2;
	Rigidbody3D._BT_DISABLE_WORLD_GRAVITY=1;
	Rigidbody3D._BT_ENABLE_GYROPSCOPIC_FORCE=2;
	__static(Rigidbody3D,
	['_nativeTempVector30',function(){return this._nativeTempVector30=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeTempVector31',function(){return this._nativeTempVector31=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeVector3Zero',function(){return this._nativeVector3Zero=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeInertia',function(){return this._nativeInertia=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeImpulse',function(){return this._nativeImpulse=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeImpulseOffset',function(){return this._nativeImpulseOffset=new Laya3D._physics3D.btVector3(0,0,0);},'_nativeGravity',function(){return this._nativeGravity=new Laya3D._physics3D.btVector3(0,0,0);}
	]);
	return Rigidbody3D;
})(PhysicsTriggerComponent)


/**
//*<code>RenderTexture</code> 类用于创建渲染目标。
*/
//class laya.d3.resource.RenderTexture extends laya.webgl.resource.BaseTexture
var RenderTexture=(function(_super){
	function RenderTexture(width,height,format,depthStencilFormat){
		/**@private */
		//this._frameBuffer=null;
		/**@private */
		//this._depthStencilBuffer=null;
		/**@private */
		//this._depthStencilFormat=0;
		(format===void 0)&& (format=0);
		(depthStencilFormat===void 0)&& (depthStencilFormat=/*laya.webgl.resource.BaseTexture.FORMAT_DEPTH_16*/0);
		RenderTexture.__super.call(this,format,false);
		this._glTextureType=/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1;
		this._width=width;
		this._height=height;
		this._depthStencilFormat=depthStencilFormat;
		this._create(width,height);
	}

	__class(RenderTexture,'laya.d3.resource.RenderTexture',_super);
	var __proto=RenderTexture.prototype;
	/**
	*@private
	*/
	__proto._create=function(width,height){
		var gl=LayaGL.instance;
		this._frameBuffer=gl.createFramebuffer();
		WebGLContext.bindTexture(gl,this._glTextureType,this._glTexture);
		var glFormat=this._getGLFormat();
		gl.texImage2D(this._glTextureType,0,glFormat,width,height,0,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,null);
		this._setGPUMemory(width *height *4);
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._frameBuffer);
		gl.framebufferTexture2D(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.COLOR_ATTACHMENT0*/0x8CE0,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._glTexture,0);
		if (this._depthStencilFormat!==/*laya.webgl.resource.BaseTexture.FORMAT_DEPTHSTENCIL_NONE*/3){
			this._depthStencilBuffer=gl.createRenderbuffer();
			gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
			switch (this._depthStencilFormat){
				case /*laya.webgl.resource.BaseTexture.FORMAT_DEPTH_16*/0:
					gl.renderbufferStorage(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5,width,height);
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_ATTACHMENT*/0x8D00,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				case /*laya.webgl.resource.BaseTexture.FORMAT_STENCIL_8*/1:
					gl.renderbufferStorage(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,/*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48,width,height);
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.STENCIL_ATTACHMENT*/0x8D20,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				case /*laya.webgl.resource.BaseTexture.FORMAT_DEPTHSTENCIL_16_8*/2:
					gl.renderbufferStorage(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9,width,height);
					gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_STENCIL_ATTACHMENT*/0x821A,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
					break ;
				default :
					throw "RenderTexture: unkonw depth format.";
				}
		}
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
		gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,null);
		this._setWarpMode(/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,this._wrapModeU);
		this._setWarpMode(/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,this._wrapModeV);
		this._setFilterMode(this._filterMode);
		this._setAnisotropy(this._anisoLevel);
		this._readyed=true;
		this._activeResource();
	}

	/**
	*生成mipMap。
	*/
	__proto.generateMipmap=function(){
		if (this._isPot(this.width)&& this._isPot(this.height)){
			this._mipmap=true;
			LayaGL.instance.generateMipmap(this._glTextureType);
			this._setFilterMode(this._filterMode);
			this._setGPUMemory(this.width *this.height *4 *(1+1 / 3));
			}else {
			this._mipmap=false;
			this._setGPUMemory(this.width *this.height *4 *(1+1 / 3));
		}
	}

	/**
	*开始绑定。
	*/
	__proto.start=function(){
		LayaGL.instance.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._frameBuffer);
		RenderTexture._currentActive=this;
		this._readyed=false;
	}

	/**
	*结束绑定。
	*/
	__proto.end=function(){
		LayaGL.instance.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
		RenderTexture._currentActive=null;
		this._readyed=true;
	}

	/**
	*获得像素数据。
	*@param x X像素坐标。
	*@param y Y像素坐标。
	*@param width 宽度。
	*@param height 高度。
	*@return 像素数据。
	*/
	__proto.getData=function(x,y,width,height,out){
		var gl=LayaGL.instance;
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._frameBuffer);
		var canRead=(gl.checkFramebufferStatus(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40)===/*laya.webgl.WebGLContext.FRAMEBUFFER_COMPLETE*/0x8CD5);
		if (!canRead){
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
			return null;
		}
		gl.readPixels(x,y,width,height,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,out);
		gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
		return out;
	}

	/**
	*@inheritDoc
	*/
	__proto._disposeResource=function(){
		if (this._frameBuffer){
			var gl=LayaGL.instance;
			gl.deleteTexture(this._glTexture);
			gl.deleteFramebuffer(this._frameBuffer);
			gl.deleteRenderbuffer(this._depthStencilBuffer);
			this._glTexture=null;
			this._frameBuffer=null;
			this._depthStencilBuffer=null;
			this._setGPUMemory(0);
		}
	}

	/**
	*获取深度格式。
	*@return 深度格式。
	*/
	__getset(0,__proto,'depthStencilFormat',function(){
		return this._depthStencilFormat;
	});

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'defaulteTexture',function(){
		return Texture2D.grayTexture;
	});

	/**
	*获取当前激活的Rendertexture
	*/
	__getset(1,RenderTexture,'currentActive',function(){
		return RenderTexture._currentActive;
	},laya.webgl.resource.BaseTexture._$SET_currentActive);

	RenderTexture._currentActive=null;
	return RenderTexture;
})(BaseTexture)


/**
*<code>TextureCube</code> 类用于生成立方体纹理。
*/
//class laya.d3.resource.TextureCube extends laya.webgl.resource.BaseTexture
var TextureCube=(function(_super){
	function TextureCube(format,mipmap){
		/**@private */
		//this._premultiplyAlpha=0;
		(format===void 0)&& (format=0);
		(mipmap===void 0)&& (mipmap=false);
		TextureCube.__super.call(this,format,mipmap);
		this._glTextureType=/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513;
	}

	__class(TextureCube,'laya.d3.resource.TextureCube',_super);
	var __proto=TextureCube.prototype;
	/**
	*通过六张图片源填充纹理。
	*@param 图片源数组。
	*/
	__proto.setSixSideImageSources=function(source,premultiplyAlpha){
		(premultiplyAlpha===void 0)&& (premultiplyAlpha=false);
		var width=0;
		var height=0;
		for (var i=0;i < 6;i++){
			var img=source[i];
			if (!img){
				console.log("TextureCube: image Source can't be null.");
				return;
			};
			var nextWidth=img.width;
			var nextHeight=img.height;
			if (i > 0){
				if (width!==nextWidth){
					console.log("TextureCube: each side image's width and height must same.");
					return;
				}
			}
			width=nextWidth;
			height=nextHeight;
			if (width!==height){
				console.log("TextureCube: each side image's width and height must same.");
				return;
			}
		}
		this._width=width;
		this._height=height;
		var gl=LayaGL.instance;
		WebGLContext.bindTexture(gl,this._glTextureType,this._glTexture);
		var glFormat=this._getGLFormat();
		if (!Render.isConchApp){
			(premultiplyAlpha)&& (gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,true));
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z*/0x8519,0,glFormat,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[0]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z*/0x851A,0,glFormat,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[1]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X*/0x8515,0,glFormat,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[2]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X*/0x8516,0,glFormat,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[3]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y*/0x8517,0,glFormat,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[4]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y*/0x8518,0,glFormat,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[5]);
			(premultiplyAlpha)&& (gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241,false));
			}else {
			if (premultiplyAlpha==true){
				for (var j=0;j < 6;j++)
				source[j].setPremultiplyAlpha(premultiplyAlpha);
			}
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z*/0x8519,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[0]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z*/0x851A,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[1]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X*/0x8515,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[2]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X*/0x8516,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[3]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y*/0x8517,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[4]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y*/0x8518,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,source[5]);
		}
		if (this._mipmap && this._isPot(width)&& this._isPot(height)){
			gl.generateMipmap(this._glTextureType);
			this._setGPUMemory(width *height *4 *(1+1 / 3)*6);
			}else {
			this._setGPUMemory(width *height *4 *6);
		}
		this._setWarpMode(/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,this._wrapModeU);
		this._setWarpMode(/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,this._wrapModeV);
		this._setFilterMode(this._filterMode);
		this._readyed=true;
		this._activeResource();
	}

	/**
	*通过六张图片源填充纹理。
	*@param 图片源数组。
	*/
	__proto.setSixSidePixels=function(width,height,pixels){
		if (width <=0 || height <=0)
			throw new Error("TextureCube:width or height must large than 0.");
		if (!pixels)
			throw new Error("TextureCube:pixels can't be null.");
		this._width=width;
		this._height=height;
		var gl=LayaGL.instance;
		WebGLContext.bindTexture(gl,this._glTextureType,this._glTexture);
		var glFormat=this._getGLFormat();
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z*/0x8519,0,glFormat,width,height,0,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,pixels[0]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z*/0x851A,0,glFormat,width,height,0,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,pixels[1]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X*/0x8515,0,glFormat,width,height,0,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,pixels[2]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X*/0x8516,0,glFormat,width,height,0,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,pixels[3]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y*/0x8517,0,glFormat,width,height,0,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,pixels[4]);
		gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y*/0x8518,0,glFormat,width,height,0,glFormat,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,pixels[5]);
		if (this._mipmap && this._isPot(width)&& this._isPot(height)){
			gl.generateMipmap(this._glTextureType);
			this._setGPUMemory(width *height *4 *(1+1 / 3)*6);
			}else {
			this._setGPUMemory(width *height *4 *6);
		}
		this._setWarpMode(/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,this._wrapModeU);
		this._setWarpMode(/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,this._wrapModeV);
		this._setFilterMode(this._filterMode);
		this._readyed=true;
		this._activeResource();
	}

	/**
	*@inheritDoc
	*/
	__proto._recoverResource=function(){}
	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'defaulteTexture',function(){
		return TextureCube.grayTexture;
	});

	TextureCube.__init__=function(){
		var pixels=new Uint8Array(3);
		pixels[0]=128;
		pixels[1]=128;
		pixels[2]=128;
		TextureCube.grayTexture=new TextureCube(0,false);
		TextureCube.grayTexture.setSixSidePixels(1,1,[pixels,pixels,pixels,pixels,pixels,pixels]);
		TextureCube.grayTexture.lock=true;
	}

	TextureCube._parse=function(data,propertyParams,constructParams){
		var texture=constructParams ? new TextureCube(constructParams[0],constructParams[1]):new TextureCube();
		texture.setSixSideImageSources(data);
		return texture;
	}

	TextureCube.load=function(url,complete){
		Laya.loader.create(url,complete,null,/*Laya3D.TEXTURECUBE*/"TEXTURECUBE");
	}

	TextureCube.grayTexture=null;
	return TextureCube;
})(BaseTexture)


/**
*<code>TrailSprite3D</code> 类用于创建拖尾渲染精灵。
*/
//class laya.d3.core.trail.TrailSprite3D extends laya.d3.core.RenderableSprite3D
var TrailSprite3D=(function(_super){
	function TrailSprite3D(){
		/**@private */
		//this._geometryFilter=null;
		TrailSprite3D.__super.call(this,this.name);
		this._render=new TrailRenderer(this);
		this._geometryFilter=new TrailFilter(this);
	}

	__class(TrailSprite3D,'laya.d3.core.trail.TrailSprite3D',_super);
	var __proto=TrailSprite3D.prototype;
	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		laya.d3.core.Sprite3D.prototype._parse.call(this,data);
		var render=this._render;
		var filter=this._geometryFilter;
		var i=0,j=0;
		var materials=data.materials;
		if (materials){
			var sharedMaterials=render.sharedMaterials;
			var materialCount=materials.length;
			sharedMaterials.length=materialCount;
			for (i=0;i < materialCount;i++)
			sharedMaterials[i]=Loader.getRes(materials[i].path);
			render.sharedMaterials=sharedMaterials;
		}
		filter.time=data.time;
		filter.minVertexDistance=data.minVertexDistance;
		filter.widthMultiplier=data.widthMultiplier;
		filter.textureMode=data.textureMode;
		(data.alignment !=null)&& (filter.alignment=data.alignment);
		var widthCurve=[];
		var widthCurveData=data.widthCurve;
		for (i=0,j=widthCurveData.length;i < j;i++){
			var trailkeyframe=new FloatKeyframe();
			trailkeyframe.time=widthCurveData[i].time;
			trailkeyframe.inTangent=widthCurveData[i].inTangent;
			trailkeyframe.outTangent=widthCurveData[i].outTangent;
			trailkeyframe.value=widthCurveData[i].value;
			widthCurve.push(trailkeyframe);
		}
		filter.widthCurve=widthCurve;
		var colorGradientData=data.colorGradient;
		var colorKeys=colorGradientData.colorKeys;
		var alphaKeys=colorGradientData.alphaKeys;
		var colorGradient=new Gradient(colorKeys.length,alphaKeys.length);
		colorGradient.mode=colorGradientData.mode;
		for (i=0,j=colorKeys.length;i < j;i++){
			var colorKey=colorKeys[i];
			colorGradient.addColorRGB(colorKey.time,new Color(colorKey.value[0],colorKey.value[1],colorKey.value[2],1.0));
		}
		for (i=0,j=alphaKeys.length;i < j;i++){
			var alphaKey=alphaKeys[i];
			colorGradient.addColorAlpha(alphaKey.time,alphaKey.value);
		}
		filter.colorGradient=colorGradient;
	}

	/**
	*@inheritDoc
	*/
	__proto._onActive=function(){
		_super.prototype._onActive.call(this);
		this._transform.position.cloneTo(this._geometryFilter._lastPosition);
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
		var i=0,j=0;
		var destTrailSprite3D=destObject;
		var destTrailFilter=destTrailSprite3D.trailFilter;
		destTrailFilter.time=this.trailFilter.time;
		destTrailFilter.minVertexDistance=this.trailFilter.minVertexDistance;
		destTrailFilter.widthMultiplier=this.trailFilter.widthMultiplier;
		destTrailFilter.textureMode=this.trailFilter.textureMode;
		var widthCurveData=this.trailFilter.widthCurve;
		var widthCurve=[];
		for (i=0,j=widthCurveData.length;i < j;i++){
			var keyFrame=new FloatKeyframe();
			widthCurveData[i].cloneTo(keyFrame);
			widthCurve.push(keyFrame);
		}
		destTrailFilter.widthCurve=widthCurve;
		var destColorGradient=new Gradient(this.trailFilter.colorGradient.maxColorRGBKeysCount,this.trailFilter.colorGradient.maxColorAlphaKeysCount);
		this.trailFilter.colorGradient.cloneTo(destColorGradient);
		destTrailFilter.colorGradient=destColorGradient;
		var destTrailRender=destTrailSprite3D.trailRenderer;
		destTrailRender.sharedMaterial=this.trailRenderer.sharedMaterial;
	}

	/**
	*<p>销毁此对象。</p>
	*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		(this._geometryFilter).destroy();
		this._geometryFilter=null;
	}

	/**
	*获取Trail过滤器。
	*@return Trail过滤器。
	*/
	__getset(0,__proto,'trailFilter',function(){
		return this._geometryFilter;
	});

	/**
	*获取Trail渲染器。
	*@return Trail渲染器。
	*/
	__getset(0,__proto,'trailRenderer',function(){
		return this._render;
	});

	TrailSprite3D.__init__=function(){
		TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND=TrailSprite3D.shaderDefines.registerDefine("GRADIENTMODE_BLEND");
	}

	TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND=0;
	__static(TrailSprite3D,
	['CURTIME',function(){return this.CURTIME=Shader3D.propertyNameToID("u_CurTime");},'LIFETIME',function(){return this.LIFETIME=Shader3D.propertyNameToID("u_LifeTime");},'WIDTHCURVE',function(){return this.WIDTHCURVE=Shader3D.propertyNameToID("u_WidthCurve");},'WIDTHCURVEKEYLENGTH',function(){return this.WIDTHCURVEKEYLENGTH=Shader3D.propertyNameToID("u_WidthCurveKeyLength");},'GRADIENTCOLORKEY',function(){return this.GRADIENTCOLORKEY=Shader3D.propertyNameToID("u_GradientColorkey");},'GRADIENTALPHAKEY',function(){return this.GRADIENTALPHAKEY=Shader3D.propertyNameToID("u_GradientAlphakey");},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(RenderableSprite3D.shaderDefines);}
	]);
	return TrailSprite3D;
})(RenderableSprite3D)


/**
*<code>PointLight</code> 类用于创建点光。
*/
//class laya.d3.core.light.PointLight extends laya.d3.core.light.LightSprite
var PointLight=(function(_super){
	function PointLight(){
		/**@private */
		this._range=NaN;
		this._lightMatrix=new Matrix4x4();
		PointLight.__super.call(this);
		this._range=6.0;
	}

	__class(PointLight,'laya.d3.core.light.PointLight',_super);
	var __proto=PointLight.prototype;
	/**
	*@inheritDoc
	*/
	__proto._onActive=function(){
		_super.prototype._onActive.call(this);
		(this._lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&&((this._scene)._defineDatas.add(Scene3D.SHADERDEFINE_POINTLIGHT));
	}

	/**
	*@inheritDoc
	*/
	__proto._onInActive=function(){
		_super.prototype._onInActive.call(this);
		(this._lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&&((this._scene)._defineDatas.remove(Scene3D.SHADERDEFINE_POINTLIGHT));
	}

	/**
	*更新点光相关渲染状态参数。
	*@param state 渲染状态参数。
	*/
	__proto._prepareToScene=function(){
		var scene=this._scene;
		if (scene.enableLight && this.activeInHierarchy){
			var defineDatas=scene._defineDatas;
			var shaderValue=scene._shaderValues;
			Vector3.scale(this.color,this._intensity,this._intensityColor);
			shaderValue.setVector(Scene3D.POINTLIGHTCOLOR,this._intensityColor);
			shaderValue.setVector(Scene3D.POINTLIGHTPOS,this.transform.position);
			shaderValue.setNumber(Scene3D.POINTLIGHTRANGE,this.range);
			var lightMatrix=this._lightMatrix;
			var lightMatrixE=lightMatrix.elements;
			lightMatrix.identity();
			lightMatrixE[0]=lightMatrixE[5]=lightMatrixE[10]=1.0 / this._range;
			var toLightMatrix=PointLight._tempMatrix0;
			this.transform.worldMatrix.invert(toLightMatrix);
			Matrix4x4.multiply(lightMatrix,toLightMatrix,lightMatrix);
			shaderValue.setMatrix4x4(Scene3D.POINTLIGHTMATRIX,lightMatrix);
			return true;
			}else {
			return false;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		_super.prototype._parse.call(this,data);
		this.range=data.range;
	}

	/**
	*设置点光的范围。
	*@param value 点光的范围。
	*/
	/**
	*获取点光的范围。
	*@return 点光的范围。
	*/
	__getset(0,__proto,'range',function(){
		return this._range;
		},function(value){
		this._range=value;
	});

	__static(PointLight,
	['_tempMatrix0',function(){return this._tempMatrix0=new Matrix4x4();}
	]);
	return PointLight;
})(LightSprite)


/**
*<code>ShuriKenParticle3D</code> 3D粒子。
*/
//class laya.d3.core.particleShuriKen.ShuriKenParticle3D extends laya.d3.core.RenderableSprite3D
var ShuriKenParticle3D=(function(_super){
	function ShuriKenParticle3D(){
		/**@private */
		//this._particleSystem=null;
		ShuriKenParticle3D.__super.call(this,null);
		this._render=new ShurikenParticleRenderer(this);
		this._particleSystem=new ShurikenParticleSystem(this);
		var elements=this._render._renderElements;
		var element=elements[0]=new RenderElement();
		element.setTransform(this._transform);
		element.render=this._render;
		element.setGeometry(this._particleSystem);
		element.material=ShurikenParticleMaterial.defaultMaterial;
	}

	__class(ShuriKenParticle3D,'laya.d3.core.particleShuriKen.ShuriKenParticle3D',_super);
	var __proto=ShuriKenParticle3D.prototype;
	/**
	*@private
	*/
	__proto._initParticleVelocity=function(gradientData){
		var gradient=new GradientDataNumber();
		var velocitysData=gradientData.velocitys;
		for (var i=0,n=velocitysData.length;i < n;i++){
			var valueData=velocitysData[i];
			gradient.add(valueData.key,valueData.value);
		}
		return gradient;
	}

	/**
	*@private
	*/
	__proto._initParticleColor=function(gradientColorData){
		var gradientColor=new Gradient(4,4);
		var alphasData=gradientColorData.alphas;
		var i=0,n=0;
		for (i=0,n=alphasData.length;i < n;i++){
			var alphaData=alphasData[i];
			if ((i===3)&& ((alphaData.key!==1))){
				alphaData.key=1;
				console.log("GradientDataColor warning:the forth key is  be force set to 1.");
			}
			gradientColor.addColorAlpha(alphaData.key,alphaData.value);
		};
		var rgbsData=gradientColorData.rgbs;
		for (i=0,n=rgbsData.length;i < n;i++){
			var rgbData=rgbsData[i];
			var rgbValue=rgbData.value;
			if ((i===3)&& ((rgbData.key!==1))){
				rgbData.key=1;
				console.log("GradientDataColor warning:the forth key is  be force set to 1.");
			}
			gradientColor.addColorRGB(rgbData.key,new Color(rgbValue[0],rgbValue[1],rgbValue[2],1.0));
		}
		return gradientColor;
	}

	/**
	*@private
	*/
	__proto._initParticleSize=function(gradientSizeData){
		var gradientSize=new GradientDataNumber();
		var sizesData=gradientSizeData.sizes;
		for (var i=0,n=sizesData.length;i < n;i++){
			var valueData=sizesData[i];
			gradientSize.add(valueData.key,valueData.value);
		}
		return gradientSize;
	}

	/**
	*@private
	*/
	__proto._initParticleRotation=function(gradientData){
		var gradient=new GradientDataNumber();
		var angularVelocitysData=gradientData.angularVelocitys;
		for (var i=0,n=angularVelocitysData.length;i < n;i++){
			var valueData=angularVelocitysData[i];
			gradient.add(valueData.key,valueData.value / 180.0 *Math.PI);
		}
		return gradient;
	}

	/**
	*@private
	*/
	__proto._initParticleFrame=function(overTimeFramesData){
		var overTimeFrame=new GradientDataInt();
		var framesData=overTimeFramesData.frames;
		for (var i=0,n=framesData.length;i < n;i++){
			var frameData=framesData[i];
			overTimeFrame.add(frameData.key,frameData.value);
		}
		return overTimeFrame;
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		laya.d3.core.Sprite3D.prototype._parse.call(this,data);
		var anglelToRad=Math.PI / 180.0;
		var i=0,n=0;
		var particleRender=this.particleRenderer;
		var material;
		var materialData=data.material;
		(materialData)&& (material=Loader.getRes(materialData.path));
		particleRender.sharedMaterial=material;
		var meshPath=data.meshPath;
		(meshPath)&& (particleRender.mesh=Loader.getRes(meshPath));
		particleRender.renderMode=data.renderMode;
		particleRender.stretchedBillboardCameraSpeedScale=data.stretchedBillboardCameraSpeedScale;
		particleRender.stretchedBillboardSpeedScale=data.stretchedBillboardSpeedScale;
		particleRender.stretchedBillboardLengthScale=data.stretchedBillboardLengthScale;
		particleRender.sortingFudge=data.sortingFudge ? data.sortingFudge :0.0;
		var particleSystem=this.particleSystem;
		particleSystem.isPerformanceMode=data.isPerformanceMode;
		particleSystem.duration=data.duration;
		particleSystem.looping=data.looping;
		particleSystem.prewarm=data.prewarm;
		particleSystem.startDelayType=data.startDelayType;
		particleSystem.startDelay=data.startDelay;
		particleSystem.startDelayMin=data.startDelayMin;
		particleSystem.startDelayMax=data.startDelayMax;
		particleSystem.startLifetimeType=data.startLifetimeType;
		particleSystem.startLifetimeConstant=data.startLifetimeConstant;
		particleSystem.startLifeTimeGradient=ShuriKenParticle3D._initStartLife(data.startLifetimeGradient);
		particleSystem.startLifetimeConstantMin=data.startLifetimeConstantMin;
		particleSystem.startLifetimeConstantMax=data.startLifetimeConstantMax;
		particleSystem.startLifeTimeGradientMin=ShuriKenParticle3D._initStartLife(data.startLifetimeGradientMin);
		particleSystem.startLifeTimeGradientMax=ShuriKenParticle3D._initStartLife(data.startLifetimeGradientMax);
		particleSystem.startSpeedType=data.startSpeedType;
		particleSystem.startSpeedConstant=data.startSpeedConstant;
		particleSystem.startSpeedConstantMin=data.startSpeedConstantMin;
		particleSystem.startSpeedConstantMax=data.startSpeedConstantMax;
		particleSystem.threeDStartSize=data.threeDStartSize;
		particleSystem.startSizeType=data.startSizeType;
		particleSystem.startSizeConstant=data.startSizeConstant;
		var startSizeConstantSeparateArray=data.startSizeConstantSeparate;
		var startSizeConstantSeparateElement=particleSystem.startSizeConstantSeparate.elements;
		startSizeConstantSeparateElement[0]=startSizeConstantSeparateArray[0];
		startSizeConstantSeparateElement[1]=startSizeConstantSeparateArray[1];
		startSizeConstantSeparateElement[2]=startSizeConstantSeparateArray[2];
		particleSystem.startSizeConstantMin=data.startSizeConstantMin;
		particleSystem.startSizeConstantMax=data.startSizeConstantMax;
		var startSizeConstantMinSeparateArray=data.startSizeConstantMinSeparate;
		var startSizeConstantMinSeparateElement=particleSystem.startSizeConstantMinSeparate.elements;
		startSizeConstantMinSeparateElement[0]=startSizeConstantMinSeparateArray[0];
		startSizeConstantMinSeparateElement[1]=startSizeConstantMinSeparateArray[1];
		startSizeConstantMinSeparateElement[2]=startSizeConstantMinSeparateArray[2];
		var startSizeConstantMaxSeparateArray=data.startSizeConstantMaxSeparate;
		var startSizeConstantMaxSeparateElement=particleSystem.startSizeConstantMaxSeparate.elements;
		startSizeConstantMaxSeparateElement[0]=startSizeConstantMaxSeparateArray[0];
		startSizeConstantMaxSeparateElement[1]=startSizeConstantMaxSeparateArray[1];
		startSizeConstantMaxSeparateElement[2]=startSizeConstantMaxSeparateArray[2];
		particleSystem.threeDStartRotation=data.threeDStartRotation;
		particleSystem.startRotationType=data.startRotationType;
		particleSystem.startRotationConstant=data.startRotationConstant *anglelToRad;
		var startRotationConstantSeparateArray=data.startRotationConstantSeparate;
		var startRotationConstantSeparateElement=particleSystem.startRotationConstantSeparate.elements;
		startRotationConstantSeparateElement[0]=startRotationConstantSeparateArray[0] *anglelToRad;
		startRotationConstantSeparateElement[1]=startRotationConstantSeparateArray[1] *anglelToRad;
		startRotationConstantSeparateElement[2]=startRotationConstantSeparateArray[2] *anglelToRad;
		particleSystem.startRotationConstantMin=data.startRotationConstantMin *anglelToRad;
		particleSystem.startRotationConstantMax=data.startRotationConstantMax *anglelToRad;
		var startRotationConstantMinSeparateArray=data.startRotationConstantMinSeparate;
		var startRotationConstantMinSeparateElement=particleSystem.startRotationConstantMinSeparate.elements;
		startRotationConstantMinSeparateElement[0]=startRotationConstantMinSeparateArray[0] *anglelToRad;
		startRotationConstantMinSeparateElement[1]=startRotationConstantMinSeparateArray[1] *anglelToRad;
		startRotationConstantMinSeparateElement[2]=startRotationConstantMinSeparateArray[2] *anglelToRad;
		var startRotationConstantMaxSeparateArray=data.startRotationConstantMaxSeparate;
		var startRotationConstantMaxSeparateElement=particleSystem.startRotationConstantMaxSeparate.elements;
		startRotationConstantMaxSeparateElement[0]=startRotationConstantMaxSeparateArray[0] *anglelToRad;
		startRotationConstantMaxSeparateElement[1]=startRotationConstantMaxSeparateArray[1] *anglelToRad;
		startRotationConstantMaxSeparateElement[2]=startRotationConstantMaxSeparateArray[2] *anglelToRad;
		particleSystem.randomizeRotationDirection=data.randomizeRotationDirection;
		particleSystem.startColorType=data.startColorType;
		var startColorConstantArray=data.startColorConstant;
		var startColorConstantElement=particleSystem.startColorConstant.elements;
		startColorConstantElement[0]=startColorConstantArray[0];
		startColorConstantElement[1]=startColorConstantArray[1];
		startColorConstantElement[2]=startColorConstantArray[2];
		startColorConstantElement[3]=startColorConstantArray[3];
		var startColorConstantMinArray=data.startColorConstantMin;
		var startColorConstantMinElement=particleSystem.startColorConstantMin.elements;
		startColorConstantMinElement[0]=startColorConstantMinArray[0];
		startColorConstantMinElement[1]=startColorConstantMinArray[1];
		startColorConstantMinElement[2]=startColorConstantMinArray[2];
		startColorConstantMinElement[3]=startColorConstantMinArray[3];
		var startColorConstantMaxArray=data.startColorConstantMax;
		var startColorConstantMaxElement=particleSystem.startColorConstantMax.elements;
		startColorConstantMaxElement[0]=startColorConstantMaxArray[0];
		startColorConstantMaxElement[1]=startColorConstantMaxArray[1];
		startColorConstantMaxElement[2]=startColorConstantMaxArray[2];
		startColorConstantMaxElement[3]=startColorConstantMaxArray[3];
		particleSystem.gravityModifier=data.gravityModifier;
		particleSystem.simulationSpace=data.simulationSpace;
		particleSystem.scaleMode=data.scaleMode;
		particleSystem.playOnAwake=data.playOnAwake;
		particleSystem.maxParticles=data.maxParticles;
		var autoRandomSeed=data.autoRandomSeed;
		(autoRandomSeed !=null)&& (particleSystem.autoRandomSeed=autoRandomSeed);
		var randomSeed=data.randomSeed;
		(randomSeed !=null)&& (particleSystem.randomSeed[0]=randomSeed);
		var emissionData=data.emission;
		var emission=particleSystem.emission;
		if (emissionData){
			emission.emissionRate=emissionData.emissionRate;
			var burstsData=emissionData.bursts;
			if (burstsData)
				for (i=0,n=burstsData.length;i < n;i++){
				var brust=burstsData[i];
				emission.addBurst(new Burst(brust.time,brust.min,brust.max));
			}
			emission.enbale=emissionData.enable;
			}else {
			emission.enbale=false;
		};
		var shapeData=data.shape;
		if (shapeData){
			var shape;
			switch (shapeData.shapeType){
				case 0:;
					var sphereShape;
					shape=sphereShape=new SphereShape();
					sphereShape.radius=shapeData.sphereRadius;
					sphereShape.emitFromShell=shapeData.sphereEmitFromShell;
					sphereShape.randomDirection=shapeData.sphereRandomDirection;
					break ;
				case 1:;
					var hemiSphereShape;
					shape=hemiSphereShape=new HemisphereShape();
					hemiSphereShape.radius=shapeData.hemiSphereRadius;
					hemiSphereShape.emitFromShell=shapeData.hemiSphereEmitFromShell;
					hemiSphereShape.randomDirection=shapeData.hemiSphereRandomDirection;
					break ;
				case 2:;
					var coneShape;
					shape=coneShape=new ConeShape();
					coneShape.angle=shapeData.coneAngle *anglelToRad;
					coneShape.radius=shapeData.coneRadius;
					coneShape.length=shapeData.coneLength;
					coneShape.emitType=shapeData.coneEmitType;
					coneShape.randomDirection=shapeData.coneRandomDirection;
					break ;
				case 3:;
					var boxShape;
					shape=boxShape=new BoxShape();
					boxShape.x=shapeData.boxX;
					boxShape.y=shapeData.boxY;
					boxShape.z=shapeData.boxZ;
					boxShape.randomDirection=shapeData.boxRandomDirection;
					break ;
				case 7:;
					var circleShape;
					shape=circleShape=new CircleShape();
					circleShape.radius=shapeData.circleRadius;
					circleShape.arc=shapeData.circleArc *anglelToRad;
					circleShape.emitFromEdge=shapeData.circleEmitFromEdge;
					circleShape.randomDirection=shapeData.circleRandomDirection;
					break ;
				default :;
					var tempShape;
					shape=tempShape=new CircleShape();
					tempShape.radius=shapeData.circleRadius;
					tempShape.arc=shapeData.circleArc *anglelToRad;
					tempShape.emitFromEdge=shapeData.circleEmitFromEdge;
					tempShape.randomDirection=shapeData.circleRandomDirection;
					break ;
				}
			shape.enable=shapeData.enable;
			particleSystem.shape=shape;
		};
		var velocityOverLifetimeData=data.velocityOverLifetime;
		if (velocityOverLifetimeData){
			var velocityData=velocityOverLifetimeData.velocity;
			var velocity;
			switch (velocityData.type){
				case 0:;
					var constantData=velocityData.constant;
					velocity=GradientVelocity.createByConstant(new Vector3(constantData[0],constantData[1],constantData[2]));
					break ;
				case 1:
					velocity=GradientVelocity.createByGradient(this._initParticleVelocity(velocityData.gradientX),this._initParticleVelocity(velocityData.gradientY),this._initParticleVelocity(velocityData.gradientZ));
					break ;
				case 2:;
					var constantMinData=velocityData.constantMin;
					var constantMaxData=velocityData.constantMax;
					velocity=GradientVelocity.createByRandomTwoConstant(new Vector3(constantMinData[0],constantMinData[1],constantMinData[2]),new Vector3(constantMaxData[0],constantMaxData[1],constantMaxData[2]));
					break ;
				case 3:
					velocity=GradientVelocity.createByRandomTwoGradient(this._initParticleVelocity(velocityData.gradientXMin),this._initParticleVelocity(velocityData.gradientXMax),this._initParticleVelocity(velocityData.gradientYMin),this._initParticleVelocity(velocityData.gradientYMax),this._initParticleVelocity(velocityData.gradientZMin),this._initParticleVelocity(velocityData.gradientZMax));
					break ;
				};
			var velocityOverLifetime=new VelocityOverLifetime(velocity);
			velocityOverLifetime.space=velocityOverLifetimeData.space;
			velocityOverLifetime.enbale=velocityOverLifetimeData.enable;
			particleSystem.velocityOverLifetime=velocityOverLifetime;
		};
		var colorOverLifetimeData=data.colorOverLifetime;
		if (colorOverLifetimeData){
			var colorData=colorOverLifetimeData.color;
			var color;
			switch (colorData.type){
				case 0:;
					var constColorData=colorData.constant;
					color=GradientColor.createByConstant(new Vector4(constColorData[0],constColorData[1],constColorData[2],constColorData[3]));
					break ;
				case 1:
					color=GradientColor.createByGradient(this._initParticleColor(colorData.gradient));
					break ;
				case 2:;
					var minConstColorData=colorData.constantMin;
					var maxConstColorData=colorData.constantMax;
					color=GradientColor.createByRandomTwoConstant(new Vector4(minConstColorData[0],minConstColorData[1],minConstColorData[2],minConstColorData[3]),new Vector4(maxConstColorData[0],maxConstColorData[1],maxConstColorData[2],maxConstColorData[3]));
					break ;
				case 3:
					color=GradientColor.createByRandomTwoGradient(this._initParticleColor(colorData.gradientMin),this._initParticleColor(colorData.gradientMax));
					break ;
				};
			var colorOverLifetime=new ColorOverLifetime(color);
			colorOverLifetime.enbale=colorOverLifetimeData.enable;
			particleSystem.colorOverLifetime=colorOverLifetime;
		};
		var sizeOverLifetimeData=data.sizeOverLifetime;
		if (sizeOverLifetimeData){
			var sizeData=sizeOverLifetimeData.size;
			var size;
			switch (sizeData.type){
				case 0:
					if (sizeData.separateAxes){
						size=GradientSize.createByGradientSeparate(this._initParticleSize(sizeData.gradientX),this._initParticleSize(sizeData.gradientY),this._initParticleSize(sizeData.gradientZ));
						}else {
						size=GradientSize.createByGradient(this._initParticleSize(sizeData.gradient));
					}
					break ;
				case 1:
					if (sizeData.separateAxes){
						var constantMinSeparateData=sizeData.constantMinSeparate;
						var constantMaxSeparateData=sizeData.constantMaxSeparate;
						size=GradientSize.createByRandomTwoConstantSeparate(new Vector3(constantMinSeparateData[0],constantMinSeparateData[1],constantMinSeparateData[2]),new Vector3(constantMaxSeparateData[0],constantMaxSeparateData[1],constantMaxSeparateData[2]));
						}else {
						size=GradientSize.createByRandomTwoConstant(sizeData.constantMin,sizeData.constantMax);
					}
					break ;
				case 2:
					if (sizeData.separateAxes){
						size=GradientSize.createByRandomTwoGradientSeparate(this._initParticleSize(sizeData.gradientXMin),this._initParticleSize(sizeData.gradientYMin),this._initParticleSize(sizeData.gradientZMin),this._initParticleSize(sizeData.gradientXMax),this._initParticleSize(sizeData.gradientYMax),this._initParticleSize(sizeData.gradientZMax));
						}else {
						size=GradientSize.createByRandomTwoGradient(this._initParticleSize(sizeData.gradientMin),this._initParticleSize(sizeData.gradientMax));
					}
					break ;
				};
			var sizeOverLifetime=new SizeOverLifetime(size);
			sizeOverLifetime.enbale=sizeOverLifetimeData.enable;
			particleSystem.sizeOverLifetime=sizeOverLifetime;
		};
		var rotationOverLifetimeData=data.rotationOverLifetime;
		if (rotationOverLifetimeData){
			var angularVelocityData=rotationOverLifetimeData.angularVelocity;
			var angularVelocity;
			switch (angularVelocityData.type){
				case 0:
					if (angularVelocityData.separateAxes){
						var conSep=angularVelocityData.constantSeparate;
						angularVelocity=GradientAngularVelocity.createByConstantSeparate(new Vector3(conSep[0]*anglelToRad,conSep[1]*anglelToRad,conSep[2]*anglelToRad));
						}else {
						angularVelocity=GradientAngularVelocity.createByConstant(angularVelocityData.constant *anglelToRad);
					}
					break ;
				case 1:
					if (angularVelocityData.separateAxes){
						angularVelocity=GradientAngularVelocity.createByGradientSeparate(this._initParticleRotation(angularVelocityData.gradientX),this._initParticleRotation(angularVelocityData.gradientY),this._initParticleRotation(angularVelocityData.gradientZ));
						}else {
						angularVelocity=GradientAngularVelocity.createByGradient(this._initParticleRotation(angularVelocityData.gradient));
					}
					break ;
				case 2:
					if (angularVelocityData.separateAxes){
						var minSep=angularVelocityData.constantMinSeparate;
						var maxSep=angularVelocityData.constantMaxSeparate;
						angularVelocity=GradientAngularVelocity.createByRandomTwoConstantSeparate(new Vector3(minSep[0] *anglelToRad,minSep[1] *anglelToRad,minSep[2] *anglelToRad),new Vector3(maxSep[0] *anglelToRad,maxSep[1] *anglelToRad,maxSep[2] *anglelToRad));
						}else {
						angularVelocity=GradientAngularVelocity.createByRandomTwoConstant(angularVelocityData.constantMin *anglelToRad,angularVelocityData.constantMax *anglelToRad);
					}
					break ;
				case 3:
					if (angularVelocityData.separateAxes){
						}else {
						angularVelocity=GradientAngularVelocity.createByRandomTwoGradient(this._initParticleRotation(angularVelocityData.gradientMin),this._initParticleRotation(angularVelocityData.gradientMax));
					}
					break ;
				};
			var rotationOverLifetime=new RotationOverLifetime(angularVelocity);
			rotationOverLifetime.enbale=rotationOverLifetimeData.enable;
			particleSystem.rotationOverLifetime=rotationOverLifetime;
		};
		var textureSheetAnimationData=data.textureSheetAnimation;
		if (textureSheetAnimationData){
			var frameData=textureSheetAnimationData.frame;
			var frameOverTime;
			switch (frameData.type){
				case 0:
					frameOverTime=FrameOverTime.createByConstant(frameData.constant);
					break ;
				case 1:
					frameOverTime=FrameOverTime.createByOverTime(this._initParticleFrame(frameData.overTime));
					break ;
				case 2:
					frameOverTime=FrameOverTime.createByRandomTwoConstant(frameData.constantMin,frameData.constantMax);
					break ;
				case 3:
					frameOverTime=FrameOverTime.createByRandomTwoOverTime(this._initParticleFrame(frameData.overTimeMin),this._initParticleFrame(frameData.overTimeMax));
					break ;
				};
			var startFrameData=textureSheetAnimationData.startFrame;
			var startFrame;
			switch (startFrameData.type){
				case 0:
					startFrame=StartFrame.createByConstant(startFrameData.constant);
					break ;
				case 1:
					startFrame=StartFrame.createByRandomTwoConstant(startFrameData.constantMin,startFrameData.constantMax);
					break ;
				};
			var textureSheetAnimation=new TextureSheetAnimation(frameOverTime,startFrame);
			textureSheetAnimation.enable=textureSheetAnimationData.enable;
			var tilesData=textureSheetAnimationData.tiles;
			textureSheetAnimation.tiles=new Vector2(tilesData[0],tilesData[1]);
			textureSheetAnimation.type=textureSheetAnimationData.type;
			textureSheetAnimation.randomRow=textureSheetAnimationData.randomRow;
			var rowIndex=textureSheetAnimationData.rowIndex;
			(rowIndex!==undefined)&& (textureSheetAnimation.rowIndex=rowIndex);
			textureSheetAnimation.cycles=textureSheetAnimationData.cycles;
			particleSystem.textureSheetAnimation=textureSheetAnimation;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._activeHierarchy=function(activeChangeComponents){
		laya.display.Node.prototype._activeHierarchy.call(this,activeChangeComponents);
		(this.particleSystem.playOnAwake)&& (this.particleSystem.play());
	}

	/**
	*@inheritDoc
	*/
	__proto._inActiveHierarchy=function(activeChangeComponents){
		laya.display.Node.prototype._inActiveHierarchy.call(this,activeChangeComponents);
		(this.particleSystem.isAlive)&& (this.particleSystem.simulate(0,true));
	}

	/**
	*@private
	*/
	__proto.cloneTo=function(destObject){
		var destShuriKenParticle3D=destObject;
		var destParticleSystem=destShuriKenParticle3D._particleSystem;
		this._particleSystem.cloneTo(destParticleSystem);
		var destParticleRender=destShuriKenParticle3D._render;
		var particleRender=this._render;
		destParticleRender.sharedMaterials=particleRender.sharedMaterials;
		destParticleRender.enable=particleRender.enable;
		destParticleRender.renderMode=particleRender.renderMode;
		destParticleRender.mesh=particleRender.mesh;
		destParticleRender.stretchedBillboardCameraSpeedScale=particleRender.stretchedBillboardCameraSpeedScale;
		destParticleRender.stretchedBillboardSpeedScale=particleRender.stretchedBillboardSpeedScale;
		destParticleRender.stretchedBillboardLengthScale=particleRender.stretchedBillboardLengthScale;
		destParticleRender.sortingFudge=particleRender.sortingFudge;
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
	}

	/**
	*<p>销毁此对象。</p>
	*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		this._particleSystem.destroy();
		this._particleSystem=null;
	}

	/**
	*获取粒子系统。
	*@return 粒子系统。
	*/
	__getset(0,__proto,'particleSystem',function(){
		return this._particleSystem;
	});

	/**
	*获取粒子渲染器。
	*@return 粒子渲染器。
	*/
	__getset(0,__proto,'particleRenderer',function(){
		return this._render;
	});

	ShuriKenParticle3D.__init__=function(){
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("SPHERHBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("STRETCHEDBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("HORIZONTALBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD=ShuriKenParticle3D.shaderDefines.registerDefine("VERTICALBILLBOARD");
		ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("COLOROVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("RANDOMCOLOROVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCURVE");
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONCURVE");
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONRANDOMCURVE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIME");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMESEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECONSTANT");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCONSTANTS");
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVE");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVESEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVES");
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE");
		ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH=ShuriKenParticle3D.shaderDefines.registerDefine("RENDERMODE_MESH");
		ShuriKenParticle3D.SHADERDEFINE_SHAPE=ShuriKenParticle3D.shaderDefines.registerDefine("SHAPE");
	}

	ShuriKenParticle3D._initStartLife=function(gradientData){
		var gradient=new GradientDataNumber();
		var startLifetimesData=gradientData.startLifetimes;
		for (var i=0,n=startLifetimesData.length;i < n;i++){
			var valueData=startLifetimesData[i];
			gradient.add(valueData.key,valueData.value);
		}
		return gradient
	}

	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD=0;
	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD=0;
	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD=0;
	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD=0;
	ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=0;
	ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=0;
	ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=0;
	ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=0;
	ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=0;
	ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=0;
	ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=0;
	ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=0;
	ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=0;
	ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=0;
	ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH=0;
	ShuriKenParticle3D.SHADERDEFINE_SHAPE=0;
	__static(ShuriKenParticle3D,
	['WORLDPOSITION',function(){return this.WORLDPOSITION=Shader3D.propertyNameToID("u_WorldPosition");},'WORLDROTATION',function(){return this.WORLDROTATION=Shader3D.propertyNameToID("u_WorldRotation");},'POSITIONSCALE',function(){return this.POSITIONSCALE=Shader3D.propertyNameToID("u_PositionScale");},'SIZESCALE',function(){return this.SIZESCALE=Shader3D.propertyNameToID("u_SizeScale");},'SCALINGMODE',function(){return this.SCALINGMODE=Shader3D.propertyNameToID("u_ScalingMode");},'GRAVITY',function(){return this.GRAVITY=Shader3D.propertyNameToID("u_Gravity");},'THREEDSTARTROTATION',function(){return this.THREEDSTARTROTATION=Shader3D.propertyNameToID("u_ThreeDStartRotation");},'STRETCHEDBILLBOARDLENGTHSCALE',function(){return this.STRETCHEDBILLBOARDLENGTHSCALE=Shader3D.propertyNameToID("u_StretchedBillboardLengthScale");},'STRETCHEDBILLBOARDSPEEDSCALE',function(){return this.STRETCHEDBILLBOARDSPEEDSCALE=Shader3D.propertyNameToID("u_StretchedBillboardSpeedScale");},'SIMULATIONSPACE',function(){return this.SIMULATIONSPACE=Shader3D.propertyNameToID("u_SimulationSpace");},'CURRENTTIME',function(){return this.CURRENTTIME=Shader3D.propertyNameToID("u_CurrentTime");},'VOLVELOCITYCONST',function(){return this.VOLVELOCITYCONST=Shader3D.propertyNameToID("u_VOLVelocityConst");},'VOLVELOCITYGRADIENTX',function(){return this.VOLVELOCITYGRADIENTX=Shader3D.propertyNameToID("u_VOLVelocityGradientX");},'VOLVELOCITYGRADIENTY',function(){return this.VOLVELOCITYGRADIENTY=Shader3D.propertyNameToID("u_VOLVelocityGradientY");},'VOLVELOCITYGRADIENTZ',function(){return this.VOLVELOCITYGRADIENTZ=Shader3D.propertyNameToID("u_VOLVelocityGradientZ");},'VOLVELOCITYCONSTMAX',function(){return this.VOLVELOCITYCONSTMAX=Shader3D.propertyNameToID("u_VOLVelocityConstMax");},'VOLVELOCITYGRADIENTXMAX',function(){return this.VOLVELOCITYGRADIENTXMAX=Shader3D.propertyNameToID("u_VOLVelocityGradientMaxX");},'VOLVELOCITYGRADIENTYMAX',function(){return this.VOLVELOCITYGRADIENTYMAX=Shader3D.propertyNameToID("u_VOLVelocityGradientMaxY");},'VOLVELOCITYGRADIENTZMAX',function(){return this.VOLVELOCITYGRADIENTZMAX=Shader3D.propertyNameToID("u_VOLVelocityGradientMaxZ");},'VOLSPACETYPE',function(){return this.VOLSPACETYPE=Shader3D.propertyNameToID("u_VOLSpaceType");},'COLOROVERLIFEGRADIENTALPHAS',function(){return this.COLOROVERLIFEGRADIENTALPHAS=Shader3D.propertyNameToID("u_ColorOverLifeGradientAlphas");},'COLOROVERLIFEGRADIENTCOLORS',function(){return this.COLOROVERLIFEGRADIENTCOLORS=Shader3D.propertyNameToID("u_ColorOverLifeGradientColors");},'MAXCOLOROVERLIFEGRADIENTALPHAS',function(){return this.MAXCOLOROVERLIFEGRADIENTALPHAS=Shader3D.propertyNameToID("u_MaxColorOverLifeGradientAlphas");},'MAXCOLOROVERLIFEGRADIENTCOLORS',function(){return this.MAXCOLOROVERLIFEGRADIENTCOLORS=Shader3D.propertyNameToID("u_MaxColorOverLifeGradientColors");},'SOLSIZEGRADIENT',function(){return this.SOLSIZEGRADIENT=Shader3D.propertyNameToID("u_SOLSizeGradient");},'SOLSIZEGRADIENTX',function(){return this.SOLSIZEGRADIENTX=Shader3D.propertyNameToID("u_SOLSizeGradientX");},'SOLSIZEGRADIENTY',function(){return this.SOLSIZEGRADIENTY=Shader3D.propertyNameToID("u_SOLSizeGradientY");},'SOLSizeGradientZ',function(){return this.SOLSizeGradientZ=Shader3D.propertyNameToID("u_SOLSizeGradientZ");},'SOLSizeGradientMax',function(){return this.SOLSizeGradientMax=Shader3D.propertyNameToID("u_SOLSizeGradientMax");},'SOLSIZEGRADIENTXMAX',function(){return this.SOLSIZEGRADIENTXMAX=Shader3D.propertyNameToID("u_SOLSizeGradientMaxX");},'SOLSIZEGRADIENTYMAX',function(){return this.SOLSIZEGRADIENTYMAX=Shader3D.propertyNameToID("u_SOLSizeGradientMaxY");},'SOLSizeGradientZMAX',function(){return this.SOLSizeGradientZMAX=Shader3D.propertyNameToID("u_SOLSizeGradientMaxZ");},'ROLANGULARVELOCITYCONST',function(){return this.ROLANGULARVELOCITYCONST=Shader3D.propertyNameToID("u_ROLAngularVelocityConst");},'ROLANGULARVELOCITYCONSTSEPRARATE',function(){return this.ROLANGULARVELOCITYCONSTSEPRARATE=Shader3D.propertyNameToID("u_ROLAngularVelocityConstSeprarate");},'ROLANGULARVELOCITYGRADIENT',function(){return this.ROLANGULARVELOCITYGRADIENT=Shader3D.propertyNameToID("u_ROLAngularVelocityGradient");},'ROLANGULARVELOCITYGRADIENTX',function(){return this.ROLANGULARVELOCITYGRADIENTX=Shader3D.propertyNameToID("u_ROLAngularVelocityGradientX");},'ROLANGULARVELOCITYGRADIENTY',function(){return this.ROLANGULARVELOCITYGRADIENTY=Shader3D.propertyNameToID("u_ROLAngularVelocityGradientY");},'ROLANGULARVELOCITYGRADIENTZ',function(){return this.ROLANGULARVELOCITYGRADIENTZ=Shader3D.propertyNameToID("u_ROLAngularVelocityGradientZ");},'ROLANGULARVELOCITYCONSTMAX',function(){return this.ROLANGULARVELOCITYCONSTMAX=Shader3D.propertyNameToID("u_ROLAngularVelocityConstMax");},'ROLANGULARVELOCITYCONSTMAXSEPRARATE',function(){return this.ROLANGULARVELOCITYCONSTMAXSEPRARATE=Shader3D.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate");},'ROLANGULARVELOCITYGRADIENTMAX',function(){return this.ROLANGULARVELOCITYGRADIENTMAX=Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMax");},'ROLANGULARVELOCITYGRADIENTXMAX',function(){return this.ROLANGULARVELOCITYGRADIENTXMAX=Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxX");},'ROLANGULARVELOCITYGRADIENTYMAX',function(){return this.ROLANGULARVELOCITYGRADIENTYMAX=Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxY");},'ROLANGULARVELOCITYGRADIENTZMAX',function(){return this.ROLANGULARVELOCITYGRADIENTZMAX=Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxZ");},'ROLANGULARVELOCITYGRADIENTWMAX',function(){return this.ROLANGULARVELOCITYGRADIENTWMAX=Shader3D.propertyNameToID("u_ROLAngularVelocityGradientMaxW");},'TEXTURESHEETANIMATIONCYCLES',function(){return this.TEXTURESHEETANIMATIONCYCLES=Shader3D.propertyNameToID("u_TSACycles");},'TEXTURESHEETANIMATIONSUBUVLENGTH',function(){return this.TEXTURESHEETANIMATIONSUBUVLENGTH=Shader3D.propertyNameToID("u_TSASubUVLength");},'TEXTURESHEETANIMATIONGRADIENTUVS',function(){return this.TEXTURESHEETANIMATIONGRADIENTUVS=Shader3D.propertyNameToID("u_TSAGradientUVs");},'TEXTURESHEETANIMATIONGRADIENTMAXUVS',function(){return this.TEXTURESHEETANIMATIONGRADIENTMAXUVS=Shader3D.propertyNameToID("u_TSAMaxGradientUVs");},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(RenderableSprite3D.shaderDefines);}
	]);
	return ShuriKenParticle3D;
})(RenderableSprite3D)


/**
*<code>MeshSprite3D</code> 类用于创建网格。
*/
//class laya.d3.core.MeshSprite3D extends laya.d3.core.RenderableSprite3D
var MeshSprite3D=(function(_super){
	function MeshSprite3D(mesh,name){
		/**@private */
		//this._meshFilter=null;
		MeshSprite3D.__super.call(this,name);
		this._meshFilter=new MeshFilter(this);
		this._render=new MeshRenderer(this);
		(mesh)&& (this._meshFilter.sharedMesh=mesh);
	}

	__class(MeshSprite3D,'laya.d3.core.MeshSprite3D',_super);
	var __proto=MeshSprite3D.prototype;
	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		laya.d3.core.Sprite3D.prototype._parse.call(this,data);
		var render=this.meshRenderer;
		var lightmapIndex=data.lightmapIndex;
		(lightmapIndex !=null)&& (render.lightmapIndex=lightmapIndex);
		var lightmapScaleOffsetArray=data.lightmapScaleOffset;
		(lightmapScaleOffsetArray)&& (render.lightmapScaleOffset=new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
		(data.meshPath!=undefined)&& (this.meshFilter.sharedMesh=Loader.getRes(data.meshPath));
		(data.enableRender!=undefined)&& (this.meshRenderer.enable=data.enableRender);
		var materials=data.materials;
		if (materials){
			var sharedMaterials=render.sharedMaterials;
			var materialCount=materials.length;
			sharedMaterials.length=materialCount;
			for (var i=0;i < materialCount;i++){
				sharedMaterials[i]=Loader.getRes(materials[i].path);
			}
			render.sharedMaterials=sharedMaterials;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._addToInitStaticBatchManager=function(){
		MeshRenderStaticBatchManager.instance._addBatchSprite(this);
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		var meshSprite3D=destObject;
		meshSprite3D._meshFilter.sharedMesh=this._meshFilter.sharedMesh;
		var meshRender=this._render;
		var destMeshRender=meshSprite3D._render;
		destMeshRender.enable=meshRender.enable;
		destMeshRender.sharedMaterials=meshRender.sharedMaterials;
		destMeshRender.castShadow=meshRender.castShadow;
		var lightmapScaleOffset=meshRender.lightmapScaleOffset;
		lightmapScaleOffset && (destMeshRender.lightmapScaleOffset=lightmapScaleOffset.clone());
		destMeshRender.lightmapIndex=meshRender.lightmapIndex;
		destMeshRender.receiveShadow=meshRender.receiveShadow;
		destMeshRender.sortingFudge=meshRender.sortingFudge;
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		this._meshFilter.destroy();
	}

	/**
	*获取网格过滤器。
	*@return 网格过滤器。
	*/
	__getset(0,__proto,'meshFilter',function(){
		return this._meshFilter;
	});

	/**
	*获取网格渲染器。
	*@return 网格渲染器。
	*/
	__getset(0,__proto,'meshRenderer',function(){
		return this._render;
	});

	MeshSprite3D.__init__=function(){
		MeshSprite3D.SHADERDEFINE_UV0=MeshSprite3D.shaderDefines.registerDefine("UV");
		MeshSprite3D.SHADERDEFINE_COLOR=MeshSprite3D.shaderDefines.registerDefine("COLOR");
		MeshSprite3D.SHADERDEFINE_UV1=MeshSprite3D.shaderDefines.registerDefine("UV1");
		StaticBatchManager._registerManager(MeshRenderStaticBatchManager.instance);
		DynamicBatchManager._registerManager(MeshRenderDynamicBatchManager.instance);
	}

	MeshSprite3D.SHADERDEFINE_UV0=0;
	MeshSprite3D.SHADERDEFINE_COLOR=0;
	MeshSprite3D.SHADERDEFINE_UV1=0;
	__static(MeshSprite3D,
	['shaderDefines',function(){return this.shaderDefines=new ShaderDefines(RenderableSprite3D.shaderDefines);}
	]);
	return MeshSprite3D;
})(RenderableSprite3D)


/**
*<code>DirectionLight</code> 类用于创建平行光。
*/
//class laya.d3.core.light.DirectionLight extends laya.d3.core.light.LightSprite
var DirectionLight=(function(_super){
	function DirectionLight(){
		/**@private */
		this._direction=null;
		DirectionLight.__super.call(this);
		this._direction=new Vector3();
	}

	__class(DirectionLight,'laya.d3.core.light.DirectionLight',_super);
	var __proto=DirectionLight.prototype;
	/**
	*@private
	*/
	__proto._initShadow=function(){
		if (this._shadow){
			this._parallelSplitShadowMap=new ParallelSplitShadowMap();
			this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap);
			this.transform.worldMatrix.getForward(this._direction);
			Vector3.normalize(this._direction,this._direction);
			this._parallelSplitShadowMap.setInfo(this.scene,this._shadowFarPlane,this._direction,this._shadowMapSize,this._shadowMapCount,this._shadowMapPCFType);
			}else {
			var defineDatas=(this._scene)._defineDatas;
			var parallelSplitShadowMaps=this.scene.parallelSplitShadowMaps;
			parallelSplitShadowMaps.splice(parallelSplitShadowMaps.indexOf(this._parallelSplitShadowMap),1);
			this._parallelSplitShadowMap.disposeAllRenderTarget();
			this._parallelSplitShadowMap=null;
			defineDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM1);
			defineDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM2);
			defineDatas.remove(Scene3D.SHADERDEFINE_SHADOW_PSSM3);
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._onActive=function(){
		_super.prototype._onActive.call(this);
		this._shadow && (this._initShadow());
		(this._lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&&((this._scene)._defineDatas.add(Scene3D.SHADERDEFINE_DIRECTIONLIGHT));
	}

	/**
	*@inheritDoc
	*/
	__proto._onInActive=function(){
		_super.prototype._onInActive.call(this);
		(this._lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&&((this._scene)._defineDatas.remove(Scene3D.SHADERDEFINE_DIRECTIONLIGHT));
	}

	/**
	*更新平行光相关渲染状态参数。
	*@param state 渲染状态参数。
	*/
	__proto._prepareToScene=function(){
		var scene=this._scene;
		if (scene.enableLight && this.activeInHierarchy){
			var defineDatas=scene._defineDatas;
			var shaderValue=scene._shaderValues;
			Vector3.scale(this.color,this._intensity,this._intensityColor);
			shaderValue.setVector(Scene3D.LIGHTDIRCOLOR,this._intensityColor);
			this.transform.worldMatrix.getForward(this._direction);
			Vector3.normalize(this._direction,this._direction);
			shaderValue.setVector(Scene3D.LIGHTDIRECTION,this._direction);
			return true;
			}else {
			return false;
		}
	}

	/**
	*@inheritDoc
	*/
	__getset(0,__proto,'shadow',_super.prototype._$get_shadow,function(value){
		if (this._shadow!==value){
			this._shadow=value;
			(this.scene)&& (this._initShadow());
		}
	});

	return DirectionLight;
})(LightSprite)


/**
*<code>SkinnedMeshSprite3D</code> 类用于创建网格。
*/
//class laya.d3.core.SkinnedMeshSprite3D extends laya.d3.core.RenderableSprite3D
var SkinnedMeshSprite3D=(function(_super){
	function SkinnedMeshSprite3D(mesh,name){
		/**@private */
		//this._meshFilter=null;
		SkinnedMeshSprite3D.__super.call(this,name);
		this._meshFilter=new MeshFilter(this);
		this._render=new SkinnedMeshRenderer(this);
		(mesh)&& (this._meshFilter.sharedMesh=mesh);
	}

	__class(SkinnedMeshSprite3D,'laya.d3.core.SkinnedMeshSprite3D',_super);
	var __proto=SkinnedMeshSprite3D.prototype;
	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		laya.d3.core.Sprite3D.prototype._parse.call(this,data);
		var render=this.skinnedMeshRenderer;
		var lightmapIndex=data.lightmapIndex;
		(lightmapIndex !=null)&& (render.lightmapIndex=lightmapIndex);
		var lightmapScaleOffsetArray=data.lightmapScaleOffset;
		(lightmapScaleOffsetArray)&& (render.lightmapScaleOffset=new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]));
		var meshPath;
		meshPath=data.meshPath;
		if (meshPath){
			var mesh=Loader.getRes(meshPath);
			(mesh)&&(this.meshFilter.sharedMesh=mesh);
		};
		var materials=data.materials;
		if (materials){
			var sharedMaterials=render.sharedMaterials;
			var materialCount=materials.length;
			sharedMaterials.length=materialCount;
			for (var i=0;i < materialCount;i++){
				sharedMaterials[i]=Loader.getRes(materials[i].path);
			}
			render.sharedMaterials=sharedMaterials;
		};
		var rootBone=data.rootBone;
		(rootBone)&& (render._setRootBone(rootBone));
		var boundBox=data.boundBox;
		var min=boundBox.min;
		var max=boundBox.max;
		var localBoundBox=new BoundBox(new Vector3(min[0],min[1],min[2]),new Vector3(max[0],max[1],max[2]));
		render.localBoundBox=localBoundBox;
		var boundSphere=data.boundSphere;
		if (boundSphere){
			var center=boundSphere.center;
			var localBoundSphere=new BoundSphere(new Vector3(center[0],center[1],center[2]),boundSphere.radius);
			render.localBoundSphere=localBoundSphere;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._changeHierarchyAnimator=function(animator){
		var lastAnimator=this._hierarchyAnimator;
		lastAnimator && (lastAnimator.unLinkSprite3DToAvatarNode(this));
		_super.prototype._changeHierarchyAnimator.call(this,animator);
		if (animator && this.skinnedMeshRenderer._rootBone)
			animator.linkSprite3DToAvatarNode(this.skinnedMeshRenderer._rootBone,this);
		this.skinnedMeshRenderer._setCacheAnimator(animator);
	}

	/**
	*@inheritDoc
	*/
	__proto._changeAnimatorAvatar=function(avatar){
		this.skinnedMeshRenderer._setCacheAvatar(avatar);
	}

	/**
	*@inheritDoc
	*/
	__proto.cloneTo=function(destObject){
		var meshSprite3D=destObject;
		meshSprite3D.meshFilter.sharedMesh=this.meshFilter.sharedMesh;
		var meshRender=this._render;
		var destMeshRender=meshSprite3D._render;
		destMeshRender.enable=meshRender.enable;
		destMeshRender.sharedMaterials=meshRender.sharedMaterials;
		destMeshRender.castShadow=meshRender.castShadow;
		var lightmapScaleOffset=meshRender.lightmapScaleOffset;
		lightmapScaleOffset && (destMeshRender.lightmapScaleOffset=lightmapScaleOffset.clone());
		destMeshRender.receiveShadow=meshRender.receiveShadow;
		destMeshRender.sortingFudge=meshRender.sortingFudge;
		destMeshRender._rootBone=meshRender._rootBone;
		var lbp=meshRender.localBoundSphere;
		(lbp)&& (destMeshRender.localBoundSphere=lbp.clone());
		var lbb=meshRender.localBoundBox;
		(lbb)&& (destMeshRender.localBoundBox=lbb.clone());
		laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		this._meshFilter.destroy();
	}

	/**
	*获取网格过滤器。
	*@return 网格过滤器。
	*/
	__getset(0,__proto,'meshFilter',function(){
		return this._meshFilter;
	});

	/**
	*获取网格渲染器。
	*@return 网格渲染器。
	*/
	__getset(0,__proto,'skinnedMeshRenderer',function(){
		return this._render;
	});

	SkinnedMeshSprite3D.__init__=function(){
		SkinnedMeshSprite3D.SHADERDEFINE_BONE=SkinnedMeshSprite3D.shaderDefines.registerDefine("BONE");
	}

	SkinnedMeshSprite3D.SHADERDEFINE_BONE=0;
	__static(SkinnedMeshSprite3D,
	['BONES',function(){return this.BONES=Shader3D.propertyNameToID("u_Bones");},'shaderDefines',function(){return this.shaderDefines=new ShaderDefines(MeshSprite3D.shaderDefines);}
	]);
	return SkinnedMeshSprite3D;
})(RenderableSprite3D)


/**
*<code>TerrainChunk</code> 类用于创建地块。
*/
//class laya.d3.terrain.TerrainChunk extends laya.d3.core.RenderableSprite3D
var TerrainChunk=(function(_super){
	function TerrainChunk(chunkOffsetX,chunkOffsetZ,girdSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse,name){
		/**@private */
		this._terrainFilter=null;
		TerrainChunk.__super.call(this,name);
		this._terrainFilter=new TerrainFilter(this,chunkOffsetX,chunkOffsetZ,girdSize,terrainHeightData,heightDataWidth,heightDataHeight,cameraCoordinateInverse);
		this._render=new TerrainRender(this);
	}

	__class(TerrainChunk,'laya.d3.terrain.TerrainChunk',_super);
	var __proto=TerrainChunk.prototype;
	__proto.buildRenderElementAndMaterial=function(detailNum,normalMap,alphaMapUrl,detailUrl1,detailUrl2,detailUrl3,detailUrl4,ambientColor,diffuseColor,specularColor,sx1,sy1,sx2,sy2,sx3,sy3,sx4,sy4){
		(sx1===void 0)&& (sx1=1);
		(sy1===void 0)&& (sy1=1);
		(sx2===void 0)&& (sx2=1);
		(sy2===void 0)&& (sy2=1);
		(sx3===void 0)&& (sx3=1);
		(sy3===void 0)&& (sy3=1);
		(sx4===void 0)&& (sx4=1);
		(sy4===void 0)&& (sy4=1);
		var terrainMaterial=new TerrainMaterial();
		if (diffuseColor)terrainMaterial.diffuseColor=diffuseColor;
		if (ambientColor)terrainMaterial.ambientColor=ambientColor;
		if (specularColor)terrainMaterial.specularColor=specularColor;
		terrainMaterial.splatAlphaTexture=Loader.getRes(alphaMapUrl);
		terrainMaterial.normalTexture=normalMap ? Loader.getRes(normalMap):null;
		terrainMaterial.diffuseTexture1=detailUrl1 ? Loader.getRes(detailUrl1):null;
		terrainMaterial.diffuseTexture2=detailUrl2 ? Loader.getRes(detailUrl2):null;
		terrainMaterial.diffuseTexture3=detailUrl3 ? Loader.getRes(detailUrl3):null;
		terrainMaterial.diffuseTexture4=detailUrl4 ? Loader.getRes(detailUrl4):null;
		terrainMaterial.setDiffuseScale1(sx1,sy1);
		terrainMaterial.setDiffuseScale2(sx2,sy2);
		terrainMaterial.setDiffuseScale3(sx3,sy3);
		terrainMaterial.setDiffuseScale4(sx4,sy4);
		terrainMaterial.setDetailNum(detailNum);
		if (this._render._renderElements.length !=0){
			terrainMaterial.renderMode=/*laya.d3.core.material.TerrainMaterial.RENDERMODE_TRANSPARENT*/2;
		};
		var renderElement=new RenderElement();
		renderElement.setTransform(this._transform);
		renderElement.render=this._render;
		renderElement.setGeometry(this._terrainFilter);
		this._render._renderElements.push(renderElement);
		this._render.sharedMaterial=terrainMaterial;
	}

	__proto.cloneTo=function(destObject){
		console.log("Terrain Chunk can't clone");
	}

	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		if (this.destroyed)
			return;
		_super.prototype.destroy.call(this,destroyChild);
		this._terrainFilter.destroy();
		this._terrainFilter=null;
	}

	/**
	*获取地形过滤器。
	*@return 地形过滤器。
	*/
	__getset(0,__proto,'terrainFilter',function(){
		return this._terrainFilter;
	});

	/**
	*获取地形渲染器。
	*@return 地形渲染器。
	*/
	__getset(0,__proto,'terrainRender',function(){
		return this._render;
	});

	return TerrainChunk;
})(RenderableSprite3D)


/**
*<code>SpotLight</code> 类用于创建聚光。
*/
//class laya.d3.core.light.SpotLight extends laya.d3.core.light.LightSprite
var SpotLight=(function(_super){
	function SpotLight(){
		/**@private */
		this._direction=null;
		/**@private */
		this._spotAngle=NaN;
		/**@private */
		this._range=NaN;
		SpotLight.__super.call(this);
		this._spotAngle=30.0;
		this._range=10.0;
		this._direction=new Vector3();
	}

	__class(SpotLight,'laya.d3.core.light.SpotLight',_super);
	var __proto=SpotLight.prototype;
	/**
	*@inheritDoc
	*/
	__proto._onActive=function(){
		_super.prototype._onActive.call(this);
		(this._lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&&((this.scene)._defineDatas.add(Scene3D.SHADERDEFINE_SPOTLIGHT));
	}

	/**
	*@inheritDoc
	*/
	__proto._onInActive=function(){
		_super.prototype._onInActive.call(this);
		(this._lightmapBakedType!==LightSprite.LIGHTMAPBAKEDTYPE_BAKED)&&((this.scene)._defineDatas.remove(Scene3D.SHADERDEFINE_SPOTLIGHT));
	}

	/**
	*更新聚光相关渲染状态参数。
	*@param state 渲染状态参数。
	*/
	__proto._prepareToScene=function(){
		var scene=this._scene;
		if (scene.enableLight && this.activeInHierarchy){
			var defineDatas=scene._defineDatas;
			var shaderValue=scene._shaderValues;
			Vector3.scale(this.color,this._intensity,this._intensityColor);
			shaderValue.setVector(Scene3D.SPOTLIGHTCOLOR,this._intensityColor);
			shaderValue.setVector(Scene3D.SPOTLIGHTPOS,this.transform.position);
			this.transform.worldMatrix.getForward(this._direction);
			Vector3.normalize(this._direction,this._direction);
			shaderValue.setVector(Scene3D.SPOTLIGHTDIRECTION,this._direction);
			shaderValue.setNumber(Scene3D.SPOTLIGHTRANGE,this.range);
			shaderValue.setNumber(Scene3D.SPOTLIGHTSPOTANGLE,this.spotAngle *Math.PI / 180);
			return true;
			}else {
			return false;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		_super.prototype._parse.call(this,data);
		this.range=data.range;
		this.spotAngle=data.spotAngle;
	}

	/**
	*设置聚光灯的锥形角度。
	*@param value 聚光灯的锥形角度。
	*/
	/**
	*获取聚光灯的锥形角度。
	*@return 聚光灯的锥形角度。
	*/
	__getset(0,__proto,'spotAngle',function(){
		return this._spotAngle;
		},function(value){
		this._spotAngle=Math.max(Math.min(value,180),0);
	});

	/**
	*设置聚光的范围。
	*@param value 聚光的范围值。
	*/
	/**
	*获取聚光的范围。
	*@return 聚光的范围值。
	*/
	__getset(0,__proto,'range',function(){
		return this._range;
		},function(value){
		this._range=value;
	});

	__static(SpotLight,
	['_tempMatrix0',function(){return this._tempMatrix0=new Matrix4x4();},'_tempMatrix1',function(){return this._tempMatrix1=new Matrix4x4();}
	]);
	return SpotLight;
})(LightSprite)


/**
*<code>PixelLineSprite3D</code> 类用于像素线渲染精灵。
*/
//class laya.d3.core.pixelLine.PixelLineSprite3D extends laya.d3.core.RenderableSprite3D
var PixelLineSprite3D=(function(_super){
	function PixelLineSprite3D(maxCount,name){
		/**@private */
		this._geometryFilter=null;
		(maxCount===void 0)&& (maxCount=2);
		PixelLineSprite3D.__super.call(this,name);
		this._geometryFilter=new PixelLineFilter(this,maxCount);
		this._render=new PixelLineRenderer(this);
		this._changeRenderObjects(this._render,0,PixelLineMaterial.defaultMaterial);
	}

	__class(PixelLineSprite3D,'laya.d3.core.pixelLine.PixelLineSprite3D',_super);
	var __proto=PixelLineSprite3D.prototype;
	/**
	*@inheritDoc
	*/
	__proto._changeRenderObjects=function(sender,index,material){
		var renderObjects=this._render._renderElements;
		(material)|| (material=PixelLineMaterial.defaultMaterial);
		var renderElement=renderObjects[index];
		(renderElement)|| (renderElement=renderObjects[index]=new RenderElement());
		renderElement.setTransform(this._transform);
		renderElement.setGeometry(this._geometryFilter);
		renderElement.render=this._render;
		renderElement.material=material;
	}

	/**
	*增加一条线。
	*@param startPosition 初始点位置
	*@param endPosition 结束点位置
	*@param startColor 初始点颜色
	*@param endColor 结束点颜色
	*/
	__proto.addLine=function(startPosition,endPosition,startColor,endColor){
		if (this._geometryFilter._lineCount!==this._geometryFilter._maxLineCount)
			this._geometryFilter._updateLineData(this._geometryFilter._lineCount++,startPosition,endPosition,startColor,endColor);
		else
		throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
	}

	/**
	*添加多条线段。
	*@param lines 线段数据
	*/
	__proto.addLines=function(lines){
		var lineCount=this._geometryFilter._lineCount;
		var addCount=lines.length;
		if (lineCount+addCount > this._geometryFilter._maxLineCount){
			throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
			}else {
			this._geometryFilter._updateLineDatas(lineCount,lines);
			this._geometryFilter._lineCount+=addCount;
		}
	}

	/**
	*移除一条线段。
	*@param index 索引。
	*/
	__proto.removeLine=function(index){
		if (index < this._geometryFilter._lineCount)
			this._geometryFilter._removeLineData(index);
		else
		throw "PixelLineSprite3D: index must less than lineCount.";
	}

	/**
	*更新线
	*@param index 索引
	*@param startPosition 初始点位置
	*@param endPosition 结束点位置
	*@param startColor 初始点颜色
	*@param endColor 结束点颜色
	*/
	__proto.setLine=function(index,startPosition,endPosition,startColor,endColor){
		if (index < this._geometryFilter._lineCount)
			this._geometryFilter._updateLineData(index,startPosition,endPosition,startColor,endColor);
		else
		throw "PixelLineSprite3D: index must less than lineCount.";
	}

	/**
	*获取线段数据
	*@param out 线段数据。
	*/
	__proto.getLine=function(index,out){
		if (index < this.lineCount)
			this._geometryFilter._getLineData(index,out);
		else
		throw "PixelLineSprite3D: index must less than lineCount.";
	}

	/**
	*清除所有线段。
	*/
	__proto.clear=function(){
		this._geometryFilter._lineCount=0;
	}

	/**
	*设置最大线数量
	*@param value 最大线数量。
	*/
	/**
	*获取最大线数量
	*@return 最大线数量。
	*/
	__getset(0,__proto,'maxLineCount',function(){
		return this._geometryFilter._maxLineCount;
		},function(value){
		this._geometryFilter._resizeLineData(value);
		this._geometryFilter._lineCount=Math.min(this._geometryFilter._lineCount,value);
	});

	/**
	*获取line渲染器。
	*@return line渲染器。
	*/
	__getset(0,__proto,'pixelLineRenderer',function(){
		return this._render;
	});

	/**
	*设置获取线数量。
	*@param value 线段数量。
	*/
	/**
	*获取线数量。
	*@return 线段数量。
	*/
	__getset(0,__proto,'lineCount',function(){
		return this._geometryFilter._lineCount;
		},function(value){
		if (value > this.maxLineCount)
			throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
		else
		this._geometryFilter._lineCount=value;
	});

	return PixelLineSprite3D;
})(RenderableSprite3D)


/**
*<code>Camera</code> 类用于创建摄像机。
*/
//class laya.d3.core.Camera extends laya.d3.core.BaseCamera
var Camera=(function(_super){
	function Camera(aspectRatio,nearPlane,farPlane){
		/**@private */
		//this._aspectRatio=NaN;
		/**@private */
		//this._viewport=null;
		/**@private */
		//this._normalizedViewport=null;
		/**@private */
		//this._viewMatrix=null;
		/**@private */
		//this._projectionMatrix=null;
		/**@private */
		//this._projectionViewMatrix=null;
		/**@private */
		//this._projectionViewMatrixNoTranslateScale=null;
		/**@private */
		//this._boundFrustum=null;
		/**@private */
		this._updateViewMatrix=true;
		/**@private [NATIVE]*/
		//this._boundFrustumBuffer=null;
		/**是否允许渲染。*/
		this.enableRender=true;
		(aspectRatio===void 0)&& (aspectRatio=0);
		(nearPlane===void 0)&& (nearPlane=0.3);
		(farPlane===void 0)&& (farPlane=1000);
		this._viewMatrix=new Matrix4x4();
		this._projectionMatrix=new Matrix4x4();
		this._projectionViewMatrix=new Matrix4x4();
		this._projectionViewMatrixNoTranslateScale=new Matrix4x4();
		this._viewport=new Viewport(0,0,0,0);
		this._normalizedViewport=new Viewport(0,0,1,1);
		this._aspectRatio=aspectRatio;
		this._boundFrustum=new BoundFrustum(Matrix4x4.DEFAULT);
		if (Render.isConchApp)
			this._boundFrustumBuffer=new Float32Array(24);
		Camera.__super.call(this,nearPlane,farPlane);
		this.transform.on(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this,this._onTransformChanged);
	}

	__class(Camera,'laya.d3.core.Camera',_super);
	var __proto=Camera.prototype;
	/**
	*@private
	*/
	__proto._onTransformChanged=function(flag){
		flag &=/*laya.d3.core.Transform3D.TRANSFORM_WORLDMATRIX*/0x40;
		(flag)&& (this._updateViewMatrix=true);
	}

	/**
	*@private
	*/
	__proto._calculationViewport=function(normalizedViewport,width,height){
		this._viewport.x=normalizedViewport.x *width;
		this._viewport.y=normalizedViewport.y *height;
		this._viewport.width=Math.min(Math.max(normalizedViewport.width *width,0),width);
		this._viewport.height=Math.min(Math.max(normalizedViewport.height *height,0),height);
	}

	/**
	*@inheritDoc
	*/
	__proto._parse=function(data){
		_super.prototype._parse.call(this,data);
		var viewport=data.viewport;
		this.normalizedViewport=new Viewport(viewport[0],viewport[1],viewport[2],viewport[3]);
	}

	/**
	*@inheritDoc
	*/
	__proto._calculateProjectionMatrix=function(){
		if (!this._useUserProjectionMatrix){
			if (this._orthographic){
				var halfWidth=this.orthographicVerticalSize *this.aspectRatio *0.5;
				var halfHeight=this.orthographicVerticalSize *0.5;
				Matrix4x4.createOrthoOffCenterRH(-halfWidth,halfWidth,-halfHeight,halfHeight,this.nearPlane,this.farPlane,this._projectionMatrix);
				}else {
				Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.aspectRatio,this.nearPlane,this.farPlane,this._projectionMatrix);
			}
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.render=function(shader,replacementTag){
		var gl=LayaGL.instance;
		var context=RenderContext3D._instance;
		var scene=context.scene=this._scene;
		if (!scene)
			return;
		if (scene.parallelSplitShadowMaps[0]){
			ShaderData.setRuntimeValueMode(false);
			var parallelSplitShadowMap=scene.parallelSplitShadowMaps[0];
			parallelSplitShadowMap._calcAllLightCameraInfo(this);
			scene._defineDatas.add(Scene3D.SHADERDEFINE_CAST_SHADOW);
			for (var i=0,n=parallelSplitShadowMap.shadowMapCount;i < n;i++){
				var smCamera=parallelSplitShadowMap.cameras[i];
				context.camera=smCamera;
				context.projectionViewMatrix=smCamera.projectionViewMatrix;
				FrustumCulling.renderObjectCulling(smCamera,scene,context,scene._castShadowRenders);
				var shadowMap=parallelSplitShadowMap.cameras[i+1].renderTarget;
				shadowMap.start();
				context.camera=smCamera;
				context.viewport=smCamera.viewport;
				smCamera._prepareCameraToRender();
				smCamera._prepareCameraViewProject(smCamera.viewMatrix,smCamera.projectionMatrix,smCamera._projectionViewMatrixNoTranslateScale);
				scene._clear(gl,context);
				var queue=scene._opaqueQueue;
				queue._render(context,false);
				shadowMap.end();
			}
			scene._defineDatas.remove(Scene3D.SHADERDEFINE_CAST_SHADOW);
			ShaderData.setRuntimeValueMode(true);
		}
		context.camera=this;
		scene._preRenderScript();
		var viewMat,projectMat;
		viewMat=context.viewMatrix=this.viewMatrix;
		var renderTar=this._renderTarget;
		if (renderTar){
			renderTar.start();
			Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this._projectionMatrix,BaseCamera._invertYProjectionMatrix);
			Matrix4x4.multiply(BaseCamera._invertYScaleMatrix,this.projectionViewMatrix,BaseCamera._invertYProjectionViewMatrix);
			projectMat=context.projectionMatrix=BaseCamera._invertYProjectionMatrix;
			context.projectionViewMatrix=BaseCamera._invertYProjectionViewMatrix;
			}else {
			projectMat=context.projectionMatrix=this._projectionMatrix;
			context.projectionViewMatrix=this.projectionViewMatrix;
		}
		context.viewport=this.viewport;
		this._prepareCameraToRender();
		this._prepareCameraViewProject(viewMat,projectMat,this._projectionViewMatrixNoTranslateScale);
		scene._preCulling(context,this);
		scene._clear(gl,context);
		scene._renderScene(gl,context,shader,replacementTag);
		scene._postRenderScript();
		(renderTar)&& (renderTar.end());
	}

	/**
	*计算从屏幕空间生成的射线。
	*@param point 屏幕空间的位置位置。
	*@return out 输出射线。
	*/
	__proto.viewportPointToRay=function(point,out){
		Picker.calculateCursorRay(point,this.viewport,this._projectionMatrix,this.viewMatrix,null,out);
	}

	/**
	*计算从裁切空间生成的射线。
	*@param point 裁切空间的位置。。
	*@return out 输出射线。
	*/
	__proto.normalizedViewportPointToRay=function(point,out){
		var finalPoint=Camera._tempVector20;
		var vp=this.viewport;
		var nVpPosE=point.elements;
		var vpPosE=finalPoint.elements;
		vpPosE[0]=nVpPosE[0] *vp.width;
		vpPosE[1]=nVpPosE[1] *vp.height;
		Picker.calculateCursorRay(finalPoint,this.viewport,this._projectionMatrix,this.viewMatrix,null,out);
	}

	/**
	*计算从世界空间准换三维坐标到屏幕空间。
	*@param position 世界空间的位置。
	*@return out 输出位置。
	*/
	__proto.worldToViewportPoint=function(position,out){
		Matrix4x4.multiply(this._projectionMatrix,this._viewMatrix,this._projectionViewMatrix);
		this.viewport.project(position,this._projectionViewMatrix,out);
		var outE=out.elements;
		outE[0]=outE[0] / Laya.stage.clientScaleX;
		outE[1]=outE[1] / Laya.stage.clientScaleY;
	}

	/**
	*计算从世界空间准换三维坐标到裁切空间。
	*@param position 世界空间的位置。
	*@return out 输出位置。
	*/
	__proto.worldToNormalizedViewportPoint=function(position,out){
		Matrix4x4.multiply(this._projectionMatrix,this._viewMatrix,this._projectionViewMatrix);
		this.normalizedViewport.project(position,this._projectionViewMatrix,out);
		var outE=out.elements;
		outE[0]=outE[0] / Laya.stage.clientScaleX;
		outE[1]=outE[1] / Laya.stage.clientScaleY;
	}

	/**
	*转换2D屏幕坐标系统到3D正交投影下的坐标系统，注:只有正交模型下有效。
	*@param source 源坐标。
	*@param out 输出坐标。
	*@return 是否转换成功。
	*/
	__proto.convertScreenCoordToOrthographicCoord=function(source,out){
		if (this._orthographic){
			var clientWidth=RenderContext3D.clientWidth;
			var clientHeight=RenderContext3D.clientHeight;
			var ratioX=this.orthographicVerticalSize *this.aspectRatio / clientWidth;
			var ratioY=this.orthographicVerticalSize / clientHeight;
			var sE=source.elements;
			var oE=out.elements;
			oE[0]=(-clientWidth / 2+sE[0])*ratioX;
			oE[1]=(clientHeight / 2-sE[1])*ratioY;
			oE[2]=(this.nearPlane-this.farPlane)*(sE[2]+1)/ 2-this.nearPlane;
			Vector3.transformCoordinate(out,this.transform.worldMatrix,out);
			return true;
			}else {
			return false;
		}
	}

	/**
	*@inheritDoc
	*/
	__proto.destroy=function(destroyChild){
		(destroyChild===void 0)&& (destroyChild=true);
		this.transform.off(/*laya.events.Event.TRANSFORM_CHANGED*/"transformchanged",this,this._onTransformChanged);
		_super.prototype.destroy.call(this,destroyChild);
	}

	/**
	*获取视图投影矩阵。
	*@return 视图投影矩阵。
	*/
	__getset(0,__proto,'projectionViewMatrix',function(){
		Matrix4x4.multiply(this.projectionMatrix,this.viewMatrix,this._projectionViewMatrix);
		return this._projectionViewMatrix;
	});

	/**
	*设置横纵比。
	*@param value 横纵比。
	*/
	/**
	*获取横纵比。
	*@return 横纵比。
	*/
	__getset(0,__proto,'aspectRatio',function(){
		if (this._aspectRatio===0){
			var vp=this.viewport;
			return vp.width / vp.height;
		}
		return this._aspectRatio;
		},function(value){
		if (value < 0)
			throw new Error("Camera: the aspect ratio has to be a positive real number.");
		this._aspectRatio=value;
		this._calculateProjectionMatrix();
	});

	/**
	*获取摄像机视锥。
	*/
	__getset(0,__proto,'boundFrustum',function(){
		this._boundFrustum.matrix=this.projectionViewMatrix;
		if (Render.isConchApp){
			var near=this._boundFrustum.near;
			var far=this._boundFrustum.far;
			var left=this._boundFrustum.left;
			var right=this._boundFrustum.right;
			var top=this._boundFrustum.top;
			var bottom=this._boundFrustum.bottom;
			var nearNE=near.normal.elements;
			var farNE=far.normal.elements;
			var leftNE=left.normal.elements;
			var rightNE=right.normal.elements;
			var topNE=top.normal.elements;
			var bottomNE=bottom.normal.elements;
			var buffer=this._boundFrustumBuffer;
			buffer[0]=nearNE[0],buffer[1]=nearNE[1],buffer[2]=nearNE[2],buffer[3]=near.distance;
			buffer[4]=farNE[0],buffer[5]=farNE[1],buffer[6]=farNE[2],buffer[7]=far.distance;
			buffer[8]=leftNE[0],buffer[9]=leftNE[1],buffer[10]=leftNE[2],buffer[11]=left.distance;
			buffer[12]=rightNE[0],buffer[13]=rightNE[1],buffer[14]=rightNE[2],buffer[15]=right.distance;
			buffer[16]=topNE[0],buffer[17]=topNE[1],buffer[18]=topNE[2],buffer[19]=top.distance;
			buffer[20]=bottomNE[0],buffer[21]=bottomNE[1],buffer[22]=bottomNE[2],buffer[23]=bottom.distance;
		}
		return this._boundFrustum;
	});

	/**
	*设置屏幕空间的视口。
	*@param 屏幕空间的视口。
	*/
	/**
	*获取屏幕空间的视口。
	*@return 屏幕空间的视口。
	*/
	__getset(0,__proto,'viewport',function(){
		var width=0;
		var height=0;
		if (this._renderTarget){
			width=this._renderTarget.width;
			height=this._renderTarget.height;
			}else {
			width=RenderContext3D.clientWidth;
			height=RenderContext3D.clientHeight;
		}
		if (width!==this._canvasWidth || height!==this._canvasHeight){
			this._calculationViewport(this._normalizedViewport,width,height);
			this._canvasWidth=width;
			this._canvasHeight=height;
		}
		return this._viewport;
		},function(value){
		var width=0;
		var height=0;
		if (this._renderTarget){
			width=this._canvasWidth=this._renderTarget.width;
			height=this._canvasHeight=this._renderTarget.height;
			}else {
			width=this._canvasWidth=RenderContext3D.clientWidth;
			height=this._canvasHeight=RenderContext3D.clientHeight;
		}
		this._normalizedViewport.x=value.x / width;
		this._normalizedViewport.y=value.y / height;
		this._normalizedViewport.width=value.width / width;
		this._normalizedViewport.height=value.height / height;
		this._calculationViewport(this._normalizedViewport,width,height);
		this._calculateProjectionMatrix();
	});

	/**
	*设置裁剪空间的视口。
	*@return 裁剪空间的视口。
	*/
	/**
	*获取裁剪空间的视口。
	*@return 裁剪空间的视口。
	*/
	__getset(0,__proto,'normalizedViewport',function(){
		return this._normalizedViewport;
		},function(value){
		var width=0;
		var height=0;
		if (this._renderTarget){
			width=this._canvasWidth=this._renderTarget.width;
			height=this._canvasHeight=this._renderTarget.height;
			}else {
			width=this._canvasWidth=RenderContext3D.clientWidth;
			height=this._canvasHeight=RenderContext3D.clientHeight;
		}
		this._normalizedViewport=value;
		this._calculationViewport(value,width,height);
		this._calculateProjectionMatrix();
	});

	/**设置投影矩阵。*/
	/**获取投影矩阵。*/
	__getset(0,__proto,'projectionMatrix',function(){
		return this._projectionMatrix;
		},function(value){
		this._projectionMatrix=value;
		this._useUserProjectionMatrix=true;
	});

	/**
	*获取视图矩阵。
	*@return 视图矩阵。
	*/
	__getset(0,__proto,'viewMatrix',function(){
		if (this._updateViewMatrix){
			var scale=this.transform.scale;
			var scaleX=scale.x;
			var scaleY=scale.y;
			var scaleZ=scale.z;
			var viewMatE=this._viewMatrix.elements;
			this.transform.worldMatrix.cloneTo(this._viewMatrix)
			viewMatE[0] /=scaleX;
			viewMatE[1] /=scaleX;
			viewMatE[2] /=scaleX;
			viewMatE[4] /=scaleY;
			viewMatE[5] /=scaleY;
			viewMatE[6] /=scaleY;
			viewMatE[8] /=scaleZ;
			viewMatE[9] /=scaleZ;
			viewMatE[10] /=scaleZ;
			this._viewMatrix.invert(this._viewMatrix);
			this._updateViewMatrix=false;
		}
		return this._viewMatrix;
	});

	__static(Camera,
	['_tempVector20',function(){return this._tempVector20=new Vector2();}
	]);
	return Camera;
})(BaseCamera)


/**
*<code>TerrainMeshSprite3D</code> 类用于创建网格。
*/
//class laya.d3.core.MeshTerrainSprite3D extends laya.d3.core.MeshSprite3D
var MeshTerrainSprite3D=(function(_super){
	function MeshTerrainSprite3D(mesh,heightMap,name){
		/**@private */
		this._minX=NaN;
		/**@private */
		this._minZ=NaN;
		/**@private */
		this._cellSize=null;
		/**@private */
		this._heightMap=null;
		MeshTerrainSprite3D.__super.call(this,mesh,name);
		this._heightMap=heightMap;
		this._cellSize=new Vector2();
	}

	__class(MeshTerrainSprite3D,'laya.d3.core.MeshTerrainSprite3D',_super);
	var __proto=MeshTerrainSprite3D.prototype;
	/**
	*@private
	*/
	__proto._disableRotation=function(){
		var rotation=this.transform.rotation;
		rotation.elements[0]=0;
		rotation.elements[1]=0;
		rotation.elements[2]=0;
		rotation.elements[3]=1;
		this.transform.rotation=rotation;
	}

	/**
	*@private
	*/
	__proto._getScaleX=function(){
		var worldMat=this.transform.worldMatrix;
		var worldMatE=worldMat.elements;
		var m11=worldMatE[0];
		var m12=worldMatE[1];
		var m13=worldMatE[2];
		return Math.sqrt((m11 *m11)+(m12 *m12)+(m13 *m13));
	}

	/**
	*@private
	*/
	__proto._getScaleZ=function(){
		var worldMat=this.transform.worldMatrix;
		var worldMatE=worldMat.elements;
		var m31=worldMatE[8];
		var m32=worldMatE[9];
		var m33=worldMatE[10];
		return Math.sqrt((m31 *m31)+(m32 *m32)+(m33 *m33));
	}

	/**
	*@private
	*/
	__proto._initCreateFromMesh=function(heightMapWidth,heightMapHeight){
		this._heightMap=HeightMap.creatFromMesh(this.meshFilter.sharedMesh,heightMapWidth,heightMapHeight,this._cellSize);
		var boundingBox=this.meshFilter.sharedMesh.boundingBox;
		var min=boundingBox.min;
		var max=boundingBox.max;
		this._minX=min.x;
		this._minZ=min.z;
	}

	/**
	*@private
	*/
	__proto._initCreateFromMeshHeightMap=function(texture,minHeight,maxHeight){
		var boundingBox=this.meshFilter.sharedMesh.boundingBox;
		this._heightMap=HeightMap.createFromImage(texture,minHeight,maxHeight);
		this._computeCellSize(boundingBox);
		var min=boundingBox.min;
		var max=boundingBox.max;
		this._minX=min.x;
		this._minZ=min.z;
	}

	/**
	*@private
	*/
	__proto._computeCellSize=function(boundingBox){
		var min=boundingBox.min;
		var max=boundingBox.max;
		var minX=min.x;
		var minZ=min.z;
		var maxX=max.x;
		var maxZ=max.z;
		var widthSize=maxX-minX;
		var heightSize=maxZ-minZ;
		this._cellSize.elements[0]=widthSize / (this._heightMap.width-1);
		this._cellSize.elements[1]=heightSize / (this._heightMap.height-1);
	}

	/**
	*@private
	*/
	__proto._update=function(state){
		this._disableRotation();
	}

	/**
	*获取地形高度。
	*@param x X轴坐标。
	*@param z Z轴坐标。
	*/
	__proto.getHeight=function(x,z){
		MeshTerrainSprite3D._tempVector3.elements[0]=x;
		MeshTerrainSprite3D._tempVector3.elements[1]=0;
		MeshTerrainSprite3D._tempVector3.elements[2]=z;
		this._disableRotation();
		var worldMat=this.transform.worldMatrix;
		worldMat.invert(MeshTerrainSprite3D._tempMatrix4x4);
		Vector3.transformCoordinate(MeshTerrainSprite3D._tempVector3,MeshTerrainSprite3D._tempMatrix4x4,MeshTerrainSprite3D._tempVector3);
		x=MeshTerrainSprite3D._tempVector3.elements[0];
		z=MeshTerrainSprite3D._tempVector3.elements[2];
		var c=(x-this._minX)/ this._cellSize.x;
		var d=(z-this._minZ)/ this._cellSize.y;
		var row=Math.floor(d);
		var col=Math.floor(c);
		var s=c-col;
		var t=d-row;
		var uy=NaN;
		var vy=NaN;
		var worldMatE=worldMat.elements;
		var m21=worldMatE[4];
		var m22=worldMatE[5];
		var m23=worldMatE[6];
		var scaleY=Math.sqrt((m21 *m21)+(m22 *m22)+(m23 *m23));
		var translateY=worldMatE[13];
		var h01=this._heightMap.getHeight(row,col+1);
		var h10=this._heightMap.getHeight((row+1),col);
		if (isNaN(h01)|| isNaN(h10))
			return NaN;
		if (s+t <=1.0){
			var h00=this._heightMap.getHeight(row,col);
			if (isNaN(h00))
				return NaN;
			uy=h01-h00;
			vy=h10-h00;
			return (h00+s *uy+t *vy)*scaleY+translateY;
			}else {
			var h11=this._heightMap.getHeight((row+1),col+1);
			if (isNaN(h11))
				return NaN;
			uy=h10-h11;
			vy=h01-h11;
			return (h11+(1.0-s)*uy+(1.0-t)*vy)*scaleY+translateY;
		}
	}

	/**
	*获取地形X轴最小位置。
	*@return 地形X轴最小位置。
	*/
	__getset(0,__proto,'minX',function(){
		var worldMat=this.transform.worldMatrix;
		var worldMatE=worldMat.elements;
		return this._minX *this._getScaleX()+worldMatE[12];
	});

	/**
	*获取地形X轴长度。
	*@return 地形X轴长度。
	*/
	__getset(0,__proto,'width',function(){
		return (this._heightMap.width-1)*this._cellSize.x *this._getScaleX();
	});

	/**
	*获取地形Z轴最小位置。
	*@return 地形X轴最小位置。
	*/
	__getset(0,__proto,'minZ',function(){
		var worldMat=this.transform.worldMatrix;
		var worldMatE=worldMat.elements;
		return this._minZ *this._getScaleZ()+worldMatE[14];
	});

	/**
	*获取地形Z轴长度。
	*@return 地形Z轴长度。
	*/
	__getset(0,__proto,'depth',function(){
		return (this._heightMap.height-1)*this._cellSize.y *this._getScaleZ();
	});

	MeshTerrainSprite3D.createFromMesh=function(mesh,heightMapWidth,heightMapHeight,name){
		var meshTerrainSprite3D=new MeshTerrainSprite3D(mesh,null,name);
		meshTerrainSprite3D._initCreateFromMesh(heightMapWidth,heightMapHeight);
		return meshTerrainSprite3D;
	}

	MeshTerrainSprite3D.createFromMeshAndHeightMap=function(mesh,texture,minHeight,maxHeight,name){
		var meshTerrainSprite3D=new MeshTerrainSprite3D(mesh,null,name);
		meshTerrainSprite3D._initCreateFromMeshHeightMap(texture,minHeight,maxHeight);
		return meshTerrainSprite3D;
	}

	__static(MeshTerrainSprite3D,
	['_tempVector3',function(){return this._tempVector3=new Vector3();},'_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();}
	]);
	return MeshTerrainSprite3D;
})(MeshSprite3D)



})(window,document,Laya);
