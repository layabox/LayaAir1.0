
(function(window,document,Laya){
	var __un=Laya.un,__uns=Laya.uns,__static=Laya.static,__class=Laya.class,__getset=Laya.getset,__newvec=Laya.__newvec;

	var AnimationContent=laya.ani.AnimationContent,AnimationPlayer=laya.ani.AnimationPlayer,AnimationState=laya.ani.AnimationState;
	var AnimationTemplet=laya.ani.AnimationTemplet,Arith=laya.maths.Arith,BaseShader=laya.webgl.shader.BaseShader;
	var Bitmap=laya.resource.Bitmap,Browser=laya.utils.Browser,Buffer=laya.webgl.utils.Buffer,Buffer2D=laya.webgl.utils.Buffer2D;
	var Byte=laya.utils.Byte,ClassUtils=laya.utils.ClassUtils,Config=Laya.Config,EmitterBase=laya.particle.emitter.EmitterBase;
	var Event=laya.events.Event,EventDispatcher=laya.events.EventDispatcher,FilterActionGL=laya.filters.webgl.FilterActionGL;
	var Handler=laya.utils.Handler,IndexBuffer2D=laya.webgl.utils.IndexBuffer2D,Loader=laya.net.Loader,LoaderManager=laya.net.LoaderManager;
	var MathUtil=laya.maths.MathUtil,Node=laya.display.Node,ParticleSetting=laya.particle.ParticleSetting,ParticleShader=laya.particle.shader.ParticleShader;
	var ParticleTemplateWebGL=laya.particle.ParticleTemplateWebGL,Rectangle=laya.maths.Rectangle,Render=laya.renders.Render;
	var RenderContext=laya.renders.RenderContext,RenderSprite=laya.renders.RenderSprite,RenderSprite3D=laya.webgl.utils.RenderSprite3D;
	var RenderState2D=laya.webgl.utils.RenderState2D,Resource=laya.resource.Resource,RunDriver=laya.utils.RunDriver;
	var Shader=laya.webgl.shader.Shader,ShaderCompile=laya.webgl.utils.ShaderCompile,ShaderValue=laya.webgl.shader.ShaderValue;
	var Sprite=laya.display.Sprite,Stat=laya.utils.Stat,StringKey=laya.utils.StringKey,URL=laya.net.URL,Utils=laya.utils.Utils;
	var VertexBuffer2D=laya.webgl.utils.VertexBuffer2D,WebGL=laya.webgl.WebGL,WebGLContext=laya.webgl.WebGLContext;
	var WebGLContext2D=laya.webgl.canvas.WebGLContext2D,WebGLImage=laya.webgl.resource.WebGLImage;
	Laya.interface('laya.d3.core.IClone');
	Laya.interface('laya.d3.graphics.IVertex');
	Laya.interface('laya.d3.core.render.IUpdate');
	Laya.interface('laya.d3.core.scene.ITreeNode');
	Laya.interface('laya.d3.core.render.IRenderable');
	/**
	*<code>SplineCurvePositionVelocity</code> 类用于通过顶点和速度创建闪光插值。
	*/
	//class laya.d3.core.glitter.SplineCurvePositionVelocity
	var SplineCurvePositionVelocity=(function(){
		function SplineCurvePositionVelocity(){
			this._tempVector30=new Vector3();
			this._tempVector31=new Vector3();
			this._tempVector32=new Vector3();
			this._a=new Vector3();
			this._b=new Vector3();
			this._c=new Vector3();
			this._d=new Vector3();
		}

		__class(SplineCurvePositionVelocity,'laya.d3.core.glitter.SplineCurvePositionVelocity');
		var __proto=SplineCurvePositionVelocity.prototype;
		/**
		*初始化插值所需信息。
		*@param position0 顶点0的位置。
		*@param velocity0 顶点0的速度。
		*@param position1 顶点1的位置。
		*@param velocity1 顶点1的速度。
		*/
		__proto.Init=function(position0,velocity0,position1,velocity1){
			position0.cloneTo(this._d);
			velocity0.cloneTo(this._c);
			Vector3.scale(position0,2.0,this._a);
			Vector3.scale(position1,2.0,this._tempVector30);
			Vector3.subtract(this._a,this._tempVector30,this._a);
			Vector3.add(this._a,velocity0,this._a);
			Vector3.add(this._a,velocity1,this._a);
			Vector3.scale(position1,3.0,this._b);
			Vector3.scale(position0,3.0,this._tempVector30);
			Vector3.subtract(this._b,this._tempVector30,this._b);
			Vector3.subtract(this._b,velocity1,this._b);
			Vector3.scale(velocity0,2.0,this._tempVector30);
			Vector3.subtract(this._b,this._tempVector30,this._b);
		}

		/**
		*初始化插值所需信息。
		*@param t 插值比例
		*@param out 输出结果
		*/
		__proto.Slerp=function(t,out){
			Vector3.scale(this._a,t *t *t,this._tempVector30);
			Vector3.scale(this._b,t *t,this._tempVector31);
			Vector3.scale(this._c,t,this._tempVector32);
			Vector3.add(this._tempVector30,this._tempVector31,out);
			Vector3.add(out,this._tempVector32,out);
			Vector3.add(out,this._d,out);
		}

		return SplineCurvePositionVelocity;
	})()


	/**
	*<code>HeightMap</code> 类用于实现高度图数据。
	*/
	//class laya.d3.core.HeightMap
	var HeightMap=(function(){
		function HeightMap(width,height,minHeight,maxHeight){
			this._datas=null;
			this._w=0;
			this._h=0;
			this._minHeight=NaN;
			this._maxHeight=NaN;
			this._datas=[];
			this._w=width;
			this._h=height;
			this._minHeight=minHeight;
			this._maxHeight=maxHeight;
		}

		__class(HeightMap,'laya.d3.core.HeightMap');
		var __proto=HeightMap.prototype;
		/**@private */
		__proto._inBounds=function(row,col){
			return row >=0 && row < this._h && col >=0 && col < this._w;
		}

		/**
		*获取高度。
		*@param row 列数。
		*@param col 行数。
		*@return 高度。
		*/
		__proto.getHeight=function(row,col){
			if (this._inBounds(row,col))
				return this._datas[row][col];
			else
			return NaN;
		}

		/**
		*获取宽度。
		*@return value 宽度。
		*/
		__getset(0,__proto,'width',function(){
			return this._w;
		});

		/**
		*获取高度。
		*@return value 高度。
		*/
		__getset(0,__proto,'height',function(){
			return this._h;
		});

		/**
		*最大高度。
		*@return value 最大高度。
		*/
		__getset(0,__proto,'maxHeight',function(){
			return this._maxHeight;
		});

		/**
		*最大高度。
		*@return value 最大高度。
		*/
		__getset(0,__proto,'minHeight',function(){
			return this._minHeight;
		});

		HeightMap.creatFromMesh=function(mesh,width,height,outCellSize){
			var vertices=[];
			var indexs=[];
			var submesheCount=mesh.getSubMeshCount();
			for (var i=0;i < submesheCount;i++){
				var subMesh=mesh.getSubMesh(i);
				var vertexBuffer=subMesh._getVertexBuffer();
				var verts=vertexBuffer.getData();
				var subMeshVertices=[];
				for (var j=0;j < verts.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
					var position=new Vector3(verts[j+0],verts[j+1],verts[j+2]);
					subMeshVertices.push(position);
				}
				vertices.push(subMeshVertices);
				var ib=subMesh._getIndexBuffer();
				indexs.push(ib.getData());
			};
			var boundingBox=mesh.boundingBox;
			var minX=boundingBox.min.x;
			var minZ=boundingBox.min.z;
			var maxX=boundingBox.max.x;
			var maxZ=boundingBox.max.z;
			var minY=boundingBox.min.y;
			var maxY=boundingBox.max.y;
			var widthSize=maxX-minX;
			var heightSize=maxZ-minZ;
			var cellWidth=outCellSize.elements[0]=widthSize / (width-1);
			var cellHeight=outCellSize.elements[1]=heightSize / (height-1);
			var heightMap=new HeightMap(width,height,minY,maxY);
			var ray=HeightMap._tempRay;
			var rayDirE=ray.direction.elements;
			rayDirE[0]=0;
			rayDirE[1]=-1;
			rayDirE[2]=0;
			var heightOffset=0.1;
			var rayY=maxY+heightOffset;
			ray.origin.elements[1]=rayY;
			for (var w=0;w < width;w++){
				var posZ=minZ+w *cellHeight;
				heightMap._datas[w]=[];
				for (var h=0;h < height;h++){
					var posX=minX+h *cellWidth;
					var rayOriE=ray.origin.elements;
					rayOriE[0]=posX;
					rayOriE[2]=posZ;
					var closestIntersection=HeightMap._getPosition(ray,vertices,indexs);
					heightMap._datas[w][h]=(closestIntersection===Number.MAX_VALUE)? NaN :rayY-closestIntersection;
				}
			}
			return heightMap;
		}

		HeightMap.createFromImage=function(texture,minHeight,maxHeight){
			var textureWidth=texture.width;
			var textureHeight=texture.height;
			var heightMap=new HeightMap(textureWidth,textureHeight,minHeight,maxHeight);
			var compressionRatio=(maxHeight-minHeight)/ 254;
			var pixelsInfo=texture.getPixels();
			var index=0;
			for (var w=0;w < textureWidth;w++){
				var colDatas=heightMap._datas[w]=[];
				for (var h=0;h < textureHeight;h++){
					var r=pixelsInfo[index++];
					var g=pixelsInfo[index++];
					var b=pixelsInfo[index++];
					var a=pixelsInfo[index++];
					if (r==255 && g==255 && b==255 && a==255)
						colDatas[h]=NaN;
					else {
						colDatas[h]=(r+g+b)/ 3 *compressionRatio+minHeight;
					}
				}
			}
			return heightMap;
		}

		HeightMap._getPosition=function(ray,vertices,indexs){
			var closestIntersection=Number.MAX_VALUE;
			for (var i=0;i < vertices.length;i++){
				var subMeshVertices=vertices[i];
				var subMeshIndexes=indexs[i];
				for (var j=0;j < subMeshIndexes.length;j+=3){
					var vertex1=subMeshVertices[subMeshIndexes[j+0]];
					var vertex2=subMeshVertices[subMeshIndexes[j+1]];
					var vertex3=subMeshVertices[subMeshIndexes[j+2]];
					var intersection=Picker.rayIntersectsTriangle(ray,vertex1,vertex2,vertex3);
					if (!isNaN(intersection)&& intersection < closestIntersection){
						closestIntersection=intersection;
					}
				}
			}
			return closestIntersection;
		}

		__static(HeightMap,
		['_tempRay',function(){return this._tempRay=new Ray(new Vector3(),new Vector3());}
		]);
		return HeightMap;
	})()


	/**
	*<code>Layer</code> 类用于实现遮罩层。
	*/
	//class laya.d3.core.Layer
	var Layer=(function(){
		function Layer(){
			this._id=0;
			this._number=0;
			this._mask=0;
			this._active=true;
			this._visible=true;
			this._colliders=null;
			this.name=null;
			if (Layer._uniqueIDCounter > 31)
				throw new Error("不允许创建Layer，请参考函数getLayerByNumber、getLayerByMask、getLayerByName！");
			this._id=Layer._uniqueIDCounter;
			Layer._uniqueIDCounter++;
			this._colliders=[];
		}

		__class(Layer,'laya.d3.core.Layer');
		var __proto=Layer.prototype;
		/**
		*获取编号。
		*@return 编号。
		*/
		__getset(0,__proto,'number',function(){
			return this._number;
		});

		/**
		*设置是否显示。
		*@param value 是否显示。
		*/
		/**
		*获取是否显示。
		*@return 是否显示。
		*/
		__getset(0,__proto,'visible',function(){
			return this._visible;
			},function(value){
			if (this._number===29 || this._number==30)
				return;
			this._visible=value;
			if (value)
				Layer._visibleLayers=Layer._visibleLayers | this.mask;
			else
			Layer._visibleLayers=Layer._visibleLayers & ~this.mask;
		});

		/**
		*获取蒙版值。
		*@return 蒙版值。
		*/
		__getset(0,__proto,'mask',function(){
			return this._mask;
		});

		/**
		*设置是否激活。
		*@param value 是否激活。
		*/
		/**
		*获取是否激活。
		*@return 是否激活。
		*/
		__getset(0,__proto,'active',function(){
			return this._active;
			},function(value){
			if (this._number===29 || this._number==30)
				return;
			this._active=value;
			if (value)
				Layer._activeLayers=Layer._activeLayers | this.mask;
			else
			Layer._activeLayers=Layer._activeLayers & ~this.mask;
		});

		/**
		*设置Layer激活层。
		*@param value 激活层。
		*/
		/**
		*获取Layer激活层。
		*@return 激活层。
		*/
		__getset(1,Layer,'activeLayers',function(){
			return Layer._activeLayers;
			},function(value){
			Layer._activeLayers=value | Layer.getLayerByNumber(29).mask | Layer.getLayerByNumber(30).mask;
			for (var i=0,n=Layer._layerList.length;i < n;i++){
				var layer=Layer._layerList[i];
				layer._active=(layer._mask & Layer._activeLayers)!==0;
			}
		});

		/**
		*设置Layer显示层。
		*@param value 显示层。
		*/
		/**
		*获取Layer显示层。
		*@return 显示层。
		*/
		__getset(1,Layer,'visibleLayers',function(){
			return Layer._visibleLayers;
			},function(value){
			Layer._visibleLayers=value | Layer.getLayerByNumber(29).mask | Layer.getLayerByNumber(30).mask;
			for (var i=0,n=Layer._layerList.length;i < n;i++){
				var layer=Layer._layerList[i];
				layer._visible=(layer._mask & Layer._visibleLayers)!==0;
			}
		});

		Layer.__init__=function(){
			Layer._layerList.length=31;
			for (var i=0;i < 31;i++){
				var layer=new Layer();
				Layer._layerList[i]=layer;
				if (i===0)
					layer.name="Default Layer";
				else if (i===29)
				layer.name="Reserved Layer0";
				else if (i===30)
				layer.name="Reserved Layer1";
				else
				layer.name="Layer-"+i;
				layer._number=i;
				layer._mask=Math.pow(2,i);
			}
			Layer._activeLayers=2147483647;
			Layer._visibleLayers=2147483647;
			Layer._currentCameraCullingMask=2147483647;
			Layer.currentCreationLayer=Layer._layerList[0];
		}

		Layer.getLayerByNumber=function(number){
			if (number < 0 || number > 30)
				throw new Error("无法返回指定Layer，该number超出范围！");
			return Layer._layerList[number];
		}

		Layer.getLayerByMask=function(mask){
			for (var i=0;i < 31;i++){
				if (Layer._layerList[i].mask===mask)
					return Layer._layerList[i];
			}
			throw new Error("无法返回指定Layer,该mask不存在");
		}

		Layer.getLayerByName=function(name){
			for (var i=0;i < 31;i++){
				if (Layer._layerList[i].name===name)
					return Layer._layerList[i];
			}
			throw new Error("无法返回指定Layer,该name不存在");
		}

		Layer.isActive=function(mask){
			return (mask & Layer._activeLayers)!=0;
		}

		Layer.isVisible=function(mask){
			return (mask & Layer._currentCameraCullingMask & Layer._visibleLayers)!=0;
		}

		Layer._uniqueIDCounter=1;
		Layer._layerCount=31;
		Layer._layerList=[];
		Layer._activeLayers=0;
		Layer._visibleLayers=0;
		Layer._currentCameraCullingMask=0;
		Layer.currentCreationLayer=null
		return Layer;
	})()


	/**
	*<code>Burst</code> 类用于粒子的爆裂描述。
	*/
	//class laya.d3.core.particleShuriKen.module.Burst
	var Burst=(function(){
		function Burst(time,minCount,maxCount){
			this._time=NaN;
			this._minCount=0;
			this._maxCount=0;
			this._time=time;
			this._minCount=minCount;
			this._maxCount=maxCount;
		}

		__class(Burst,'laya.d3.core.particleShuriKen.module.Burst');
		var __proto=Burst.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destBurst=destObject;
			destBurst._time=this._time
			destBurst._minCount=this._minCount;
			destBurst._maxCount=this._maxCount;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destBurst=/*__JS__ */new this.constructor();
			this.cloneTo(destBurst);
			return destBurst;
		}

		/**
		*获取爆裂时间,单位为秒。
		*@return 爆裂时间,单位为秒。
		*/
		__getset(0,__proto,'time',function(){
			return this._time;
		});

		/**
		*获取爆裂的最小数量。
		*@return 爆裂的最小数量。
		*/
		__getset(0,__proto,'minCount',function(){
			return this._minCount;
		});

		/**
		*获取爆裂的最大数量。
		*@return 爆裂的最大数量。
		*/
		__getset(0,__proto,'maxCount',function(){
			return this._maxCount;
		});

		return Burst;
	})()


	/**
	*<code>ColorOverLifetime</code> 类用于粒子的生命周期颜色。
	*/
	//class laya.d3.core.particleShuriKen.module.ColorOverLifetime
	var ColorOverLifetime=(function(){
		function ColorOverLifetime(color){
			this._color=null;
			this.enbale=false;
			this._color=color;
		}

		__class(ColorOverLifetime,'laya.d3.core.particleShuriKen.module.ColorOverLifetime');
		var __proto=ColorOverLifetime.prototype;
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destColorOverLifetime=destObject;
			this._color.cloneTo(destColorOverLifetime._color);
			destColorOverLifetime.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destColor;
			switch (this._color.type){
				case 0:
					destColor=GradientColor.createByConstant(this._color.constant.clone());
					break ;
				case 1:
					destColor=GradientColor.createByGradient(this._color.gradient.clone());
					break ;
				case 2:
					destColor=GradientColor.createByRandomTwoConstant(this._color.constantMin.clone(),this._color.constantMax.clone());
					break ;
				case 3:
					destColor=GradientColor.createByRandomTwoGradient(this._color.gradientMin.clone(),this._color.gradientMax.clone());
					break ;
				};
			var destColorOverLifetime=/*__JS__ */new this.constructor(destColor);
			destColorOverLifetime.enbale=this.enbale;
			return destColorOverLifetime;
		}

		/**
		*获取颜色。
		*/
		__getset(0,__proto,'color',function(){
			return this._color;
		});

		return ColorOverLifetime;
	})()


	/**
	*<code>Emission</code> 类用于粒子发射器。
	*/
	//class laya.d3.core.particleShuriKen.module.Emission
	var Emission=(function(){
		function Emission(){
			this._destroyed=false;
			this._emissionRate=0;
			this._minEmissionTime=NaN;
			this._particleSystem=null;
			this._shape=null;
			this._bursts=null;
			this.enbale=false;
			this._destroyed=false;
			this.emissionRate=10;
			this._bursts=[];
		}

		__class(Emission,'laya.d3.core.particleShuriKen.module.Emission');
		var __proto=Emission.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true,"laya.resource.IDestroy":true})
		/**
		*@private
		*/
		__proto._destroy=function(){
			this._bursts=null;
			this._particleSystem=null;
			this._destroyed=true;
		}

		/**
		*获取粒子爆裂个数。
		*@return 粒子爆裂个数。
		*/
		__proto.getBurstsCount=function(){
			return this._bursts.length;
		}

		/**
		*通过索引获取粒子爆裂。
		*@param index 爆裂索引。
		*@return 粒子爆裂。
		*/
		__proto.getBurstByIndex=function(index){
			return this._bursts[index];
		}

		/**
		*增加粒子爆裂。
		*@param burst 爆裂。
		*/
		__proto.addBurst=function(burst){
			var burstsCount=this._bursts.length;
			if (burstsCount > 0)
				for (var i=0;i < burstsCount;i++){
				if (this._bursts[i].time > burst.time)
					this._bursts.splice(i,0,burst);
			}
			else
			this._bursts.push(burst);
		}

		/**
		*移除粒子爆裂。
		*@param burst 爆裂。
		*/
		__proto.removeBurst=function(burst){
			var index=this._bursts.indexOf(burst);
			if (index!==-1){
				this._bursts.splice(index,1);
			}
		}

		/**
		*通过索引移除粒子爆裂。
		*@param index 爆裂索引。
		*/
		__proto.removeBurstByIndex=function(index){
			this._bursts.splice(index,1);
		}

		/**
		*清空粒子爆裂。
		*/
		__proto.clearBurst=function(){
			this._bursts.length=0;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destEmission=destObject;
			var destBursts=destEmission._bursts;
			destBursts.length=this._bursts.length;
			for (var i=0,n=this._bursts.length;i < n;i++){
				var destBurst=destBursts[i];
				if (destBurst)
					this._bursts[i].cloneTo(destBurst);
				else
				destBursts[i]=this._bursts[i].clone();
			}
			destEmission._minEmissionTime=this._minEmissionTime;
			destEmission._emissionRate=this._emissionRate;
			destEmission.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destEmission=/*__JS__ */new this.constructor();
			this.cloneTo(destEmission);
			return destEmission;
		}

		/**
		*获取是否已销毁。
		*@return 是否已销毁。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		/**
		*设置粒子发射速率。
		*@param emissionRate 粒子发射速率 (个/秒)。
		*/
		/**
		*获取粒子发射速率。
		*@return 粒子发射速率 (个/秒)。
		*/
		__getset(0,__proto,'emissionRate',function(){
			return this._emissionRate;
			},function(value){
			if (value < 0)
				throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
			this._emissionRate=value;
			if (value===0)
				this._minEmissionTime=2147483647;
			else
			this._minEmissionTime=1 / value;
		});

		return Emission;
	})()


	/**
	*<code>FrameOverTime</code> 类用于创建时间帧。
	*/
	//class laya.d3.core.particleShuriKen.module.FrameOverTime
	var FrameOverTime=(function(){
		function FrameOverTime(){
			this._type=0;
			this._constant=0;
			this._overTime=null;
			this._constantMin=0;
			this._constantMax=0;
			this._overTimeMin=null;
			this._overTimeMax=null;
		}

		__class(FrameOverTime,'laya.d3.core.particleShuriKen.module.FrameOverTime');
		var __proto=FrameOverTime.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destFrameOverTime=destObject;
			destFrameOverTime._type=this._type;
			destFrameOverTime._constant=this._constant;
			this._overTime.cloneTo(destFrameOverTime._overTime);
			destFrameOverTime._constantMin=this._constantMin;
			destFrameOverTime._constantMax=this._constantMax;
			this._overTimeMin.cloneTo(destFrameOverTime._overTimeMin);
			this._overTimeMax.cloneTo(destFrameOverTime._overTimeMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destFrameOverTime=/*__JS__ */new this.constructor();
			this.cloneTo(destFrameOverTime);
			return destFrameOverTime;
		}

		/**
		*时间帧。
		*/
		__getset(0,__proto,'frameOverTimeData',function(){
			return this._overTime;
		});

		/**
		*固定帧。
		*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*生命周期旋转类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*最小时间帧。
		*/
		__getset(0,__proto,'frameOverTimeDataMin',function(){
			return this._overTimeMin;
		});

		/**
		*最小固定帧。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*最大时间帧。
		*/
		__getset(0,__proto,'frameOverTimeDataMax',function(){
			return this._overTimeMax;
		});

		/**
		*最大固定帧。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		FrameOverTime.createByConstant=function(constant){
			var rotationOverLifetime=new FrameOverTime();
			rotationOverLifetime._type=0;
			rotationOverLifetime._constant=constant;
			return rotationOverLifetime;
		}

		FrameOverTime.createByOverTime=function(overTime){
			var rotationOverLifetime=new FrameOverTime();
			rotationOverLifetime._type=1;
			rotationOverLifetime._overTime=overTime;
			return rotationOverLifetime;
		}

		FrameOverTime.createByRandomTwoConstant=function(constantMin,constantMax){
			var rotationOverLifetime=new FrameOverTime();
			rotationOverLifetime._type=2;
			rotationOverLifetime._constantMin=constantMin;
			rotationOverLifetime._constantMax=constantMax;
			return rotationOverLifetime;
		}

		FrameOverTime.createByRandomTwoOverTime=function(gradientFrameMin,gradientFrameMax){
			var rotationOverLifetime=new FrameOverTime();
			rotationOverLifetime._type=3;
			rotationOverLifetime._overTimeMin=gradientFrameMin;
			rotationOverLifetime._overTimeMax=gradientFrameMax;
			return rotationOverLifetime;
		}

		return FrameOverTime;
	})()


	/**
	*<code>GradientRotation</code> 类用于创建渐变角速度。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientAngularVelocity
	var GradientAngularVelocity=(function(){
		function GradientAngularVelocity(){
			this._type=0;
			this._separateAxes=false;
			this._constant=NaN;
			this._constantSeparate=null;
			this._gradient=null;
			this._gradientX=null;
			this._gradientY=null;
			this._gradientZ=null;
			this._constantMin=NaN;
			this._constantMax=NaN;
			this._constantMinSeparate=null;
			this._constantMaxSeparate=null;
			this._gradientMin=null;
			this._gradientMax=null;
			this._gradientXMin=null;
			this._gradientXMax=null;
			this._gradientYMin=null;
			this._gradientYMax=null;
			this._gradientZMin=null;
			this._gradientZMax=null;
		}

		__class(GradientAngularVelocity,'laya.d3.core.particleShuriKen.module.GradientAngularVelocity');
		var __proto=GradientAngularVelocity.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientAngularVelocity=destObject;
			destGradientAngularVelocity._type=this._type;
			destGradientAngularVelocity._separateAxes=this._separateAxes;
			destGradientAngularVelocity._constant=this._constant;
			this._constantSeparate.cloneTo(destGradientAngularVelocity._constantSeparate);
			this._gradient.cloneTo(destGradientAngularVelocity._gradient);
			this._gradientX.cloneTo(destGradientAngularVelocity._gradientX);
			this._gradientY.cloneTo(destGradientAngularVelocity._gradientY);
			this._gradientZ.cloneTo(destGradientAngularVelocity._gradientZ);
			destGradientAngularVelocity._constantMin=this._constantMin;
			destGradientAngularVelocity._constantMax=this._constantMax;
			this._constantMinSeparate.cloneTo(destGradientAngularVelocity._constantMinSeparate);
			this._constantMaxSeparate.cloneTo(destGradientAngularVelocity._constantMaxSeparate);
			this._gradientMin.cloneTo(destGradientAngularVelocity._gradientMin);
			this._gradientMax.cloneTo(destGradientAngularVelocity._gradientMax);
			this._gradientXMin.cloneTo(destGradientAngularVelocity._gradientXMin);
			this._gradientXMax.cloneTo(destGradientAngularVelocity._gradientXMax);
			this._gradientYMin.cloneTo(destGradientAngularVelocity._gradientYMin);
			this._gradientYMax.cloneTo(destGradientAngularVelocity._gradientYMax);
			this._gradientZMin.cloneTo(destGradientAngularVelocity._gradientZMin);
			this._gradientZMax.cloneTo(destGradientAngularVelocity._gradientZMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientAngularVelocity=/*__JS__ */new this.constructor();
			this.cloneTo(destGradientAngularVelocity);
			return destGradientAngularVelocity;
		}

		/**
		*渐变角速度Z。
		*/
		__getset(0,__proto,'gradientZ',function(){
			return this._gradientZ;
		});

		/**
		*固定角速度。
		*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*渐变角速度。
		*/
		__getset(0,__proto,'gradient',function(){
			return this._gradient;
		});

		/**
		*是否分轴。
		*/
		__getset(0,__proto,'separateAxes',function(){
			return this._separateAxes;
		});

		/**
		*生命周期角速度类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*分轴固定角速度。
		*/
		__getset(0,__proto,'constantSeparate',function(){
			return this._constantSeparate;
		});

		/**
		*最小渐变角速度。
		*/
		__getset(0,__proto,'gradientMin',function(){
			return this._gradientMin;
		});

		/**
		*最小随机双固定角速度。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*渐变角角速度X。
		*/
		__getset(0,__proto,'gradientX',function(){
			return this._gradientX;
		});

		/**
		*渐变角速度Y。
		*/
		__getset(0,__proto,'gradientY',function(){
			return this._gradientY;
		});

		/**
		*最大渐变角速度。
		*/
		__getset(0,__proto,'gradientMax',function(){
			return this._gradientMax;
		});

		/**
		*最大随机双固定角速度。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		/**
		*最小分轴随机双固定角速度。
		*/
		__getset(0,__proto,'constantMinSeparate',function(){
			return this._constantMinSeparate;
		});

		/**
		*最大分轴随机双固定角速度。
		*/
		__getset(0,__proto,'constantMaxSeparate',function(){
			return this._constantMaxSeparate;
		});

		/**
		*最小渐变角速度X。
		*/
		__getset(0,__proto,'gradientXMin',function(){
			return this._gradientXMin;
		});

		/**
		*最大渐变角速度X。
		*/
		__getset(0,__proto,'gradientXMax',function(){
			return this._gradientXMax;
		});

		/**
		*最小渐变角速度Y。
		*/
		__getset(0,__proto,'gradientYMin',function(){
			return this._gradientYMin;
		});

		/**
		*最大渐变角速度Y。
		*/
		__getset(0,__proto,'gradientYMax',function(){
			return this._gradientYMax;
		});

		/**
		*最小渐变角速度Z。
		*/
		__getset(0,__proto,'gradientZMin',function(){
			return this._gradientZMin;
		});

		/**
		*最大渐变角速度Z。
		*/
		__getset(0,__proto,'gradientZMax',function(){
			return this._gradientZMax;
		});

		GradientAngularVelocity.createByConstant=function(constant){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=0;
			gradientAngularVelocity._separateAxes=false;
			gradientAngularVelocity._constant=constant;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByConstantSeparate=function(separateConstant){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=0;
			gradientAngularVelocity._separateAxes=true;
			gradientAngularVelocity._constantSeparate=separateConstant;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByGradient=function(gradient){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=1;
			gradientAngularVelocity._separateAxes=false;
			gradientAngularVelocity._gradient=gradient;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByGradientSeparate=function(gradientX,gradientY,gradientZ){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=1;
			gradientAngularVelocity._separateAxes=true;
			gradientAngularVelocity._gradientX=gradientX;
			gradientAngularVelocity._gradientY=gradientY;
			gradientAngularVelocity._gradientZ=gradientZ;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByRandomTwoConstant=function(constantMin,constantMax){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=2;
			gradientAngularVelocity._separateAxes=false;
			gradientAngularVelocity._constantMin=constantMin;
			gradientAngularVelocity._constantMax=constantMax;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByRandomTwoConstantSeparate=function(separateConstantMin,separateConstantMax){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=2;
			gradientAngularVelocity._separateAxes=true;
			gradientAngularVelocity._constantMinSeparate=separateConstantMin;
			gradientAngularVelocity._constantMaxSeparate=separateConstantMax;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByRandomTwoGradient=function(gradientMin,gradientMax){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=3;
			gradientAngularVelocity._separateAxes=false;
			gradientAngularVelocity._gradientMin=gradientMin;
			gradientAngularVelocity._gradientMax=gradientMax;
			return gradientAngularVelocity;
		}

		GradientAngularVelocity.createByRandomTwoGradientSeparate=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
			var gradientAngularVelocity=new GradientAngularVelocity();
			gradientAngularVelocity._type=3;
			gradientAngularVelocity._separateAxes=true;
			gradientAngularVelocity._gradientXMin=gradientXMin;
			gradientAngularVelocity._gradientXMax=gradientXMax;
			gradientAngularVelocity._gradientYMin=gradientYMin;
			gradientAngularVelocity._gradientYMax=gradientYMax;
			gradientAngularVelocity._gradientZMin=gradientZMin;
			gradientAngularVelocity._gradientZMax=gradientZMax;
			return gradientAngularVelocity;
		}

		return GradientAngularVelocity;
	})()


	/**
	*<code>GradientColor</code> 类用于创建渐变颜色。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientColor
	var GradientColor=(function(){
		function GradientColor(){
			this._type=0;
			this._constant=null;
			this._constantMin=null;
			this._constantMax=null;
			this._gradient=null;
			this._gradientMin=null;
			this._gradientMax=null;
		}

		__class(GradientColor,'laya.d3.core.particleShuriKen.module.GradientColor');
		var __proto=GradientColor.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientColor=destObject;
			destGradientColor._type=this._type;
			this._constant.cloneTo(destGradientColor._constant);
			this._constantMin.cloneTo(destGradientColor._constantMin);
			this._constantMax.cloneTo(destGradientColor._constantMax);
			this._gradient.cloneTo(destGradientColor._gradient);
			this._gradientMin.cloneTo(destGradientColor._gradientMin);
			this._gradientMax.cloneTo(destGradientColor._gradientMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientColor=/*__JS__ */new this.constructor();
			this.cloneTo(destGradientColor);
			return destGradientColor;
		}

		/**
		*渐变颜色。
		*/
		__getset(0,__proto,'gradient',function(){
			return this._gradient;
		});

		/**
		*固定颜色。
		*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*生命周期颜色类型,0为固定颜色模式,1渐变模式,2为随机双固定颜色模式,3随机双渐变模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*最小渐变颜色。
		*/
		__getset(0,__proto,'gradientMin',function(){
			return this._gradientMin;
		});

		/**
		*最小固定颜色。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*最大渐变颜色。
		*/
		__getset(0,__proto,'gradientMax',function(){
			return this._gradientMax;
		});

		/**
		*最大固定颜色。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		GradientColor.createByConstant=function(constant){
			var gradientColor=new GradientColor();
			gradientColor._type=0;
			gradientColor._constant=constant;
			return gradientColor;
		}

		GradientColor.createByGradient=function(gradient){
			var gradientColor=new GradientColor();
			gradientColor._type=1;
			gradientColor._gradient=gradient;
			return gradientColor;
		}

		GradientColor.createByRandomTwoConstant=function(minConstant,maxConstant){
			var gradientColor=new GradientColor();
			gradientColor._type=2;
			gradientColor._constantMin=minConstant;
			gradientColor._constantMax=maxConstant;
			return gradientColor;
		}

		GradientColor.createByRandomTwoGradient=function(minGradient,maxGradient){
			var gradientColor=new GradientColor();
			gradientColor._type=3;
			gradientColor._gradientMin=minGradient;
			gradientColor._gradientMax=maxGradient;
			return gradientColor;
		}

		return GradientColor;
	})()


	/**
	*<code>GradientDataColor</code> 类用于创建颜色渐变。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientDataColor
	var GradientDataColor=(function(){
		function GradientDataColor(){
			this._alphaCurrentLength=0;
			this._rgbCurrentLength=0;
			this._alphaElements=null;
			this._rgbElements=null;
			this._alphaElements=new Float32Array(8);
			this._rgbElements=new Float32Array(16);
		}

		__class(GradientDataColor,'laya.d3.core.particleShuriKen.module.GradientDataColor');
		var __proto=GradientDataColor.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*增加Alpha渐变。
		*@param key 生命周期，范围为0到1。
		*@param value rgb值。
		*/
		__proto.addAlpha=function(key,value){
			if (this._alphaCurrentLength < 8){
				if ((this._alphaCurrentLength===6)&& ((key!==1))){
					key=1;
					console.log("GradientDataColor warning:the forth key is  be force set to 1.");
				}
				this._alphaElements[this._alphaCurrentLength++]=key;
				this._alphaElements[this._alphaCurrentLength++]=value;
				}else {
				console.log("GradientDataColor warning:data count must lessEqual than 4");
			}
		}

		/**
		*增加RGB渐变。
		*@param key 生命周期，范围为0到1。
		*@param value RGB值。
		*/
		__proto.addRGB=function(key,value){
			if (this._rgbCurrentLength < 16){
				if ((this._rgbCurrentLength===12)&& ((key!==1))){
					key=1;
					console.log("GradientDataColor warning:the forth key is  be force set to 1.");
				}
				this._rgbElements[this._rgbCurrentLength++]=key;
				this._rgbElements[this._rgbCurrentLength++]=value.x;
				this._rgbElements[this._rgbCurrentLength++]=value.y;
				this._rgbElements[this._rgbCurrentLength++]=value.z;
				}else {
				console.log("GradientDataColor warning:data count must lessEqual than 4");
			}
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientDataColor=destObject;
			var i=0,n=0;
			destGradientDataColor._alphaCurrentLength=this._alphaCurrentLength;
			var destAlphaElements=destGradientDataColor._alphaElements;
			destAlphaElements.length=this._alphaElements.length;
			for (i=0,n=this._alphaElements.length;i < n;i++)
			destAlphaElements[i]=this._alphaElements[i];
			destGradientDataColor._rgbCurrentLength=this._rgbCurrentLength;
			var destRGBElements=destGradientDataColor._rgbElements;
			destRGBElements.length=this._rgbElements.length;
			for (i=0,n=this._rgbElements.length;i < n;i++)
			destRGBElements[i]=this._rgbElements[i];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientDataColor=/*__JS__ */new this.constructor();
			this.cloneTo(destGradientDataColor);
			return destGradientDataColor;
		}

		/**渐变Alpha数量。*/
		__getset(0,__proto,'alphaGradientCount',function(){
			return this._alphaCurrentLength / 2;
		});

		/**渐变RGB数量。*/
		__getset(0,__proto,'rgbGradientCount',function(){
			return this._rgbCurrentLength / 4;
		});

		return GradientDataColor;
	})()


	/**
	*<code>GradientDataInt</code> 类用于创建整形渐变。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientDataInt
	var GradientDataInt=(function(){
		function GradientDataInt(){
			this._currentLength=0;
			this._elements=null;
			this._elements=new Float32Array(8);
		}

		__class(GradientDataInt,'laya.d3.core.particleShuriKen.module.GradientDataInt');
		var __proto=GradientDataInt.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*增加整形渐变。
		*@param key 生命周期，范围为0到1。
		*@param value 整形值。
		*/
		__proto.add=function(key,value){
			if (this._currentLength < 8){
				if ((this._currentLength===6)&& ((key!==1))){
					key=1;
					console.log("Warning:the forth key is  be force set to 1.");
				}
				this._elements[this._currentLength++]=key;
				this._elements[this._currentLength++]=value;
				}else {
				console.log("Warning:data count must lessEqual than 4");
			}
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientDataInt=destObject;
			destGradientDataInt._currentLength=this._currentLength;
			var destElements=destGradientDataInt._elements;
			destElements.length=this._elements.length;
			for (var i=0,n=this._elements.length;i < n;i++){
				destElements[i]=this._elements[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientDataInt=/*__JS__ */new this.constructor();
			this.cloneTo(destGradientDataInt);
			return destGradientDataInt;
		}

		/**整形渐变数量。*/
		__getset(0,__proto,'gradientCount',function(){
			return this._currentLength / 2;
		});

		return GradientDataInt;
	})()


	/**
	*<code>GradientDataNumber</code> 类用于创建浮点渐变。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientDataNumber
	var GradientDataNumber=(function(){
		function GradientDataNumber(){
			this._currentLength=0;
			this._elements=null;
			this._elements=new Float32Array(8);
		}

		__class(GradientDataNumber,'laya.d3.core.particleShuriKen.module.GradientDataNumber');
		var __proto=GradientDataNumber.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*增加浮点渐变。
		*@param key 生命周期，范围为0到1。
		*@param value 浮点值。
		*/
		__proto.add=function(key,value){
			if (this._currentLength < 8){
				if ((this._currentLength===6)&& ((key!==1))){
					key=1;
					console.log("GradientDataNumber warning:the forth key is  be force set to 1.");
				}
				this._elements[this._currentLength++]=key;
				this._elements[this._currentLength++]=value;
				}else {
				console.log("GradientDataNumber warning:data count must lessEqual than 4");
			}
		}

		/**
		*通过索引获取键。
		*@param index 索引。
		*@return value 键。
		*/
		__proto.getKeyByIndex=function(index){
			return this._elements[index *2];
		}

		/**
		*通过索引获取值。
		*@param index 索引。
		*@return value 值。
		*/
		__proto.getValueByIndex=function(index){
			return this._elements[index *2+1];
		}

		/**
		*获取平均值。
		*/
		__proto.getAverageValue=function(){
			var total=0;
			for (var i=0,n=this._currentLength-2;i < n;i+=2){
				var subValue=this._elements[i+1];
				subValue+=this._elements[i+3];
				subValue=subValue *(this._elements[i+2]-this._elements[i]);
			}
			return total / 2;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientDataNumber=destObject;
			destGradientDataNumber._currentLength=this._currentLength;
			var destElements=destGradientDataNumber._elements;
			destElements.length=this._elements.length;
			for (var i=0,n=this._elements.length;i < n;i++)
			destElements[i]=this._elements[i];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientDataNumber=/*__JS__ */new this.constructor();
			this.cloneTo(destGradientDataNumber);
			return destGradientDataNumber;
		}

		/**渐变浮点数量。*/
		__getset(0,__proto,'gradientCount',function(){
			return this._currentLength / 2;
		});

		return GradientDataNumber;
	})()


	/**
	*<code>GradientDataVector2</code> 类用于创建二维向量渐变。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientDataVector2
	var GradientDataVector2=(function(){
		function GradientDataVector2(){
			this._currentLength=0;
			this._elements=null;
			this._elements=new Float32Array(12);
		}

		__class(GradientDataVector2,'laya.d3.core.particleShuriKen.module.GradientDataVector2');
		var __proto=GradientDataVector2.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*增加二维向量渐变。
		*@param key 生命周期，范围为0到1。
		*@param value 二维向量值。
		*/
		__proto.add=function(key,value){
			if (this._currentLength < 8){
				if ((this._currentLength===6)&& ((key!==1))){
					key=1;
					console.log("GradientDataVector2 warning:the forth key is  be force set to 1.");
				}
				this._elements[this._currentLength++]=key;
				this._elements[this._currentLength++]=value.x;
				this._elements[this._currentLength++]=value.y;
				}else {
				console.log("GradientDataVector2 warning:data count must lessEqual than 4");
			}
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientDataVector2=destObject;
			destGradientDataVector2._currentLength=this._currentLength;
			var destElements=destGradientDataVector2._elements;
			destElements.length=this._elements.length;
			for (var i=0,n=this._elements.length;i < n;i++){
				destElements[i]=this._elements[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientDataVector2=/*__JS__ */new this.constructor();
			this.cloneTo(destGradientDataVector2);
			return destGradientDataVector2;
		}

		/**二维向量渐变数量。*/
		__getset(0,__proto,'gradientCount',function(){
			return this._currentLength / 3;
		});

		return GradientDataVector2;
	})()


	/**
	*<code>GradientSize</code> 类用于创建渐变尺寸。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientSize
	var GradientSize=(function(){
		function GradientSize(){
			this._type=0;
			this._separateAxes=false;
			this._gradient=null;
			this._gradientX=null;
			this._gradientY=null;
			this._gradientZ=null;
			this._constantMin=NaN;
			this._constantMax=NaN;
			this._constantMinSeparate=null;
			this._constantMaxSeparate=null;
			this._gradientMin=null;
			this._gradientMax=null;
			this._gradientXMin=null;
			this._gradientXMax=null;
			this._gradientYMin=null;
			this._gradientYMax=null;
			this._gradientZMin=null;
			this._gradientZMax=null;
		}

		__class(GradientSize,'laya.d3.core.particleShuriKen.module.GradientSize');
		var __proto=GradientSize.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*获取最大尺寸。
		*/
		__proto.getMaxSizeInGradient=function(){
			var i=0,n=0;
			var maxSize=-Number.MAX_VALUE;
			switch (this._type){
				case 0:
					if (this._separateAxes){
						for (i=0,n=this._gradientX.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientX.getValueByIndex(i));
						for (i=0,n=this._gradientY.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientY.getValueByIndex(i));
						}else {
						for (i=0,n=this._gradient.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradient.getValueByIndex(i));
					}
					break ;
				case 1:
					if (this._separateAxes){
						maxSize=Math.max(this._constantMinSeparate.x,this._constantMaxSeparate.x);
						maxSize=Math.max(maxSize,this._constantMinSeparate.y);
						maxSize=Math.max(maxSize,this._constantMaxSeparate.y);
						}else {
						maxSize=Math.max(this._constantMin,this._constantMax);
					}
					break ;
				case 2:
					if (this._separateAxes){
						for (i=0,n=this._gradientXMin.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientXMin.getValueByIndex(i));
						for (i=0,n=this._gradientXMax.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientXMax.getValueByIndex(i));
						for (i=0,n=this._gradientYMin.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientYMin.getValueByIndex(i));
						for (i=0,n=this._gradientZMax.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientZMax.getValueByIndex(i));
						}else {
						for (i=0,n=this._gradientMin.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientMin.getValueByIndex(i));
						for (i=0,n=this._gradientMax.gradientCount;i < n;i++)
						maxSize=Math.max(maxSize,this._gradientMax.getValueByIndex(i));
					}
					break ;
				}
			return maxSize;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientSize=destObject;
			destGradientSize._type=this._type;
			destGradientSize._separateAxes=this._separateAxes;
			this._gradient.cloneTo(destGradientSize._gradient);
			this._gradientX.cloneTo(destGradientSize._gradientX);
			this._gradientY.cloneTo(destGradientSize._gradientY);
			this._gradientZ.cloneTo(destGradientSize._gradientZ);
			destGradientSize._constantMin=this._constantMin;
			destGradientSize._constantMax=this._constantMax;
			this._constantMinSeparate.cloneTo(destGradientSize._constantMinSeparate);
			this._constantMaxSeparate.cloneTo(destGradientSize._constantMaxSeparate);
			this._gradientMin.cloneTo(destGradientSize._gradientMin);
			this._gradientMax.cloneTo(destGradientSize._gradientMax);
			this._gradientXMin.cloneTo(destGradientSize._gradientXMin);
			this._gradientXMax.cloneTo(destGradientSize._gradientXMax);
			this._gradientYMin.cloneTo(destGradientSize._gradientYMin);
			this._gradientYMax.cloneTo(destGradientSize._gradientYMax);
			this._gradientZMin.cloneTo(destGradientSize._gradientZMin);
			this._gradientZMax.cloneTo(destGradientSize._gradientZMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientSize=/*__JS__ */new this.constructor();
			this.cloneTo(destGradientSize);
			return destGradientSize;
		}

		/**
		*渐变尺寸Z。
		*/
		__getset(0,__proto,'gradientZ',function(){
			return this._gradientZ;
		});

		/**
		*渐变尺寸。
		*/
		__getset(0,__proto,'gradient',function(){
			return this._gradient;
		});

		/**
		*是否分轴。
		*/
		__getset(0,__proto,'separateAxes',function(){
			return this._separateAxes;
		});

		/**
		*生命周期尺寸类型，0曲线模式，1随机双常量模式，2随机双曲线模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*渐变最小尺寸。
		*/
		__getset(0,__proto,'gradientMin',function(){
			return this._gradientMin;
		});

		/**
		*最小随机双固定尺寸。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*渐变尺寸X。
		*/
		__getset(0,__proto,'gradientX',function(){
			return this._gradientX;
		});

		/**
		*渐变尺寸Y。
		*/
		__getset(0,__proto,'gradientY',function(){
			return this._gradientY;
		});

		/**
		*渐变最大尺寸。
		*/
		__getset(0,__proto,'gradientMax',function(){
			return this._gradientMax;
		});

		/**
		*最大随机双固定尺寸。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		/**
		*最小分轴随机双固定尺寸。
		*/
		__getset(0,__proto,'constantMinSeparate',function(){
			return this._constantMinSeparate;
		});

		/**
		*最小分轴随机双固定尺寸。
		*/
		__getset(0,__proto,'constantMaxSeparate',function(){
			return this._constantMaxSeparate;
		});

		/**
		*渐变最小尺寸X。
		*/
		__getset(0,__proto,'gradientXMin',function(){
			return this._gradientXMin;
		});

		/**
		*渐变最大尺寸X。
		*/
		__getset(0,__proto,'gradientXMax',function(){
			return this._gradientXMax;
		});

		/**
		*渐变最小尺寸Y。
		*/
		__getset(0,__proto,'gradientYMin',function(){
			return this._gradientYMin;
		});

		/**
		*渐变最大尺寸Y。
		*/
		__getset(0,__proto,'gradientYMax',function(){
			return this._gradientYMax;
		});

		/**
		*渐变最小尺寸Z。
		*/
		__getset(0,__proto,'gradientZMin',function(){
			return this._gradientZMin;
		});

		/**
		*渐变最大尺寸Z。
		*/
		__getset(0,__proto,'gradientZMax',function(){
			return this._gradientZMax;
		});

		GradientSize.createByGradient=function(gradient){
			var gradientSize=new GradientSize();
			gradientSize._type=0;
			gradientSize._separateAxes=false;
			gradientSize._gradient=gradient;
			return gradientSize;
		}

		GradientSize.createByGradientSeparate=function(gradientX,gradientY,gradientZ){
			var gradientSize=new GradientSize();
			gradientSize._type=0;
			gradientSize._separateAxes=true;
			gradientSize._gradientX=gradientX;
			gradientSize._gradientY=gradientY;
			gradientSize._gradientZ=gradientZ;
			return gradientSize;
		}

		GradientSize.createByRandomTwoConstant=function(constantMin,constantMax){
			var gradientSize=new GradientSize();
			gradientSize._type=1;
			gradientSize._separateAxes=false;
			gradientSize._constantMin=constantMin;
			gradientSize._constantMax=constantMax;
			return gradientSize;
		}

		GradientSize.createByRandomTwoConstantSeparate=function(constantMinSeparate,constantMaxSeparate){
			var gradientSize=new GradientSize();
			gradientSize._type=1;
			gradientSize._separateAxes=true;
			gradientSize._constantMinSeparate=constantMinSeparate;
			gradientSize._constantMaxSeparate=constantMaxSeparate;
			return gradientSize;
		}

		GradientSize.createByRandomTwoGradient=function(gradientMin,gradientMax){
			var gradientSize=new GradientSize();
			gradientSize._type=2;
			gradientSize._separateAxes=false;
			gradientSize._gradientMin=gradientMin;
			gradientSize._gradientMax=gradientMax;
			return gradientSize;
		}

		GradientSize.createByRandomTwoGradientSeparate=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
			var gradientSize=new GradientSize();
			gradientSize._type=2;
			gradientSize._separateAxes=true;
			gradientSize._gradientXMin=gradientXMin;
			gradientSize._gradientXMax=gradientXMax;
			gradientSize._gradientYMin=gradientYMin;
			gradientSize._gradientYMax=gradientYMax;
			gradientSize._gradientZMin=gradientZMin;
			gradientSize._gradientZMax=gradientZMax;
			return gradientSize;
		}

		return GradientSize;
	})()


	/**
	*<code>GradientVelocity</code> 类用于创建渐变速度。
	*/
	//class laya.d3.core.particleShuriKen.module.GradientVelocity
	var GradientVelocity=(function(){
		function GradientVelocity(){
			this._type=0;
			this._constant=null;
			this._gradientX=null;
			this._gradientY=null;
			this._gradientZ=null;
			this._constantMin=null;
			this._constantMax=null;
			this._gradientXMin=null;
			this._gradientXMax=null;
			this._gradientYMin=null;
			this._gradientYMax=null;
			this._gradientZMin=null;
			this._gradientZMax=null;
		}

		__class(GradientVelocity,'laya.d3.core.particleShuriKen.module.GradientVelocity');
		var __proto=GradientVelocity.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destGradientVelocity=destObject;
			destGradientVelocity._type=this._type;
			this._constant.cloneTo(destGradientVelocity._constant);
			this._gradientX.cloneTo(destGradientVelocity._gradientX);
			this._gradientY.cloneTo(destGradientVelocity._gradientY);
			this._gradientZ.cloneTo(destGradientVelocity._gradientZ);
			this._constantMin.cloneTo(destGradientVelocity._constantMin);
			this._constantMax.cloneTo(destGradientVelocity._constantMax);
			this._gradientXMin.cloneTo(destGradientVelocity._gradientXMin);
			this._gradientXMax.cloneTo(destGradientVelocity._gradientXMax);
			this._gradientYMin.cloneTo(destGradientVelocity._gradientYMin);
			this._gradientYMax.cloneTo(destGradientVelocity._gradientYMax);
			this._gradientZMin.cloneTo(destGradientVelocity._gradientZMin);
			this._gradientZMax.cloneTo(destGradientVelocity._gradientZMax);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destGradientVelocity=/*__JS__ */new this.constructor();
			this.cloneTo(destGradientVelocity);
			return destGradientVelocity;
		}

		/**
		*渐变速度Z。
		*/
		__getset(0,__proto,'gradientZ',function(){
			return this._gradientZ;
		});

		/**固定速度。*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*生命周期速度类型，0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*渐变最大速度X。
		*/
		__getset(0,__proto,'gradientXMax',function(){
			return this._gradientXMax;
		});

		/**最小固定速度。*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*渐变速度X。
		*/
		__getset(0,__proto,'gradientX',function(){
			return this._gradientX;
		});

		/**
		*渐变速度Y。
		*/
		__getset(0,__proto,'gradientY',function(){
			return this._gradientY;
		});

		/**
		*渐变最小速度X。
		*/
		__getset(0,__proto,'gradientXMin',function(){
			return this._gradientXMin;
		});

		/**最大固定速度。*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		/**
		*渐变最小速度Y。
		*/
		__getset(0,__proto,'gradientYMin',function(){
			return this._gradientYMin;
		});

		/**
		*渐变最大速度Y。
		*/
		__getset(0,__proto,'gradientYMax',function(){
			return this._gradientYMax;
		});

		/**
		*渐变最小速度Z。
		*/
		__getset(0,__proto,'gradientZMin',function(){
			return this._gradientZMin;
		});

		/**
		*渐变最大速度Z。
		*/
		__getset(0,__proto,'gradientZMax',function(){
			return this._gradientZMax;
		});

		GradientVelocity.createByConstant=function(constant){
			var gradientVelocity=new GradientVelocity();
			gradientVelocity._type=0;
			gradientVelocity._constant=constant;
			return gradientVelocity;
		}

		GradientVelocity.createByGradient=function(gradientX,gradientY,gradientZ){
			var gradientVelocity=new GradientVelocity();
			gradientVelocity._type=1;
			gradientVelocity._gradientX=gradientX;
			gradientVelocity._gradientY=gradientY;
			gradientVelocity._gradientZ=gradientZ;
			return gradientVelocity;
		}

		GradientVelocity.createByRandomTwoConstant=function(constantMin,constantMax){
			var gradientVelocity=new GradientVelocity();
			gradientVelocity._type=2;
			gradientVelocity._constantMin=constantMin;
			gradientVelocity._constantMax=constantMax;
			return gradientVelocity;
		}

		GradientVelocity.createByRandomTwoGradient=function(gradientXMin,gradientXMax,gradientYMin,gradientYMax,gradientZMin,gradientZMax){
			var gradientVelocity=new GradientVelocity();
			gradientVelocity._type=3;
			gradientVelocity._gradientXMin=gradientXMin;
			gradientVelocity._gradientXMax=gradientXMax;
			gradientVelocity._gradientYMin=gradientYMin;
			gradientVelocity._gradientYMax=gradientYMax;
			gradientVelocity._gradientZMin=gradientZMin;
			gradientVelocity._gradientZMax=gradientZMax;
			return gradientVelocity;
		}

		return GradientVelocity;
	})()


	/**
	*<code>RotationOverLifetime</code> 类用于粒子的生命周期旋转。
	*/
	//class laya.d3.core.particleShuriKen.module.RotationOverLifetime
	var RotationOverLifetime=(function(){
		function RotationOverLifetime(angularVelocity){
			this._angularVelocity=null;
			this.enbale=false;
			this._angularVelocity=angularVelocity;
		}

		__class(RotationOverLifetime,'laya.d3.core.particleShuriKen.module.RotationOverLifetime');
		var __proto=RotationOverLifetime.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destRotationOverLifetime=destObject;
			this._angularVelocity.cloneTo(destRotationOverLifetime._angularVelocity);
			destRotationOverLifetime.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destAngularVelocity;
			switch (this._angularVelocity.type){
				case 0:
					if (this._angularVelocity.separateAxes)
						destAngularVelocity=GradientAngularVelocity.createByConstantSeparate(this._angularVelocity.constantSeparate.clone());
					else
					destAngularVelocity=GradientAngularVelocity.createByConstant(this._angularVelocity.constant);
					break ;
				case 1:
					if (this._angularVelocity.separateAxes)
						destAngularVelocity=GradientAngularVelocity.createByGradientSeparate(this._angularVelocity.gradientX.clone(),this._angularVelocity.gradientY.clone(),this._angularVelocity.gradientZ.clone());
					else
					destAngularVelocity=GradientAngularVelocity.createByGradient(this._angularVelocity.gradient.clone());
					break ;
				case 2:
					if (this._angularVelocity.separateAxes)
						destAngularVelocity=GradientAngularVelocity.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(),this._angularVelocity.constantMaxSeparate.clone());
					else
					destAngularVelocity=GradientAngularVelocity.createByRandomTwoConstant(this._angularVelocity.constantMin,this._angularVelocity.constantMax);
					break ;
				case 3:
					if (this._angularVelocity.separateAxes)
						destAngularVelocity=GradientAngularVelocity.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(),this._angularVelocity.gradientYMin.clone(),this._angularVelocity.gradientZMin.clone(),this._angularVelocity.gradientXMax.clone(),this._angularVelocity.gradientYMax.clone(),this._angularVelocity.gradientZMax.clone());
					else
					destAngularVelocity=GradientAngularVelocity.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(),this._angularVelocity.gradientMax.clone());
					break ;
				};
			var destRotationOverLifetime=/*__JS__ */new this.constructor(destAngularVelocity);
			destRotationOverLifetime.enbale=this.enbale;
			return destRotationOverLifetime;
		}

		/**
		*获取角速度。
		*/
		__getset(0,__proto,'angularVelocity',function(){
			return this._angularVelocity;
		});

		return RotationOverLifetime;
	})()


	/**
	*<code>BaseShape</code> 类用于粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.BaseShape
	var BaseShape=(function(){
		function BaseShape(){
			this.enable=false;
			this.randomDirection=false;
		}

		__class(BaseShape,'laya.d3.core.particleShuriKen.module.shape.BaseShape');
		var __proto=BaseShape.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**@private */
		__proto._getShapeBoundBox=function(boundBox){
			throw new Error("BaseShape: must override it.");
		}

		/**@private */
		__proto._getSpeedBoundBox=function(boundBox){
			throw new Error("BaseShape: must override it.");
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			throw new Error("BaseShape: must override it.");
		}

		/**
		*@private
		*/
		__proto._calculateProceduralBounds=function(boundBox,emitterPosScale,minMaxBounds){
			this._getShapeBoundBox(boundBox);
			var min=boundBox.min;
			var max=boundBox.max;
			Vector3.multiply(min,emitterPosScale,min);
			Vector3.multiply(max,emitterPosScale,max);
			var speedBounds=new BoundBox(new Vector3(),new Vector3());
			if (this.randomDirection){
				speedBounds.min=new Vector3(-1,-1,-1);
				speedBounds.max=new Vector3(1,1,1);
			}
			else{
				this._getSpeedBoundBox(speedBounds);
			};
			var maxSpeedBound=new BoundBox(new Vector3(),new Vector3());
			var maxSpeedMin=maxSpeedBound.min;
			var maxSpeedMax=maxSpeedBound.max;
			Vector3.scale(speedBounds.min,minMaxBounds.y,maxSpeedMin);
			Vector3.scale(speedBounds.max,minMaxBounds.y,maxSpeedMax);
			Vector3.add(boundBox.min,maxSpeedMin,maxSpeedMin);
			Vector3.add(boundBox.max,maxSpeedMax,maxSpeedMax);
			Vector3.min(boundBox.min,maxSpeedMin,boundBox.min);
			Vector3.max(boundBox.max,maxSpeedMin,boundBox.max);
			var minSpeedBound=new BoundBox(new Vector3(),new Vector3());
			var minSpeedMin=minSpeedBound.min;
			var minSpeedMax=minSpeedBound.max;
			Vector3.scale(speedBounds.min,minMaxBounds.x,minSpeedMin);
			Vector3.scale(speedBounds.max,minMaxBounds.x,minSpeedMax);
			Vector3.min(minSpeedBound.min,minSpeedMax,maxSpeedMin);
			Vector3.max(minSpeedBound.min,minSpeedMax,maxSpeedMax);
			Vector3.min(boundBox.min,maxSpeedMin,boundBox.min);
			Vector3.max(boundBox.max,maxSpeedMin,boundBox.max);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destShape=destObject;
			destShape.enable=this.enable;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destShape=/*__JS__ */new this.constructor();
			this.cloneTo(destShape);
			return destShape;
		}

		return BaseShape;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.particleShuriKen.module.shape.ShapeUtils
	var ShapeUtils=(function(){
		function ShapeUtils(){}
		__class(ShapeUtils,'laya.d3.core.particleShuriKen.module.shape.ShapeUtils');
		ShapeUtils._randomPointUnitArcCircle=function(arc,out,rand){
			var outE=out.elements;
			var angle=NaN;
			if (rand)
				angle=rand.getFloat()*arc;
			else
			angle=Math.random()*arc;
			outE[0]=Math.cos(angle);
			outE[1]=Math.sin(angle);
		}

		ShapeUtils._randomPointInsideUnitArcCircle=function(arc,out,rand){
			var outE=out.elements;
			ShapeUtils._randomPointUnitArcCircle(arc,out,rand);
			var range=NaN;
			if (rand)
				range=Math.pow(rand.getFloat(),1.0 / 2.0);
			else
			range=Math.pow(Math.random(),1.0 / 2.0);
			outE[0]=outE[0] *range;
			outE[1]=outE[1] *range;
		}

		ShapeUtils._randomPointUnitCircle=function(out,rand){
			var outE=out.elements;
			var angle=NaN;
			if (rand)
				angle=rand.getFloat()*Math.PI *2;
			else
			angle=Math.random()*Math.PI *2;
			outE[0]=Math.cos(angle);
			outE[1]=Math.sin(angle);
		}

		ShapeUtils._randomPointInsideUnitCircle=function(out,rand){
			var outE=out.elements;
			ShapeUtils._randomPointUnitCircle(out);
			var range=NaN;
			if (rand)
				range=Math.pow(rand.getFloat(),1.0 / 2.0);
			else
			range=Math.pow(Math.random(),1.0 / 2.0);
			outE[0]=outE[0] *range;
			outE[1]=outE[1] *range;
		}

		ShapeUtils._randomPointUnitSphere=function(out,rand){
			var outE=out.elements;
			var z=NaN;
			var a=NaN;
			if (rand){
				z=outE[2]=rand.getFloat()*2-1.0;
				a=rand.getFloat()*Math.PI *2;
				}else {
				z=outE[2]=Math.random()*2-1.0;
				a=Math.random()*Math.PI *2;
			};
			var r=Math.sqrt(1.0-z *z);
			outE[0]=r *Math.cos(a);
			outE[1]=r *Math.sin(a);
		}

		ShapeUtils._randomPointInsideUnitSphere=function(out,rand){
			var outE=out.elements;
			ShapeUtils._randomPointUnitSphere(out);
			var range=NaN;
			if (rand)
				range=Math.pow(rand.getFloat(),1.0 / 3.0);
			else
			range=Math.pow(Math.random(),1.0 / 3.0);
			outE[0]=outE[0] *range;
			outE[1]=outE[1] *range;
			outE[2]=outE[2] *range;
		}

		ShapeUtils._randomPointInsideHalfUnitBox=function(out,rand){
			var outE=out.elements;
			if (rand){
				outE[0]=(rand.getFloat()-0.5);
				outE[1]=(rand.getFloat()-0.5);
				outE[2]=(rand.getFloat()-0.5);
				}else {
				outE[0]=(Math.random()-0.5);
				outE[1]=(Math.random()-0.5);
				outE[2]=(Math.random()-0.5);
			}
		}

		return ShapeUtils;
	})()


	/**
	*<code>SizeOverLifetime</code> 类用于粒子的生命周期尺寸。
	*/
	//class laya.d3.core.particleShuriKen.module.SizeOverLifetime
	var SizeOverLifetime=(function(){
		function SizeOverLifetime(size){
			this._size=null;
			this.enbale=false;
			this._size=size;
		}

		__class(SizeOverLifetime,'laya.d3.core.particleShuriKen.module.SizeOverLifetime');
		var __proto=SizeOverLifetime.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destSizeOverLifetime=destObject;
			this._size.cloneTo(destSizeOverLifetime._size);
			destSizeOverLifetime.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destSize;
			switch (this._size.type){
				case 0:
					if (this._size.separateAxes)
						destSize=GradientSize.createByGradientSeparate(this._size.gradientX.clone(),this._size.gradientY.clone(),this._size.gradientZ.clone());
					else
					destSize=GradientSize.createByGradient(this._size.gradient.clone());
					break ;
				case 1:
					if (this._size.separateAxes)
						destSize=GradientSize.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(),this._size.constantMaxSeparate.clone());
					else
					destSize=GradientSize.createByRandomTwoConstant(this._size.constantMin,this._size.constantMax);
					break ;
				case 2:
					if (this._size.separateAxes)
						destSize=GradientSize.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(),this._size.gradientYMin.clone(),this._size.gradientZMin.clone(),this._size.gradientXMax.clone(),this._size.gradientYMax.clone(),this._size.gradientZMax.clone());
					else
					destSize=GradientSize.createByRandomTwoGradient(this._size.gradientMin.clone(),this._size.gradientMax.clone());
					break ;
				};
			var destSizeOverLifetime=/*__JS__ */new this.constructor(destSize);
			destSizeOverLifetime.enbale=this.enbale;
			return destSizeOverLifetime;
		}

		/**
		*获取尺寸。
		*/
		__getset(0,__proto,'size',function(){
			return this._size;
		});

		return SizeOverLifetime;
	})()


	/**
	*<code>StartFrame</code> 类用于创建开始帧。
	*/
	//class laya.d3.core.particleShuriKen.module.StartFrame
	var StartFrame=(function(){
		function StartFrame(){
			this._type=0;
			this._constant=NaN;
			this._constantMin=NaN;
			this._constantMax=NaN;
		}

		__class(StartFrame,'laya.d3.core.particleShuriKen.module.StartFrame');
		var __proto=StartFrame.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destStartFrame=destObject;
			destStartFrame._type=this._type;
			destStartFrame._constant=this._constant;
			destStartFrame._constantMin=this._constantMin;
			destStartFrame._constantMax=this._constantMax;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destStartFrame=/*__JS__ */new this.constructor();
			this.cloneTo(destStartFrame);
			return destStartFrame;
		}

		/**
		*固定帧。
		*/
		__getset(0,__proto,'constant',function(){
			return this._constant;
		});

		/**
		*开始帧类型,0常量模式，1随机双常量模式。
		*/
		__getset(0,__proto,'type',function(){
			return this._type;
		});

		/**
		*最小固定帧。
		*/
		__getset(0,__proto,'constantMin',function(){
			return this._constantMin;
		});

		/**
		*最大固定帧。
		*/
		__getset(0,__proto,'constantMax',function(){
			return this._constantMax;
		});

		StartFrame.createByConstant=function(constant){
			var rotationOverLifetime=new StartFrame();
			rotationOverLifetime._type=0;
			rotationOverLifetime._constant=constant;
			return rotationOverLifetime;
		}

		StartFrame.createByRandomTwoConstant=function(constantMin,constantMax){
			var rotationOverLifetime=new StartFrame();
			rotationOverLifetime._type=1;
			rotationOverLifetime._constantMin=constantMin;
			rotationOverLifetime._constantMax=constantMax;
			return rotationOverLifetime;
		}

		return StartFrame;
	})()


	/**
	*<code>TextureSheetAnimation</code> 类用于创建粒子帧动画。
	*/
	//class laya.d3.core.particleShuriKen.module.TextureSheetAnimation
	var TextureSheetAnimation=(function(){
		function TextureSheetAnimation(frame,startFrame){
			this._frame=null;
			this._startFrame=null;
			this.tiles=null;
			this.type=0;
			this.randomRow=false;
			this.cycles=0;
			this.enableUVChannels=0;
			this.enbale=false;
			this.tiles=new Vector2(1,1);
			this.type=0;
			this.randomRow=true;
			this.cycles=1;
			this.enableUVChannels=1;
			this._frame=frame;
			this._startFrame=startFrame;
		}

		__class(TextureSheetAnimation,'laya.d3.core.particleShuriKen.module.TextureSheetAnimation');
		var __proto=TextureSheetAnimation.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destTextureSheetAnimation=destObject;
			this.tiles.cloneTo(destTextureSheetAnimation.tiles);
			destTextureSheetAnimation.type=this.type;
			destTextureSheetAnimation.randomRow=this.randomRow;
			this._frame.cloneTo(destTextureSheetAnimation._frame);
			this._startFrame.cloneTo(destTextureSheetAnimation._startFrame);
			destTextureSheetAnimation.cycles=this.cycles;
			destTextureSheetAnimation.enableUVChannels=this.enableUVChannels;
			destTextureSheetAnimation.enbale=this.enbale;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destFrame;
			switch (this._frame.type){
				case 0:
					destFrame=FrameOverTime.createByConstant(this._frame.constant);
					break ;
				case 1:
					destFrame=FrameOverTime.createByOverTime(this._frame.frameOverTimeData.clone());
					break ;
				case 2:
					destFrame=FrameOverTime.createByRandomTwoConstant(this._frame.constantMin,this._frame.constantMax);
					break ;
				case 3:
					destFrame=FrameOverTime.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(),this._frame.frameOverTimeDataMax.clone());
					break ;
				};
			var destStartFrame;
			switch (this._startFrame.type){
				case 0:
					destStartFrame=StartFrame.createByConstant(this._startFrame.constant);
					break ;
				case 1:
					destStartFrame=StartFrame.createByRandomTwoConstant(this._startFrame.constantMin,this._startFrame.constantMax);
					break ;
				};
			var destTextureSheetAnimation=/*__JS__ */new this.constructor(destFrame,destStartFrame);
			this.tiles.cloneTo(destTextureSheetAnimation.tiles);
			destTextureSheetAnimation.type=this.type;
			destTextureSheetAnimation.randomRow=this.randomRow;
			destTextureSheetAnimation.cycles=this.cycles;
			destTextureSheetAnimation.enableUVChannels=this.enableUVChannels;
			destTextureSheetAnimation.enbale=this.enbale;
			return destTextureSheetAnimation;
		}

		/**获取时间帧率。*/
		__getset(0,__proto,'frame',function(){
			return this._frame;
		});

		/**获取开始帧率。*/
		__getset(0,__proto,'startFrame',function(){
			return this._startFrame;
		});

		return TextureSheetAnimation;
	})()


	/**
	*<code>VelocityOverLifetime</code> 类用于粒子的生命周期速度。
	*/
	//class laya.d3.core.particleShuriKen.module.VelocityOverLifetime
	var VelocityOverLifetime=(function(){
		function VelocityOverLifetime(velocity){
			this._velocity=null;
			this.enbale=false;
			this.space=0;
			this._velocity=velocity;
		}

		__class(VelocityOverLifetime,'laya.d3.core.particleShuriKen.module.VelocityOverLifetime');
		var __proto=VelocityOverLifetime.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destVelocityOverLifetime=destObject;
			this._velocity.cloneTo(destVelocityOverLifetime._velocity);
			destVelocityOverLifetime.enbale=this.enbale;
			destVelocityOverLifetime.space=this.space;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destVelocity;
			switch(this._velocity.type){
				case 0:
					destVelocity=GradientVelocity.createByConstant(this._velocity.constant.clone());
					break ;
				case 1:
					destVelocity=GradientVelocity.createByGradient(this._velocity.gradientX.clone(),this._velocity.gradientY.clone(),this._velocity.gradientZ.clone());
					break ;
				case 2:
					destVelocity=GradientVelocity.createByRandomTwoConstant(this._velocity.constantMin.clone(),this._velocity.constantMax.clone());
					break ;
				case 3:
					destVelocity=GradientVelocity.createByRandomTwoGradient(this._velocity.gradientXMin.clone(),this._velocity.gradientYMin.clone(),this._velocity.gradientZMin.clone(),this._velocity.gradientXMax.clone(),this._velocity.gradientYMax.clone(),this._velocity.gradientZMax.clone());
					break ;
				};
			var destVelocityOverLifetime=/*__JS__ */new this.constructor(destVelocity);
			destVelocityOverLifetime.enbale=this.enbale;
			destVelocityOverLifetime.space=this.space;
			return destVelocityOverLifetime;
		}

		/**
		*获取尺寸。
		*/
		__getset(0,__proto,'velocity',function(){
			return this._velocity;
		});

		return VelocityOverLifetime;
	})()


	/**
	*@private
	*/
	//class laya.d3.core.particleShuriKen.ShurikenParticleData
	var ShurikenParticleData=(function(){
		function ShurikenParticleData(){
			this.startLifeTime=NaN;
			this.position=null;
			this.direction=null;
			this.startColor=null;
			this.startSize=null;
			this.startRotation0=null;
			this.startRotation1=null;
			this.startRotation2=null;
			this.time=NaN;
			this.startSpeed=NaN;
			this.startUVInfo=null;
			this.simulationWorldPostion=null;
		}

		__class(ShurikenParticleData,'laya.d3.core.particleShuriKen.ShurikenParticleData');
		ShurikenParticleData._getStartLifetimeFromGradient=function(startLifeTimeGradient,emissionTime){
			for (var i=1,n=startLifeTimeGradient.gradientCount;i < n;i++){
				var key=startLifeTimeGradient.getKeyByIndex(i);
				if (key >=emissionTime){
					var lastKey=startLifeTimeGradient.getKeyByIndex(i-1);
					var age=(emissionTime-lastKey)/ (key-lastKey);
					return MathUtil.lerp(startLifeTimeGradient.getValueByIndex(i-1),startLifeTimeGradient.getValueByIndex(i),age)
				}
			}
			throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
		}

		ShurikenParticleData.create=function(particleSystem,particleRender,position,direction,time,transform){
			var autoRandomSeed=particleSystem.autoRandomSeed;
			var rand=particleSystem._rand;
			var randomSeeds=particleSystem._randomSeeds;
			var particleData=new ShurikenParticleData();
			particleData.position=position;
			particleData.direction=direction;
			particleData.startColor=ShurikenParticleData._tempStartColor;
			switch (particleSystem.startColorType){
				case 0:;
					var startColorE=particleData.startColor;
					var constantStartColorE=particleSystem.startColorConstant.elements;
					startColorE[0]=constantStartColorE[0];
					startColorE[1]=constantStartColorE[1];
					startColorE[2]=constantStartColorE[2];
					startColorE[3]=constantStartColorE[3];
					break ;
				case 2:
					if (autoRandomSeed){
						MathUtil.lerpVector4(particleSystem.startColorConstantMin.elements,particleSystem.startColorConstantMax.elements,Math.random(),particleData.startColor);
						}else {
						rand.seed=randomSeeds[3];
						MathUtil.lerpVector4(particleSystem.startColorConstantMin.elements,particleSystem.startColorConstantMax.elements,rand.getFloat(),particleData.startColor);
						randomSeeds[3]=rand.seed;
					}
					break ;
				};
			var colorOverLifetime=particleSystem.colorOverLifetime;
			if (colorOverLifetime && colorOverLifetime.enbale){
				var startColor=particleData.startColor;
				var color=colorOverLifetime.color;
				switch (color.type){
					case 0:
						startColor[0]=startColor[0] *color.constant.x;
						startColor[1]=startColor[1] *color.constant.y;
						startColor[2]=startColor[2] *color.constant.z;
						startColor[3]=startColor[3] *color.constant.w;
						break ;
					case 2:;
						var colorRandom=NaN;
						if (autoRandomSeed){
							colorRandom=Math.random();
							}else {
							rand.seed=randomSeeds[10];
							colorRandom=rand.getFloat();
							randomSeeds[10]=rand.seed;
						};
						var minConstantColor=color.constantMin;
						var maxConstantColor=color.constantMax;
						startColor[0]=startColor[0] *MathUtil.lerp(minConstantColor.x,maxConstantColor.x,colorRandom);
						startColor[1]=startColor[1] *MathUtil.lerp(minConstantColor.y,maxConstantColor.y,colorRandom);
						startColor[2]=startColor[2] *MathUtil.lerp(minConstantColor.z,maxConstantColor.z,colorRandom);
						startColor[3]=startColor[3] *MathUtil.lerp(minConstantColor.w,maxConstantColor.w,colorRandom);
						break ;
					}
			}
			particleData.startSize=ShurikenParticleData._tempStartSize;
			var particleSize=particleData.startSize;
			switch (particleSystem.startSizeType){
				case 0:
					if (particleSystem.threeDStartSize){
						var startSizeConstantSeparate=particleSystem.startSizeConstantSeparate;
						particleSize[0]=startSizeConstantSeparate.x;
						particleSize[1]=startSizeConstantSeparate.y;
						particleSize[2]=startSizeConstantSeparate.z;
						}else {
						particleSize[0]=particleSize[1]=particleSize[2]=particleSystem.startSizeConstant;
					}
					break ;
				case 2:
					if (particleSystem.threeDStartSize){
						var startSizeConstantMinSeparate=particleSystem.startSizeConstantMinSeparate;
						var startSizeConstantMaxSeparate=particleSystem.startSizeConstantMaxSeparate;
						if (autoRandomSeed){
							particleSize[0]=MathUtil.lerp(startSizeConstantMinSeparate.x,startSizeConstantMaxSeparate.x,Math.random());
							particleSize[1]=MathUtil.lerp(startSizeConstantMinSeparate.y,startSizeConstantMaxSeparate.y,Math.random());
							particleSize[2]=MathUtil.lerp(startSizeConstantMinSeparate.z,startSizeConstantMaxSeparate.z,Math.random());
							}else {
							rand.seed=randomSeeds[4];
							particleSize[0]=MathUtil.lerp(startSizeConstantMinSeparate.x,startSizeConstantMaxSeparate.x,rand.getFloat());
							particleSize[1]=MathUtil.lerp(startSizeConstantMinSeparate.y,startSizeConstantMaxSeparate.y,rand.getFloat());
							particleSize[2]=MathUtil.lerp(startSizeConstantMinSeparate.z,startSizeConstantMaxSeparate.z,rand.getFloat());
							randomSeeds[4]=rand.seed;
						}
						}else {
						if (autoRandomSeed){
							particleSize[0]=particleSize[1]=particleSize[2]=MathUtil.lerp(particleSystem.startSizeConstantMin,particleSystem.startSizeConstantMax,Math.random());
							}else {
							rand.seed=randomSeeds[4];
							particleSize[0]=particleSize[1]=particleSize[2]=MathUtil.lerp(particleSystem.startSizeConstantMin,particleSystem.startSizeConstantMax,rand.getFloat());
							randomSeeds[4]=rand.seed;
						}
					}
					break ;
				};
			var sizeOverLifetime=particleSystem.sizeOverLifetime;
			if (sizeOverLifetime && sizeOverLifetime.enbale && sizeOverLifetime.size.type===1){
				var size=sizeOverLifetime.size;
				if (size.separateAxes){
					if (autoRandomSeed){
						particleSize[0]=particleSize[0] *MathUtil.lerp(size.constantMinSeparate.x,size.constantMaxSeparate.x,Math.random());
						particleSize[1]=particleSize[1] *MathUtil.lerp(size.constantMinSeparate.y,size.constantMaxSeparate.y,Math.random());
						particleSize[2]=particleSize[2] *MathUtil.lerp(size.constantMinSeparate.z,size.constantMaxSeparate.z,Math.random());
						}else {
						rand.seed=randomSeeds[11];
						particleSize[0]=particleSize[0] *MathUtil.lerp(size.constantMinSeparate.x,size.constantMaxSeparate.x,rand.getFloat());
						particleSize[1]=particleSize[1] *MathUtil.lerp(size.constantMinSeparate.y,size.constantMaxSeparate.y,rand.getFloat());;
						particleSize[2]=particleSize[2] *MathUtil.lerp(size.constantMinSeparate.z,size.constantMaxSeparate.z,rand.getFloat());
						randomSeeds[11]=rand.seed;
					}
					}else {
					var randomSize=NaN;
					if (autoRandomSeed){
						randomSize=MathUtil.lerp(size.constantMin,size.constantMax,Math.random());
						}else {
						rand.seed=randomSeeds[11];
						randomSize=MathUtil.lerp(size.constantMin,size.constantMax,rand.getFloat());
						randomSeeds[11]=rand.seed;
					}
					particleSize[0]=particleSize[0] *randomSize;
					particleSize[1]=particleSize[1] *randomSize;
					particleSize[2]=particleSize[2] *randomSize;
				}
			};
			var particleRotation0;
			var particleRotation1;
			var particleRotation2;
			var rotationMatrixE;
			switch (particleSystem.startRotationType){
				case 0:
					if (particleSystem.threeDStartRotation && (particleRender.renderMode!==1)&& (particleRender.renderMode!==1)){
						var startRotationConstantSeparate=particleSystem.startRotationConstantSeparate;
						Matrix4x4.createRotationYawPitchRoll(startRotationConstantSeparate.y,startRotationConstantSeparate.x,startRotationConstantSeparate.z,ShurikenParticleData._tempRotationMatrix);
						rotationMatrixE=ShurikenParticleData._tempRotationMatrix.elements;
						particleData.startRotation0=ShurikenParticleData._tempStartRotation0;
						particleRotation0=particleData.startRotation0;
						particleRotation0[0]=rotationMatrixE[0];
						particleRotation0[1]=rotationMatrixE[1];
						particleRotation0[2]=rotationMatrixE[2];
						particleData.startRotation1=ShurikenParticleData._tempStartRotation1;
						particleRotation1=particleData.startRotation1;
						particleRotation1[0]=rotationMatrixE[4];
						particleRotation1[1]=rotationMatrixE[5];
						particleRotation1[2]=rotationMatrixE[6];
						particleData.startRotation2=ShurikenParticleData._tempStartRotation2;
						particleRotation2=particleData.startRotation2;
						particleRotation2[0]=rotationMatrixE[8];
						particleRotation2[1]=rotationMatrixE[9];
						particleRotation2[2]=rotationMatrixE[10];
						}else {
						particleData.startRotation0=ShurikenParticleData._tempStartRotation0;
						particleRotation0=particleData.startRotation0;
						particleRotation0[0]=particleRotation0[1]=particleRotation0[2]=particleSystem.startRotationConstant;
					}
					break ;
				case 2:
					if (particleSystem.threeDStartRotation && (particleRender.renderMode!==1)&& (particleRender.renderMode!==2)){
						particleData.startRotation0=ShurikenParticleData._tempStartRotation0;
						particleRotation0=particleData.startRotation0;
						var startRotationConstantMinSeparate=particleSystem.startRotationConstantMinSeparate;
						var startRotationConstantMaxSeparate=particleSystem.startRotationConstantMaxSeparate;
						if (autoRandomSeed){
							Matrix4x4.createRotationYawPitchRoll(MathUtil.lerp(startRotationConstantMinSeparate.y,startRotationConstantMaxSeparate.y,Math.random()),MathUtil.lerp(startRotationConstantMinSeparate.x,startRotationConstantMaxSeparate.x,Math.random()),MathUtil.lerp(startRotationConstantMinSeparate.z,startRotationConstantMaxSeparate.z,Math.random()),ShurikenParticleData._tempRotationMatrix);
							}else {
							rand.seed=randomSeeds[5];
							Matrix4x4.createRotationYawPitchRoll(MathUtil.lerp(startRotationConstantMinSeparate.y,startRotationConstantMaxSeparate.y,rand.getFloat()),MathUtil.lerp(startRotationConstantMinSeparate.x,startRotationConstantMaxSeparate.x,rand.getFloat()),MathUtil.lerp(startRotationConstantMinSeparate.z,startRotationConstantMaxSeparate.z,rand.getFloat()),ShurikenParticleData._tempRotationMatrix);
							randomSeeds[5]=rand.seed;
						}
						rotationMatrixE=ShurikenParticleData._tempRotationMatrix.elements;
						particleData.startRotation0=ShurikenParticleData._tempStartRotation0;
						particleRotation0=particleData.startRotation0;
						particleRotation0[0]=rotationMatrixE[0];
						particleRotation0[1]=rotationMatrixE[1];
						particleRotation0[2]=rotationMatrixE[2];
						particleData.startRotation1=ShurikenParticleData._tempStartRotation1;
						particleRotation1=particleData.startRotation1;
						particleRotation1[0]=rotationMatrixE[4];
						particleRotation1[1]=rotationMatrixE[5];
						particleRotation1[2]=rotationMatrixE[6];
						particleData.startRotation2=ShurikenParticleData._tempStartRotation2;
						particleRotation2=particleData.startRotation2;
						particleRotation2[0]=rotationMatrixE[8];
						particleRotation2[1]=rotationMatrixE[9];
						particleRotation2[2]=rotationMatrixE[10];
						}else {
						particleData.startRotation0=ShurikenParticleData._tempStartRotation0;
						particleRotation0=particleData.startRotation0;
						if (autoRandomSeed){
							particleRotation0[0]=particleRotation0[1]=particleRotation0[2]=MathUtil.lerp(particleSystem.startRotationConstantMin,particleSystem.startRotationConstantMax,Math.random());
							}else {
							rand.seed=randomSeeds[5];
							particleRotation0[0]=particleRotation0[1]=particleRotation0[2]=MathUtil.lerp(particleSystem.startRotationConstantMin,particleSystem.startRotationConstantMax,rand.getFloat());
							randomSeeds[5]=rand.seed;
						}
					}
					break ;
				};
			var randDic=NaN;
			if (autoRandomSeed){
				randDic=Math.random();
				}else {
				rand.seed=randomSeeds[6];
				randDic=rand.getFloat();
				randomSeeds[6]=rand.seed;
			}
			if (randDic < particleSystem.randomizeRotationDirection){
				particleRotation0[0]=-particleRotation0[0];
				particleRotation0[1]=-particleRotation0[1];
				particleRotation0[2]=-particleRotation0[2];
			}
			particleData.startRotation1=ShurikenParticleData._tempStartRotation1;
			particleData.startRotation2=ShurikenParticleData._tempStartRotation2;
			switch (particleSystem.startLifetimeType){
				case 0:
					particleData.startLifeTime=particleSystem.startLifetimeConstant;
					break ;
				case 1:
					particleData.startLifeTime=ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradient,particleSystem.emissionTime);
					break ;
				case 2:
					if (autoRandomSeed){
						particleData.startLifeTime=MathUtil.lerp(particleSystem.startLifetimeConstantMin,particleSystem.startLifetimeConstantMax,Math.random());
						}else {
						rand.seed=randomSeeds[7];
						particleData.startLifeTime=MathUtil.lerp(particleSystem.startLifetimeConstantMin,particleSystem.startLifetimeConstantMax,rand.getFloat());
						randomSeeds[7]=rand.seed;
					}
					break ;
				case 3:;
					var emissionTime=particleSystem.emissionTime;
					if (autoRandomSeed){
						particleData.startLifeTime=MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin,emissionTime),ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax,emissionTime),Math.random());
						}else {
						rand.seed=randomSeeds[7];
						particleData.startLifeTime=MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMin,emissionTime),ShurikenParticleData._getStartLifetimeFromGradient(particleSystem.startLifeTimeGradientMax,emissionTime),rand.getFloat());
						randomSeeds[7]=rand.seed;
					}
					break ;
				}
			switch (particleSystem.startSpeedType){
				case 0:
					particleData.startSpeed=particleSystem.startSpeedConstant;
					break ;
				case 2:
					if (autoRandomSeed){
						particleData.startSpeed=MathUtil.lerp(particleSystem.startSpeedConstantMin,particleSystem.startSpeedConstantMax,Math.random());
						}else {
						rand.seed=randomSeeds[8];
						particleData.startSpeed=MathUtil.lerp(particleSystem.startSpeedConstantMin,particleSystem.startSpeedConstantMax,rand.getFloat());
						randomSeeds[8]=rand.seed;
					}
					break ;
				}
			particleData.startUVInfo=ShurikenParticleData._tempStartUVInfo;
			var textureSheetAnimation=particleSystem.textureSheetAnimation;
			var enableSheetAnimation=textureSheetAnimation && textureSheetAnimation.enbale;
			var startUVInfo;
			if (enableSheetAnimation){
				var title=textureSheetAnimation.tiles;
				var titleX=title.x,titleY=title.y;
				var subU=1.0 / titleX,subV=1.0 / titleY;
				var totalFrameCount=0;
				var startRow=0;
				var randomRow=textureSheetAnimation.randomRow;
				switch (textureSheetAnimation.type){
					case 0:
						totalFrameCount=titleX *titleY;
						break ;
					case 1:
						totalFrameCount=titleX;
						if (randomRow){
							if (autoRandomSeed){
								startRow=Math.round(Math.random()*titleY);
								}else {
								rand.seed=randomSeeds[13];
								startRow=Math.round(rand.getFloat()*titleY);
								randomSeeds[13]=rand.seed;
							}
							}else {
							startRow=0;
						}
						break ;
					};
				var startFrameCount=0;
				var startFrame=textureSheetAnimation.startFrame;
				switch (startFrame.type){
					case 0:
						startFrameCount=startFrame.constant;
						break ;
					case 1:
						if (autoRandomSeed){
							startFrameCount=Math.round(MathUtil.lerp(startFrame.constantMin,startFrame.constantMax,Math.random()));
							}else {
							rand.seed=randomSeeds[14];
							startFrameCount=Math.round(MathUtil.lerp(startFrame.constantMin,startFrame.constantMax,rand.getFloat()));
							randomSeeds[14]=rand.seed;
						}
						break ;
					};
				var frame=textureSheetAnimation.frame;
				switch (frame.type){
					case 0:
						startFrameCount+=frame.constant;
						break ;
					case 2:
						if (autoRandomSeed){
							startFrameCount+=Math.round(MathUtil.lerp(frame.constantMin,frame.constantMax,Math.random()));
							}else {
							rand.seed=randomSeeds[15];
							startFrameCount+=Math.round(MathUtil.lerp(frame.constantMin,frame.constantMax,rand.getFloat()));
							randomSeeds[15]=rand.seed;
						}
						break ;
					}
				if (!randomRow)
					startRow=Math.floor(startFrameCount / titleX);
				var startCol=startFrameCount % titleX;
				startUVInfo=particleData.startUVInfo;
				startUVInfo[0]=subU;
				startUVInfo[1]=subV;
				startUVInfo[2]=startCol *subU;
				startUVInfo[3]=startRow *subV;
				}else {
				startUVInfo=particleData.startUVInfo;
				startUVInfo[0]=1.0;
				startUVInfo[1]=1.0;
				startUVInfo[2]=0.0;
				startUVInfo[3]=0.0;
			}
			particleData.time=time;
			particleData.simulationWorldPostion=ShurikenParticleData._tempSimulationWorldPostion;
			var particleSimulationWorldPostion=particleData.simulationWorldPostion;
			if (particleSystem.simulationSpace===0){
				var positionE=transform.position.elements;
				particleSimulationWorldPostion[0]=positionE[0];
				particleSimulationWorldPostion[1]=positionE[1];
				particleSimulationWorldPostion[2]=positionE[2];
				}else {
				particleSimulationWorldPostion[0]=0;
				particleSimulationWorldPostion[1]=0;
				particleSimulationWorldPostion[2]=0;
			}
			return particleData;
		}

		__static(ShurikenParticleData,
		['_tempRotationMatrix',function(){return this._tempRotationMatrix=new Matrix4x4();},'_tempStartColor',function(){return this._tempStartColor=new Float32Array(4);},'_tempStartSize',function(){return this._tempStartSize=new Float32Array(3);},'_tempStartRotation0',function(){return this._tempStartRotation0=new Float32Array(3);},'_tempStartRotation1',function(){return this._tempStartRotation1=new Float32Array(3);},'_tempStartRotation2',function(){return this._tempStartRotation2=new Float32Array(3);},'_tempStartUVInfo',function(){return this._tempStartUVInfo=new Float32Array(4);},'_tempSimulationWorldPostion',function(){return this._tempSimulationWorldPostion=new Float32Array(3);}
		]);
		return ShurikenParticleData;
	})()


	/**
	*@private
	*<code>PhasorSpriter3D</code> 类用于创建矢量笔刷。
	*/
	//class laya.d3.core.PhasorSpriter3D
	var PhasorSpriter3D=(function(){
		function PhasorSpriter3D(){
			this._tempInt0=0;
			this._tempInt1=0;
			this._tempUint0=0;
			this._tempUint1=0;
			this._tempUint2=0;
			this._tempUint3=0;
			this._tempUint4=0;
			this._tempUint5=0;
			this._tempUint6=0;
			this._tempUint7=0;
			this._tempNumver0=NaN;
			this._tempNumver1=NaN;
			this._tempNumver2=NaN;
			this._tempNumver3=NaN;
			this._floatSizePerVer=7;
			this._defaultBufferSize=600 *this._floatSizePerVer;
			this._vb=null;
			this._posInVBData=0;
			this._ib=null;
			this._posInIBData=0;
			this._primitiveType=NaN;
			this._hasBegun=false;
			this._numVertsPerPrimitive=0;
			this._renderState=null;
			this._sharderNameID=0;
			this._shader=null;
			this._shaderCompile=null;
			this._vbData=new Float32Array(this._defaultBufferSize);
			this._ibData=new Uint16Array(this._defaultBufferSize);
			this._spriteShaderValue=new ValusArray();
			;
			this._vb=VertexBuffer3D.create(PhasorSpriter3D._vertexDeclaration,this._defaultBufferSize/this._floatSizePerVer,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this._ib=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._defaultBufferSize,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this._sharderNameID=Shader3D.nameKey.getID("LINE");
			this._shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
		}

		__class(PhasorSpriter3D,'laya.d3.core.PhasorSpriter3D');
		var __proto=PhasorSpriter3D.prototype;
		__proto.line=function(startX,startY,startZ,startR,startG,startB,startA,endX,endY,endZ,endR,endG,endB,endA){
			if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.LINES*/0x0001)
				this.drawLinesException();
			if (this._posInVBData+2 *this._floatSizePerVer > this._vbData.length || this._posInIBData+2 > this._ibData.length)
				this.flush();
			this._tempUint0=this._posInVBData / this._floatSizePerVer;
			this.addVertex(startX,startY,startZ,startR,startG,startB,startA);
			this.addVertex(endX,endY,endZ,endR,endG,endB,endA);
			this.addIndexes(this._tempUint0,this._tempUint0+1);
			return this;
		}

		__proto.circle=function(radius,numberOfPoints,r,g,b,a){
			if (!this._hasBegun || (this._primitiveType!==/*laya.webgl.WebGLContext.LINES*/0x0001))
				this.drawLinesException();
			this._tempUint0=numberOfPoints *2;
			if (this._posInVBData+this._tempUint0 *this._floatSizePerVer > this._vbData.length || this._posInIBData+2 *this._tempUint0 > this._ibData.length)
				this.flush();
			this._tempUint1=this._posInVBData / this._floatSizePerVer;
			for (this._tempNumver0=0,this._tempInt0=0;this._tempNumver0 < 3.1416 *2;this._tempNumver0=this._tempNumver0+(3.1416 / numberOfPoints),this._tempInt0++){
				this.addVertex(Math.sin(this._tempNumver0)*radius,Math.cos(this._tempNumver0)*radius,0,r,g,b,a);
				if (this._tempInt0===0){
					this.addIndexes(this._tempUint1);
					}else if (this._tempInt0===this._tempUint0-1){
					this._tempUint2=this._tempUint1+this._tempInt0;
					this.addIndexes(this._tempUint2,this._tempUint2,this._tempUint1);
					}else {
					this._tempUint2=this._tempUint1+this._tempInt0;
					this.addIndexes(this._tempUint2,this._tempUint2);
				}
			}
			return this;
		}

		__proto.plane=function(positionX,positionY,positionZ,width,height,r,g,b,a){
			if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.TRIANGLES*/0x0004)
				this.drawTrianglesException();
			if (this._posInVBData+4 *this._floatSizePerVer > this._vbData.length || this._posInIBData+6 > this._ibData.length)
				this.flush();
			this._tempNumver0=width / 2;
			this._tempNumver1=height / 2;
			this._tempUint0=this._posInVBData / this._floatSizePerVer;
			this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ,r,g,b,a);
			this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ,r,g,b,a);
			this._tempUint1=this._tempUint0+1;
			this._tempUint2=this._tempUint0+2;
			this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint2,this._tempUint2,this._tempUint1,this._tempUint0+3);
			return this;
		}

		__proto.box=function(positionX,positionY,positionZ,width,height,depth,r,g,b,a){
			if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.TRIANGLES*/0x0004)
				this.drawTrianglesException();
			if (this._posInVBData+8 *this._floatSizePerVer > this._vbData.length || this._posInIBData+36 > this._ibData.length)
				this.flush();
			this._tempNumver0=width / 2;
			this._tempNumver1=height / 2;
			this._tempNumver2=depth / 2;
			this._tempUint0=this._posInVBData / this._floatSizePerVer;
			this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
			this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ+this._tempNumver2,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY+this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
			this.addVertex(positionX-this._tempNumver0,positionY+this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
			this.addVertex(positionX+this._tempNumver0,positionY-this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
			this.addVertex(positionX-this._tempNumver0,positionY-this._tempNumver1,positionZ-this._tempNumver2,r,g,b,a);
			this._tempUint1=this._tempUint0+1;
			this._tempUint2=this._tempUint0+2;
			this._tempUint3=this._tempUint0+3;
			this._tempUint4=this._tempUint0+4;
			this._tempUint5=this._tempUint0+5;
			this._tempUint6=this._tempUint0+6;
			this._tempUint7=this._tempUint0+7;
			this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint2,this._tempUint2,this._tempUint1,this._tempUint3,
			this._tempUint4,this._tempUint5,this._tempUint6,this._tempUint6,this._tempUint5,this._tempUint7,
			this._tempUint5,this._tempUint0,this._tempUint7,this._tempUint7,this._tempUint0,this._tempUint2,
			this._tempUint1,this._tempUint4,this._tempUint3,this._tempUint3,this._tempUint4,this._tempUint6,
			this._tempUint5,this._tempUint4,this._tempUint0,this._tempUint0,this._tempUint4,this._tempUint1,
			this._tempUint2,this._tempUint3,this._tempUint7,this._tempUint7,this._tempUint3,this._tempUint6);
			return this;
		}

		__proto.cone=function(radius,length,Slices,r,g,b,a){
			if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.TRIANGLES*/0x0004)
				this.drawTrianglesException();
			if (this._posInVBData+(2 *Slices+2)*this._floatSizePerVer > this._vbData.length || this._posInIBData+6 *Slices > this._ibData.length)
				this.flush();
			this._tempUint0=this._posInVBData;
			this._tempUint1=this._posInVBData / this._floatSizePerVer;
			this._tempNumver0=Math.PI *2 / Slices;
			this.addVertexIndex(0,length,0,r,g,b,a,this._tempUint0);
			this.addVertexIndex(0,0,0,r,g,b,a,this._tempUint0+this._floatSizePerVer);
			this._tempInt0=2;
			this._tempNumver1=0;
			for (this._tempInt1=0;this._tempInt1 < Slices;this._tempInt1++){
				this._tempNumver2=Math.cos(this._tempNumver1);
				this._tempNumver3=Math.sin(this._tempNumver1);
				this.addVertexIndex(radius *this._tempNumver2,0,radius *this._tempNumver3,r,g,b,a,this._tempUint0+this._tempInt0 *this._floatSizePerVer);
				this.addIndexes(this._tempUint1,this._tempUint1+this._tempInt0);
				if (this._tempInt1==Slices-1)
					this.addIndexes(this._tempUint1+2);
				else
				this.addIndexes(this._tempUint1+this._tempInt0+1);
				this.addVertexIndex(radius *this._tempNumver2,0,radius *this._tempNumver3,r,g,b,a,this._tempUint0+(this._tempInt0+Slices)*this._floatSizePerVer);
				this.addIndexes(this._tempUint1+1);
				if (this._tempInt1==Slices-1)
					this.addIndexes(this._tempUint1+Slices+2);
				else
				this.addIndexes(this._tempUint1+this._tempInt0+Slices+1);
				this.addIndexes(this._tempUint1+this._tempInt0+Slices);
				this._tempInt0++;
				this._tempNumver1+=this._tempNumver0;
			}
			return this;
		}

		__proto.boundingBoxLine=function(minX,minY,minZ,maxX,maxY,maxZ,r,g,b,a){
			if (!this._hasBegun || this._primitiveType!==/*laya.webgl.WebGLContext.LINES*/0x0001)
				this.drawLinesException();
			if (this._posInVBData+8 *this._floatSizePerVer > this._vbData.length || this._posInIBData+48 > this._ibData.length)
				this.flush();
			this._tempUint0=this._posInVBData / this._floatSizePerVer;
			this.addVertex(minX,maxY,maxZ,r,g,b,a);
			this.addVertex(maxX,maxY,maxZ,r,g,b,a);
			this.addVertex(minX,minY,maxZ,r,g,b,a);
			this.addVertex(maxX,minY,maxZ,r,g,b,a);
			this.addVertex(maxX,maxY,minZ,r,g,b,a);
			this.addVertex(minX,maxY,minZ,r,g,b,a);
			this.addVertex(maxX,minY,minZ,r,g,b,a);
			this.addVertex(minX,minY,minZ,r,g,b,a);
			this._tempUint1=this._tempUint0+1;
			this._tempUint2=this._tempUint0+2;
			this._tempUint3=this._tempUint0+3;
			this._tempUint4=this._tempUint0+4;
			this._tempUint5=this._tempUint0+5;
			this._tempUint6=this._tempUint0+6;
			this._tempUint7=this._tempUint0+7;
			this.addIndexes(this._tempUint0,this._tempUint1,this._tempUint1,this._tempUint3,this._tempUint3,this._tempUint2,this._tempUint2,this._tempUint0,
			this._tempUint4,this._tempUint5,this._tempUint5,this._tempUint7,this._tempUint7,this._tempUint6,this._tempUint6,this._tempUint4,
			this._tempUint5,this._tempUint0,this._tempUint0,this._tempUint2,this._tempUint2,this._tempUint7,this._tempUint7,this._tempUint5,
			this._tempUint1,this._tempUint4,this._tempUint4,this._tempUint6,this._tempUint6,this._tempUint3,this._tempUint3,this._tempUint1,
			this._tempUint5,this._tempUint4,this._tempUint4,this._tempUint1,this._tempUint1,this._tempUint0,this._tempUint0,this._tempUint5,
			this._tempUint2,this._tempUint3,this._tempUint3,this._tempUint6,this._tempUint6,this._tempUint7,this._tempUint7,this._tempUint2);
			return this;
		}

		__proto.addVertex=function(x,y,z,r,g,b,a){
			if (!this._hasBegun)
				this.addVertexIndexException();
			this._vbData[this._posInVBData]=x,this._vbData[this._posInVBData+1]=y,this._vbData[this._posInVBData+2]=z;
			this._vbData[this._posInVBData+3]=r,this._vbData[this._posInVBData+4]=g,this._vbData[this._posInVBData+5]=b,this._vbData[this._posInVBData+6]=a;
			this._posInVBData+=this._floatSizePerVer;
			return this;
		}

		__proto.addVertexIndex=function(x,y,z,r,g,b,a,index){
			if (!this._hasBegun)
				this.addVertexIndexException();
			this._vbData[index]=x,this._vbData[index+1]=y,this._vbData[index+2]=z;
			this._vbData[index+3]=r,this._vbData[index+4]=g,this._vbData[index+5]=b,this._vbData[index+6]=a;
			index+=this._floatSizePerVer;
			if (index > this._posInVBData)
				this._posInVBData=index;
			return this;
		}

		__proto.addIndexes=function(__indexes){
			var indexes=arguments;
			if (!this._hasBegun)
				this.addVertexIndexException();
			for (var i=0;i < indexes.length;i++){
				this._ibData[this._posInIBData]=indexes[i];
				this._posInIBData++;
			}
			return this;
		}

		__proto.begin=function(primitive,state){
			if (this._hasBegun)
				this.beginException0();
			if (primitive!==/*laya.webgl.WebGLContext.LINES*/0x0001 && primitive!==/*laya.webgl.WebGLContext.TRIANGLES*/0x0004)
				this.beginException1();
			this._primitiveType=primitive;
			this._renderState=state;
			this._hasBegun=true;
			return this;
		}

		__proto.end=function(){
			if (!this._hasBegun)
				this.endException();
			this.flush();
			this._hasBegun=false;
			return this;
		}

		__proto.flush=function(){
			if (this._posInVBData===0)
				return;
			this._ib.setData(this._ibData);
			this._vb.setData(this._vbData);
			this._vb._bind();
			this._ib._bind();
			this._shader=this._getShader(this._renderState);
			this._shader.bind();
			this._shader.uploadAttributes(PhasorSpriter3D._vertexDeclaration.shaderValues.data,null);
			this._spriteShaderValue.setValue(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,this._renderState._projectionViewMatrix.elements);
			this._shader.uploadSpriteUniforms(this._spriteShaderValue.data);
			Stat.drawCall++;
			WebGL.mainContext.drawElements(this._primitiveType,this._posInIBData,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
			this._posInIBData=0;
			this._posInVBData=0;
		}

		__proto._getShader=function(state){
			var defineValue=state.scene._shaderDefineValue;
			return this._shaderCompile.withCompile(this._sharderNameID,defineValue,0,0);
		}

		__proto.addVertexIndexException=function(){
			throw new Error("请先调用begin()函数");
		}

		__proto.beginException0=function(){
			throw new Error("调用begin()前请确保已成功调用end()！");
		}

		__proto.beginException1=function(){
			throw new Error("只支持“LINES”和“TRIANGLES”两种基元！");
		}

		__proto.endException=function(){
			throw new Error("调用end()前请确保已成功调用begin()！");
		}

		__proto.drawLinesException=function(){
			throw new Error("您必须确保在此之前已调用begin()且使用“LINES”基元！");
		}

		__proto.drawTrianglesException=function(){
			throw new Error("您必须确保在此之前已调用begin()且使用“TRIANGLES”基元！");
		}

		__static(PhasorSpriter3D,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(28,[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1)]);}
		]);
		return PhasorSpriter3D;
	})()


	/**
	*@private
	*<code>RenderElement</code> 类用于实现渲染物体。
	*/
	//class laya.d3.core.render.RenderElement
	var RenderElement=(function(){
		function RenderElement(){
			this._type=0;
			this._mainSortID=0;
			this._render=null;
			this._sprite3D=null;
			this._material=null;
			this._renderObj=null;
			this._staticBatch=null;
			this._batchIndexStart=0;
			this._batchIndexEnd=0;
			this._canDynamicBatch=false;
			this._shaderValue=null;
			this._onPreRenderFunction=null;
			this._conchSubmesh=null;
			this._canDynamicBatch=true;
			this._shaderValue=new ValusArray();
			if (Render.isConchNode){
				this._conchSubmesh=/*__JS__ */new ConchSubmesh();
			}
		}

		__class(RenderElement,'laya.d3.core.render.RenderElement');
		var __proto=RenderElement.prototype;
		/**
		*@private
		*/
		__proto.getStaticBatchBakedVertexs=function(index){
			var byteSizeInFloat=4;
			var vertexBuffer=this._renderObj._getVertexBuffer(index);
			var vertexDeclaration=vertexBuffer.vertexDeclaration;
			var positionOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.POSITION0*/0).offset / byteSizeInFloat;
			var normalOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3).offset / byteSizeInFloat;
			var owner=this._render._owner;
			var lightmapScaleOffset=(owner).meshRender.lightmapScaleOffset;
			var i=0,n=0,bakedVertexes,bakedVertexFloatCount=0,lightingMapTexcoordOffset=0,uv1Element;
			var uv0Offset=0,oriVertexFloatCount=0;
			if (lightmapScaleOffset){
				uv1Element=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15);
				if (uv1Element){
					bakedVertexFloatCount=vertexDeclaration.vertexStride / byteSizeInFloat;
					bakedVertexes=vertexBuffer.getData().slice();
					lightingMapTexcoordOffset=uv1Element.offset / byteSizeInFloat;
					}else {
					oriVertexFloatCount=vertexDeclaration.vertexStride / byteSizeInFloat;
					bakedVertexFloatCount=oriVertexFloatCount+2;
					bakedVertexes=new Float32Array(vertexBuffer.vertexCount *(vertexBuffer.vertexDeclaration.vertexStride / byteSizeInFloat+2));
					uv0Offset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2).offset / byteSizeInFloat;
					lightingMapTexcoordOffset=uv0Offset+2;
					var oriVertexes=vertexBuffer.getData();
					for (i=0,n=oriVertexes.length / oriVertexFloatCount;i < n;i++){
						var oriVertexOffset=i *oriVertexFloatCount;
						var bakedVertexOffset=i *bakedVertexFloatCount;
						var j=0;
						for (j=0;j < lightingMapTexcoordOffset;j++)
						bakedVertexes[bakedVertexOffset+j]=oriVertexes[oriVertexOffset+j];
						for (j=lightingMapTexcoordOffset;j < oriVertexFloatCount;j++)
						bakedVertexes[bakedVertexOffset+j+2]=oriVertexes[oriVertexOffset+j];
					}
				}
				}else {
				bakedVertexFloatCount=vertexDeclaration.vertexStride / byteSizeInFloat;
				bakedVertexes=vertexBuffer.getData().slice();
			};
			var rootTransform=this._staticBatch._rootSprite.transform.worldMatrix;
			var transform=this._sprite3D.transform.worldMatrix;
			var rootInvertMat=RenderElement._tempMatrix4x40;
			var result=RenderElement._tempMatrix4x41;
			rootTransform.invert(rootInvertMat);
			Matrix4x4.multiply(rootInvertMat,transform,result);
			var rotation=RenderElement._tempQuaternion0;
			result.decomposeTransRotScale(RenderElement._tempVector30,rotation,RenderElement._tempVector31);
			for (i=0,n=bakedVertexes.length / bakedVertexFloatCount;i < n;i++){
				var posOffset=i *bakedVertexFloatCount+positionOffset;
				var norOffset=i *bakedVertexFloatCount+normalOffset;
				Utils3D.transformVector3ArrayToVector3ArrayCoordinate(bakedVertexes,posOffset,result,bakedVertexes,posOffset);
				Utils3D.transformVector3ArrayByQuat(bakedVertexes,norOffset,rotation,bakedVertexes,norOffset);
				if ((owner instanceof laya.d3.core.MeshSprite3D )&& lightmapScaleOffset){
					var lightingMapTexOffset=i *bakedVertexFloatCount+lightingMapTexcoordOffset;
					if (uv1Element){
						Utils3D.transformLightingMapTexcoordByUV1Array(bakedVertexes,lightingMapTexOffset,lightmapScaleOffset,bakedVertexes,lightingMapTexOffset);
						}else {
						var tex0Offset=i *oriVertexFloatCount+uv0Offset;
						Utils3D.transformLightingMapTexcoordByUV0Array(oriVertexes,tex0Offset,lightmapScaleOffset,bakedVertexes,lightingMapTexOffset);
					}
				}
			}
			return bakedVertexes;
		}

		/**
		*@private
		*/
		__proto.getDynamicBatchBakedVertexs=function(index){
			var byteSizeInFloat=4;
			var vb=this._renderObj._getVertexBuffer(index);
			var bakedVertexes=vb.getData().slice();
			var vertexDeclaration=vb.vertexDeclaration;
			var positionOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.POSITION0*/0).offset / byteSizeInFloat;
			var normalOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3).offset / byteSizeInFloat;
			var transform=this._sprite3D.transform;
			var worldMatrix=transform.worldMatrix;
			var rotation=transform.rotation;
			var vertexFloatCount=vertexDeclaration.vertexStride / byteSizeInFloat;
			for (var i=0,n=bakedVertexes.length;i < n;i+=vertexFloatCount){
				var posOffset=i+positionOffset;
				var norOffset=i+normalOffset;
				Utils3D.transformVector3ArrayToVector3ArrayCoordinate(bakedVertexes,posOffset,worldMatrix,bakedVertexes,posOffset);
				Utils3D.transformVector3ArrayByQuat(bakedVertexes,norOffset,rotation,bakedVertexes,norOffset);
			}
			return bakedVertexes;
		}

		/**
		*@private
		*/
		__proto.getBakedIndices=function(){
			return this._renderObj._getIndexBuffer().getData();
		}

		/**NATIVE*/
		__getset(0,__proto,'renderObj',function(){
			return this._renderObj;
			},function(value){
			if (this._renderObj!==value){
				this._renderObj=value;
			}
		});

		__static(RenderElement,
		['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempMatrix4x41',function(){return this._tempMatrix4x41=new Matrix4x4();}
		]);
		return RenderElement;
	})()


	/**
	*@private
	*<code>RenderQuene</code> 类用于实现渲染队列。
	*/
	//class laya.d3.core.render.RenderQueue
	var RenderQueue=(function(){
		function RenderQueue(scene){
			this._id=0;
			this._needSort=false;
			this._renderElements=null;
			this._staticBatches=null;
			this._renderableRenderObjects=null;
			this._staticBatchCombineRenderElements=null;
			this._dynamicBatchCombineRenderElements=null;
			this._finalElements=null;
			this._scene=null;
			this._id=++RenderQueue._uniqueIDCounter;
			this._needSort=false;
			this._scene=scene;
			this._renderElements=[];
			this._renderableRenderObjects=[];
			this._staticBatchCombineRenderElements=[];
			this._dynamicBatchCombineRenderElements=[];
			this._staticBatches=[];
		}

		__class(RenderQueue,'laya.d3.core.render.RenderQueue');
		var __proto=RenderQueue.prototype;
		__proto._sortOpaqueFunc=function(a,b){
			if (a._render && b._render)
				return a._render._distanceForSort-b._render._distanceForSort;
			else
			return 0;
		}

		__proto._sortAlphaFunc=function(a,b){
			if (a._render && b._render)
				return b._render._distanceForSort-a._render._distanceForSort;
			else
			return 0;
		}

		/**
		*@private
		*/
		__proto._begainRenderElement=function(state,renderObj,material){
			if (renderObj._beforeRender(state)){
				return true;
			}
			return false;
		}

		/**
		*@private
		*更新组件preRenderUpdate函数
		*@param state 渲染相关状态
		*/
		__proto._preRenderUpdateComponents=function(sprite3D,state){
			for (var i=0;i < sprite3D.componentsCount;i++){
				var component=sprite3D.getComponentByIndex(i);
				(!component.started)&& (component._start(state),component.started=true);
				(component.enable)&& (component._preRenderUpdate(state));
			}
		}

		/**
		*@private
		*更新组件postRenderUpdate函数
		*@param state 渲染相关状态
		*/
		__proto._postRenderUpdateComponents=function(sprite3D,state){
			for (var i=0;i < sprite3D.componentsCount;i++){
				var component=sprite3D.getComponentByIndex(i);
				(!component.started)&& (component._start(state),component.started=true);
				(component.enable)&& (component._postRenderUpdate(state));
			}
		}

		/**
		*@private
		*/
		__proto._sortAlpha=function(cameraPos){
			RenderQueue._cameraPosition=cameraPos;
			this._finalElements.sort(this._sortAlphaFunc);
		}

		/**
		*@private
		*/
		__proto._sortOpaque=function(cameraPos){
			RenderQueue._cameraPosition=cameraPos;
			this._finalElements.sort(this._sortOpaqueFunc);
		}

		/**
		*@private
		*准备渲染队列。
		*@param state 渲染状态。
		*/
		__proto._preRender=function(state){
			this._staticBatchCombineRenderElements.length=0;
			for (var i=0,n=this._staticBatches.length;i < n;i++)
			this._staticBatches[i]._getRenderElement(this._staticBatchCombineRenderElements);
			this._finalElements=this._renderElements.concat(this._staticBatchCombineRenderElements,this._dynamicBatchCombineRenderElements);
		}

		/**
		*@private
		*渲染队列。
		*@param state 渲染状态。
		*/
		__proto._render=function(state,isTarget){
			var loopCount=Stat.loopCount;
			var scene=this._scene;
			var camera=state.camera;
			var cameraID=camera.id;
			var vertexBuffer,vertexDeclaration,shader;
			var forceUploadParams=false;
			var lastStateMaterial,lastStateOwner;
			for (var i=0,n=this._finalElements.length;i < n;i++){
				var renderElement=this._finalElements[i];
				var renderObj,material,owner;
				if (renderElement._onPreRenderFunction!=null){
					renderElement._onPreRenderFunction.call(renderElement._sprite3D,state);
				}
				if (renderElement._type===0){
					state.owner=owner=renderElement._sprite3D;
					state.renderElement=renderElement;
					this._preRenderUpdateComponents(owner,state);
					renderObj=renderElement.renderObj,material=renderElement._material;
					if (this._begainRenderElement(state,renderObj,material)){
						vertexBuffer=renderObj._getVertexBuffer(0);
						vertexDeclaration=vertexBuffer.vertexDeclaration;
						shader=state._shader=material._getShader(scene._shaderDefineValue,vertexDeclaration.shaderDefineValue,owner._shaderDefineValue);
						forceUploadParams=shader.bind()|| (loopCount!==shader._uploadLoopCount);
						if (shader._uploadVertexBuffer!==vertexBuffer || forceUploadParams){
							shader.uploadAttributes(vertexDeclaration.shaderValues.data,null);
							shader._uploadVertexBuffer=vertexBuffer;
						}
						if (shader._uploadScene!==scene || forceUploadParams){
							shader.uploadSceneUniforms(scene._shaderValues.data);
							shader._uploadScene=scene;
						}
						if (camera!==shader._uploadCamera || shader._uploadSprite3D!==owner || forceUploadParams){
							shader.uploadSpriteUniforms(owner._shaderValues.data);
							shader._uploadSprite3D=owner;
						}
						if (camera!==shader._uploadCamera || forceUploadParams){
							shader.uploadCameraUniforms(camera._shaderValues.data);
							shader._uploadCamera=camera;
						}
						if (shader._uploadMaterial!==material || forceUploadParams){
							material._setMaterialShaderParams(state);
							material._upload();
							shader._uploadMaterial=material;
						}
						if (lastStateMaterial!==material){
							material._setRenderStateBlendDepth();
							material._setRenderStateFrontFace(isTarget,owner.transform);
							lastStateMaterial=material;
							lastStateOwner=owner;
							}else {
							if (lastStateOwner!==owner){
								material._setRenderStateFrontFace(isTarget,owner.transform);
								lastStateOwner=owner;
							}
						}
						renderObj._render(state);
						shader._uploadLoopCount=loopCount;
					}
					this._postRenderUpdateComponents(owner,state);
					}else if (renderElement._type===1){
					var staticBatch=renderElement.renderObj;
					state.owner=owner=staticBatch._rootSprite;
					state.renderElement=renderElement;
					state._batchIndexStart=renderElement._batchIndexStart;
					state._batchIndexEnd=renderElement._batchIndexEnd;
					renderObj=renderElement.renderObj,material=renderElement._material;
					if (this._begainRenderElement(state,renderObj,material)){
						vertexBuffer=renderObj._getVertexBuffer(0);
						vertexDeclaration=vertexBuffer.vertexDeclaration;
						shader=state._shader=material._getShader(scene._shaderDefineValue,vertexDeclaration.shaderDefineValue,owner._shaderDefineValue);
						forceUploadParams=shader.bind()|| (loopCount!==shader._uploadLoopCount);
						if (shader._uploadVertexBuffer!==vertexBuffer || forceUploadParams){
							shader.uploadAttributes(vertexDeclaration.shaderValues.data,null);
							shader._uploadVertexBuffer=vertexBuffer;
						}
						if (shader._uploadScene!==scene || forceUploadParams){
							shader.uploadSceneUniforms(scene._shaderValues.data);
							shader._uploadScene=scene;
						}
						if (camera!==shader._uploadCamera || shader._uploadSprite3D!==owner || forceUploadParams){
							shader.uploadSpriteUniforms(owner._shaderValues.data);
							shader._uploadSprite3D=owner;
						}
						if (camera!==shader._uploadCamera || forceUploadParams){
							shader.uploadCameraUniforms(camera._shaderValues.data);
							shader._uploadCamera=camera;
						}
						if (shader._uploadMaterial!==material || forceUploadParams){
							material._setMaterialShaderParams(state);
							material._upload();
							shader._uploadMaterial=material;
						}
						if (lastStateMaterial!==material){
							material._setRenderStateBlendDepth();
							material._setRenderStateFrontFace(isTarget,owner.transform);
							lastStateMaterial=material;
							lastStateOwner=owner;
							}else {
							if (lastStateOwner!==owner){
								material._setRenderStateFrontFace(isTarget,owner.transform);
								lastStateOwner=owner;
							}
						}
						renderObj._render(state);
						shader._uploadLoopCount=loopCount;
					}
					}else if (renderElement._type===2){
					var dynamicBatch=renderElement.renderObj;
					state.owner=owner=renderElement._sprite3D;
					state.renderElement=renderElement;
					state._batchIndexStart=renderElement._batchIndexStart;
					state._batchIndexEnd=renderElement._batchIndexEnd;
					renderObj=renderElement.renderObj,material=renderElement._material;
					if (this._begainRenderElement(state,renderObj,material)){
						vertexBuffer=renderObj._getVertexBuffer(0);
						vertexDeclaration=vertexBuffer.vertexDeclaration;
						shader=state._shader=material._getShader(scene._shaderDefineValue,vertexDeclaration.shaderDefineValue,owner._shaderDefineValue);
						forceUploadParams=shader.bind()|| (loopCount!==shader._uploadLoopCount);
						if (shader._uploadVertexBuffer!==vertexBuffer || forceUploadParams){
							shader.uploadAttributes(vertexDeclaration.shaderValues.data,null);
							shader._uploadVertexBuffer=vertexBuffer;
						}
						if (shader._uploadScene!==scene || forceUploadParams){
							shader.uploadSceneUniforms(scene._shaderValues.data);
							shader._uploadScene=scene;
						}
						if (camera!==shader._uploadCamera || shader._uploadSprite3D!==owner || forceUploadParams){
							shader.uploadSpriteUniforms(owner._shaderValues.data);
							shader._uploadSprite3D=owner;
						}
						if (camera!==shader._uploadCamera || forceUploadParams){
							shader.uploadCameraUniforms(camera._shaderValues.data);
							shader._uploadCamera=camera;
						}
						if (shader._uploadMaterial!==material || forceUploadParams){
							material._setMaterialShaderParams(state);
							material._upload();
							shader._uploadMaterial=material;
						}
						if (lastStateMaterial!==material){
							material._setRenderStateBlendDepth();
							material._setRenderStateFrontFace(isTarget,owner.transform);
							lastStateMaterial=material;
							lastStateOwner=owner;
							}else {
							if (lastStateOwner!==owner){
								material._setRenderStateFrontFace(isTarget,owner.transform);
								lastStateOwner=owner;
							}
						}
						renderObj._render(state);
						shader._uploadLoopCount=loopCount;
					}
				}
			}
		}

		/**
		*@private
		*渲染队列。
		*@param state 渲染状态。
		*/
		__proto._renderShadow=function(state,isOnePSSM){
			var loopCount=Stat.loopCount;
			var scene=this._scene;
			var camera=state.camera;
			var vertexBuffer,vertexDeclaration,shader;
			var forceUploadParams=false;
			var lastStateMaterial,lastStateOwner;
			for (var i=0,n=this._finalElements.length;i < n;i++){
				var renderElement=this._finalElements[i];
				var renderObj,material,owner;
				if (renderElement._type===0){
					state.owner=owner=renderElement._sprite3D;
					if (!isOnePSSM && (owner._projectionViewWorldUpdateCamera!==camera || owner._projectionViewWorldUpdateLoopCount!==Stat.loopCount)){
						owner._renderUpdate(state._projectionViewMatrix);
						owner._projectionViewWorldUpdateLoopCount=Stat.loopCount;
						owner._projectionViewWorldUpdateCamera=camera;
					}
					state.renderElement=renderElement;
					this._preRenderUpdateComponents(owner,state);
					renderObj=renderElement.renderObj,material=renderElement._material;
					if (this._begainRenderElement(state,renderObj,null)){
						vertexBuffer=renderObj._getVertexBuffer(0);
						vertexDeclaration=vertexBuffer.vertexDeclaration;
						shader=material._getShader(scene._shaderDefineValue,vertexDeclaration.shaderDefineValue,owner._shaderDefineValue);
						forceUploadParams=shader.bind()|| (loopCount!==shader._uploadLoopCount);
						if (shader._uploadVertexBuffer!==vertexBuffer || forceUploadParams){
							shader.uploadAttributes(vertexDeclaration.shaderValues.data,null);
							shader._uploadVertexBuffer=vertexBuffer;
						}
						if (camera!==shader._uploadCamera || shader._uploadSprite3D!==owner || forceUploadParams){
							shader.uploadSpriteUniforms(owner._shaderValues.data);
							shader._uploadSprite3D=owner;
						}
						if (camera!==shader._uploadCamera || forceUploadParams){
							shader.uploadCameraUniforms(camera._shaderValues.data);
							shader._uploadCamera=camera;
						}
						if (shader._uploadMaterial!==material || forceUploadParams){
							material._setMaterialShaderParams(state);
							material._upload();
							shader._uploadMaterial=material;
						}
						if (shader._uploadRenderElement!==renderElement || forceUploadParams){}
							if (lastStateMaterial!==material){
							material._setRenderStateFrontFace(false,owner.transform);
							lastStateMaterial=material;
							lastStateOwner=owner;
							}else {
							if (lastStateOwner!==owner){
								material._setRenderStateFrontFace(false,owner.transform);
								lastStateOwner=owner;
							}
						}
						renderObj._render(state);
						shader._uploadLoopCount=loopCount;
					}
					this._postRenderUpdateComponents(owner,state);
				}
			}
		}

		/**
		*清空队列中的渲染物体。
		*/
		__proto._clearRenderElements=function(){
			this._staticBatches.length=0;
			this._dynamicBatchCombineRenderElements.length=0;
			this._renderElements.length=0;
			this._needSort=true;
		}

		/**
		*添加渲染物体。
		*@param renderObj 渲染物体。
		*/
		__proto._addRenderElement=function(renderElement){
			this._renderElements.push(renderElement);
			this._needSort=true;
		}

		/**
		*添加静态批处理。
		*@param renderObj 静态批处理。
		*/
		__proto._addStaticBatch=function(staticBatch){
			this._staticBatches.push(staticBatch)
		}

		/**
		*添加动态批处理。
		*@param renderObj 动态批处理。
		*/
		__proto._addDynamicBatchElement=function(dynamicBatchElement){
			this._dynamicBatchCombineRenderElements.push(dynamicBatchElement);
		}

		/**
		*获取唯一标识ID(通常用于优化或识别)。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		RenderQueue._uniqueIDCounter=0;
		RenderQueue.OPAQUE=1;
		RenderQueue.TRANSPARENT=2;
		RenderQueue._cameraPosition=null
		return RenderQueue;
	})()


	/**
	*<code>RenderState</code> 类用于实现渲染状态。
	*/
	//class laya.d3.core.render.RenderState
	var RenderState=(function(){
		function RenderState(){
			this._staticBatch=null;
			this._batchIndexStart=0;
			this._batchIndexEnd=0;
			this._viewMatrix=null;
			this._projectionMatrix=null;
			this._projectionViewMatrix=null;
			this._viewport=null;
			this._boundFrustum=null;
			this._shader=null;
			this.elapsedTime=NaN;
			this.scene=null;
			this.owner=null;
			this.renderElement=null;
			this.camera=null;
			this.cameraBoundingFrustum=null;
		}

		__class(RenderState,'laya.d3.core.render.RenderState');
		RenderState.clientWidth=0;
		RenderState.clientHeight=0;
		return RenderState;
	})()


	//class laya.d3.core.scene.OctreeNode
	var OctreeNode=(function(){
		function OctreeNode(scene,currentDepth){
			this._exactBox=null;
			this._relaxBox=null;
			this._scene=null;
			this._parent=null;
			this._currentDepth=0;
			this._boundingSphere=new BoundSphere(new Vector3(),0);
			this._corners=[];
			this._boundingBoxCenter=new Vector3();
			this._children=__newvec(8);
			this._objects=[];
			this._tempBoundBoxCorners=[];
			this._scene=scene;
			this._currentDepth=currentDepth;
		}

		__class(OctreeNode,'laya.d3.core.scene.OctreeNode');
		var __proto=OctreeNode.prototype;
		Laya.imps(__proto,{"laya.d3.core.scene.ITreeNode":true})
		__proto.init=function(center,treeSize){
			var min=new Vector3();
			var max=new Vector3();
			Vector3.scale(treeSize,-0.5,min);
			Vector3.scale(treeSize,0.5,max);
			Vector3.add(min,center,min);
			Vector3.add(max,center,max);
			this.exactBox=new BoundBox(min,max);
			this.relaxBox=new BoundBox(min,max);
		}

		__proto.addTreeNode=function(render){
			if (Collision.boxContainsBox(this._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1)
				this.addNodeDown(render,0);
			else
			this.addObject(render);
		}

		__proto.addChild=function(index){
			var child=this._children[index];
			if (child==null){
				child=new OctreeNode(this._scene,this._currentDepth+1);
				this._children[index]=child;
				child._parent=this;
				Vector3.subtract(this._exactBox.max,this._exactBox.min,OctreeNode.tempSize);
				Vector3.multiply(OctreeNode.tempSize,OctreeNode._octreeSplit[index],OctreeNode.tempCenter);
				Vector3.add(this._exactBox.min,OctreeNode.tempCenter,OctreeNode.tempCenter);
				Vector3.scale(OctreeNode.tempSize,0.25,OctreeNode.tempSize);
				var min=new Vector3();
				var max=new Vector3();
				Vector3.subtract(OctreeNode.tempCenter,OctreeNode.tempSize,min);
				Vector3.add(OctreeNode.tempCenter,OctreeNode.tempSize,max);
				child.exactBox=new BoundBox(min,max);
				Vector3.scale(OctreeNode.tempSize,OctreeNode.relax,OctreeNode.tempSize);
				var relaxMin=new Vector3();
				var relaxMax=new Vector3();
				Vector3.subtract(OctreeNode.tempCenter,OctreeNode.tempSize,relaxMin);
				Vector3.add(OctreeNode.tempCenter,OctreeNode.tempSize,relaxMax);
				child.relaxBox=new BoundBox(relaxMin,relaxMax);
			}
			return child;
		}

		__proto.addObject=function(object){
			object._treeNode=this;
			this._objects.push(object);
		}

		__proto.removeObject=function(object){
			if (object._treeNode !=this){
				console.log("OctreeNode::removeObject error");
				return false;
			};
			var index=this._objects.indexOf(object);
			if (index!==-1){
				this._objects.splice(index,1);
				return true;
			}
			return false;
		}

		__proto.clearObject=function(){
			this._objects.length=0;
		}

		__proto.addNodeUp=function(render,depth){
			if (this._parent && (Collision.boxContainsBox(this._exactBox,render.boundingBox)!==/*laya.d3.math.ContainmentType.Contains*/1)){
				this._parent.addNodeUp(render,depth-1);
			}else
			this.addNodeDown(render,depth);
		}

		__proto.addNodeDown=function(render,depth){
			if (depth < this._scene.treeLevel){
				var childIndex=this.inChildIndex(render.boundingBoxCenter);
				var child=this.addChild(childIndex);
				if (Collision.boxContainsBox(child._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1){
					child.addNodeDown(render,++depth);
				}else
				this.addObject(render);
				}else {
				this.addObject(render);
			}
		}

		__proto.inChildIndex=function(objectCenter){
			var z=objectCenter.z < this._boundingBoxCenter.z ? 0 :1;
			var y=objectCenter.y < this._boundingBoxCenter.y ? 0 :1;
			var x=objectCenter.x < this._boundingBoxCenter.x ? 0 :1;
			return z *4+y *2+x;
		}

		__proto.updateObject=function(render){
			if (Collision.boxContainsBox(this._relaxBox,render.boundingBox)===/*laya.d3.math.ContainmentType.Contains*/1){
				this.removeObject(render);
				render._treeNode=null;
				this.addNodeDown(render,this._currentDepth);
				}else if (this._parent){
				this.removeObject(render);
				render._treeNode=null;
				this._parent.addNodeUp(render,this._currentDepth-1);
			}
		}

		__proto.cullingObjects=function(boundFrustum,testVisible,flags,cameraPosition,projectionView){
			var i=0,j=0,n=0,m=0;
			var dynamicBatchManager=this._scene._dynamicBatchManager;
			for (i=0,n=this._objects.length;i < n;i++){
				var render=this._objects[i];
				if (Layer.isVisible(render._owner.layer.mask)&& render.enable){
					if (testVisible){
						Stat.treeSpriteCollision+=1;
						if (boundFrustum.containsBoundSphere(render.boundingSphere)===/*laya.d3.math.ContainmentType.Disjoint*/0)
							continue ;
					}
					render._owner._renderUpdate(projectionView);
					render._distanceForSort=Vector3.distance(render.boundingSphere.center,cameraPosition)+render.sortingFudge;
					var renderElements=render._renderElements;
					for (j=0,m=renderElements.length;j < m;j++){
						var renderElement=renderElements[j];
						var staticBatch=renderElement._staticBatch;
						if (staticBatch && (staticBatch._material===renderElement._material)){
							staticBatch._addRenderElement(renderElement);
							}else {
							var renderObj=renderElement.renderObj;
							if ((renderObj.triangleCount < /*laya.d3.graphics.DynamicBatch.maxCombineTriangleCount*/50)&& (renderObj._vertexBufferCount===1)&& (renderObj._getIndexBuffer())&& (renderElement._material.renderQueue < 2)&& renderElement._canDynamicBatch && (!render._owner.isStatic))
								dynamicBatchManager._addPrepareRenderElement(renderElement);
							else
							this._scene.getRenderQueue(renderElement._material.renderQueue)._addRenderElement(renderElement);
						}
					}
				}
			}
			for (i=0;i < 8;i++){
				var child=this._children[i];
				if (child==null)
					continue ;
				var testVisibleChild=testVisible;
				if (testVisible){
					var type=boundFrustum.containsBoundBox(child._relaxBox);
					Stat.treeNodeCollision+=1;
					if (type===/*laya.d3.math.ContainmentType.Disjoint*/0)
						continue ;
					testVisibleChild=(type===/*laya.d3.math.ContainmentType.Intersects*/2);
				}
				child.cullingObjects(boundFrustum,testVisibleChild,flags,cameraPosition,projectionView);
			}
		}

		/**
		*@private
		*/
		__proto.cullingShadowObjects=function(lightBoundFrustum,splitShadowQueues,testVisible,flags,scene){
			var i=0,j=0,n=0,m=0;
			var dynamicBatchManager=this._scene._dynamicBatchManager;
			for (i=0,n=this._objects.length;i < n;i++){
				var baseRender=this._objects[i];
				if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
					if (testVisible && lightBoundFrustum[0].containsBoundSphere(baseRender.boundingSphere)===/*laya.d3.math.ContainmentType.Disjoint*/0)
						continue ;
					for (var k=1,kNum=lightBoundFrustum.length;k < kNum;k++){
						var shadowQueue=splitShadowQueues[k-1];
						if (lightBoundFrustum[k].containsBoundSphere(baseRender.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
							var renderElements=baseRender._renderElements;
							for (j=0,m=renderElements.length;j < m;j++)
							shadowQueue._addRenderElement(renderElements[j]);
						}
					}
				}
			}
			for (i=0;i < 8;i++){
				var child=this._children[i];
				if (child==null)
					continue ;
				var testVisibleChild=testVisible;
				if (testVisible){
					var type=lightBoundFrustum[0].containsBoundBox(child._relaxBox);
					if (type===/*laya.d3.math.ContainmentType.Disjoint*/0)
						continue ;
					testVisibleChild=(type===/*laya.d3.math.ContainmentType.Intersects*/2);
				}
				child.cullingShadowObjects(lightBoundFrustum,splitShadowQueues,testVisibleChild,flags,scene);
			}
		}

		/**
		*@private
		*/
		__proto.cullingShadowObjectsOnePSSM=function(lightBoundFrustum,splitShadowQueues,lightViewProjectMatrix,testVisible,flags,scene){
			var shadowQueue=splitShadowQueues[0];
			var i=0,j=0,n=0,m=0;
			for (i=0,n=this._objects.length;i < n;i++){
				var baseRender=this._objects[i];
				if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
					if (testVisible && lightBoundFrustum.containsBoundSphere(baseRender.boundingSphere)===/*laya.d3.math.ContainmentType.Disjoint*/0)
						continue ;
					baseRender._owner._renderUpdate(lightViewProjectMatrix);
					var renderElements=baseRender._renderElements;
					for (j=0,m=renderElements.length;j < m;j++)
					shadowQueue._addRenderElement(renderElements[j]);
				}
			}
			for (i=0;i < 8;i++){
				var child=this._children[i];
				if (child==null)
					continue ;
				var testVisibleChild=testVisible;
				if (testVisible){
					var type=lightBoundFrustum.containsBoundBox(child._relaxBox);
					if (type===/*laya.d3.math.ContainmentType.Disjoint*/0)
						continue ;
					testVisibleChild=(type===/*laya.d3.math.ContainmentType.Intersects*/2);
				}
				child.cullingShadowObjectsOnePSSM(lightBoundFrustum,splitShadowQueues,lightViewProjectMatrix,testVisibleChild,flags,scene);
			}
		}

		__proto.renderBoudingBox=function(linePhasor){
			this._renderBoudingBox(linePhasor);
			for (var i=0;i < 8;++i){
				var pChild=this._children[i];
				if (pChild){
					pChild.renderBoudingBox(linePhasor);
				}
			}
		}

		__proto.buildAllChild=function(depth){
			if (depth < this._scene.treeLevel){
				for (var i=0;i < 8;i++){
					var child=this.addChild(i);
					child.buildAllChild(depth+1);
				}
			}
		}

		__proto._renderBoudingBox=function(linePhasor){}
		__getset(0,__proto,'exactBox',function(){
			return this._exactBox;
			},function(value){
			this._exactBox=value;
			Vector3.add(value.min,value.max,this._boundingBoxCenter);
			Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
		});

		__getset(0,__proto,'relaxBox',function(){
			return this._relaxBox;
			},function(value){
			this._relaxBox=value;
			value.getCorners(this._corners);
			BoundSphere.createfromPoints(this._corners,this._boundingSphere);
		});

		OctreeNode.debugMode=false;
		OctreeNode.relax=1.15;
		OctreeNode.CHILDNUM=8;
		__static(OctreeNode,
		['tempVector0',function(){return this.tempVector0=new Vector3();},'tempSize',function(){return this.tempSize=new Vector3();},'tempCenter',function(){return this.tempCenter=new Vector3();},'_octreeSplit',function(){return this._octreeSplit=[new Vector3(0.250,0.250,0.250),new Vector3(0.750,0.250,0.250),new Vector3(0.250,0.750,0.250),new Vector3(0.750,0.750,0.250),new Vector3(0.250,0.250,0.750),new Vector3(0.750,0.250,0.750),new Vector3(0.250,0.750,0.750),new Vector3(0.750,0.750,0.750)];}
		]);
		return OctreeNode;
	})()


	/**
	*@private
	*<code>DynamicBatch</code> 类用于动态批处理。
	*/
	//class laya.d3.graphics.DynamicBatch
	var DynamicBatch=(function(){
		function DynamicBatch(vertexDeclaration){
			this._vertexDeclaration=null;
			this._vertexDatas=null;
			this._indexDatas=null;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._currentCombineVertexCount=0;
			this._currentCombineIndexCount=0;
			this._combineRenderElements=null;
			this._materials=null;
			this._materialToRenderElementsOffsets=null;
			this._merageElements=null;
			this._combineRenderElementPool=null;
			this._combineRenderElementPoolIndex=0;
			this._currentCombineVertexCount=0;
			this._currentCombineIndexCount=0;
			this._combineRenderElements=[];
			this._materialToRenderElementsOffsets=[];
			this._materials=[];
			this._merageElements=[];
			this._combineRenderElementPool=[];
			this._combineRenderElementPoolIndex=0;
			this._vertexDeclaration=vertexDeclaration;
		}

		__class(DynamicBatch,'laya.d3.graphics.DynamicBatch');
		var __proto=DynamicBatch.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer;
			else
			return null;
		}

		__proto._getIndexBuffer=function(){
			return this._indexBuffer;
		}

		__proto._getCombineRenderElementFromPool=function(view,projection,projectionView){
			var renderElement=this._combineRenderElementPool[this._combineRenderElementPoolIndex++];
			if (!renderElement){
				this._combineRenderElementPool[this._combineRenderElementPoolIndex-1]=renderElement=new RenderElement();
				renderElement._sprite3D=new Sprite3D();
			}
			renderElement._sprite3D._renderUpdate(projectionView);
			return renderElement;
		}

		__proto._getRenderElement=function(view,projection,projectionView){
			if (!this._vertexDatas){
				this._vertexDatas=new Float32Array(this._vertexDeclaration.vertexStride / 4 *DynamicBatch.maxVertexCount);
				this._indexDatas=new Uint16Array(DynamicBatch.maxIndexCount);
				this._vertexBuffer=VertexBuffer3D.create(this._vertexDeclaration,DynamicBatch.maxVertexCount,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
				this._indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",DynamicBatch.maxIndexCount,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			}
			this._merageElements.length=0;
			var curMerVerCount=0;
			var curIndexCount=0;
			for (var i=0,n=this._combineRenderElements.length;i < n;i++){
				var renderElement=this._combineRenderElements[i];
				var subVertexDatas=renderElement.getDynamicBatchBakedVertexs(0);
				var subIndexDatas=renderElement.getBakedIndices();
				var isInvert=renderElement._sprite3D.transform._isFrontFaceInvert;
				var indexOffset=curMerVerCount / (this._vertexDeclaration.vertexStride / 4);
				var indexStart=curIndexCount;
				var indexEnd=indexStart+subIndexDatas.length;
				renderElement._batchIndexStart=indexStart;
				renderElement._batchIndexEnd=indexEnd;
				this._indexDatas.set(subIndexDatas,curIndexCount);
				var k=0;
				if (isInvert){
					for (k=indexStart;k < indexEnd;k+=3){
						this._indexDatas[k]=indexOffset+this._indexDatas[k];
						var index1=this._indexDatas[k+1];
						var index2=this._indexDatas[k+2];
						this._indexDatas[k+1]=indexOffset+index2;
						this._indexDatas[k+2]=indexOffset+index1;
					}
					}else {
					for (k=indexStart;k < indexEnd;k+=3){
						this._indexDatas[k]=indexOffset+this._indexDatas[k];
						this._indexDatas[k+1]=indexOffset+this._indexDatas[k+1];
						this._indexDatas[k+2]=indexOffset+this._indexDatas[k+2];
					}
				}
				curIndexCount+=subIndexDatas.length;
				this._vertexDatas.set(subVertexDatas,curMerVerCount);
				curMerVerCount+=subVertexDatas.length;
			}
			this._vertexBuffer.setData(this._vertexDatas);
			this._indexBuffer.setData(this._indexDatas);
			this._combineRenderElementPoolIndex=0;
			for (i=0,n=this._materials.length;i < n;i++){
				var merageElement=this._getCombineRenderElementFromPool(view,projection,projectionView);
				merageElement._type=2;
				merageElement._staticBatch=null;
				merageElement.renderObj=this;
				var renderElementStartIndex=this._combineRenderElements[this._materialToRenderElementsOffsets[i]]._batchIndexStart;
				var renderElementEndIndex=(i+1===this._materialToRenderElementsOffsets.length)? curIndexCount :this._combineRenderElements[this._materialToRenderElementsOffsets[i+1]]._batchIndexStart;
				merageElement._batchIndexStart=renderElementStartIndex;
				merageElement._batchIndexEnd=renderElementEndIndex;
				merageElement._material=this._materials[i];
				this._merageElements.push(merageElement);
			}
		}

		__proto._addCombineRenderObjTest=function(renderElement){
			var renderObj=renderElement.renderObj;
			var indexCount=this._currentCombineIndexCount+renderObj._getIndexBuffer().indexCount;
			var vertexCount=this._currentCombineVertexCount+renderObj._getVertexBuffer().vertexCount;
			if (vertexCount > DynamicBatch.maxVertexCount || indexCount > DynamicBatch.maxIndexCount){
				return false;
			}
			return true;
		}

		__proto._addCombineRenderObj=function(renderElement){
			var renderObj=renderElement.renderObj;
			this._combineRenderElements.push(renderElement);
			this._currentCombineIndexCount=this._currentCombineIndexCount+renderObj._getIndexBuffer().indexCount;
			this._currentCombineVertexCount=this._currentCombineVertexCount+renderObj._getVertexBuffer().vertexCount;
		}

		__proto._addCombineMaterial=function(material){
			this._materials.push(material);
		}

		__proto._addMaterialToRenderElementOffset=function(offset){
			this._materialToRenderElementsOffsets.push(offset);
		}

		__proto._clearRenderElements=function(){
			this._combineRenderElements.length=0;
			this._materials.length=0;
			this._materialToRenderElementsOffsets.length=0;
			this._currentCombineVertexCount=0;
			this._currentCombineIndexCount=0;
		}

		__proto._addToRenderQueue=function(scene,view,projection,projectionView){
			this._getRenderElement(view,projection,projectionView);
			for (var i=0,n=this._materials.length;i < n;i++)
			scene.getRenderQueue(this._materials[i].renderQueue)._addDynamicBatchElement(this._merageElements[i]);
		}

		__proto._beforeRender=function(state){
			this._vertexBuffer._bind();
			this._indexBuffer._bind();
			return true;
		}

		__proto._render=function(state){
			var indexCount=state._batchIndexEnd-state._batchIndexStart;
			WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,state._batchIndexStart *2);
			Stat.drawCall++;
			Stat.trianglesFaces+=indexCount / 3;
		}

		/**NATIVE*/
		__proto._renderRuntime=function(conchGraphics3D,renderElement,state){}
		__getset(0,__proto,'indexOfHost',function(){
			return 0;
		});

		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer.indexCount / 3;
		});

		__getset(0,__proto,'combineRenderElementsCount',function(){
			return this._combineRenderElements.length;
		});

		DynamicBatch.maxVertexCount=20000;
		DynamicBatch.maxIndexCount=40000;
		DynamicBatch.maxCombineTriangleCount=50;
		return DynamicBatch;
	})()


	/**
	*@private
	*<code>DynamicBatchManager</code> 类用于管理动态批处理。
	*/
	//class laya.d3.graphics.DynamicBatchManager
	var DynamicBatchManager=(function(){
		function DynamicBatchManager(){
			this._dynamicBatches=null;
			this._prepareDynamicBatchCombineElements=null;
			this._dynamicBatches={};
			this._prepareDynamicBatchCombineElements=[];
		}

		__class(DynamicBatchManager,'laya.d3.graphics.DynamicBatchManager');
		var __proto=DynamicBatchManager.prototype;
		__proto.getDynamicBatch=function(_vertexDeclaration,number){
			var dynamicBatch;
			var key=_vertexDeclaration.id.toString()+number;
			if (!this._dynamicBatches[key]){
				this._dynamicBatches[key]=dynamicBatch=new DynamicBatch(_vertexDeclaration);
				}else {
				dynamicBatch=this._dynamicBatches[key];
			}
			return dynamicBatch;
		}

		/**需手动调用*/
		__proto._garbageCollection=function(){
			for (var key in this._dynamicBatches)
			if (this._dynamicBatches[key].combineRenderElementsCount===0)
				delete this._dynamicBatches[key];
		}

		__proto._addPrepareRenderElement=function(renderElement){
			this._prepareDynamicBatchCombineElements.push(renderElement);
		}

		/**@private */
		__proto._finishCombineDynamicBatch=function(scene){
			this._prepareDynamicBatchCombineElements.sort(DynamicBatchManager._sortPrepareDynamicBatch);
			var lastMaterial;
			var lastVertexDeclaration;
			var lastRenderElement;
			var lastBatchNumber=-1;
			var lastCanMerage=true;
			var curMaterial;
			var curRenderElement;
			var curDynamicBatch;
			var curbatchNumber=0;
			var laterAddMaterial;
			var laterAddRenderElement;
			var laterAddMatToElementOffset=-1;
			for (var i=0,n=this._prepareDynamicBatchCombineElements.length;i < n;i++){
				curRenderElement=this._prepareDynamicBatchCombineElements[i];
				var curDeclaration=curRenderElement.renderObj._getVertexBuffer(0).vertexDeclaration;
				var declarationChanged=(lastVertexDeclaration!==curDeclaration);
				declarationChanged && (curbatchNumber=0,lastVertexDeclaration=curDeclaration);
				var batchNumbrChanged=(curbatchNumber!==lastBatchNumber);
				batchNumbrChanged && (lastBatchNumber=curbatchNumber);
				if ((declarationChanged)|| batchNumbrChanged){
					curDynamicBatch=this.getDynamicBatch(curDeclaration,curbatchNumber);
					lastMaterial=null;
				}
				if (lastCanMerage){
					if (curDynamicBatch._addCombineRenderObjTest(curRenderElement)){
						curMaterial=curRenderElement._material;
						if (lastMaterial!==curMaterial){
							if (laterAddMaterial){
								scene.getRenderQueue(laterAddRenderElement._material.renderQueue)._addRenderElement(laterAddRenderElement);
								laterAddMaterial=null;
								laterAddRenderElement=null;
								laterAddMatToElementOffset=-1;
							}
							laterAddMaterial=curMaterial;
							laterAddMatToElementOffset=curDynamicBatch.combineRenderElementsCount;
							laterAddRenderElement=curRenderElement;
							lastMaterial=curMaterial;
							}else {
							if (laterAddMaterial){
								var lastRenderObj=laterAddRenderElement.renderObj;
								var curRenderObj=curRenderElement.renderObj;
								if (((lastRenderObj._getVertexBuffer().vertexCount+curRenderObj._getVertexBuffer().vertexCount)> DynamicBatch.maxVertexCount)|| ((lastRenderObj._getIndexBuffer().indexCount+curRenderObj._getIndexBuffer().indexCount)> DynamicBatch.maxIndexCount)){
									scene.getRenderQueue(laterAddRenderElement._material.renderQueue)._addRenderElement(laterAddRenderElement);
									laterAddMaterial=curMaterial;
									laterAddMatToElementOffset=curDynamicBatch.combineRenderElementsCount;
									laterAddRenderElement=curRenderElement;
									}else {
									curDynamicBatch._addCombineMaterial(laterAddMaterial);
									curDynamicBatch._addMaterialToRenderElementOffset(laterAddMatToElementOffset);
									curDynamicBatch._addCombineRenderObj(laterAddRenderElement);
									laterAddMaterial=null;
									laterAddRenderElement=null;
									laterAddMatToElementOffset=-1;
									curDynamicBatch._addCombineRenderObj(curRenderElement);
								}
								}else {
								curDynamicBatch._addCombineRenderObj(curRenderElement);
							}
						}
						lastCanMerage=true;
						}else {
						if (laterAddMaterial){
							scene.getRenderQueue(laterAddRenderElement._material.renderQueue)._addRenderElement(laterAddRenderElement);
							laterAddMaterial=null;
							laterAddRenderElement=null;
							laterAddMatToElementOffset=-1;
						}
						curbatchNumber++;
						lastCanMerage=false;
					}
					}else {
					lastRenderElement=this._prepareDynamicBatchCombineElements[i-1];
					curDynamicBatch._addMaterialToRenderElementOffset(curDynamicBatch.combineRenderElementsCount);
					lastMaterial=lastRenderElement._material;
					curDynamicBatch._addCombineMaterial(lastMaterial);
					curDynamicBatch._addCombineRenderObj(lastRenderElement);
					lastCanMerage=true;
					curMaterial=curRenderElement._material;
					if (lastMaterial!==curMaterial){
						laterAddMaterial=curMaterial;
						laterAddMatToElementOffset=curDynamicBatch.combineRenderElementsCount;
						laterAddRenderElement=curRenderElement;
						}else {
						curDynamicBatch._addCombineRenderObj(curRenderElement);
					}
					lastMaterial=curMaterial;
				}
			}
			if (laterAddMaterial){
				scene.getRenderQueue(laterAddRenderElement._material.renderQueue)._addRenderElement(laterAddRenderElement);
				laterAddMaterial=null;
				laterAddRenderElement=null;
				laterAddMatToElementOffset=-1;
			}
			this._prepareDynamicBatchCombineElements.length=0;
		}

		__proto._clearRenderElements=function(){
			for (var key in this._dynamicBatches)
			this._dynamicBatches[key]._clearRenderElements();
		}

		__proto._addToRenderQueue=function(scene,view,projection,projectionView){
			for (var key in this._dynamicBatches){
				var dynamicBatch=this._dynamicBatches[key];
				(dynamicBatch.combineRenderElementsCount > 0)&& (dynamicBatch._addToRenderQueue(scene,view,projection,projectionView));
			}
		}

		__proto.dispose=function(){
			this._dynamicBatches=null;
		}

		DynamicBatchManager._sortPrepareDynamicBatch=function(a,b){
			return a._mainSortID-b._mainSortID;
		}

		return DynamicBatchManager;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.FrustumCulling
	var FrustumCulling=(function(){
		function FrustumCulling(){}
		__class(FrustumCulling,'laya.d3.graphics.FrustumCulling');
		FrustumCulling.renderShadowObjectCulling=function(scene,lightFrustum,shadowQueues,lightViewProjectMatrix,nPSSMNum){
			var i=0,j=0,n=0,m=0;
			for (i=0,n=shadowQueues.length;i < n;i++){
				var quene=shadowQueues[i];
				(quene)&& (quene._clearRenderElements());
			};
			var frustumCullingObjects=scene._frustumCullingObjects;
			var baseRender,shadowQueue,renderElements;
			if (nPSSMNum > 1){
				for (i=0,n=frustumCullingObjects.length;i < n;i++){
					baseRender=frustumCullingObjects[i];
					if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
						for (var k=1,kNum=lightFrustum.length;k < kNum;k++){
							shadowQueue=shadowQueues[k-1];
							if (lightFrustum[k].containsBoundSphere(baseRender.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
								renderElements=baseRender._renderElements;
								for (j=0,m=renderElements.length;j < m;j++)
								shadowQueue._addRenderElement(renderElements[j]);
							}
						}
					}
				}
				}else {
				for (i=0,n=frustumCullingObjects.length;i < n;i++){
					baseRender=frustumCullingObjects[i];
					if (baseRender.castShadow && Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
						if (lightFrustum[0].containsBoundSphere(baseRender.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0){
							baseRender._owner._renderUpdate(lightViewProjectMatrix);
							shadowQueue=shadowQueues[0];
							renderElements=baseRender._renderElements;
							for (j=0,m=renderElements.length;j < m;j++)
							shadowQueue._addRenderElement(renderElements[j]);
						}
					}
				}
			}
		}

		FrustumCulling.renderShadowObjectCullingOctree=function(scene,lightFrustum,quenesResult,lightViewProjectMatrix,nPSSMNum){
			for (var i=0,n=quenesResult.length;i < n;i++){
				var quene=quenesResult[i];
				(quene)&& (quene._clearRenderElements());
			}
			if (nPSSMNum > 1){
				scene.treeRoot.cullingShadowObjects(lightFrustum,quenesResult,true,0,scene);
				}else {
				scene.treeRoot.cullingShadowObjectsOnePSSM(lightFrustum[0],quenesResult,lightViewProjectMatrix,true,0,scene);
			}
		}

		FrustumCulling.renderObjectCulling=function(boundFrustum,scene,camera,view,projection,projectionView){
			var i=0,iNum=0,j=0,jNum=0;
			var queues=scene._quenes;
			var staticBatchMananger=scene._staticBatchManager;
			var dynamicBatchManager=scene._dynamicBatchManager;
			var frustumCullingObjects=scene._frustumCullingObjects;
			for (i=0,iNum=queues.length;i < iNum;i++){
				var queue=queues[i];
				(queue)&& (queue._clearRenderElements());
			}
			staticBatchMananger._clearRenderElements();
			dynamicBatchManager._clearRenderElements();
			var cameraPosition=camera.transform.position;
			for (i=0,iNum=frustumCullingObjects.length;i < iNum;i++){
				var baseRender=frustumCullingObjects[i];
				if (Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable && (boundFrustum.containsBoundSphere(baseRender.boundingSphere)!==/*laya.d3.math.ContainmentType.Disjoint*/0)){
					baseRender._owner._renderUpdate(projectionView);
					baseRender._distanceForSort=Vector3.distance(baseRender.boundingSphere.center,cameraPosition)+baseRender.sortingFudge;
					var renderElements=baseRender._renderElements;
					for (j=0,jNum=renderElements.length;j < jNum;j++){
						var renderElement=renderElements[j];
						var staticBatch=renderElement._staticBatch;
						if (staticBatch && (staticBatch._material===renderElement._material)){
							staticBatch._addRenderElement(renderElement);
							}else {
							var renderObj=renderElement.renderObj;
							if ((renderObj.triangleCount < /*laya.d3.graphics.DynamicBatch.maxCombineTriangleCount*/50)&& (renderObj._vertexBufferCount===1)&& (renderObj._getIndexBuffer())&& (renderElement._material.renderQueue < 2)&& renderElement._canDynamicBatch && (!baseRender._owner.isStatic))
								dynamicBatchManager._addPrepareRenderElement(renderElement);
							else
							scene.getRenderQueue(renderElement._material.renderQueue)._addRenderElement(renderElement);
						}
					}
				}
			}
			staticBatchMananger._addToRenderQueue(scene,view,projection,projectionView);
			dynamicBatchManager._finishCombineDynamicBatch(scene);
			dynamicBatchManager._addToRenderQueue(scene,view,projection,projectionView);
		}

		FrustumCulling.renderObjectCullingOctree=function(boundFrustum,scene,camera,view,projection,projectionView){
			var queues=scene._quenes;
			var staticBatchMananger=scene._staticBatchManager;
			var dynamicBatchManager=scene._dynamicBatchManager;
			for (var i=0,n=queues.length;i < n;i++){
				var queue=queues[i];
				(queue)&& (queue._clearRenderElements());
			}
			staticBatchMananger._clearRenderElements();
			dynamicBatchManager._clearRenderElements();
			scene._frustumCullingObjects.length=0;
			scene.treeRoot.cullingObjects(boundFrustum,true,0,camera.transform.position,projectionView);
			staticBatchMananger._addToRenderQueue(scene,view,projection,projectionView);
			dynamicBatchManager._finishCombineDynamicBatch(scene);
			dynamicBatchManager._addToRenderQueue(scene,view,projection,projectionView);
		}

		FrustumCulling.renderObjectCullingNoBoundFrustum=function(scene,camera,view,projection,projectionView){
			var i=0,iNum=0,j=0,jNum=0;
			var queues=scene._quenes;
			var staticBatchMananger=scene._staticBatchManager;
			var dynamicBatchManager=scene._dynamicBatchManager;
			var frustumCullingObjects=scene._frustumCullingObjects;
			for (i=0,iNum=queues.length;i < iNum;i++){
				var queue=queues[i];
				(queue)&& (queue._clearRenderElements());
			}
			staticBatchMananger._clearRenderElements();
			dynamicBatchManager._clearRenderElements();
			var cameraPosition=camera.transform.position;
			for (i=0,iNum=frustumCullingObjects.length;i < iNum;i++){
				var baseRender=frustumCullingObjects[i];
				if (Layer.isVisible(baseRender._owner.layer.mask)&& baseRender.enable){
					baseRender._owner._renderUpdate(projectionView);
					baseRender._distanceForSort=Vector3.distance(baseRender.boundingSphere.center,cameraPosition)+baseRender.sortingFudge;
					var renderElements=baseRender._renderElements;
					for (j=0,jNum=renderElements.length;j < jNum;j++){
						var renderElement=renderElements[j];
						var staticBatch=renderElement._staticBatch;
						if (staticBatch && (staticBatch._material===renderElement._material)){
							staticBatch._addRenderElement(renderElement);
							}else {
							var renderObj=renderElement.renderObj;
							if ((renderObj.triangleCount < /*laya.d3.graphics.DynamicBatch.maxCombineTriangleCount*/50)&& (renderObj._vertexBufferCount===1)&& (renderObj._getIndexBuffer())&& (renderElement._material.renderQueue < 2)&& renderElement._canDynamicBatch && (!baseRender._owner.isStatic))
								dynamicBatchManager._addPrepareRenderElement(renderElement);
							else
							scene.getRenderQueue(renderElement._material.renderQueue)._addRenderElement(renderElement);
						}
					}
				}
			}
			staticBatchMananger._addToRenderQueue(scene,view,projection,projectionView);
			dynamicBatchManager._finishCombineDynamicBatch(scene);
			dynamicBatchManager._addToRenderQueue(scene,view,projection,projectionView);
		}

		return FrustumCulling;
	})()


	/**
	*@private
	*<code>StaticBatch</code> 类用于静态批处理。
	*/
	//class laya.d3.graphics.StaticBatch
	var StaticBatch=(function(){
		function StaticBatch(rootSprite,vertexDeclaration,material){
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._renderElements=null;
			this._combineRenderElementPool=null;
			this._combineRenderElementPoolIndex=0;
			this._combineRenderElements=null;
			this._currentCombineVertexCount=0;
			this._currentCombineIndexCount=0;
			this._needFinishCombine=false;
			this._rootSprite=null;
			this._vertexDeclaration=null;
			this._material=null;
			this._shaderValues=null;
			this._owner=null;
			this._shaderValues=new ValusArray();
			this._owner=rootSprite;
			this._currentCombineVertexCount=0;
			this._currentCombineIndexCount=0;
			this._needFinishCombine=false;
			this._renderElements=[];
			this._combineRenderElements=[];
			this._combineRenderElementPool=[];
			this._combineRenderElementPoolIndex=0;
			this._rootSprite=rootSprite;
			this._vertexDeclaration=vertexDeclaration;
			if ((material instanceof laya.d3.core.material.StandardMaterial )){
				if ((material).ambientTexture)
					this._vertexDeclaration=this._getLightMapVertexDec(vertexDeclaration);
			}
			this._material=material;
		}

		__class(StaticBatch,'laya.d3.graphics.StaticBatch');
		var __proto=StaticBatch.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
		__proto._getLightMapVertexDec=function(vertexDeclaration){
			if (vertexDeclaration===VertexPositionNormalTextureSkinTangent.vertexDeclaration){
				return VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration;
				}else if (vertexDeclaration===VertexPositionNormalTextureSkin.vertexDeclaration){
				return VertexPositionNormalTexture0Texture1Skin.vertexDeclaration;
				}else if (vertexDeclaration===VertexPositionNormalColorTextureTangent.vertexDeclaration){
				return VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration;
				}else if (vertexDeclaration===VertexPositionNTBTexture.vertexDeclaration){
				return null;
				}else if (vertexDeclaration===VertexPositionNormalColorTexture.vertexDeclaration){
				return VertexPositionNormalColorTexture0Texture1.vertexDeclaration;
				}else if (vertexDeclaration===VertexPositionNormalTextureTangent.vertexDeclaration){
				return VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration;
				}else if (vertexDeclaration===VertexPositionNormalTexture.vertexDeclaration){
				return VertexPositionNormalTexture0Texture1.vertexDeclaration;
				}else {
				return vertexDeclaration;
			}
		}

		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer;
			else
			return null;
		}

		__proto._getIndexBuffer=function(){
			return this._indexBuffer;
		}

		__proto._getCombineRenderElementFromPool=function(){
			var renderElement=this._combineRenderElementPool[this._combineRenderElementPoolIndex++];
			return renderElement || (this._combineRenderElementPool[this._combineRenderElementPoolIndex-1]=new RenderElement());
		}

		__proto._addCombineRenderObjTest=function(renderElement){
			var renderObj=renderElement.renderObj;
			var vertexCount=this._currentCombineVertexCount+renderObj._getVertexBuffer().vertexCount;
			if (vertexCount > StaticBatch.maxVertexCount){
				return false;
			}
			return true;
		}

		__proto._addCombineRenderObj=function(renderElement){
			var renderObj=renderElement.renderObj;
			this._combineRenderElements.push(renderElement);
			renderElement._staticBatch=this;
			this._currentCombineIndexCount=this._currentCombineIndexCount+renderObj._getIndexBuffer().indexCount;
			this._currentCombineVertexCount=this._currentCombineVertexCount+renderObj._getVertexBuffer().vertexCount;
			this._needFinishCombine=true;
		}

		__proto._deleteCombineRenderObj=function(renderElement){
			var renderObj=renderElement.renderObj;
			var index=this._combineRenderElements.indexOf(renderElement);
			if (index!==-1){
				this._combineRenderElements.splice(index,1);
				renderElement._staticBatch=null;
				this._currentCombineIndexCount=this._currentCombineIndexCount-renderObj._getIndexBuffer().indexCount;
				this._currentCombineVertexCount=this._currentCombineVertexCount-renderObj._getVertexBuffer().vertexCount;
				this._needFinishCombine=true;
			}
		}

		__proto._finshCombine=function(){
			if (this._needFinishCombine){
				var curMerVerCount=0;
				var curIndexCount=0;
				var vertexDatas=new Float32Array(this._vertexDeclaration.vertexStride / 4 *this._currentCombineVertexCount);
				var indexDatas=new Uint16Array(this._currentCombineIndexCount);
				if (this._vertexBuffer){
					this._vertexBuffer.dispose();
					this._indexBuffer.dispose();
				}
				this._vertexBuffer=VertexBuffer3D.create(this._vertexDeclaration,this._currentCombineVertexCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
				this._indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._currentCombineIndexCount,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
				for (var i=0,n=this._combineRenderElements.length;i < n;i++){
					var renderElement=this._combineRenderElements[i];
					var subVertexDatas=renderElement.getStaticBatchBakedVertexs(0);
					var subIndexDatas=renderElement.getBakedIndices();
					var isInvert=renderElement._sprite3D.transform._isFrontFaceInvert;
					var indexOffset=curMerVerCount / (this._vertexDeclaration.vertexStride / 4);
					var indexStart=curIndexCount;
					var indexEnd=indexStart+subIndexDatas.length;
					renderElement._batchIndexStart=indexStart;
					renderElement._batchIndexEnd=indexEnd;
					indexDatas.set(subIndexDatas,curIndexCount);
					var k=0;
					if (isInvert){
						for (k=indexStart;k < indexEnd;k+=3){
							indexDatas[k]=indexOffset+indexDatas[k];
							var index1=indexDatas[k+1];
							var index2=indexDatas[k+2];
							indexDatas[k+1]=indexOffset+index2;
							indexDatas[k+2]=indexOffset+index1;
						}
						}else {
						for (k=indexStart;k < indexEnd;k+=3){
							indexDatas[k]=indexOffset+indexDatas[k];
							indexDatas[k+1]=indexOffset+indexDatas[k+1];
							indexDatas[k+2]=indexOffset+indexDatas[k+2];
						}
					}
					curIndexCount+=subIndexDatas.length;
					vertexDatas.set(subVertexDatas,curMerVerCount);
					curMerVerCount+=subVertexDatas.length;
				}
				this._vertexBuffer.setData(vertexDatas);
				this._indexBuffer.setData(indexDatas);
				this._needFinishCombine=false;
			}
		}

		__proto._clearRenderElements=function(){
			this._renderElements.length=0;
		}

		__proto._addRenderElement=function(renderElement){
			for (var i=0,n=this._renderElements.length;i < n;i++){
				if (this._renderElements[i]._batchIndexStart > renderElement._batchIndexStart){
					this._renderElements.splice(i,0,renderElement);
					return;
				}
			}
			this._renderElements.push(renderElement);
		}

		__proto._getRenderElement=function(mergeElements){
			this._combineRenderElementPoolIndex=0;
			var length=this._renderElements.length;
			var merageElement=this._getCombineRenderElementFromPool();
			merageElement._type=1;
			merageElement._staticBatch=null;
			merageElement.renderObj=this;
			merageElement._batchIndexStart=this._renderElements[0]._batchIndexStart;
			merageElement._batchIndexEnd=this._renderElements[0]._batchIndexEnd;
			merageElement._material=this._material;
			merageElement._material=this._material;
			mergeElements.push(merageElement);
			if (length > 1){
				for (var i=1;i < length;i++){
					var renderElement=this._renderElements[i];
					if (this._renderElements[i-1]._batchIndexEnd!==renderElement._batchIndexStart){
						merageElement=this._getCombineRenderElementFromPool();
						merageElement._type=1;
						merageElement._staticBatch=null;
						merageElement.renderObj=this;
						merageElement._batchIndexStart=renderElement._batchIndexStart;
						merageElement._batchIndexEnd=renderElement._batchIndexEnd;
						merageElement._material=this._material;
						mergeElements.push(merageElement);
						}else {
						merageElement._batchIndexEnd=renderElement._batchIndexEnd;
					}
				}
			}
		}

		__proto._addToRenderQueue=function(scene){
			(this._renderElements.length > 0)&& (scene.getRenderQueue(this._material.renderQueue)._addStaticBatch(this));
		}

		//TODO:>0移到外层
		__proto._beforeRender=function(state){
			this._vertexBuffer._bind();
			this._indexBuffer._bind();
			return true;
		}

		__proto._render=function(state){
			var indexCount=state._batchIndexEnd-state._batchIndexStart;
			WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,state._batchIndexStart *2);
			Stat.drawCall++;
			Stat.trianglesFaces+=indexCount / 3;
		}

		/**NATIVE*/
		__proto._renderRuntime=function(conchGraphics3D,renderElement,state){}
		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		__getset(0,__proto,'indexOfHost',function(){
			return 0;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer.indexCount / 3;
		});

		StaticBatch._addToRenderQueueStaticBatch=function(scene,sprite3D){
			var i=0,n=0;
			if (((sprite3D instanceof laya.d3.core.MeshSprite3D ))&& (sprite3D.isStatic)){
				var renderElements=(sprite3D).meshRender._renderElements;
				for (i=0,n=renderElements.length;i < n;i++){
					var renderElement=renderElements[i];
					if (renderElement.renderObj._vertexBufferCount===1)
						scene._staticBatchManager._addPrepareRenderElement(renderElement);
				}
			}
			for (i=0,n=sprite3D.numChildren;i < n;i++)
			StaticBatch._addToRenderQueueStaticBatch(scene,sprite3D._childs [i]);
		}

		StaticBatch.combine=function(staticBatchRoot){
			var scene=staticBatchRoot.scene;
			if (!scene)
				throw new Error("BaseScene: staticBatchRoot is not a part of scene.");
			StaticBatch._addToRenderQueueStaticBatch(scene,staticBatchRoot);
			scene._staticBatchManager._finishCombineStaticBatch(staticBatchRoot);
		}

		StaticBatch.maxVertexCount=65535;
		return StaticBatch;
	})()


	/**
	*@private
	*<code>StaticBatchManager</code> 类用于管理静态批处理。
	*/
	//class laya.d3.graphics.StaticBatchManager
	var StaticBatchManager=(function(){
		function StaticBatchManager(){
			this._staticBatches=null;
			this._prepareStaticBatchCombineElements=null;
			this._staticBatches={};
			this._prepareStaticBatchCombineElements=[];
		}

		__class(StaticBatchManager,'laya.d3.graphics.StaticBatchManager');
		var __proto=StaticBatchManager.prototype;
		/**完成合并*/
		__proto._finshCombine=function(){
			for (var key in this._staticBatches)
			this._staticBatches[key]._finshCombine();
		}

		__proto.getStaticBatch=function(rootSprite,_vertexDeclaration,material,number){
			var staticBatch;
			var key=rootSprite.id.toString()+material.id.toString()+_vertexDeclaration.id.toString()+number;
			if (!this._staticBatches[key]){
				this._staticBatches[key]=staticBatch=new StaticBatch(rootSprite,_vertexDeclaration,material);
				}else {
				staticBatch=this._staticBatches[key];
			}
			return staticBatch;
		}

		/**@private 通常应在所有getStaticBatchQneue函数相关操作结束后执行*/
		__proto._garbageCollection=function(){
			for (var key in this._staticBatches)
			if (this._staticBatches[key].combineRenderElementsCount===0)
				delete this._staticBatches[key];
		}

		/**@private */
		__proto._addPrepareRenderElement=function(renderElement){
			this._prepareStaticBatchCombineElements.push(renderElement);
		}

		/**@private */
		__proto._finishCombineStaticBatch=function(rootSprite){
			this._prepareStaticBatchCombineElements.sort(StaticBatchManager._sortPrepareStaticBatch);
			var lastMaterial;
			var lastVertexDeclaration;
			var lastCanMerage=false;
			var curStaticBatch;
			var renderElement;
			var lastRenderObj;
			var vb;
			var oldStaticBatch;
			var batchNumber=0;
			for (var i=0,n=this._prepareStaticBatchCombineElements.length;i < n;i++){
				renderElement=this._prepareStaticBatchCombineElements[i];
				vb=renderElement.renderObj._getVertexBuffer(0);
				if ((lastVertexDeclaration===vb.vertexDeclaration)&& (lastMaterial===renderElement._material)){
					if (!lastCanMerage){
						lastRenderObj=this._prepareStaticBatchCombineElements[i-1];
						var lastRenderElement=lastRenderObj.renderObj;
						var curRenderElement=renderElement.renderObj;
						if (((lastRenderElement._getVertexBuffer().vertexCount+curRenderElement._getVertexBuffer().vertexCount)> StaticBatch.maxVertexCount)){
							lastCanMerage=false;
							}else {
							curStaticBatch=this.getStaticBatch(rootSprite,lastVertexDeclaration,lastMaterial,batchNumber);
							oldStaticBatch=lastRenderObj._staticBatch;
							(oldStaticBatch)&& (oldStaticBatch!==curStaticBatch)&& (oldStaticBatch._deleteCombineRenderObj(lastRenderObj));
							curStaticBatch._addCombineRenderObj(lastRenderObj);
							oldStaticBatch=renderElement._staticBatch;
							(oldStaticBatch)&& (oldStaticBatch!==curStaticBatch)&& (oldStaticBatch._deleteCombineRenderObj(renderElement));
							curStaticBatch._addCombineRenderObj(renderElement);
							lastCanMerage=true;
						}
						}else {
						if (!curStaticBatch._addCombineRenderObjTest(renderElement)){
							lastCanMerage=false;
							batchNumber++;
							}else {
							oldStaticBatch=renderElement._staticBatch;
							(oldStaticBatch)&& (oldStaticBatch!==curStaticBatch)&& (oldStaticBatch._deleteCombineRenderObj(renderElement));
							curStaticBatch._addCombineRenderObj(renderElement)
						}
					}
					}else {
					lastCanMerage=false;
					batchNumber=0;
				}
				lastMaterial=renderElement._material;
				lastVertexDeclaration=vb.vertexDeclaration;
			}
			this._garbageCollection();
			this._finshCombine();
			this._prepareStaticBatchCombineElements.length=0;
		}

		__proto._clearRenderElements=function(){
			for (var key in this._staticBatches)
			this._staticBatches[key]._clearRenderElements();
		}

		__proto._addToRenderQueue=function(scene,view,projection,projectionView){
			for (var key in this._staticBatches){
				var staticBatch=this._staticBatches[key];
				staticBatch._owner._renderUpdate(projectionView);
				staticBatch._addToRenderQueue(scene);
			}
		}

		__proto.dispose=function(){
			this._staticBatches=null;
		}

		StaticBatchManager._sortPrepareStaticBatch=function(a,b){
			var id=a._mainSortID-b._mainSortID;
			return (id===0)? (a.renderObj.triangleCount-b.renderObj.triangleCount):id;
		}

		return StaticBatchManager;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.VertexDeclaration
	var VertexDeclaration=(function(){
		function VertexDeclaration(vertexStride,vertexElements){
			this._id=0;
			this._shaderValues=null;
			this._shaderDefineValue=0;
			this._vertexStride=0;
			this._vertexElements=null;
			this._vertexElementsDic=null;
			this._conchVertexDeclaration=null;
			this._id=++VertexDeclaration._uniqueIDCounter;
			if (this._id > VertexDeclaration.maxVertexDeclaration)
				throw new Error("VertexDeclaration: VertexDeclaration count should not large than ",VertexDeclaration.maxVertexDeclaration);
			this._shaderValues=new ValusArray();
			this._vertexElementsDic={};
			this._vertexStride=vertexStride;
			this._vertexElements=vertexElements;
			if (Render.isConchNode){
				this._conchVertexDeclaration=/*__JS__ */new ConchVertexDeclare();
			}
			for (var i=0;i < vertexElements.length;i++){
				var vertexElement=vertexElements[i];
				var attributeName=vertexElement.elementUsage;
				this._vertexElementsDic[attributeName]=vertexElement;
				var value=[VertexDeclaration._getTypeSize(vertexElement.elementFormat)/ 4,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,this._vertexStride,vertexElement.offset];
				this._shaderValues.setValue(attributeName,value);
				switch (attributeName){
					case /*laya.d3.graphics.VertexElementUsage.COLOR0*/1:
						this._addShaderDefine(ShaderCompile3D.SHADERDEFINE_COLOR);
						break
					case /*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2:
						this._addShaderDefine(ShaderCompile3D.SHADERDEFINE_UV0);
						break ;
					case /*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15:
						this._addShaderDefine(ShaderCompile3D.SHADERDEFINE_UV1);
						break ;
					}
			}
			if (Render.isConchNode){
				var conchVertexElements=[];
				for (var ci=0,cn=vertexElements.length;ci < cn;ci++){
					var cVertexElement=vertexElements[ci];
					switch (cVertexElement.elementFormat){
						case /*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2":
							conchVertexElements.push({offset:cVertexElement.offset,elementFormat:/*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50,elementUsage:cVertexElement.elementUsage});
							break ;
						case /*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3":
							conchVertexElements.push({offset:cVertexElement.offset,elementFormat:/*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51,elementUsage:cVertexElement.elementUsage});
							break ;
						case /*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4":
							conchVertexElements.push({offset:cVertexElement.offset,elementFormat:/*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52,elementUsage:cVertexElement.elementUsage});
							break ;
						}
				}
				this._conchVertexDeclaration.setDelcare(conchVertexElements);
			}
		}

		__class(VertexDeclaration,'laya.d3.graphics.VertexDeclaration');
		var __proto=VertexDeclaration.prototype;
		/**
		*增加Shader宏定义。
		*@param value 宏定义。
		*/
		__proto._addShaderDefine=function(value){
			this._shaderDefineValue |=value;
			if (this._conchVertexDeclaration){
				this._conchVertexDeclaration.addShaderDefine(value);
			}
		}

		/**
		*移除Shader宏定义。
		*@param value 宏定义。
		*/
		__proto._removeShaderDefine=function(value){
			this._shaderDefineValue &=~value;
			if (this._conchVertexDeclaration){
				this._conchVertexDeclaration.removeShaderDefine(value)
			}
		}

		__proto.getVertexElements=function(){
			return this._vertexElements.slice();
		}

		__proto.getVertexElementByUsage=function(usage){
			return this._vertexElementsDic[usage];
		}

		__proto.unBinding=function(){}
		__getset(0,__proto,'shaderDefineValue',function(){
			return this._shaderDefineValue;
		});

		/**
		*获取唯一标识ID(通常用于优化或识别)。
		*@return 唯一标识ID
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		__getset(0,__proto,'vertexStride',function(){
			return this._vertexStride;
		});

		__getset(0,__proto,'shaderValues',function(){
			return this._shaderValues;
		});

		VertexDeclaration._getTypeSize=function(format){
			switch (format){
				case /*laya.d3.graphics.VertexElementFormat.Single*/"single":
					return 4;
				case /*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2":
					return 8;
				case /*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3":
					return 12;
				case /*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4":
					return 16;
				case /*laya.d3.graphics.VertexElementFormat.Color*/"color":
					return 4;
				case /*laya.d3.graphics.VertexElementFormat.Byte4*/"byte4":
					return 4;
				case /*laya.d3.graphics.VertexElementFormat.Short2*/"short2":
					return 4;
				case /*laya.d3.graphics.VertexElementFormat.Short4*/"short4":
					return 8;
				case /*laya.d3.graphics.VertexElementFormat.NormalizedShort2*/"normalizedshort2":
					return 4;
				case /*laya.d3.graphics.VertexElementFormat.NormalizedShort4*/"normalizedshort4":
					return 8;
				case /*laya.d3.graphics.VertexElementFormat.HalfVector2*/"halfvector2":
					return 4;
				case /*laya.d3.graphics.VertexElementFormat.HalfVector4*/"halfvector4":
					return 8;
				}
			return 0;
		}

		VertexDeclaration.getVertexStride=function(vertexElements){
			var curStride=0;
			for (var i=0;i < vertexElements.Length;i++){
				var element=vertexElements[i];
				var stride=element.offset+VertexDeclaration._getTypeSize(element.elementFormat);
				if (curStride < stride){
					curStride=stride;
				}
			}
			return curStride;
		}

		VertexDeclaration._maxVertexDeclarationBit=1000;
		VertexDeclaration._uniqueIDCounter=1;
		__static(VertexDeclaration,
		['maxVertexDeclaration',function(){return this.maxVertexDeclaration=2147483647-Math.floor(2147483647 / 1000)*1000;}
		]);
		return VertexDeclaration;
	})()


	/**
	*<code>VertexElement</code> 类用于创建顶点结构分配。
	*/
	//class laya.d3.graphics.VertexElement
	var VertexElement=(function(){
		function VertexElement(offset,elementFormat,elementUsage){
			this.offset=0;
			this.elementFormat=null;
			this.elementUsage=0;
			this.offset=offset;
			this.elementFormat=elementFormat;
			this.elementUsage=elementUsage;
		}

		__class(VertexElement,'laya.d3.graphics.VertexElement');
		return VertexElement;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.VertexElementFormat
	var VertexElementFormat=(function(){
		function VertexElementFormat(){};
		__class(VertexElementFormat,'laya.d3.graphics.VertexElementFormat');
		VertexElementFormat.Single="single";
		VertexElementFormat.Vector2="vector2";
		VertexElementFormat.Vector3="vector3";
		VertexElementFormat.Vector4="vector4";
		VertexElementFormat.Color="color";
		VertexElementFormat.Byte4="byte4";
		VertexElementFormat.Short2="short2";
		VertexElementFormat.Short4="short4";
		VertexElementFormat.NormalizedShort2="normalizedshort2";
		VertexElementFormat.NormalizedShort4="normalizedshort4";
		VertexElementFormat.HalfVector2="halfvector2";
		VertexElementFormat.HalfVector4="halfvector4";
		return VertexElementFormat;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.graphics.VertexElementUsage
	var VertexElementUsage=(function(){
		function VertexElementUsage(){};
		__class(VertexElementUsage,'laya.d3.graphics.VertexElementUsage');
		VertexElementUsage.POSITION0=0;
		VertexElementUsage.COLOR0=1;
		VertexElementUsage.TEXTURECOORDINATE0=2;
		VertexElementUsage.NORMAL0=3;
		VertexElementUsage.BINORMAL0=4;
		VertexElementUsage.TANGENT0=5;
		VertexElementUsage.BLENDINDICES0=6;
		VertexElementUsage.BLENDWEIGHT0=7;
		VertexElementUsage.DEPTH0=8;
		VertexElementUsage.FOG0=9;
		VertexElementUsage.POINTSIZE0=10;
		VertexElementUsage.SAMPLE0=11;
		VertexElementUsage.TESSELLATEFACTOR0=12;
		VertexElementUsage.COLOR1=13;
		VertexElementUsage.NEXTTEXTURECOORDINATE0=14;
		VertexElementUsage.TEXTURECOORDINATE1=15;
		VertexElementUsage.NEXTTEXTURECOORDINATE1=16;
		VertexElementUsage.CORNERTEXTURECOORDINATE0=17;
		VertexElementUsage.VELOCITY0=18;
		VertexElementUsage.STARTCOLOR0=19;
		VertexElementUsage.STARTSIZE=20;
		VertexElementUsage.AGEADDSCALE0=21;
		VertexElementUsage.STARTROTATION0=22;
		VertexElementUsage.STARTROTATION1=23;
		VertexElementUsage.STARTROTATION2=24;
		VertexElementUsage.ENDCOLOR0=25;
		VertexElementUsage.STARTLIFETIME=26;
		VertexElementUsage.TIME0=33;
		VertexElementUsage.POSITIONSTARTLIFETIME=30;
		VertexElementUsage.DIRECTIONTIME=32;
		VertexElementUsage.SIZEROTATION0=27;
		VertexElementUsage.RADIUS0=28;
		VertexElementUsage.RADIAN0=29;
		VertexElementUsage.STARTSPEED=31;
		VertexElementUsage.RANDOM0=34;
		VertexElementUsage.RANDOM1=35;
		VertexElementUsage.SIMULATIONWORLDPOSTION=36;
		return VertexElementUsage;
	})()


	/**
	*<code>VertexPositionNormalColorTangent</code> 类用于创建粒子顶点结构。
	*/
	//class laya.d3.graphics.VertexGlitter
	var VertexGlitter=(function(){
		function VertexGlitter(position,textureCoordinate,time){
			this._position=null;
			this._textureCoordinate0=null;
			this._time=NaN;
			this._position=position;
			this._textureCoordinate0=textureCoordinate;
			this._time=time;
		}

		__class(VertexGlitter,'laya.d3.graphics.VertexGlitter');
		var __proto=VertexGlitter.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'time',function(){
			return this._time;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexGlitter._vertexDeclaration;
		});

		__getset(1,VertexGlitter,'vertexDeclaration',function(){
			return VertexGlitter._vertexDeclaration;
		});

		__static(VertexGlitter,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(24,
			[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(20,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.TIME0*/33)]);}
		]);
		return VertexGlitter;
	})()


	/**
	*<code>VertexPositionNormalColorTangent</code> 类用于创建粒子顶点结构。
	*/
	//class laya.d3.graphics.VertexParticle
	var VertexParticle=(function(){
		function VertexParticle(cornerTextureCoordinate,position,velocity,startColor,endColor,sizeRotation,radius,radian,ageAddScale,time){
			this._cornerTextureCoordinate=null;
			this._position=null;
			this._velocity=null;
			this._startColor=null;
			this._endColor=null;
			this._sizeRotation=null;
			this._radius=null;
			this._radian=null;
			this._ageAddScale=NaN;
			this._time=NaN;
			this._cornerTextureCoordinate=cornerTextureCoordinate;
			this._position=position;
			this._velocity=velocity;
			this._startColor=startColor;
			this._endColor=endColor;
			this._sizeRotation=sizeRotation;
			this._radius=radius;
			this._radian=radian;
			this._ageAddScale=ageAddScale;
			this._time=time;
		}

		__class(VertexParticle,'laya.d3.graphics.VertexParticle');
		var __proto=VertexParticle.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'endColor',function(){
			return this._endColor;
		});

		__getset(0,__proto,'cornerTextureCoordinate',function(){
			return this._cornerTextureCoordinate;
		});

		__getset(0,__proto,'sizeRotation',function(){
			return this._sizeRotation;
		});

		__getset(0,__proto,'velocity',function(){
			return this._velocity;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'startColor',function(){
			return this._startColor;
		});

		__getset(0,__proto,'radius',function(){
			return this._radius;
		});

		__getset(0,__proto,'radian',function(){
			return this._radian;
		});

		__getset(0,__proto,'ageAddScale',function(){
			return this._ageAddScale;
		});

		__getset(0,__proto,'time',function(){
			return this._time;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexParticle._vertexDeclaration;
		});

		__getset(1,VertexParticle,'vertexDeclaration',function(){
			return VertexParticle._vertexDeclaration;
		});

		__static(VertexParticle,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(116,
			[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.CORNERTEXTURECOORDINATE0*/17),
			new VertexElement(16,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(28,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.VELOCITY0*/18),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.STARTCOLOR0*/19),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.ENDCOLOR0*/25),
			new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.SIZEROTATION0*/27),
			new VertexElement(84,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.RADIUS0*/28),
			new VertexElement(92,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.RADIAN0*/29),
			new VertexElement(108,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.STARTLIFETIME*/26),
			new VertexElement(112,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.TIME0*/33)]);}
		]);
		return VertexParticle;
	})()


	/**
	*<code>VertexPositionNormalColorTangent</code> 类用于创建粒子顶点结构。
	*/
	//class laya.d3.graphics.VertexParticleShuriken
	var VertexParticleShuriken=(function(){
		function VertexParticleShuriken(cornerTextureCoordinate,position,velocity,startColor,startSize,startRotation0,startRotation1,startRotation2,ageAddScale,time,startSpeed,randoms0,randoms1,simulationWorldPostion){
			this._cornerTextureCoordinate=null;
			this._position=null;
			this._velocity=null;
			this._startColor=null;
			this._startSize=null;
			this._startRotation0=null;
			this._startRotation1=null;
			this._startRotation2=null;
			this._startLifeTime=NaN;
			this._time=NaN;
			this._startSpeed=NaN;
			this._randoms0=null;
			this._randoms1=null;
			this._simulationWorldPostion=null;
			this._cornerTextureCoordinate=cornerTextureCoordinate;
			this._position=position;
			this._velocity=velocity;
			this._startColor=startColor;
			this._startSize=startSize;
			this._startRotation0=startRotation0;
			this._startRotation1=startRotation1;
			this._startRotation2=startRotation2;
			this._startLifeTime=ageAddScale;
			this._time=time;
			this._startSpeed=startSpeed;
			this._randoms0=this.random0;
			this._randoms1=this.random1;
			this._simulationWorldPostion=simulationWorldPostion;
		}

		__class(VertexParticleShuriken,'laya.d3.graphics.VertexParticleShuriken');
		var __proto=VertexParticleShuriken.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'cornerTextureCoordinate',function(){
			return this._cornerTextureCoordinate;
		});

		__getset(0,__proto,'velocity',function(){
			return this._velocity;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'random0',function(){
			return this._randoms0;
		});

		__getset(0,__proto,'startSize',function(){
			return this._startSize;
		});

		__getset(0,__proto,'startColor',function(){
			return this._startColor;
		});

		__getset(0,__proto,'startRotation0',function(){
			return this._startRotation0;
		});

		__getset(0,__proto,'startRotation1',function(){
			return this._startRotation1;
		});

		__getset(0,__proto,'random1',function(){
			return this._randoms1;
		});

		__getset(0,__proto,'startRotation2',function(){
			return this._startRotation2;
		});

		__getset(0,__proto,'startLifeTime',function(){
			return this._startLifeTime;
		});

		__getset(0,__proto,'time',function(){
			return this._time;
		});

		__getset(0,__proto,'startSpeed',function(){
			return this._startSpeed;
		});

		__getset(0,__proto,'simulationWorldPostion',function(){
			return this._simulationWorldPostion;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexParticleShuriken._vertexDeclaration;
		});

		__getset(1,VertexParticleShuriken,'vertexDeclaration',function(){
			return VertexParticleShuriken._vertexDeclaration;
		});

		__static(VertexParticleShuriken,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(160,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.CORNERTEXTURECOORDINATE0*/17),
			new VertexElement(16,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.POSITIONSTARTLIFETIME*/30),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.DIRECTIONTIME*/32),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.STARTCOLOR0*/19),
			new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.STARTSIZE*/20),
			new VertexElement(76,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.STARTROTATION0*/22),
			new VertexElement(88,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.STARTROTATION1*/23),
			new VertexElement(100,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.STARTROTATION2*/24),
			new VertexElement(112,/*laya.d3.graphics.VertexElementFormat.Single*/"single",/*laya.d3.graphics.VertexElementUsage.STARTSPEED*/31),
			new VertexElement(116,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.RANDOM0*/34),
			new VertexElement(132,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.RANDOM1*/35),
			new VertexElement(148,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.SIMULATIONWORLDPOSTION*/36)]);}
		]);
		return VertexParticleShuriken;
	})()


	/**
	*<code>VertexPositionNormalColor</code> 类用于创建位置、法线、颜色顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColor
	var VertexPositionNormalColor=(function(){
		function VertexPositionNormalColor(position,normal,color){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
		}

		__class(VertexPositionNormalColor,'laya.d3.graphics.VertexPositionNormalColor');
		var __proto=VertexPositionNormalColor.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColor._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColor,'vertexDeclaration',function(){
			return VertexPositionNormalColor._vertexDeclaration;
		});

		__static(VertexPositionNormalColor,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1)]);}
		]);
		return VertexPositionNormalColor;
	})()


	/**
	*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorSkin
	var VertexPositionNormalColorSkin=(function(){
		function VertexPositionNormalColorSkin(position,normal,color,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorSkin,'laya.d3.graphics.VertexPositionNormalColorSkin');
		var __proto=VertexPositionNormalColorSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorSkin,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
		]);
		return VertexPositionNormalColorSkin;
	})()


	/**
	*<code>VertexPositionNormalColorSkin</code> 类用于创建位置、法线、颜色、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorSkinTangent
	var VertexPositionNormalColorSkinTangent=(function(){
		function VertexPositionNormalColorSkinTangent(position,normal,color,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorSkinTangent,'laya.d3.graphics.VertexPositionNormalColorSkinTangent');
		var __proto=VertexPositionNormalColorSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(84,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
			new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalColorSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTangent</code> 类用于创建位置、法线、颜色、切线顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTangent
	var VertexPositionNormalColorTangent=(function(){
		function VertexPositionNormalColorTangent(position,normal,color,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorTangent,'laya.d3.graphics.VertexPositionNormalColorTangent');
		var __proto=VertexPositionNormalColorTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(52,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalColorTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTexture</code> 类用于创建位置、法线、颜色、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTexture
	var VertexPositionNormalColorTexture=(function(){
		function VertexPositionNormalColorTexture(position,normal,color,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNormalColorTexture,'laya.d3.graphics.VertexPositionNormalColorTexture');
		var __proto=VertexPositionNormalColorTexture.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTexture,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(48,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
		]);
		return VertexPositionNormalColorTexture;
	})()


	/**
	*<code>VertexPositionNormalColorTexture</code> 类用于创建位置、法线、颜色、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1
	var VertexPositionNormalColorTexture0Texture1=(function(){
		function VertexPositionNormalColorTexture0Texture1(position,normal,color,textureCoordinate0,textureCoordinate1){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
		}

		__class(VertexPositionNormalColorTexture0Texture1,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1');
		var __proto=VertexPositionNormalColorTexture0Texture1.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Skin
	var VertexPositionNormalColorTexture0Texture1Skin=(function(){
		function VertexPositionNormalColorTexture0Texture1Skin(position,normal,color,textureCoordinate0,textureCoordinate1,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTexture0Texture1Skin,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Skin');
		var __proto=VertexPositionNormalColorTexture0Texture1Skin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Skin._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1Skin,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Skin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1Skin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1Skin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1SkinTangent
	var VertexPositionNormalColorTexture0Texture1SkinTangent=(function(){
		function VertexPositionNormalColorTexture0Texture1SkinTangent(){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
		}

		__class(VertexPositionNormalColorTexture0Texture1SkinTangent,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1SkinTangent');
		var __proto=VertexPositionNormalColorTexture0Texture1SkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__proto.VertexPositionNormalColorTexture0SkinTangent=function(position,normal,color,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1SkinTangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1SkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1SkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1SkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(100,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
			new VertexElement(88,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1SkinTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Tangent
	var VertexPositionNormalColorTexture0Texture1Tangent=(function(){
		function VertexPositionNormalColorTexture0Texture1Tangent(){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._tangent=null;
		}

		__class(VertexPositionNormalColorTexture0Texture1Tangent,'laya.d3.graphics.VertexPositionNormalColorTexture0Texture1Tangent');
		var __proto=VertexPositionNormalColorTexture0Texture1Tangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__proto.VertexPositionNormalColorTexture0Tangent=function(position,normal,color,textureCoordinate0,textureCoordinate1,tangent){
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
		}

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Tangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalColorTexture0Texture1Tangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTexture0Texture1Tangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTexture0Texture1Tangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(68,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalColorTexture0Texture1Tangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTextureSkin
	var VertexPositionNormalColorTextureSkin=(function(){
		function VertexPositionNormalColorTextureSkin(position,normal,color,textureCoordinate,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTextureSkin,'laya.d3.graphics.VertexPositionNormalColorTextureSkin');
		var __proto=VertexPositionNormalColorTextureSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureSkin,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(80,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
		]);
		return VertexPositionNormalColorTextureSkin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTextureSkinTangent
	var VertexPositionNormalColorTextureSkinTangent=(function(){
		function VertexPositionNormalColorTextureSkinTangent(position,normal,color,textureCoordinate,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalColorTextureSkinTangent,'laya.d3.graphics.VertexPositionNormalColorTextureSkinTangent');
		var __proto=VertexPositionNormalColorTextureSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(92,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
			new VertexElement(80,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalColorTextureSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureTangent</code> 类用于创建位置、法线、颜色、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalColorTextureTangent
	var VertexPositionNormalColorTextureTangent=(function(){
		function VertexPositionNormalColorTextureTangent(position,normal,color,textureCoordinate,tangent){
			this._position=null;
			this._normal=null;
			this._color=null;
			this._textureCoordinate=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._color=color;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalColorTextureTangent,'laya.d3.graphics.VertexPositionNormalColorTextureTangent');
		var __proto=VertexPositionNormalColorTextureTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'color',function(){
			return this._color;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalColorTextureTangent,'vertexDeclaration',function(){
			return VertexPositionNormalColorTextureTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalColorTextureTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(60,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.COLOR0*/1),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalColorTextureTangent;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTexture
	var VertexPositionNormalTexture=(function(){
		function VertexPositionNormalTexture(position,normal,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNormalTexture,'laya.d3.graphics.VertexPositionNormalTexture');
		var __proto=VertexPositionNormalTexture.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTexture,'vertexDeclaration',function(){
			return VertexPositionNormalTexture._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(32,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
		]);
		return VertexPositionNormalTexture;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTexture0Texture1
	var VertexPositionNormalTexture0Texture1=(function(){
		function VertexPositionNormalTexture0Texture1(position,normal,textureCoordinate0,textureCoordinate1){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
		}

		__class(VertexPositionNormalTexture0Texture1,'laya.d3.graphics.VertexPositionNormalTexture0Texture1');
		var __proto=VertexPositionNormalTexture0Texture1.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalTexture0Texture1,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15)]);}
		]);
		return VertexPositionNormalTexture0Texture1;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTexture0Texture1Skin
	var VertexPositionNormalTexture0Texture1Skin=(function(){
		function VertexPositionNormalTexture0Texture1Skin(position,normal,textureCoordinate0,textureCoordinate1,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTexture0Texture1Skin,'laya.d3.graphics.VertexPositionNormalTexture0Texture1Skin');
		var __proto=VertexPositionNormalTexture0Texture1Skin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Skin._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(1,VertexPositionNormalTexture0Texture1Skin,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Skin._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1Skin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(72,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
		]);
		return VertexPositionNormalTexture0Texture1Skin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTexture0Texture1SkinTangent
	var VertexPositionNormalTexture0Texture1SkinTangent=(function(){
		function VertexPositionNormalTexture0Texture1SkinTangent(){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
		}

		__class(VertexPositionNormalTexture0Texture1SkinTangent,'laya.d3.graphics.VertexPositionNormalTexture0Texture1SkinTangent');
		var __proto=VertexPositionNormalTexture0Texture1SkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__proto.VertexPositionNormalTexture0SkinTangent=function(position,normal,textureCoordinate0,textureCoordinate1,tangent,blendIndex,blendWeight){
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1SkinTangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(1,VertexPositionNormalTexture0Texture1SkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1SkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1SkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(84,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
			new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalTexture0Texture1SkinTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTexture0Texture1Tangent
	var VertexPositionNormalTexture0Texture1Tangent=(function(){
		function VertexPositionNormalTexture0Texture1Tangent(){
			this._position=null;
			this._normal=null;
			this._textureCoordinate0=null;
			this._textureCoordinate1=null;
			this._tangent=null;
		}

		__class(VertexPositionNormalTexture0Texture1Tangent,'laya.d3.graphics.VertexPositionNormalTexture0Texture1Tangent');
		var __proto=VertexPositionNormalTexture0Texture1Tangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__proto.VertexPositionNormalTexture0Tangent=function(position,normal,textureCoordinate0,textureCoordinate1,tangent){
			this._position=position;
			this._normal=normal;
			this._textureCoordinate0=textureCoordinate0;
			this._textureCoordinate1=textureCoordinate1;
			this._tangent=tangent;
		}

		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoordinate0',function(){
			return this._textureCoordinate0;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Tangent._vertexDeclaration;
		});

		__getset(0,__proto,'textureCoordinate1',function(){
			return this._textureCoordinate1;
		});

		__getset(1,VertexPositionNormalTexture0Texture1Tangent,'vertexDeclaration',function(){
			return VertexPositionNormalTexture0Texture1Tangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTexture0Texture1Tangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(52,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15),
			new VertexElement(40,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalTexture0Texture1Tangent;
	})()


	/**
	*<code>VertexPositionNormalColorTextureSkin</code> 类用于创建位置、法线、颜色、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTextureSkin
	var VertexPositionNormalTextureSkin=(function(){
		function VertexPositionNormalTextureSkin(position,normal,textureCoordinate,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTextureSkin,'laya.d3.graphics.VertexPositionNormalTextureSkin');
		var __proto=VertexPositionNormalTextureSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureSkin,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkin._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(64,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
		]);
		return VertexPositionNormalTextureSkin;
	})()


	/**
	*<code>VertexPositionNormalTextureSkin</code> 类用于创建位置、法线、纹理、骨骼索引、骨骼权重顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTextureSkinTangent
	var VertexPositionNormalTextureSkinTangent=(function(){
		function VertexPositionNormalTextureSkinTangent(position,normal,textureCoordinate,tangent,blendIndex,blendWeight){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._blendIndex=null;
			this._blendWeight=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
			this._blendIndex=blendIndex;
			this._blendWeight=blendWeight;
		}

		__class(VertexPositionNormalTextureSkinTangent,'laya.d3.graphics.VertexPositionNormalTextureSkinTangent');
		var __proto=VertexPositionNormalTextureSkinTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'blendIndex',function(){
			return this._blendIndex;
		});

		__getset(0,__proto,'blendWeight',function(){
			return this._blendWeight;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkinTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureSkinTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTextureSkinTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureSkinTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(76,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6),
			new VertexElement(64,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalTextureSkinTangent;
	})()


	/**
	*<code>VertexPositionNormalTextureTangent</code> 类用于创建位置、法线、纹理、切线顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNormalTextureTangent
	var VertexPositionNormalTextureTangent=(function(){
		function VertexPositionNormalTextureTangent(position,normal,textureCoordinate,tangent){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._tangent=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
			this._tangent=tangent;
		}

		__class(VertexPositionNormalTextureTangent,'laya.d3.graphics.VertexPositionNormalTextureTangent');
		var __proto=VertexPositionNormalTextureTangent.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'tangent',function(){
			return this._tangent;
		});

		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNormalTextureTangent._vertexDeclaration;
		});

		__getset(1,VertexPositionNormalTextureTangent,'vertexDeclaration',function(){
			return VertexPositionNormalTextureTangent._vertexDeclaration;
		});

		__static(VertexPositionNormalTextureTangent,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(44,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)]);}
		]);
		return VertexPositionNormalTextureTangent;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNTBTexture
	var VertexPositionNTBTexture=(function(){
		function VertexPositionNTBTexture(position,normal,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNTBTexture,'laya.d3.graphics.VertexPositionNTBTexture');
		var __proto=VertexPositionNTBTexture.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNTBTexture._vertexDeclaration;
		});

		__getset(1,VertexPositionNTBTexture,'vertexDeclaration',function(){
			return VertexPositionNTBTexture._vertexDeclaration;
		});

		__static(VertexPositionNTBTexture,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(56,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5),
			new VertexElement(36,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.BINORMAL0*/4),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
		]);
		return VertexPositionNTBTexture;
	})()


	/**
	*<code>VertexPositionNormalTexture</code> 类用于创建位置、法线、纹理顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionNTBTextureSkin
	var VertexPositionNTBTextureSkin=(function(){
		function VertexPositionNTBTextureSkin(position,normal,textureCoordinate){
			this._position=null;
			this._normal=null;
			this._textureCoordinate=null;
			this._position=position;
			this._normal=normal;
			this._textureCoordinate=textureCoordinate;
		}

		__class(VertexPositionNTBTextureSkin,'laya.d3.graphics.VertexPositionNTBTextureSkin');
		var __proto=VertexPositionNTBTextureSkin.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'textureCoordinate',function(){
			return this._textureCoordinate;
		});

		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionNTBTextureSkin._vertexDeclaration;
		});

		__getset(1,VertexPositionNTBTextureSkin,'vertexDeclaration',function(){
			return VertexPositionNTBTextureSkin._vertexDeclaration;
		});

		__static(VertexPositionNTBTextureSkin,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(88,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5),
			new VertexElement(36,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.BINORMAL0*/4),
			new VertexElement(48,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(56,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7),
			new VertexElement(72,/*laya.d3.graphics.VertexElementFormat.Vector4*/"vector4",/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6)]);}
		]);
		return VertexPositionNTBTextureSkin;
	})()


	/**
	*<code>VertexPositionTerrain</code> 类用于创建位置、法线、纹理1、纹理2顶点结构。
	*/
	//class laya.d3.graphics.VertexPositionTerrain
	var VertexPositionTerrain=(function(){
		function VertexPositionTerrain(position,normal,textureCoord0,textureCoord1){
			this._position=null;
			this._normal=null;
			this._textureCoord0=null;
			this._textureCoord1=null;
			this._position=position;
			this._normal=normal;
			this._textureCoord0=textureCoord0;
			this._textureCoord1=textureCoord1;
		}

		__class(VertexPositionTerrain,'laya.d3.graphics.VertexPositionTerrain');
		var __proto=VertexPositionTerrain.prototype;
		Laya.imps(__proto,{"laya.d3.graphics.IVertex":true})
		__getset(0,__proto,'normal',function(){
			return this._normal;
		});

		__getset(0,__proto,'position',function(){
			return this._position;
		});

		__getset(0,__proto,'textureCoord0',function(){
			return this._textureCoord0;
		});

		__getset(0,__proto,'textureCoord1',function(){
			return this._textureCoord1;
		});

		__getset(0,__proto,'vertexDeclaration',function(){
			return VertexPositionTerrain._vertexDeclaration;
		});

		__getset(1,VertexPositionTerrain,'vertexDeclaration',function(){
			return VertexPositionTerrain._vertexDeclaration;
		});

		__static(VertexPositionTerrain,
		['_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(40,[
			new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),
			new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3),
			new VertexElement(24,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2),
			new VertexElement(32,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15)]);}
		]);
		return VertexPositionTerrain;
	})()


	/**
	*@private
	*<code>LoadModel</code> 类用于模型加载。
	*/
	//class laya.d3.loaders.LoadModelV01
	var LoadModelV01=(function(){
		function LoadModelV01(readData,version,mesh,materials,materialMap){
			this._version=null;
			this._strings=['BLOCK','DATA',"STRINGS"];
			this._materials=null;
			this._materialMap=null;
			this._readData=null;
			this._mesh=null;
			this._BLOCK={count:0};
			this._DATA={offset:0,size:0};
			this._STRINGS={offset:0,size:0};
			this._shaderAttributes=null;
			this._mesh=mesh;
			this._materials=materials;
			this._materialMap=materialMap;
			this._version=version;
			this._onLoaded(readData);
		}

		__class(LoadModelV01,'laya.d3.loaders.LoadModelV01');
		var __proto=LoadModelV01.prototype;
		/**
		*@private
		*/
		__proto._onLoaded=function(readData){
			this._readData=readData;
			this.READ_BLOCK();
			for (var i=0;i < this._BLOCK.count;i++){
				var index=this._readData.getUint16();
				var blockName=this._strings[index];
				var fn=this["READ_"+blockName];
				if (fn==null)throw new Error("model file err,no this function:"+index+" "+blockName);
				if (!fn.call(this))break ;
			}
			return this._mesh;
		}

		__proto.onError=function(){}
		/**
		*@private
		*/
		__proto._readString=function(){
			return this._strings[this._readData.getUint16()];
		}

		__proto.READ_BLOCK=function(){
			var n=this._readData.getUint16();
			this._BLOCK.count=this._readData.getUint16();
			return true;
		}

		__proto.READ_DATA=function(){
			this._DATA.offset=this._readData.getUint32();
			this._DATA.size=this._readData.getUint32();
			return true;
		}

		__proto.READ_STRINGS=function(){
			this._STRINGS.offset=this._readData.getUint16();
			this._STRINGS.size=this._readData.getUint16();
			var ofs=this._readData.pos;
			this._readData.pos=this._STRINGS.offset+this._DATA.offset;
			for (var i=0;i < this._STRINGS.size;i++){
				this._strings[i]=this._readData.readUTFString();
			}
			this._readData.pos=ofs;
			return true;
		}

		__proto.READ_MATERIAL=function(){
			var i=0,n=0;
			var index=this._readData.getUint16();
			var shaderName=this._readString();
			var url=this._readString();
			if (url!=="null")
				this._materials[index]=Loader.getRes(this._materialMap[url]);
			else
			this._materials[index]=new BaseMaterial();
			return true;
		}

		__proto.READ_MESH=function(){
			var name=this._readString();
			switch (this._version){
				case "LAYAMODEL:01":
					console.log("Warning: The (.lm) file is converted by old fbxTools,please reConverted it use  lastest fbxTools version,later we will remove the  support of old version (.lm) support.");
					break ;
				case "LAYASKINANI:01":
				case "LAYAMODEL:02":;
					var arrayBuffer=this._readData.__getBuffer();
					var i=0,n=0;
					var bindPoseStart=this._readData.getUint32();
					var binPoseLength=this._readData.getUint32();
					var bindPoseDatas=new Float32Array(arrayBuffer.slice(bindPoseStart+this._DATA.offset,bindPoseStart+this._DATA.offset+binPoseLength));
					this.mesh._bindPoses=[];
					for (i=0,n=bindPoseDatas.length;i < n;i+=16){
						var bindPose=new Matrix4x4(bindPoseDatas[i+0],bindPoseDatas[i+1],bindPoseDatas[i+2],bindPoseDatas[i+3],bindPoseDatas[i+4],bindPoseDatas[i+5],bindPoseDatas[i+6],bindPoseDatas[i+7],bindPoseDatas[i+8],bindPoseDatas[i+9],bindPoseDatas[i+10],bindPoseDatas[i+11],bindPoseDatas[i+12],bindPoseDatas[i+13],bindPoseDatas[i+14],bindPoseDatas[i+15]);
						this.mesh._bindPoses.push(bindPose);
					};
					var inverseGlobalBindPoseStart=this._readData.getUint32();
					var inverseGlobalBinPoseLength=this._readData.getUint32();
					var invGloBindPoseDatas=new Float32Array(arrayBuffer.slice(inverseGlobalBindPoseStart+this._DATA.offset,inverseGlobalBindPoseStart+this._DATA.offset+inverseGlobalBinPoseLength));
					this.mesh._inverseBindPoses=[];
					for (i=0,n=invGloBindPoseDatas.length;i < n;i+=16){
						var inverseGlobalBindPose=new Matrix4x4(invGloBindPoseDatas[i+0],invGloBindPoseDatas[i+1],invGloBindPoseDatas[i+2],invGloBindPoseDatas[i+3],invGloBindPoseDatas[i+4],invGloBindPoseDatas[i+5],invGloBindPoseDatas[i+6],invGloBindPoseDatas[i+7],invGloBindPoseDatas[i+8],invGloBindPoseDatas[i+9],invGloBindPoseDatas[i+10],invGloBindPoseDatas[i+11],invGloBindPoseDatas[i+12],invGloBindPoseDatas[i+13],invGloBindPoseDatas[i+14],invGloBindPoseDatas[i+15]);
						this.mesh._inverseBindPoses.push(inverseGlobalBindPose);
					}
					break ;
				default :
					throw new Error("LoadModel:unknown version.");
				}
			return true;
		}

		__proto.READ_SUBMESH=function(){
			var className=this._readString();
			var material=this._readData.getUint8();
			var bufferAttribute=this._readString();
			this._shaderAttributes=bufferAttribute.match(LoadModelV01._attrReg);
			var ibofs=this._readData.getUint32();
			var ibsize=this._readData.getUint32();
			var vbIndicesofs=this._readData.getUint32();
			var vbIndicessize=this._readData.getUint32();
			var vbofs=this._readData.getUint32();
			var vbsize=this._readData.getUint32();
			var boneDicofs=this._readData.getUint32();
			var boneDicsize=this._readData.getUint32();
			var arrayBuffer=this._readData.__getBuffer();
			var submesh=new SubMesh(this._mesh);
			var vertexDeclaration=this._getVertexDeclaration();
			var vb=VertexBuffer3D.create(vertexDeclaration,vbsize / vertexDeclaration.vertexStride,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			var vbStart=vbofs+this._DATA.offset;
			var vbArrayBuffer=arrayBuffer.slice(vbStart,vbStart+vbsize);
			vb.setData(new Float32Array(vbArrayBuffer));
			submesh._vertexBuffer=vb;
			var vertexElements=vb.vertexDeclaration.getVertexElements();
			for (var i=0;i < vertexElements.length;i++)
			submesh._bufferUsage[(vertexElements [i]).elementUsage]=vb;
			var ib=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",ibsize / 2,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			var ibStart=ibofs+this._DATA.offset;
			var ibArrayBuffer=arrayBuffer.slice(ibStart,ibStart+ibsize);
			ib.setData(new Uint16Array(ibArrayBuffer));
			submesh._indexBuffer=ib;
			var boneDicArrayBuffer=arrayBuffer.slice(boneDicofs+this._DATA.offset,boneDicofs+this._DATA.offset+boneDicsize);
			submesh._boneIndicesList[0]=new Uint8Array(boneDicArrayBuffer);
			this._mesh._add(submesh);
			return true;
		}

		__proto.READ_DATAAREA=function(){
			return false;
		}

		__proto._getVertexDeclaration=function(){
			var position=false,normal=false,color=false,texcoord0=false,texcoord1=false,tangent=false,blendWeight=false,blendIndex=false;
			var binormal=false;
			for (var i=0;i < this._shaderAttributes.length;i+=8){
				switch (this._shaderAttributes[i]){
					case "POSITION":
						position=true;
						break ;
					case "NORMAL":
						normal=true;
						break ;
					case "COLOR":
						color=true;
						break ;
					case "UV":
						texcoord0=true;
						break ;
					case "UV1":
						texcoord1=true;
						break ;
					case "BLENDWEIGHT":
						blendWeight=true;
						break ;
					case "BLENDINDICES":
						blendIndex=true;
						break ;
					case "TANGENT":
						tangent=true;
						break ;
					case "BINORMAL":
						binormal=true;
						break ;
					}
			};
			var vertexDeclaration;
			if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex && tangent)
				vertexDeclaration=VertexPositionNormalColorTexture0Texture1SkinTangent.vertexDeclaration;
			else if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTexture0Texture1Skin.vertexDeclaration;
			else if (position && normal && color && texcoord0 && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalColorTextureSkinTangent.vertexDeclaration;
			else if (position && normal && color && texcoord0 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorTextureSkin.vertexDeclaration;
			else if (position && normal && tangent && binormal && texcoord0 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNTBTextureSkin.vertexDeclaration;
			else if (position && normal && texcoord0 && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalTextureSkinTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTextureSkin.vertexDeclaration;
			else if (position && normal && color && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalColorSkinTangent.vertexDeclaration;
			else if (position && normal && color && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorSkin.vertexDeclaration;
			else if (position && normal && color && texcoord0 && texcoord1 && tangent)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration;
			else if (position && normal && color && texcoord0 && texcoord1)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1 && tangent)
			vertexDeclaration=VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1)
			vertexDeclaration=VertexPositionNormalTexture0Texture1.vertexDeclaration;
			else if (position && normal && color && texcoord0 && tangent)
			vertexDeclaration=VertexPositionNormalColorTextureTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && tangent && binormal)
			vertexDeclaration=VertexPositionNTBTexture.vertexDeclaration;
			else if (position && normal && color && texcoord0)
			vertexDeclaration=VertexPositionNormalColorTexture.vertexDeclaration;
			else if (position && normal && texcoord0 && tangent)
			vertexDeclaration=VertexPositionNormalTextureTangent.vertexDeclaration;
			else if (position && normal && texcoord0)
			vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			else if (position && normal && color && tangent)
			vertexDeclaration=VertexPositionNormalColorTangent.vertexDeclaration;
			else if (position && normal && color)
			vertexDeclaration=VertexPositionNormalColor.vertexDeclaration;
			return vertexDeclaration;
		}

		__getset(0,__proto,'mesh',function(){
			return this._mesh;
		});

		LoadModelV01._attrReg=new RegExp("(\\w+)|([:,;])","g");
		return LoadModelV01;
	})()


	/**
	*@private
	*<code>LoadModel</code> 类用于模型加载。
	*/
	//class laya.d3.loaders.LoadModelV02
	var LoadModelV02=(function(){
		function LoadModelV02(){};
		__class(LoadModelV02,'laya.d3.loaders.LoadModelV02');
		LoadModelV02.parse=function(readData,version,mesh,materials,materialMap){
			LoadModelV02._mesh=mesh;
			LoadModelV02._materials=materials;
			LoadModelV02._materialMap=materialMap;
			LoadModelV02._version=version;
			LoadModelV02._readData=readData;
			LoadModelV02.READ_DATA();
			LoadModelV02.READ_BLOCK();
			LoadModelV02.READ_STRINGS();
			for (var i=0,n=LoadModelV02._BLOCK.count;i < n;i++){
				var index=LoadModelV02._readData.getUint16();
				var blockName=LoadModelV02._strings[index];
				var fn=LoadModelV02["READ_"+blockName];
				if (fn==null)
					throw new Error("model file err,no this function:"+index+" "+blockName);
				else
				fn.call();
			}
			LoadModelV02._strings.length=0;
			LoadModelV02._readData=null;
			LoadModelV02._version=null;
			LoadModelV02._mesh=null;
			LoadModelV02._materials=null;
			LoadModelV02._materialMap=null;
		}

		LoadModelV02._readString=function(){
			return LoadModelV02._strings[LoadModelV02._readData.getUint16()];
		}

		LoadModelV02.READ_DATA=function(){
			LoadModelV02._DATA.offset=LoadModelV02._readData.getUint32();
			LoadModelV02._DATA.size=LoadModelV02._readData.getUint32();
		}

		LoadModelV02.READ_BLOCK=function(){
			var count=LoadModelV02._BLOCK.count=LoadModelV02._readData.getUint16();
			var blockStarts=LoadModelV02._BLOCK.blockStarts=[];
			var blockLengths=LoadModelV02._BLOCK.blockLengths=[];
			for (var i=0;i < count;i++){
				blockStarts.push(LoadModelV02._readData.getUint32());
				blockLengths.push(LoadModelV02._readData.getUint32());
			}
		}

		LoadModelV02.READ_STRINGS=function(){
			var offset=LoadModelV02._readData.getUint32();
			var count=LoadModelV02._readData.getUint16();
			var prePos=LoadModelV02._readData.pos;
			LoadModelV02._readData.pos=offset+LoadModelV02._DATA.offset;
			for (var i=0;i < count;i++)
			LoadModelV02._strings[i]=LoadModelV02._readData.readUTFString();
			LoadModelV02._readData.pos=prePos;
		}

		LoadModelV02.READ_MATERIAL=function(){
			var i=0,n=0;
			var clasName=LoadModelV02._readString();
			var shaderName=LoadModelV02._readString();
			var url=LoadModelV02._readString();
			if (url!=="null")
				LoadModelV02._materials.push(Loader.getRes(LoadModelV02._materialMap[url]));
			else
			LoadModelV02._materials.push(/*__JS__ */new windows[clasName]());
			return true;
		}

		LoadModelV02.READ_MESH=function(){
			var name=LoadModelV02._readString();
			var arrayBuffer=LoadModelV02._readData.__getBuffer();
			var i=0,n=0;
			var vertexBufferCount=LoadModelV02._readData.getInt16();
			var offset=LoadModelV02._DATA.offset;
			for (i=0;i < vertexBufferCount;i++){
				var vbStart=offset+LoadModelV02._readData.getUint32();
				var vbLength=LoadModelV02._readData.getUint32();
				var vbDatas=new Float32Array(arrayBuffer.slice(vbStart,vbStart+vbLength));
				var bufferAttribute=LoadModelV02._readString();
				var shaderAttributes=bufferAttribute.match(LoadModelV02._attrReg);
				var vertexDeclaration=LoadModelV02._getVertexDeclaration(shaderAttributes);
				var vertexBuffer=VertexBuffer3D.create(vertexDeclaration,(vbDatas.length *4)/ vertexDeclaration.vertexStride,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
				vertexBuffer.setData(vbDatas);
				LoadModelV02._mesh._vertexBuffers.push(vertexBuffer);
			};
			var ibStart=offset+LoadModelV02._readData.getUint32();
			var ibLength=LoadModelV02._readData.getUint32();
			var ibDatas=new Uint16Array(arrayBuffer.slice(ibStart,ibStart+ibLength));
			var indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",ibLength / 2,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			indexBuffer.setData(ibDatas);
			LoadModelV02._mesh._indexBuffer=indexBuffer;
			var boneNames=LoadModelV02._mesh._boneNames=[];
			var boneCount=LoadModelV02._readData.getUint16();
			boneNames.length=boneCount;
			for (i=0;i < boneCount;i++)
			boneNames[i]=LoadModelV02._strings[LoadModelV02._readData.getUint16()];
			var bindPoseStart=LoadModelV02._readData.getUint32();
			var binPoseLength=LoadModelV02._readData.getUint32();
			var bindPoseDatas=new Float32Array(arrayBuffer.slice(offset+bindPoseStart,offset+bindPoseStart+binPoseLength));
			LoadModelV02._mesh._bindPoses=[];
			for (i=0,n=bindPoseDatas.length;i < n;i+=16){
				var bindPose=new Matrix4x4(bindPoseDatas[i+0],bindPoseDatas[i+1],bindPoseDatas[i+2],bindPoseDatas[i+3],bindPoseDatas[i+4],bindPoseDatas[i+5],bindPoseDatas[i+6],bindPoseDatas[i+7],bindPoseDatas[i+8],bindPoseDatas[i+9],bindPoseDatas[i+10],bindPoseDatas[i+11],bindPoseDatas[i+12],bindPoseDatas[i+13],bindPoseDatas[i+14],bindPoseDatas[i+15]);
				LoadModelV02._mesh._bindPoses.push(bindPose);
			};
			var inverseGlobalBindPoseStart=LoadModelV02._readData.getUint32();
			var inverseGlobalBinPoseLength=LoadModelV02._readData.getUint32();
			var invGloBindPoseDatas=new Float32Array(arrayBuffer.slice(offset+inverseGlobalBindPoseStart,offset+inverseGlobalBindPoseStart+inverseGlobalBinPoseLength));
			LoadModelV02._mesh._inverseBindPoses=[];
			for (i=0,n=invGloBindPoseDatas.length;i < n;i+=16){
				var inverseGlobalBindPose=new Matrix4x4(invGloBindPoseDatas[i+0],invGloBindPoseDatas[i+1],invGloBindPoseDatas[i+2],invGloBindPoseDatas[i+3],invGloBindPoseDatas[i+4],invGloBindPoseDatas[i+5],invGloBindPoseDatas[i+6],invGloBindPoseDatas[i+7],invGloBindPoseDatas[i+8],invGloBindPoseDatas[i+9],invGloBindPoseDatas[i+10],invGloBindPoseDatas[i+11],invGloBindPoseDatas[i+12],invGloBindPoseDatas[i+13],invGloBindPoseDatas[i+14],invGloBindPoseDatas[i+15]);
				LoadModelV02._mesh._inverseBindPoses.push(inverseGlobalBindPose);
			}
			return true;
		}

		LoadModelV02.READ_SUBMESH=function(){
			var arrayBuffer=LoadModelV02._readData.__getBuffer();
			var submesh=new SubMesh(LoadModelV02._mesh);
			var vbIndex=LoadModelV02._readData.getInt16();
			var vbStart=LoadModelV02._readData.getUint32();
			var vbLength=LoadModelV02._readData.getUint32();
			submesh._vertexBuffer=LoadModelV02._mesh._vertexBuffers[vbIndex];
			submesh._vertexBufferStart=vbStart;
			submesh.__vertexBufferCount=vbLength;
			var ibStart=LoadModelV02._readData.getUint32();
			var ibLength=LoadModelV02._readData.getUint32();
			submesh._indexBuffer=LoadModelV02._mesh._indexBuffer;
			submesh._indexBufferStart=ibStart;
			submesh._indexBufferCount=ibLength;
			var offset=LoadModelV02._DATA.offset;
			var subIndexBufferStart=submesh._subIndexBufferStart;
			var subIndexBufferCount=submesh._subIndexBufferCount;
			var boneIndicesList=submesh._boneIndicesList;
			var drawCount=LoadModelV02._readData.getUint16();
			subIndexBufferStart.length=drawCount;
			subIndexBufferCount.length=drawCount;
			boneIndicesList.length=drawCount;
			for (var i=0;i < drawCount;i++){
				subIndexBufferStart[i]=LoadModelV02._readData.getUint32();
				subIndexBufferCount[i]=LoadModelV02._readData.getUint32();
				var boneDicofs=LoadModelV02._readData.getUint32();
				var boneDicsize=LoadModelV02._readData.getUint32();
				submesh._boneIndicesList[i]=new Uint8Array(arrayBuffer.slice(offset+boneDicofs,offset+boneDicofs+boneDicsize));
			}
			LoadModelV02._mesh._add(submesh);
			return true;
		}

		LoadModelV02._getVertexDeclaration=function(shaderAttributes){
			var position=false,normal=false,color=false,texcoord0=false,texcoord1=false,tangent=false,blendWeight=false,blendIndex=false;
			var binormal=false;
			for (var i=0;i < shaderAttributes.length;i++){
				switch (shaderAttributes[i]){
					case "POSITION":
						position=true;
						break ;
					case "NORMAL":
						normal=true;
						break ;
					case "COLOR":
						color=true;
						break ;
					case "UV":
						texcoord0=true;
						break ;
					case "UV1":
						texcoord1=true;
						break ;
					case "BLENDWEIGHT":
						blendWeight=true;
						break ;
					case "BLENDINDICES":
						blendIndex=true;
						break ;
					case "TANGENT":
						tangent=true;
						break ;
					case "BINORMAL":
						binormal=true;
						break ;
					}
			};
			var vertexDeclaration;
			if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex && tangent)
				vertexDeclaration=VertexPositionNormalColorTexture0Texture1SkinTangent.vertexDeclaration;
			else if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1Skin.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTexture0Texture1Skin.vertexDeclaration;
			else if (position && normal && color && texcoord0 && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalColorTextureSkinTangent.vertexDeclaration;
			else if (position && normal && color && texcoord0 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorTextureSkin.vertexDeclaration;
			else if (position && normal && texcoord0 && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalTextureSkinTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTextureSkin.vertexDeclaration;
			else if (position && normal && color && blendWeight && blendIndex && tangent)
			vertexDeclaration=VertexPositionNormalColorSkinTangent.vertexDeclaration;
			else if (position && normal && color && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorSkin.vertexDeclaration;
			else if (position && normal && color && texcoord0 && texcoord1 && tangent)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration;
			else if (position && normal && color && texcoord0 && texcoord1)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1 && tangent)
			vertexDeclaration=VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1)
			vertexDeclaration=VertexPositionNormalTexture0Texture1.vertexDeclaration;
			else if (position && normal && color && texcoord0 && tangent)
			vertexDeclaration=VertexPositionNormalColorTextureTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && tangent && binormal)
			vertexDeclaration=VertexPositionNTBTexture.vertexDeclaration;
			else if (position && normal && color && texcoord0)
			vertexDeclaration=VertexPositionNormalColorTexture.vertexDeclaration;
			else if (position && normal && texcoord0 && tangent)
			vertexDeclaration=VertexPositionNormalTextureTangent.vertexDeclaration;
			else if (position && normal && texcoord0)
			vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			else if (position && normal && color && tangent)
			vertexDeclaration=VertexPositionNormalColorTangent.vertexDeclaration;
			else if (position && normal && color)
			vertexDeclaration=VertexPositionNormalColor.vertexDeclaration;
			return vertexDeclaration;
		}

		LoadModelV02._attrReg=new RegExp("(\\w+)|([:,;])","g");
		LoadModelV02._strings=[];
		LoadModelV02._readData=null
		LoadModelV02._version=null
		LoadModelV02._mesh=null
		LoadModelV02._materials=null
		LoadModelV02._materialMap=null
		__static(LoadModelV02,
		['_BLOCK',function(){return this._BLOCK={count:0};},'_DATA',function(){return this._DATA={offset:0,size:0};}
		]);
		return LoadModelV02;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.loaders.MeshReader
	var MeshReader=(function(){
		function MeshReader(){}
		__class(MeshReader,'laya.d3.loaders.MeshReader');
		MeshReader.read=function(data,mesh,materials,materialMap){
			var readData=new Byte(data);
			readData.pos=0;
			var version=readData.readUTFString();
			switch (version){
				case "LAYAMODEL:01":
				case "LAYASKINANI:01":
					MeshReader._readVersion01(readData,version,mesh,materials,materialMap);
					break ;
				case "LAYAMODEL:02":
					MeshReader._readVersion02(readData,version,mesh,materials,materialMap);
					break ;
				default :
					throw new Error("MeshReader: unknown mesh version.");
				}
		}

		MeshReader._readVersion01=function(readData,version,mesh,materials,materialMap){
			new LoadModelV01(readData,version,mesh,materials,materialMap);
		}

		MeshReader._readVersion02=function(readData,version,mesh,materials,materialMap){
			LoadModelV02.parse(readData,version,mesh,materials,materialMap);
		}

		return MeshReader;
	})()


	/**
	*<code>BoundBox</code> 类用于创建包围盒。
	*/
	//class laya.d3.math.BoundBox
	var BoundBox=(function(){
		function BoundBox(min,max){
			this.min=null;
			this.max=null;
			this.min=min;
			this.max=max;
		}

		__class(BoundBox,'laya.d3.math.BoundBox');
		var __proto=BoundBox.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*获取包围盒的8个角顶点。
		*@param corners 返回顶点的输出队列。
		*/
		__proto.getCorners=function(corners){
			corners.length=8;
			var mine=this.min.elements;
			var maxe=this.max.elements;
			var minX=mine[0];
			var minY=mine[1];
			var minZ=mine[2];
			var maxX=maxe[0];
			var maxY=maxe[1];
			var maxZ=maxe[2];
			corners[0]=new Vector3(minX,maxY,maxZ);
			corners[1]=new Vector3(maxX,maxY,maxZ);
			corners[2]=new Vector3(maxX,minY,maxZ);
			corners[3]=new Vector3(minX,minY,maxZ);
			corners[4]=new Vector3(minX,maxY,minZ);
			corners[5]=new Vector3(maxX,maxY,minZ);
			corners[6]=new Vector3(maxX,minY,minZ);
			corners[7]=new Vector3(minX,minY,minZ);
		}

		__proto.toDefault=function(){
			this.min.toDefault();
			this.max.toDefault();
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			this.min.cloneTo(dest.min);
			this.max.cloneTo(dest.max);
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=/*__JS__ */new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		BoundBox.createfromPoints=function(points,out){
			if (points==null)
				throw new Error("points");
			var min=out.min;
			var max=out.max;
			var minE=min.elements;
			minE[0]=Number.MAX_VALUE;
			minE[1]=Number.MAX_VALUE;
			minE[2]=Number.MAX_VALUE;
			var maxE=max.elements;
			maxE[0]=-Number.MAX_VALUE;
			maxE[1]=-Number.MAX_VALUE;
			maxE[2]=-Number.MAX_VALUE;
			for (var i=0,n=points.length;i < n;++i){
				Vector3.min(min,points[i],min);
				Vector3.max(max,points[i],max);
			}
		}

		BoundBox.merge=function(box1,box2,out){
			Vector3.min(box1.min,box2.min,out.min);
			Vector3.max(box1.max,box2.max,out.max);
		}

		return BoundBox;
	})()


	/**
	*<code>BoundFrustum</code> 类用于创建锥截体。
	*/
	//class laya.d3.math.BoundFrustum
	var BoundFrustum=(function(){
		function BoundFrustum(matrix){
			this._matrix=null;
			this._near=null;
			this._far=null;
			this._left=null;
			this._right=null;
			this._top=null;
			this._bottom=null;
			this._matrix=matrix;
			this._near=new Plane(new Vector3());
			this._far=new Plane(new Vector3());
			this._left=new Plane(new Vector3());
			this._right=new Plane(new Vector3());
			this._top=new Plane(new Vector3());
			this._bottom=new Plane(new Vector3());
			BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
		}

		__class(BoundFrustum,'laya.d3.math.BoundFrustum');
		var __proto=BoundFrustum.prototype;
		/**
		*判断是否与其他锥截体相等。
		*@param other 锥截体。
		*/
		__proto.equalsBoundFrustum=function(other){
			return this._matrix.equalsOtherMatrix(other.matrix)
		}

		/**
		*判断是否与其他对象相等。
		*@param obj 对象。
		*/
		__proto.equalsObj=function(obj){
			if ((obj instanceof laya.d3.math.BoundFrustum )){
				var bf=obj;
				return this.equalsBoundFrustum(bf);
			}
			return false;
		}

		/**
		*获取锥截体的任意一平面。
		*0:近平面
		*1:远平面
		*2:左平面
		*3:右平面
		*4:顶平面
		*5:底平面
		*@param index 索引。
		*/
		__proto.getPlane=function(index){
			switch (index){
				case 0:
					return this._near;
				case 1:
					return this._far;
				case 2:
					return this._left;
				case 3:
					return this._right;
				case 4:
					return this._top;
				case 5:
					return this._bottom;
				default :
					return null;
				}
		}

		/**
		*锥截体的8个顶点。
		*@param corners 返回顶点的输出队列。
		*/
		__proto.getCorners=function(corners){
			BoundFrustum._get3PlaneInterPoint(this._near,this._bottom,this._right).cloneTo(corners[0]);
			BoundFrustum._get3PlaneInterPoint(this._near,this._top,this._right).cloneTo(corners[1]);
			BoundFrustum._get3PlaneInterPoint(this._near,this._top,this._left).cloneTo(corners[2]);
			BoundFrustum._get3PlaneInterPoint(this._near,this._bottom,this._left).cloneTo(corners[3]);
			BoundFrustum._get3PlaneInterPoint(this._far,this._bottom,this._right).cloneTo(corners[4]);
			BoundFrustum._get3PlaneInterPoint(this._far,this._top,this._right).cloneTo(corners[5]);
			BoundFrustum._get3PlaneInterPoint(this._far,this._top,this._left).cloneTo(corners[6]);
			BoundFrustum._get3PlaneInterPoint(this._far,this._bottom,this._left).cloneTo(corners[7]);
		}

		/**
		*与点的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param point 点。
		*/
		__proto.containsPoint=function(point){
			var result=Plane.PlaneIntersectionType_Front;
			var planeResult=Plane.PlaneIntersectionType_Front;
			for (var i=0;i < 6;i++){
				switch (i){
					case 0:
						planeResult=Collision.intersectsPlaneAndPoint(this._near,point);
						break ;
					case 1:
						planeResult=Collision.intersectsPlaneAndPoint(this._far,point);
						break ;
					case 2:
						planeResult=Collision.intersectsPlaneAndPoint(this._left,point);
						break ;
					case 3:
						planeResult=Collision.intersectsPlaneAndPoint(this._right,point);
						break ;
					case 4:
						planeResult=Collision.intersectsPlaneAndPoint(this._top,point);
						break ;
					case 5:
						planeResult=Collision.intersectsPlaneAndPoint(this._bottom,point);
						break ;
					}
				switch (planeResult){
					case Plane.PlaneIntersectionType_Back:
						return /*laya.d3.math.ContainmentType.Disjoint*/0;
					case Plane.PlaneIntersectionType_Intersecting:
						result=Plane.PlaneIntersectionType_Intersecting;
						break ;
					}
			}
			switch (result){
				case Plane.PlaneIntersectionType_Intersecting:
					return /*laya.d3.math.ContainmentType.Intersects*/2;
				default :
					return /*laya.d3.math.ContainmentType.Contains*/1;
				}
		}

		/**
		*与包围盒的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param box 包围盒。
		*/
		__proto.containsBoundBox=function(box){
			var p=BoundFrustum._tempV30,n=BoundFrustum._tempV31;
			var plane;
			var result=/*laya.d3.math.ContainmentType.Contains*/1;
			for (var i=0;i < 6;i++){
				plane=this.getPlane(i);
				this._getBoxToPlanePVertexNVertex(box,plane.normal,p,n);
				if (Collision.intersectsPlaneAndPoint(plane,p)===Plane.PlaneIntersectionType_Back)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
				if (Collision.intersectsPlaneAndPoint(plane,n)===Plane.PlaneIntersectionType_Back)
					result=/*laya.d3.math.ContainmentType.Intersects*/2;
			}
			return result;
		}

		/**
		*与包围球的位置关系。返回-1,包涵;0,相交;1,不相交
		*@param sphere 包围球。
		*/
		__proto.containsBoundSphere=function(sphere){
			var result=Plane.PlaneIntersectionType_Front;
			var planeResult=Plane.PlaneIntersectionType_Front;
			for (var i=0;i < 6;i++){
				switch (i){
					case 0:
						planeResult=Collision.intersectsPlaneAndSphere(this._near,sphere);
						break ;
					case 1:
						planeResult=Collision.intersectsPlaneAndSphere(this._far,sphere);
						break ;
					case 2:
						planeResult=Collision.intersectsPlaneAndSphere(this._left,sphere);
						break ;
					case 3:
						planeResult=Collision.intersectsPlaneAndSphere(this._right,sphere);
						break ;
					case 4:
						planeResult=Collision.intersectsPlaneAndSphere(this._top,sphere);
						break ;
					case 5:
						planeResult=Collision.intersectsPlaneAndSphere(this._bottom,sphere);
						break ;
					}
				switch (planeResult){
					case Plane.PlaneIntersectionType_Back:
						return /*laya.d3.math.ContainmentType.Disjoint*/0;
					case Plane.PlaneIntersectionType_Intersecting:
						result=Plane.PlaneIntersectionType_Intersecting;
						break ;
					}
			}
			switch (result){
				case Plane.PlaneIntersectionType_Intersecting:
					return /*laya.d3.math.ContainmentType.Intersects*/2;
				default :
					return /*laya.d3.math.ContainmentType.Contains*/1;
				}
		}

		/**
		*@private
		*/
		__proto._getBoxToPlanePVertexNVertex=function(box,planeNormal,outP,outN){
			var boxMin=box.min;
			var boxMinE=boxMin.elements;
			var boxMax=box.max;
			var boxMaxE=boxMax.elements;
			var planeNorE=planeNormal.elements;
			var planeNorEX=planeNorE[0];
			var planeNorEY=planeNorE[1];
			var planeNorEZ=planeNorE[2];
			boxMin.cloneTo(outP);;
			var outPE=outP.elements;
			if (planeNorEX >=0)
				outPE[0]=boxMaxE[0];
			if (planeNorEY >=0)
				outPE[1]=boxMaxE[1];
			if (planeNorEZ >=0)
				outPE[2]=boxMaxE[2];
			boxMax.cloneTo(outN);
			var outNE=outN.elements;
			if (planeNorEX >=0)
				outNE[0]=boxMinE[0];
			if (planeNorEY >=0)
				outNE[1]=boxMinE[1];
			if (planeNorEZ >=0)
				outNE[2]=boxMinE[2];
		}

		/**
		*获取顶平面。
		*@return 顶平面。
		*/
		__getset(0,__proto,'top',function(){
			return this._top;
		});

		/**
		*设置描述矩阵。
		*@param matrix 描述矩阵。
		*/
		/**
		*获取描述矩阵。
		*@return 描述矩阵。
		*/
		__getset(0,__proto,'matrix',function(){
			return this._matrix;
			},function(matrix){
			this._matrix=matrix;
			BoundFrustum._getPlanesFromMatrix(this._matrix,this._near,this._far,this._left,this._right,this._top,this._bottom);
		});

		/**
		*获取近平面。
		*@return 近平面。
		*/
		__getset(0,__proto,'near',function(){
			return this._near;
		});

		/**
		*获取远平面。
		*@return 远平面。
		*/
		__getset(0,__proto,'far',function(){
			return this._far;
		});

		/**
		*获取左平面。
		*@return 左平面。
		*/
		__getset(0,__proto,'left',function(){
			return this._left;
		});

		/**
		*获取右平面。
		*@return 右平面。
		*/
		__getset(0,__proto,'right',function(){
			return this._right;
		});

		/**
		*获取底平面。
		*@return 底平面。
		*/
		__getset(0,__proto,'bottom',function(){
			return this._bottom;
		});

		BoundFrustum._getPlanesFromMatrix=function(m,np,fp,lp,rp,tp,bp){
			var matrixE=m.elements;
			var m11=matrixE[0];
			var m12=matrixE[1];
			var m13=matrixE[2];
			var m14=matrixE[3];
			var m21=matrixE[4];
			var m22=matrixE[5];
			var m23=matrixE[6];
			var m24=matrixE[7];
			var m31=matrixE[8];
			var m32=matrixE[9];
			var m33=matrixE[10];
			var m34=matrixE[11];
			var m41=matrixE[12];
			var m42=matrixE[13];
			var m43=matrixE[14];
			var m44=matrixE[15];
			var nearNorE=np.normal.elements;
			nearNorE[0]=m13;
			nearNorE[1]=m23;
			nearNorE[2]=m33;
			np.distance=m43;
			np.normalize();
			var farNorE=fp.normal.elements;
			farNorE[0]=m14-m13;
			farNorE[1]=m24-m23;
			farNorE[2]=m34-m33;
			fp.distance=m44-m43;
			fp.normalize();
			var leftNorE=lp.normal.elements;
			leftNorE[0]=m14+m11;
			leftNorE[1]=m24+m21;
			leftNorE[2]=m34+m31;
			lp.distance=m44+m41;
			lp.normalize();
			var rightNorE=rp.normal.elements;
			rightNorE[0]=m14-m11;
			rightNorE[1]=m24-m21;
			rightNorE[2]=m34-m31;
			rp.distance=m44-m41;
			rp.normalize();
			var topNorE=tp.normal.elements;
			topNorE[0]=m14-m12;
			topNorE[1]=m24-m22;
			topNorE[2]=m34-m32;
			tp.distance=m44-m42;
			tp.normalize();
			var bottomNorE=bp.normal.elements;
			bottomNorE[0]=m14+m12;
			bottomNorE[1]=m24+m22;
			bottomNorE[2]=m34+m32;
			bp.distance=m44+m42;
			bp.normalize();
		}

		BoundFrustum._get3PlaneInterPoint=function(p1,p2,p3){
			var p1Nor=p1.normal;
			var p2Nor=p2.normal;
			var p3Nor=p3.normal;
			Vector3.cross(p2Nor,p3Nor,BoundFrustum._tempV30);
			Vector3.cross(p3Nor,p1Nor,BoundFrustum._tempV31);
			Vector3.cross(p1Nor,p2Nor,BoundFrustum._tempV32);
			var a=Vector3.dot(p1Nor,BoundFrustum._tempV30);
			var b=Vector3.dot(p2Nor,BoundFrustum._tempV31);
			var c=Vector3.dot(p3Nor,BoundFrustum._tempV32);
			Vector3.scale(BoundFrustum._tempV30,-p1.distance / a,BoundFrustum._tempV33);
			Vector3.scale(BoundFrustum._tempV31,-p2.distance / b,BoundFrustum._tempV34);
			Vector3.scale(BoundFrustum._tempV32,-p3.distance / c,BoundFrustum._tempV35);
			Vector3.add(BoundFrustum._tempV33,BoundFrustum._tempV34,BoundFrustum._tempV36);
			Vector3.add(BoundFrustum._tempV35,BoundFrustum._tempV36,BoundFrustum._tempV37);
			var v=BoundFrustum._tempV37;
			return v;
		}

		__static(BoundFrustum,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempV37',function(){return this._tempV37=new Vector3();}
		]);
		return BoundFrustum;
	})()


	/**
	*<code>BoundSphere</code> 类用于创建包围球。
	*/
	//class laya.d3.math.BoundSphere
	var BoundSphere=(function(){
		function BoundSphere(center,radius){
			this.center=null;
			this.radius=NaN;
			this.center=center;
			this.radius=radius;
		}

		__class(BoundSphere,'laya.d3.math.BoundSphere');
		var __proto=BoundSphere.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		__proto.toDefault=function(){
			this.center.toDefault();
			this.radius=0;
		}

		/**
		*判断射线是否与碰撞球交叉，并返回交叉距离。
		*@param ray 射线。
		*@return 距离交叉点的距离，-1表示不交叉。
		*/
		__proto.intersectsRayDistance=function(ray){
			return Collision.intersectsRayAndSphereRD(ray,this);
		}

		/**
		*判断射线是否与碰撞球交叉，并返回交叉点。
		*@param ray 射线。
		*@param point 交叉点。
		*@return 距离交叉点的距离，-1表示不交叉。
		*/
		__proto.intersectsRayPoint=function(ray,point){
			return Collision.intersectsRayAndSphereRP(ray,this,point);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			this.center.cloneTo(dest.center);
			dest.radius=this.radius;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=/*__JS__ */new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		BoundSphere.createFromSubPoints=function(points,start,count,out){
			if (points==null){
				throw new Error("points");
			}
			if (start < 0 || start >=points.length){
				throw new Error("start"+start+"Must be in the range [0, "+(points.length-1)+"]");
			}
			if (count < 0 || (start+count)> points.length){
				throw new Error("count"+count+"Must be in the range <= "+points.length+"}");
			};
			var upperEnd=start+count;
			var center=BoundSphere._tempVector3;
			center.elements[0]=0;
			center.elements[1]=0;
			center.elements[2]=0;
			for (var i=start;i < upperEnd;++i){
				Vector3.add(points[i],center,center);
			};
			var outCenter=out.center;
			Vector3.scale(center,1 / count,outCenter);
			var radius=0.0;
			for (i=start;i < upperEnd;++i){
				var distance=Vector3.distanceSquared(outCenter,points[i]);
				if (distance > radius)
					radius=distance;
			}
			out.radius=Math.sqrt(radius);
		}

		BoundSphere.createfromPoints=function(points,out){
			if (points==null){
				throw new Error("points");
			}
			BoundSphere.createFromSubPoints(points,0,points.length,out);
		}

		__static(BoundSphere,
		['_tempVector3',function(){return this._tempVector3=new Vector3();}
		]);
		return BoundSphere;
	})()


	/**
	*<code>Collision</code> 类用于检测碰撞。
	*/
	//class laya.d3.math.Collision
	var Collision=(function(){
		/**
		*创建一个 <code>Collision</code> 实例。
		*/
		function Collision(){}
		__class(Collision,'laya.d3.math.Collision');
		Collision.distancePlaneToPoint=function(plane,point){
			var dot=Vector3.dot(plane.normal,point);
			return dot-plane.distance;
		}

		Collision.distanceBoxToPoint=function(box,point){
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var pointe=point.elements;
			var pointeX=pointe[0];
			var pointeY=pointe[1];
			var pointeZ=pointe[2];
			var distance=0;
			if (pointeX < boxMineX)
				distance+=(boxMineX-pointeX)*(boxMineX-pointeX);
			if (pointeX > boxMaxeX)
				distance+=(boxMaxeX-pointeX)*(boxMaxeX-pointeX);
			if (pointeY < boxMineY)
				distance+=(boxMineY-pointeY)*(boxMineY-pointeY);
			if (pointeY > boxMaxeY)
				distance+=(boxMaxeY-pointeY)*(boxMaxeY-pointeY);
			if (pointeZ < boxMineZ)
				distance+=(boxMineZ-pointeZ)*(boxMineZ-pointeZ);
			if (pointeZ > boxMaxeZ)
				distance+=(boxMaxeZ-pointeZ)*(boxMaxeZ-pointeZ);
			return Math.sqrt(distance);
		}

		Collision.distanceBoxToBox=function(box1,box2){
			var box1Mine=box1.min.elements;
			var box1MineX=box1Mine[0];
			var box1MineY=box1Mine[1];
			var box1MineZ=box1Mine[2];
			var box1Maxe=box1.max.elements;
			var box1MaxeX=box1Maxe[0];
			var box1MaxeY=box1Maxe[1];
			var box1MaxeZ=box1Maxe[2];
			var box2Mine=box2.min.elements;
			var box2MineX=box2Mine[0];
			var box2MineY=box2Mine[1];
			var box2MineZ=box2Mine[2];
			var box2Maxe=box2.max.elements;
			var box2MaxeX=box2Maxe[0];
			var box2MaxeY=box2Maxe[1];
			var box2MaxeZ=box2Maxe[2];
			var distance=0;
			var delta=NaN;
			if (box1MineX > box2MaxeX){
				delta=box1MineX-box2MaxeX;
				distance+=delta *delta;
				}else if (box2MineX > box1MaxeX){
				delta=box2MineX-box1MaxeX;
				distance+=delta *delta;
			}
			if (box1MineY > box2MaxeY){
				delta=box1MineY-box2MaxeY;
				distance+=delta *delta;
				}else if (box2MineY > box1MaxeY){
				delta=box2MineY-box1MaxeY;
				distance+=delta *delta;
			}
			if (box1MineZ > box2MaxeZ){
				delta=box1MineZ-box2MaxeZ;
				distance+=delta *delta;
				}else if (box2MineZ > box1MaxeZ){
				delta=box2MineZ-box1MaxeZ;
				distance+=delta *delta;
			}
			return Math.sqrt(distance);
		}

		Collision.distanceSphereToPoint=function(sphere,point){
			var distance=Math.sqrt(Vector3.distanceSquared(sphere.center,point));
			distance-=sphere.radius;
			return Math.max(distance,0);
		}

		Collision.distanceSphereToSphere=function(sphere1,sphere2){
			var distance=Math.sqrt(Vector3.distanceSquared(sphere1.center,sphere2.center));
			distance-=sphere1.radius+sphere2.radius;
			return Math.max(distance,0);
		}

		Collision.intersectsRayAndTriangleRD=function(ray,vertex1,vertex2,vertex3,out){
			var rayO=ray.origin;
			var rayOe=rayO.elements;
			var rayOeX=rayOe[0];
			var rayOeY=rayOe[1];
			var rayOeZ=rayOe[2];
			var rayD=ray.direction;
			var rayDe=rayD.elements;
			var rayDeX=rayDe[0];
			var rayDeY=rayDe[1];
			var rayDeZ=rayDe[2];
			var v1e=vertex1.elements;
			var v1eX=v1e[0];
			var v1eY=v1e[1];
			var v1eZ=v1e[2];
			var v2e=vertex2.elements;
			var v2eX=v2e[0];
			var v2eY=v2e[1];
			var v2eZ=v2e[2];
			var v3e=vertex3.elements;
			var v3eX=v3e[0];
			var v3eY=v3e[1];
			var v3eZ=v3e[2];
			var _tempV30e=Collision._tempV30.elements;
			var _tempV30eX=_tempV30e[0];
			var _tempV30eY=_tempV30e[1];
			var _tempV30eZ=_tempV30e[2];
			_tempV30eX=v2eX-v1eX;
			_tempV30eY=v2eY-v1eY;
			_tempV30eZ=v2eZ-v1eZ;
			var _tempV31e=Collision._tempV31.elements;
			var _tempV31eX=_tempV31e[0];
			var _tempV31eY=_tempV31e[1];
			var _tempV31eZ=_tempV31e[2];
			_tempV31eX=v3eX-v1eX;
			_tempV31eY=v3eY-v1eY;
			_tempV31eZ=v3eZ-v1eZ;
			var _tempV32e=Collision._tempV32.elements;
			var _tempV32eX=_tempV32e[0];
			var _tempV32eY=_tempV32e[1];
			var _tempV32eZ=_tempV32e[2];
			_tempV32eX=(rayDeY *_tempV31eZ)-(rayDeZ *_tempV31eY);
			_tempV32eY=(rayDeZ *_tempV31eX)-(rayDeX *_tempV31eZ);
			_tempV32eZ=(rayDeX *_tempV31eY)-(rayDeY *_tempV31eX);
			var determinant=(_tempV30eX *_tempV32eX)+(_tempV30eY *_tempV32eY)+(_tempV30eZ *_tempV32eZ);
			if (MathUtils3D.isZero(determinant)){
				out=0;
				return false;
			};
			var inversedeterminant=1 / determinant;
			var _tempV33e=Collision._tempV33.elements;
			var _tempV33eX=_tempV33e[0];
			var _tempV33eY=_tempV33e[1];
			var _tempV33eZ=_tempV33e[2];
			_tempV33eX=rayOeX-v1eX;
			_tempV33eY=rayOeY-v1eY;
			_tempV33eZ=rayOeZ-v1eZ;
			var triangleU=(_tempV33eX *_tempV32eX)+(_tempV33eY *_tempV32eY)+(_tempV33eZ *_tempV32eZ);
			triangleU *=inversedeterminant;
			if (triangleU < 0 || triangleU > 1){
				out=0;
				return false;
			};
			var _tempV34e=Collision._tempV34.elements;
			var _tempV34eX=_tempV34e[0];
			var _tempV34eY=_tempV34e[1];
			var _tempV34eZ=_tempV34e[2];
			_tempV34eX=(_tempV33eY *_tempV30eZ)-(_tempV33eZ *_tempV30eY);
			_tempV34eY=(_tempV33eZ *_tempV30eX)-(_tempV33eX *_tempV30eZ);
			_tempV34eZ=(_tempV33eX *_tempV30eY)-(_tempV33eY *_tempV30eX);
			var triangleV=((rayDeX *_tempV34eX)+(rayDeY *_tempV34eY))+(rayDeZ *_tempV34eZ);
			triangleV *=inversedeterminant;
			if (triangleV < 0 || triangleU+triangleV > 1){
				out=0;
				return false;
			};
			var raydistance=(_tempV31eX *_tempV34eX)+(_tempV31eY *_tempV34eY)+(_tempV31eZ *_tempV34eZ);
			raydistance *=inversedeterminant;
			if (raydistance < 0){
				out=0;
				return false;
			}
			out=raydistance;
			return true;
		}

		Collision.intersectsRayAndTriangleRP=function(ray,vertex1,vertex2,vertex3,out){
			var distance=NaN;
			if (!Collision.intersectsRayAndTriangleRD(ray,vertex1,vertex2,vertex3,distance)){
				out=Vector3.ZERO;
				return false;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,out);
			return true;
		}

		Collision.intersectsRayAndPoint=function(ray,point){
			Vector3.subtract(ray.origin,point,Collision._tempV30);
			var b=Vector3.dot(Collision._tempV30,ray.direction);
			var c=Vector3.dot(Collision._tempV30,Collision._tempV30)-MathUtils3D.zeroTolerance;
			if (c > 0 && b > 0)
				return false;
			var discriminant=b *b-c;
			if (discriminant < 0)
				return false;
			return true;
		}

		Collision.intersectsRayAndRay=function(ray1,ray2,out){
			var ray1o=ray1.origin;
			var ray1oe=ray1o.elements;
			var ray1oeX=ray1oe[0];
			var ray1oeY=ray1oe[1];
			var ray1oeZ=ray1oe[2];
			var ray1d=ray1.direction;
			var ray1de=ray1d.elements;
			var ray1deX=ray1de[0];
			var ray1deY=ray1de[1];
			var ray1deZ=ray1de[2];
			var ray2o=ray2.origin;
			var ray2oe=ray2o.elements;
			var ray2oeX=ray2oe[0];
			var ray2oeY=ray2oe[1];
			var ray2oeZ=ray2oe[2];
			var ray2d=ray2.direction;
			var ray2de=ray2d.elements;
			var ray2deX=ray2de[0];
			var ray2deY=ray2de[1];
			var ray2deZ=ray2de[2];
			Vector3.cross(ray1d,ray2d,Collision._tempV30);
			var tempV3e=Collision._tempV30.elements;
			var denominator=Vector3.scalarLength(Collision._tempV30);
			if (MathUtils3D.isZero(denominator)){
				if (MathUtils3D.nearEqual(ray2oeX,ray1oeX)&& MathUtils3D.nearEqual(ray2oeY,ray1oeY)&& MathUtils3D.nearEqual(ray2oeZ,ray1oeZ)){
					out=Vector3.ZERO;
					return true;
				}
			}
			denominator=denominator *denominator;
			var m11=ray2oeX-ray1oeX;
			var m12=ray2oeY-ray1oeY;
			var m13=ray2oeZ-ray1oeZ;
			var m21=ray2deX;
			var m22=ray2deY;
			var m23=ray2deZ;
			var m31=tempV3e[0];
			var m32=tempV3e[1];
			var m33=tempV3e[2];
			var dets=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
			m21=ray1deX;
			m22=ray1deY;
			m23=ray1deZ;
			var dett=m11 *m22 *m33+m12 *m23 *m31+m13 *m21 *m32-m11 *m23 *m32-m12 *m21 *m33-m13 *m22 *m31;
			var s=dets / denominator;
			var t=dett / denominator;
			Vector3.scale(ray1d,s,Collision._tempV30);
			Vector3.scale(ray2d,s,Collision._tempV31);
			Vector3.add(ray1o,Collision._tempV30,Collision._tempV32);
			Vector3.add(ray2o,Collision._tempV31,Collision._tempV33);
			var point1e=Collision._tempV32.elements;
			var point2e=Collision._tempV33.elements;
			if (!MathUtils3D.nearEqual(point2e[0],point1e[0])|| !MathUtils3D.nearEqual(point2e[1],point1e[1])|| !MathUtils3D.nearEqual(point2e[2],point1e[2])){
				out=Vector3.ZERO;
				return false;
			}
			out=Collision._tempV32;
			return true;
		}

		Collision.intersectsPlaneAndTriangle=function(plane,vertex1,vertex2,vertex3){
			var test1=Collision.intersectsPlaneAndPoint(plane,vertex1);
			var test2=Collision.intersectsPlaneAndPoint(plane,vertex2);
			var test3=Collision.intersectsPlaneAndPoint(plane,vertex3);
			if (test1==Plane.PlaneIntersectionType_Front && test2==Plane.PlaneIntersectionType_Front && test3==Plane.PlaneIntersectionType_Front)
				return Plane.PlaneIntersectionType_Front;
			if (test1==Plane.PlaneIntersectionType_Back && test2==Plane.PlaneIntersectionType_Back && test3==Plane.PlaneIntersectionType_Back)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsRayAndPlaneRD=function(ray,plane,out){
			var planeNor=plane.normal;
			var direction=Vector3.dot(planeNor,ray.direction);
			if (MathUtils3D.isZero(direction)){
				out=0;
				return false;
			};
			var position=Vector3.dot(planeNor,ray.origin);
			out=(-plane.distance-position)/ direction;
			if (out < 0){
				out=0;
				return false;
			}
			return true;
		}

		Collision.intersectsRayAndPlaneRP=function(ray,plane,out){
			var distance=NaN;
			if (!Collision.intersectsRayAndPlaneRD(ray,plane,distance)){
				out=Vector3.ZERO;
				return false;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			out=Collision._tempV31;
			return true;
		}

		Collision.intersectsRayAndBoxRD=function(ray,box){
			var rayoe=ray.origin.elements;
			var rayoeX=rayoe[0];
			var rayoeY=rayoe[1];
			var rayoeZ=rayoe[2];
			var rayde=ray.direction.elements;
			var raydeX=rayde[0];
			var raydeY=rayde[1];
			var raydeZ=rayde[2];
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var out=0;
			var tmax=MathUtils3D.MaxValue;
			if (MathUtils3D.isZero(raydeX)){
				if (rayoeX < boxMineX || rayoeX > boxMaxeX){
					return-1;
				}
				}else {
				var inverse=1 / raydeX;
				var t1=(boxMineX-rayoeX)*inverse;
				var t2=(boxMaxeX-rayoeX)*inverse;
				if (t1 > t2){
					var temp=t1;
					t1=t2;
					t2=temp;
				}
				out=Math.max(t1,out);
				tmax=Math.min(t2,tmax);
				if (out > tmax){
					return-1;
				}
			}
			if (MathUtils3D.isZero(raydeY)){
				if (rayoeY < boxMineY || rayoeY > boxMaxeY){
					return-1;
				}
				}else {
				var inverse1=1 / raydeY;
				var t3=(boxMineY-rayoeY)*inverse1;
				var t4=(boxMaxeY-rayoeY)*inverse1;
				if (t3 > t4){
					var temp1=t3;
					t3=t4;
					t4=temp1;
				}
				out=Math.max(t3,out);
				tmax=Math.min(t4,tmax);
				if (out > tmax){
					return-1;
				}
			}
			if (MathUtils3D.isZero(raydeZ)){
				if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ){
					return-1;
				}
				}else {
				var inverse2=1 / raydeZ;
				var t5=(boxMineZ-rayoeZ)*inverse2;
				var t6=(boxMaxeZ-rayoeZ)*inverse2;
				if (t5 > t6){
					var temp2=t5;
					t5=t6;
					t6=temp2;
				}
				out=Math.max(t5,out);
				tmax=Math.min(t6,tmax);
				if (out > tmax){
					return-1;
				}
			}
			return out;
		}

		Collision.intersectsRayAndBoxRP=function(ray,box,out){
			var distance=Collision.intersectsRayAndBoxRD(ray,box);
			if (distance===-1){
				Vector3.ZERO.cloneTo(out);
				return distance;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			Collision._tempV31.cloneTo(out);
			return distance;
		}

		Collision.intersectsRayAndSphereRD=function(ray,sphere){
			var sphereR=sphere.radius;
			Vector3.subtract(ray.origin,sphere.center,Collision._tempV30);
			var b=Vector3.dot(Collision._tempV30,ray.direction);
			var c=Vector3.dot(Collision._tempV30,Collision._tempV30)-(sphereR *sphereR);
			if (c > 0 && b > 0){
				return-1;
			};
			var discriminant=b *b-c;
			if (discriminant < 0){
				return-1;
			};
			var distance=-b-Math.sqrt(discriminant);
			if (distance < 0)
				distance=0;
			return distance;
		}

		Collision.intersectsRayAndSphereRP=function(ray,sphere,out){
			var distance=Collision.intersectsRayAndSphereRD(ray,sphere);
			if (distance===-1){
				Vector3.ZERO.cloneTo(out);
				return distance;
			}
			Vector3.scale(ray.direction,distance,Collision._tempV30);
			Vector3.add(ray.origin,Collision._tempV30,Collision._tempV31);
			Collision._tempV31.cloneTo(out);
			return distance;
		}

		Collision.intersectsSphereAndTriangle=function(sphere,vertex1,vertex2,vertex3){
			var sphereC=sphere.center;
			var sphereR=sphere.radius;
			Collision.closestPointPointTriangle(sphereC,vertex1,vertex2,vertex3,Collision._tempV30);
			Vector3.subtract(Collision._tempV30,sphereC,Collision._tempV31);
			var dot=Vector3.dot(Collision._tempV31,Collision._tempV31);
			return dot <=sphereR *sphereR;
		}

		Collision.intersectsPlaneAndPoint=function(plane,point){
			var distance=Vector3.dot(plane.normal,point)+plane.distance;
			if (distance > 0)
				return Plane.PlaneIntersectionType_Front;
			if (distance < 0)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsPlaneAndPlane=function(plane1,plane2){
			Vector3.cross(plane1.normal,plane2.normal,Collision._tempV30);
			var denominator=Vector3.dot(Collision._tempV30,Collision._tempV30);
			if (MathUtils3D.isZero(denominator))
				return false;
			return true;
		}

		Collision.intersectsPlaneAndPlaneRL=function(plane1,plane2,line){
			var plane1nor=plane1.normal;
			var plane2nor=plane2.normal;
			Vector3.cross(plane1nor,plane2nor,Collision._tempV34);
			var denominator=Vector3.dot(Collision._tempV34,Collision._tempV34);
			if (MathUtils3D.isZero(denominator))
				return false;
			Vector3.scale(plane2nor,plane1.distance,Collision._tempV30);
			Vector3.scale(plane1nor,plane2.distance,Collision._tempV31);
			Vector3.subtract(Collision._tempV30,Collision._tempV31,Collision._tempV32);
			Vector3.cross(Collision._tempV32,Collision._tempV34,Collision._tempV33);
			Vector3.normalize(Collision._tempV34,Collision._tempV34);
			line=new Ray(Collision._tempV33,Collision._tempV34);
			return true;
		}

		Collision.intersectsPlaneAndBox=function(plane,box){
			var planeD=plane.distance;
			var planeNor=plane.normal;
			var planeNore=planeNor.elements;
			var planeNoreX=planeNore[0];
			var planeNoreY=planeNore[1];
			var planeNoreZ=planeNore[2];
			var boxMine=box.min.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMaxe=box.max.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			Collision._tempV30.elements[0]=(planeNoreX > 0)? boxMineX :boxMaxeX;
			Collision._tempV30.elements[1]=(planeNoreY > 0)? boxMineY :boxMaxeY;
			Collision._tempV30.elements[2]=(planeNoreZ > 0)? boxMineZ :boxMaxeZ;
			Collision._tempV31.elements[0]=(planeNoreX > 0)? boxMaxeX :boxMineX;
			Collision._tempV31.elements[1]=(planeNoreY > 0)? boxMaxeY :boxMineY;
			Collision._tempV31.elements[2]=(planeNoreZ > 0)? boxMaxeZ :boxMineZ;
			var distance=Vector3.dot(planeNor,Collision._tempV30);
			if (distance+planeD > 0)
				return Plane.PlaneIntersectionType_Front;
			distance=Vector3.dot(planeNor,Collision._tempV31);
			if (distance+planeD < 0)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsPlaneAndSphere=function(plane,sphere){
			var sphereR=sphere.radius;
			var distance=Vector3.dot(plane.normal,sphere.center)+plane.distance;
			if (distance > sphereR)
				return Plane.PlaneIntersectionType_Front;
			if (distance <-sphereR)
				return Plane.PlaneIntersectionType_Back;
			return Plane.PlaneIntersectionType_Intersecting;
		}

		Collision.intersectsBoxAndBox=function(box1,box2){
			var box1Mine=box1.min.elements;
			var box1Maxe=box1.max.elements;
			var box2Mine=box2.min.elements;
			var box2Maxe=box2.max.elements;
			if (box1Mine[0] > box2Maxe[0] || box2Mine[0] > box1Maxe[0])
				return false;
			if (box1Mine[1] > box2Maxe[1] || box2Mine[1] > box1Maxe[1])
				return false;
			if (box1Mine[2] > box2Maxe[2] || box2Mine[2] > box1Maxe[2])
				return false;
			return true;
		}

		Collision.intersectsBoxAndSphere=function(box,sphere){
			var sphereC=sphere.center;
			var sphereR=sphere.radius;
			Vector3.Clamp(sphereC,box.min,box.max,Collision._tempV30);
			var distance=Vector3.distanceSquared(sphereC,Collision._tempV30);
			return distance <=sphereR *sphereR;
		}

		Collision.intersectsSphereAndSphere=function(sphere1,sphere2){
			var radiisum=sphere1.radius+sphere2.radius;
			return Vector3.distanceSquared(sphere1.center,sphere2.center)<=radiisum *radiisum;
		}

		Collision.boxContainsPoint=function(box,point){
			var boxMine=box.min.elements;
			var boxMaxe=box.max.elements;
			var pointe=point.elements;
			if (boxMine[0] <=pointe[0] && boxMaxe[0] >=pointe[0] && boxMine[1] <=pointe[1] && boxMaxe[1] >=pointe[1] && boxMine[2] <=pointe[2] && boxMaxe[2] >=pointe[2])
				return /*laya.d3.math.ContainmentType.Contains*/1;
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}

		Collision.boxContainsBox=function(box1,box2){
			var box1Mine=box1.min.elements;
			var box1MineX=box1Mine[0];
			var box1MineY=box1Mine[1];
			var box1MineZ=box1Mine[2];
			var box1Maxe=box1.max.elements;
			var box1MaxeX=box1Maxe[0];
			var box1MaxeY=box1Maxe[1];
			var box1MaxeZ=box1Maxe[2];
			var box2Mine=box2.min.elements;
			var box2MineX=box2Mine[0];
			var box2MineY=box2Mine[1];
			var box2MineZ=box2Mine[2];
			var box2Maxe=box2.max.elements;
			var box2MaxeX=box2Maxe[0];
			var box2MaxeY=box2Maxe[1];
			var box2MaxeZ=box2Maxe[2];
			if (box1MaxeX < box2MineX || box1MineX > box2MaxeX)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (box1MaxeY < box2MineY || box1MineY > box2MaxeY)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (box1MaxeZ < box2MineZ || box1MineZ > box2MaxeZ)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (box1MineX <=box2MineX && box2MaxeX <=box2MaxeX && box1MineY <=box2MineY && box2MaxeY <=box1MaxeY && box1MineZ <=box2MineZ && box2MaxeZ <=box1MaxeZ){
				return /*laya.d3.math.ContainmentType.Contains*/1;
			}
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		}

		Collision.boxContainsSphere=function(box,sphere){
			var boxMin=box.min;
			var boxMine=boxMin.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMax=box.max;
			var boxMaxe=boxMax.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var sphereC=sphere.center;
			var sphereCe=sphereC.elements;
			var sphereCeX=sphereCe[0];
			var sphereCeY=sphereCe[1];
			var sphereCeZ=sphereCe[2];
			var sphereR=sphere.radius;
			Vector3.Clamp(sphereC,boxMin,boxMax,Collision._tempV30);
			var distance=Vector3.distanceSquared(sphereC,Collision._tempV30);
			if (distance > sphereR *sphereR)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if ((((boxMineX+sphereR <=sphereCeX)&& (sphereCeX <=boxMaxeX-sphereR))&& ((boxMaxeX-boxMineX > sphereR)&&
				(boxMineY+sphereR <=sphereCeY)))&& (((sphereCeY <=boxMaxeY-sphereR)&& (boxMaxeY-boxMineY > sphereR))&&
			(((boxMineZ+sphereR <=sphereCeZ)&& (sphereCeZ <=boxMaxeZ-sphereR))&& (boxMaxeZ-boxMineZ > sphereR))))
			return /*laya.d3.math.ContainmentType.Contains*/1;
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		}

		Collision.sphereContainsPoint=function(sphere,point){
			if (Vector3.distanceSquared(point,sphere.center)<=sphere.radius *sphere.radius)
				return /*laya.d3.math.ContainmentType.Contains*/1;
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}

		Collision.sphereContainsTriangle=function(sphere,vertex1,vertex2,vertex3){
			var test1=Collision.sphereContainsPoint(sphere,vertex1);
			var test2=Collision.sphereContainsPoint(sphere,vertex2);
			var test3=Collision.sphereContainsPoint(sphere,vertex3);
			if (test1==/*laya.d3.math.ContainmentType.Contains*/1 && test2==/*laya.d3.math.ContainmentType.Contains*/1 && test3==/*laya.d3.math.ContainmentType.Contains*/1)
				return /*laya.d3.math.ContainmentType.Contains*/1;
			if (Collision.intersectsSphereAndTriangle(sphere,vertex1,vertex2,vertex3))
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}

		Collision.sphereContainsBox=function(sphere,box){
			var sphereC=sphere.center;
			var sphereCe=sphereC.elements;
			var sphereCeX=sphereCe[0];
			var sphereCeY=sphereCe[1];
			var sphereCeZ=sphereCe[2];
			var sphereR=sphere.radius;
			var boxMin=box.min;
			var boxMine=boxMin.elements;
			var boxMineX=boxMine[0];
			var boxMineY=boxMine[1];
			var boxMineZ=boxMine[2];
			var boxMax=box.max;
			var boxMaxe=boxMax.elements;
			var boxMaxeX=boxMaxe[0];
			var boxMaxeY=boxMaxe[1];
			var boxMaxeZ=boxMaxe[2];
			var _tempV30e=Collision._tempV30.elements;
			var _tempV30eX=_tempV30e[0];
			var _tempV30eY=_tempV30e[1];
			var _tempV30eZ=_tempV30e[2];
			if (!Collision.intersectsBoxAndSphere(box,sphere))
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			var radiusSquared=sphereR *sphereR;
			_tempV30eX=sphereCeX-boxMineX;
			_tempV30eY=sphereCeY-boxMaxeY;
			_tempV30eZ=sphereCeZ-boxMaxeZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			_tempV30eX=sphereCeX-boxMaxeX;
			_tempV30eY=sphereCeY-boxMaxeY;
			_tempV30eZ=sphereCeZ-boxMaxeZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			_tempV30eX=sphereCeX-boxMaxeX;
			_tempV30eY=sphereCeY-boxMineY;
			_tempV30eZ=sphereCeZ-boxMaxeZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			_tempV30eX=sphereCeX-boxMineX;
			_tempV30eY=sphereCeY-boxMineY;
			_tempV30eZ=sphereCeZ-boxMaxeZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			_tempV30eX=sphereCeX-boxMineX;
			_tempV30eY=sphereCeY-boxMaxeY;
			_tempV30eZ=sphereCeZ-boxMineZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			_tempV30eX=sphereCeX-boxMaxeX;
			_tempV30eY=sphereCeY-boxMaxeY;
			_tempV30eZ=sphereCeZ-boxMineZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			_tempV30eX=sphereCeX-boxMaxeX;
			_tempV30eY=sphereCeY-boxMineY;
			_tempV30eZ=sphereCeZ-boxMineZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			_tempV30eX=sphereCeX-boxMineX;
			_tempV30eY=sphereCeY-boxMineY;
			_tempV30eZ=sphereCeZ-boxMineZ;
			if (Vector3.scalarLengthSquared(Collision._tempV30)> radiusSquared)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			return /*laya.d3.math.ContainmentType.Contains*/1;
		}

		Collision.sphereContainsSphere=function(sphere1,sphere2){
			var sphere1R=sphere1.radius;
			var sphere2R=sphere2.radius;
			var distance=Vector3.distance(sphere1.center,sphere2.center);
			if (sphere1R+sphere2R < distance)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (sphere1R-sphere2R < distance)
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			return /*laya.d3.math.ContainmentType.Contains*/1;
		}

		Collision.closestPointPointTriangle=function(point,vertex1,vertex2,vertex3,out){
			Vector3.subtract(vertex2,vertex1,Collision._tempV30);
			Vector3.subtract(vertex3,vertex1,Collision._tempV31);
			Vector3.subtract(point,vertex1,Collision._tempV32);
			Vector3.subtract(point,vertex2,Collision._tempV33);
			Vector3.subtract(point,vertex3,Collision._tempV34);
			var d1=Vector3.dot(Collision._tempV30,Collision._tempV32);
			var d2=Vector3.dot(Collision._tempV31,Collision._tempV32);
			var d3=Vector3.dot(Collision._tempV30,Collision._tempV33);
			var d4=Vector3.dot(Collision._tempV31,Collision._tempV33);
			var d5=Vector3.dot(Collision._tempV30,Collision._tempV34);
			var d6=Vector3.dot(Collision._tempV31,Collision._tempV34);
			if (d1 <=0 && d2 <=0){
				vertex1.cloneTo(out);
				return;
			}
			if (d3 >=0 && d4 <=d3){
				vertex2.cloneTo(out);
				return;
			};
			var vc=d1 *d4-d3 *d2;
			if (vc <=0 && d1 >=0 && d3 <=0){
				var v=d1 / (d1-d3);
				Vector3.scale(Collision._tempV30,v,out);
				Vector3.add(vertex1,out,out);
				return;
			}
			if (d6 >=0 && d5 <=d6){
				vertex3.cloneTo(out);
				return;
			};
			var vb=d5 *d2-d1 *d6;
			if (vb <=0 && d2 >=0 && d6 <=0){
				var w=d2 / (d2-d6);
				Vector3.scale(Collision._tempV31,w,out);
				Vector3.add(vertex1,out,out);
				return;
			};
			var va=d3 *d6-d5 *d4;
			if (va <=0 && (d4-d3)>=0 && (d5-d6)>=0){
				var w3=(d4-d3)/ ((d4-d3)+(d5-d6));
				Vector3.subtract(vertex3,vertex2,out);
				Vector3.scale(out,w3,out);
				Vector3.add(vertex2,out,out);
				return;
			};
			var denom=1 / (va+vb+vc);
			var v2=vb *denom;
			var w2=vc *denom;
			Vector3.scale(Collision._tempV30,v2,Collision._tempV35);
			Vector3.scale(Collision._tempV31,w2,Collision._tempV36);
			Vector3.add(Collision._tempV35,Collision._tempV36,out);
			Vector3.add(vertex1,out,out);
		}

		Collision.closestPointPlanePoint=function(plane,point,out){
			var planeN=plane.normal;
			var t=Vector3.dot(planeN,point)-plane.distance;
			Vector3.scale(planeN,t,Collision._tempV30);
			Vector3.subtract(point,Collision._tempV30,out);
		}

		Collision.closestPointBoxPoint=function(box,point,out){
			Vector3.max(point,box.min,Collision._tempV30);
			Vector3.min(Collision._tempV30,box.max,out);
		}

		Collision.closestPointSpherePoint=function(sphere,point,out){
			var sphereC=sphere.center;
			Vector3.subtract(point,sphereC,out);
			Vector3.normalize(out,out);
			Vector3.scale(out,sphere.radius,out);
			Vector3.add(out,sphereC,out);
		}

		Collision.closestPointSphereSphere=function(sphere1,sphere2,out){
			var sphere1C=sphere1.center;
			Vector3.subtract(sphere2.center,sphere1C,out);
			Vector3.normalize(out,out);
			Vector3.scale(out,sphere1.radius,out);
			Vector3.add(out,sphere1C,out);
		}

		__static(Collision,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();}
		]);
		return Collision;
	})()


	/**
	*<code>ContainmentType</code> 类用于定义空间物体位置关系。
	*/
	//class laya.d3.math.ContainmentType
	var ContainmentType=(function(){
		function ContainmentType(){};
		__class(ContainmentType,'laya.d3.math.ContainmentType');
		ContainmentType.Disjoint=0;
		ContainmentType.Contains=1;
		ContainmentType.Intersects=2;
		return ContainmentType;
	})()


	/**
	*<code>MathUtils</code> 类用于创建数学工具。
	*/
	//class laya.d3.math.MathUtils3D
	var MathUtils3D=(function(){
		/**
		*创建一个 <code>MathUtils</code> 实例。
		*/
		function MathUtils3D(){}
		__class(MathUtils3D,'laya.d3.math.MathUtils3D');
		MathUtils3D.isZero=function(v){
			return Math.abs(v)< MathUtils3D.zeroTolerance;
		}

		MathUtils3D.nearEqual=function(n1,n2){
			if (MathUtils3D.isZero(n1-n2))
				return true;
			return false;
		}

		MathUtils3D.fastInvSqrt=function(value){
			if (MathUtils3D.isZero(value))
				return value;
			return 1.0 / Math.sqrt(value);
		}

		__static(MathUtils3D,
		['zeroTolerance',function(){return this.zeroTolerance=1e-6;},'MaxValue',function(){return this.MaxValue=3.40282347e+38;},'MinValue',function(){return this.MinValue=-3.40282347e+38;}
		]);
		return MathUtils3D;
	})()


	/**
	*<code>Matrix3x3</code> 类用于创建3x3矩阵。
	*/
	//class laya.d3.math.Matrix3x3
	var Matrix3x3=(function(){
		function Matrix3x3(){
			//this.elements=null;
			var e=this.elements=new Float32Array(9);
			e[0]=1;
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=1;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		__class(Matrix3x3,'laya.d3.math.Matrix3x3');
		var __proto=Matrix3x3.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*计算3x3矩阵的行列式
		*@return 矩阵的行列式
		*/
		__proto.determinant=function(){
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			return a00 *(a22 *a11-a12 *a21)+a01 *(-a22 *a10+a12 *a20)+a02 *(a21 *a10-a11 *a20);
		}

		/**
		*通过一个二维向量转换3x3矩阵
		*@param tra 转换向量
		*@param out 输出矩阵
		*/
		__proto.translate=function(trans,out){
			var e=out.elements;
			var f=this.elements;
			var g=trans.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var x=g[0],y=g[1];
			e[0]=a00;
			e[1]=a01;
			e[2]=a02;
			e[3]=a10;
			e[4]=a11;
			e[5]=a12;
			e[6]=x *a00+y *a10+a20;
			e[7]=x *a01+y *a11+a21;
			e[8]=x *a02+y *a12+a22;
		}

		/**
		*根据指定角度旋转3x3矩阵
		*@param rad 旋转角度
		*@param out 输出矩阵
		*/
		__proto.rotate=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var s=Math.sin(rad);
			var c=Math.cos(rad);
			e[0]=c *a00+s *a10;
			e[1]=c *a01+s *a11;
			e[2]=c *a02+s *a12;
			e[3]=c *a10-s *a00;
			e[4]=c *a11-s *a01;
			e[5]=c *a12-s *a02;
			e[6]=a20;
			e[7]=a21;
			e[8]=a22;
		}

		/**
		*根据制定缩放3x3矩阵
		*@param scale 缩放值
		*@param out 输出矩阵
		*/
		__proto.scale=function(scale,out){
			var e=out.elements;
			var f=this.elements;
			var g=scale.elements;
			var x=g[0],y=g[1];
			e[0]=x *f[0];
			e[1]=x *f[1];
			e[2]=x *f[2];
			e[3]=y *f[3];
			e[4]=y *f[4];
			e[5]=y *f[5];
			e[6]=f[6];
			e[7]=f[7];
			e[8]=f[8];
		}

		/**
		*计算3x3矩阵的逆矩阵
		*@param out 输出的逆矩阵
		*/
		__proto.invert=function(out){
			var e=out.elements;
			var f=this.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var b01=a22 *a11-a12 *a21;
			var b11=-a22 *a10+a12 *a20;
			var b21=a21 *a10-a11 *a20;
			var det=a00 *b01+a01 *b11+a02 *b21;
			if (!det){
				out=null;
			}
			det=1.0 / det;
			e[0]=b01 *det;
			e[1]=(-a22 *a01+a02 *a21)*det;
			e[2]=(a12 *a01-a02 *a11)*det;
			e[3]=b11 *det;
			e[4]=(a22 *a00-a02 *a20)*det;
			e[5]=(-a12 *a00+a02 *a10)*det;
			e[6]=b21 *det;
			e[7]=(-a21 *a00+a01 *a20)*det;
			e[8]=(a11 *a00-a01 *a10)*det;
		}

		/**
		*计算3x3矩阵的转置矩阵
		*@param out 输出矩阵
		*/
		__proto.transpose=function(out){
			var e=out.elements;
			var f=this.elements;
			if (out===this){
				var a01=f[1],a02=f[2],a12=f[5];
				e[1]=f[3];
				e[2]=f[6];
				e[3]=a01;
				e[5]=f[7];
				e[6]=a02;
				e[7]=a12;
				}else {
				e[0]=f[0];
				e[1]=f[3];
				e[2]=f[6];
				e[3]=f[1];
				e[4]=f[4];
				e[5]=f[7];
				e[6]=f[2];
				e[7]=f[5];
				e[8]=f[8];
			}
		}

		/**设置已有的矩阵为单位矩阵*/
		__proto.identity=function(){
			var e=this.elements;
			e[0]=1;
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=1;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var i,s,d;
			s=this.elements;
			d=destObject.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 9;++i){
				d[i]=s[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=/*__JS__ */new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		Matrix3x3.createFromTranslation=function(trans,out){
			var e=out.elements;
			var g=trans.elements;
			out[0]=1;
			out[1]=0;
			out[2]=0;
			out[3]=0;
			out[4]=1;
			out[5]=0;
			out[6]=g[0];
			out[7]=g[1];
			out[8]=1;
		}

		Matrix3x3.createFromRotation=function(rad,out){
			var e=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			e[0]=c;
			e[1]=s;
			e[2]=0;
			e[3]=-s;
			e[4]=c;
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		Matrix3x3.createFromScaling=function(scale,out){
			var e=out.elements;
			var g=scale.elements;
			e[0]=g[0];
			e[1]=0;
			e[2]=0;
			e[3]=0;
			e[4]=g[1];
			e[5]=0;
			e[6]=0;
			e[7]=0;
			e[8]=1;
		}

		Matrix3x3.createFromMatrix4x4=function(sou,out){
			out[0]=sou[0];
			out[1]=sou[1];
			out[2]=sou[2];
			out[3]=sou[4];
			out[4]=sou[5];
			out[5]=sou[6];
			out[6]=sou[8];
			out[7]=sou[9];
			out[8]=sou[10];
		}

		Matrix3x3.multiply=function(left,right,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			var a00=f[0],a01=f[1],a02=f[2];
			var a10=f[3],a11=f[4],a12=f[5];
			var a20=f[6],a21=f[7],a22=f[8];
			var b00=g[0],b01=g[1],b02=g[2];
			var b10=g[3],b11=g[4],b12=g[5];
			var b20=g[6],b21=g[7],b22=g[8];
			e[0]=b00 *a00+b01 *a10+b02 *a20;
			e[1]=b00 *a01+b01 *a11+b02 *a21;
			e[2]=b00 *a02+b01 *a12+b02 *a22;
			e[3]=b10 *a00+b11 *a10+b12 *a20;
			e[4]=b10 *a01+b11 *a11+b12 *a21;
			e[5]=b10 *a02+b11 *a12+b12 *a22;
			e[6]=b20 *a00+b21 *a10+b22 *a20;
			e[7]=b20 *a01+b21 *a11+b22 *a21;
			e[8]=b20 *a02+b21 *a12+b22 *a22;
		}

		Matrix3x3.lookAt=function(eye,target,up,out){
			Vector3.subtract(eye,target,Matrix3x3._tempV30);
			Vector3.normalize(Matrix3x3._tempV30,Matrix3x3._tempV30);
			Vector3.cross(up,Matrix3x3._tempV30,Matrix3x3._tempV31);
			Vector3.normalize(Matrix3x3._tempV31,Matrix3x3._tempV31);
			Vector3.cross(Matrix3x3._tempV30,Matrix3x3._tempV31,Matrix3x3._tempV32);
			var v0e=Matrix3x3._tempV30.elements;
			var v1e=Matrix3x3._tempV31.elements;
			var v2e=Matrix3x3._tempV32.elements;
			var me=out.elements;
			me[0]=v1e[0];
			me[3]=v1e[1];
			me[6]=v1e[2];
			me[1]=v2e[0];
			me[4]=v2e[1];
			me[7]=v2e[2];
			me[2]=v0e[0];
			me[5]=v0e[1];
			me[8]=v0e[2];
		}

		Matrix3x3.DEFAULT=new Matrix3x3();
		__static(Matrix3x3,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();}
		]);
		return Matrix3x3;
	})()


	/**
	*<code>Matrix4x4</code> 类用于创建4x4矩阵。
	*/
	//class laya.d3.math.Matrix4x4
	var Matrix4x4=(function(){
		function Matrix4x4(m11,m12,m13,m14,m21,m22,m23,m24,m31,m32,m33,m34,m41,m42,m43,m44){
			//this.elements=null;
			(m11===void 0)&& (m11=1);
			(m12===void 0)&& (m12=0);
			(m13===void 0)&& (m13=0);
			(m14===void 0)&& (m14=0);
			(m21===void 0)&& (m21=0);
			(m22===void 0)&& (m22=1);
			(m23===void 0)&& (m23=0);
			(m24===void 0)&& (m24=0);
			(m31===void 0)&& (m31=0);
			(m32===void 0)&& (m32=0);
			(m33===void 0)&& (m33=1);
			(m34===void 0)&& (m34=0);
			(m41===void 0)&& (m41=0);
			(m42===void 0)&& (m42=0);
			(m43===void 0)&& (m43=0);
			(m44===void 0)&& (m44=1);
			var e=this.elements=new Float32Array(16);
			e[0]=m11;
			e[1]=m12;
			e[2]=m13;
			e[3]=m14;
			e[4]=m21;
			e[5]=m22;
			e[6]=m23;
			e[7]=m24;
			e[8]=m31;
			e[9]=m32;
			e[10]=m33;
			e[11]=m34;
			e[12]=m41;
			e[13]=m42;
			e[14]=m43;
			e[15]=m44;
		}

		__class(Matrix4x4,'laya.d3.math.Matrix4x4');
		var __proto=Matrix4x4.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		__proto.getElementByRowColumn=function(row,column){
			if (row < 0 || row > 3)
				throw new Error("row","Rows and columns for matrices run from 0 to 3, inclusive.");
			if (column < 0 || column > 3)
				throw new Error("column","Rows and columns for matrices run from 0 to 3, inclusive.");
			return this.elements[(row *4)+column];
		}

		__proto.setElementByRowColumn=function(row,column,value){
			if (row < 0 || row > 3)
				throw new Error("row","Rows and columns for matrices run from 0 to 3, inclusive.");
			if (column < 0 || column > 3)
				throw new Error("column","Rows and columns for matrices run from 0 to 3, inclusive.");
			this.elements[(row *4)+column]=value;
		}

		/**
		*判断两个4x4矩阵的值是否相等。
		*@param other 4x4矩阵
		*/
		__proto.equalsOtherMatrix=function(other){
			var e=this.elements;
			var oe=other.elements;
			return (MathUtils3D.nearEqual(e[0],oe[0])&& MathUtils3D.nearEqual(e[1],oe[1])&& MathUtils3D.nearEqual(e[2],oe[2])&& MathUtils3D.nearEqual(e[3],oe[3])&& MathUtils3D.nearEqual(e[4],oe[4])&& MathUtils3D.nearEqual(e[5],oe[5])&& MathUtils3D.nearEqual(e[6],oe[6])&& MathUtils3D.nearEqual(e[7],oe[7])&& MathUtils3D.nearEqual(e[8],oe[8])&& MathUtils3D.nearEqual(e[9],oe[9])&& MathUtils3D.nearEqual(e[10],oe[10])&& MathUtils3D.nearEqual(e[11],oe[11])&& MathUtils3D.nearEqual(e[12],oe[12])&& MathUtils3D.nearEqual(e[13],oe[13])&& MathUtils3D.nearEqual(e[14],oe[14])&& MathUtils3D.nearEqual(e[15],oe[15]));
		}

		/**
		*分解矩阵为平移向量、旋转四元数、缩放向量。
		*@param translation 平移向量。
		*@param rotation 旋转四元数。
		*@param scale 缩放向量。
		*@return 是否分解成功。
		*/
		__proto.decomposeTransRotScale=function(translation,rotation,scale){
			var rotationMatrix=Matrix4x4._tempMatrix4x4;
			if (this.decomposeTransRotMatScale(translation,rotationMatrix,scale)){
				Quaternion.createFromMatrix4x4(rotationMatrix,rotation);
				return true;
				}else {
				rotation.identity();
				return false;
			}
		}

		/**
		*分解矩阵为平移向量、旋转矩阵、缩放向量。
		*@param translation 平移向量。
		*@param rotationMatrix 旋转矩阵。
		*@param scale 缩放向量。
		*@return 是否分解成功。
		*/
		__proto.decomposeTransRotMatScale=function(translation,rotationMatrix,scale){
			var e=this.elements;
			var te=translation.elements;
			var re=rotationMatrix.elements;
			var se=scale.elements;
			te[0]=e[12];
			te[1]=e[13];
			te[2]=e[14];
			var m11=e[0],m12=e[1],m13=e[2];
			var m21=e[4],m22=e[5],m23=e[6];
			var m31=e[8],m32=e[9],m33=e[10];
			var sX=se[0]=Math.sqrt((m11 *m11)+(m12 *m12)+(m13 *m13));
			var sY=se[1]=Math.sqrt((m21 *m21)+(m22 *m22)+(m23 *m23));
			var sZ=se[2]=Math.sqrt((m31 *m31)+(m32 *m32)+(m33 *m33));
			if (MathUtils3D.isZero(sX)|| MathUtils3D.isZero(sY)|| MathUtils3D.isZero(sZ)){
				re[1]=re[2]=re[3]=re[4]=re[6]=re[7]=re[8]=re[9]=re[11]=re[12]=re[13]=re[14]=0;
				re[0]=re[5]=re[10]=re[15]=1;
				return false;
			};
			var at=Matrix4x4._tempVector0;
			var atE=at.elements;
			atE[0]=m31 / sZ;
			atE[1]=m32 / sZ;
			atE[2]=m33 / sZ;
			var tempRight=Matrix4x4._tempVector1;
			var tempRightE=tempRight.elements;
			tempRightE[0]=m11 / sX;
			tempRightE[1]=m12 / sX;
			tempRightE[2]=m13 / sX;
			var up=Matrix4x4._tempVector2;
			Vector3.cross(at,tempRight,up);
			var right=Matrix4x4._tempVector1;
			Vector3.cross(up,at,right);
			re[3]=re[7]=re[11]=re[12]=re[13]=re[14]=0;
			re[15]=1;
			re[0]=right.x;
			re[1]=right.y;
			re[2]=right.z;
			re[4]=up.x;
			re[5]=up.y;
			re[6]=up.z;
			re[8]=at.x;
			re[9]=at.y;
			re[10]=at.z;
			((re[0] *m11+re[1] *m12+re[2] *m13)< 0.0)&& (se[0]=-sX);
			((re[4] *m21+re[5] *m22+re[6] *m23)< 0.0)&& (se[1]=-sY);
			((re[8] *m31+re[9] *m32+re[10] *m33)< 0.0)&& (se[2]=-sZ);
			return true;
		}

		/**归一化矩阵 */
		__proto.normalize=function(){
			var v=this.elements;
			var c=v[0],d=v[1],e=v[2],g=Math.sqrt(c *c+d *d+e *e);
			if (g){
				if (g==1)
					return;
				}else {
				v[0]=0;
				v[1]=0;
				v[2]=0;
				return;
			}
			g=1 / g;
			v[0]=c *g;
			v[1]=d *g;
			v[2]=e *g;
		}

		/**计算矩阵的转置矩阵*/
		__proto.transpose=function(){
			var e,t;
			e=this.elements;
			t=e[1];
			e[1]=e[4];
			e[4]=t;
			t=e[2];
			e[2]=e[8];
			e[8]=t;
			t=e[3];
			e[3]=e[12];
			e[12]=t;
			t=e[6];
			e[6]=e[9];
			e[9]=t;
			t=e[7];
			e[7]=e[13];
			e[13]=t;
			t=e[11];
			e[11]=e[14];
			e[14]=t;
			return this;
		}

		/**
		*计算一个矩阵的逆矩阵
		*@param out 输出矩阵
		*/
		__proto.invert=function(out){
			var ae=this.elements;
			var oe=out.elements;
			var a00=ae[0],a01=ae[1],a02=ae[2],a03=ae[3],a10=ae[4],a11=ae[5],a12=ae[6],a13=ae[7],a20=ae[8],a21=ae[9],a22=ae[10],a23=ae[11],a30=ae[12],a31=ae[13],a32=ae[14],a33=ae[15],
			b00=a00 *a11-a01 *a10,b01=a00 *a12-a02 *a10,b02=a00 *a13-a03 *a10,b03=a01 *a12-a02 *a11,b04=a01 *a13-a03 *a11,b05=a02 *a13-a03 *a12,b06=a20 *a31-a21 *a30,b07=a20 *a32-a22 *a30,b08=a20 *a33-a23 *a30,b09=a21 *a32-a22 *a31,b10=a21 *a33-a23 *a31,b11=a22 *a33-a23 *a32,
			det=b00 *b11-b01 *b10+b02 *b09+b03 *b08-b04 *b07+b05 *b06;
			if (Math.abs(det)===0.0){
				return;
			}
			det=1.0 / det;
			oe[0]=(a11 *b11-a12 *b10+a13 *b09)*det;
			oe[1]=(a02 *b10-a01 *b11-a03 *b09)*det;
			oe[2]=(a31 *b05-a32 *b04+a33 *b03)*det;
			oe[3]=(a22 *b04-a21 *b05-a23 *b03)*det;
			oe[4]=(a12 *b08-a10 *b11-a13 *b07)*det;
			oe[5]=(a00 *b11-a02 *b08+a03 *b07)*det;
			oe[6]=(a32 *b02-a30 *b05-a33 *b01)*det;
			oe[7]=(a20 *b05-a22 *b02+a23 *b01)*det;
			oe[8]=(a10 *b10-a11 *b08+a13 *b06)*det;
			oe[9]=(a01 *b08-a00 *b10-a03 *b06)*det;
			oe[10]=(a30 *b04-a31 *b02+a33 *b00)*det;
			oe[11]=(a21 *b02-a20 *b04-a23 *b00)*det;
			oe[12]=(a11 *b07-a10 *b09-a12 *b06)*det;
			oe[13]=(a00 *b09-a01 *b07+a02 *b06)*det;
			oe[14]=(a31 *b01-a30 *b03-a32 *b00)*det;
			oe[15]=(a20 *b03-a21 *b01+a22 *b00)*det;
		}

		/**设置矩阵为单位矩阵*/
		__proto.identity=function(){
			var e=this.elements;
			e[1]=e[2]=e[3]=e[4]=e[6]=e[7]=e[8]=e[9]=e[11]=e[12]=e[13]=e[14]=0;
			e[0]=e[5]=e[10]=e[15]=1;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var i,s,d;
			s=this.elements;
			d=destObject.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 16;++i){
				d[i]=s[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=/*__JS__ */new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		/**
		*获取平移向量。
		*@param out 平移向量。
		*/
		__proto.getTranslationVector=function(out){
			var me=this.elements;
			var te=out.elements;
			te[0]=me[12];
			te[1]=me[13];
			te[2]=me[14];
		}

		/**
		*设置平移向量。
		*@param translate 平移向量。
		*/
		__proto.setTranslationVector=function(translate){
			var me=this.elements;
			var ve=translate.elements;
			me[12]=ve[0];
			me[13]=ve[1];
			me[14]=ve[2];
		}

		/**
		*获取前向量。
		*@param out 前向量。
		*/
		__proto.getForward=function(out){
			var me=this.elements;
			var te=out.elements;
			te[0]=-me[8];
			te[1]=-me[9];
			te[2]=-me[10];
		}

		/**
		*设置前向量。
		*@param forward 前向量。
		*/
		__proto.setForward=function(forward){
			var me=this.elements;
			var ve=forward.elements;
			me[8]=-ve[0];
			me[9]=-ve[1];
			me[10]=-ve[2];
		}

		Matrix4x4.createRotationX=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[1]=oe[2]=oe[3]=oe[4]=oe[7]=oe[8]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[0]=oe[15]=1;
			oe[5]=oe[10]=c;
			oe[6]=s;
			oe[9]=-s;
		}

		Matrix4x4.createRotationY=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[1]=oe[3]=oe[4]=oe[6]=oe[7]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[5]=oe[15]=1;
			oe[0]=oe[10]=c;
			oe[2]=-s;
			oe[8]=s;
		}

		Matrix4x4.createRotationZ=function(rad,out){
			var oe=out.elements;
			var s=Math.sin(rad),c=Math.cos(rad);
			oe[2]=oe[3]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=oe[12]=oe[13]=oe[14]=0;
			oe[10]=oe[15]=1;
			oe[0]=oe[5]=c;
			oe[1]=s;
			oe[4]=-s;
		}

		Matrix4x4.createRotationYawPitchRoll=function(yaw,pitch,roll,result){
			Quaternion.createFromYawPitchRoll(yaw,pitch,roll,Matrix4x4._tempQuaternion);
			Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion,result);
		}

		Matrix4x4.createRotationQuaternion=function(rotation,result){
			var rotationE=rotation.elements;
			var resultE=result.elements;
			var rotationX=rotationE[0];
			var rotationY=rotationE[1];
			var rotationZ=rotationE[2];
			var rotationW=rotationE[3];
			var xx=rotationX *rotationX;
			var yy=rotationY *rotationY;
			var zz=rotationZ *rotationZ;
			var xy=rotationX *rotationY;
			var zw=rotationZ *rotationW;
			var zx=rotationZ *rotationX;
			var yw=rotationY *rotationW;
			var yz=rotationY *rotationZ;
			var xw=rotationX *rotationW;
			resultE[3]=resultE[7]=resultE[11]=resultE[12]=resultE[13]=resultE[14]=0;
			resultE[15]=1.0;
			resultE[0]=1.0-(2.0 *(yy+zz));
			resultE[1]=2.0 *(xy+zw);
			resultE[2]=2.0 *(zx-yw);
			resultE[4]=2.0 *(xy-zw);
			resultE[5]=1.0-(2.0 *(zz+xx));
			resultE[6]=2.0 *(yz+xw);
			resultE[8]=2.0 *(zx+yw);
			resultE[9]=2.0 *(yz-xw);
			resultE[10]=1.0-(2.0 *(yy+xx));
		}

		Matrix4x4.createTranslate=function(trans,out){
			var te=trans.elements;
			var oe=out.elements;
			oe[4]=oe[8]=oe[1]=oe[9]=oe[2]=oe[6]=oe[3]=oe[7]=oe[11]=0;
			oe[0]=oe[5]=oe[10]=oe[15]=1;
			oe[12]=te[0];
			oe[13]=te[1];
			oe[14]=te[2];
		}

		Matrix4x4.createScaling=function(scale,out){
			var se=scale.elements;
			var oe=out.elements;
			oe[0]=se[0];
			oe[5]=se[1];
			oe[10]=se[2];
			oe[1]=oe[4]=oe[8]=oe[12]=oe[9]=oe[13]=oe[2]=oe[6]=oe[14]=oe[3]=oe[7]=oe[11]=0;
			oe[15]=1;
		}

		Matrix4x4.multiply=function(left,right,out){
			var i,e,a,b,ai0,ai1,ai2,ai3;
			e=out.elements;
			a=left.elements;
			b=right.elements;
			if (e===b){
				b=new Float32Array(16);
				for (i=0;i < 16;++i){
					b[i]=e[i];
				}
			}
			for (i=0;i < 4;i++){
				ai0=a[i];
				ai1=a[i+4];
				ai2=a[i+8];
				ai3=a[i+12];
				e[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
				e[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
				e[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
				e[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
			}
		}

		Matrix4x4.createFromQuaternion=function(rotation,out){
			var e=out.elements;
			var q=rotation.elements;
			var x=q[0],y=q[1],z=q[2],w=q[3];
			var x2=x+x;
			var y2=y+y;
			var z2=z+z;
			var xx=x *x2;
			var yx=y *x2;
			var yy=y *y2;
			var zx=z *x2;
			var zy=z *y2;
			var zz=z *z2;
			var wx=w *x2;
			var wy=w *y2;
			var wz=w *z2;
			e[0]=1-yy-zz;
			e[1]=yx+wz;
			e[2]=zx-wy;
			e[3]=0;
			e[4]=yx-wz;
			e[5]=1-xx-zz;
			e[6]=zy+wx;
			e[7]=0;
			e[8]=zx+wy;
			e[9]=zy-wx;
			e[10]=1-xx-yy;
			e[11]=0;
			e[12]=0;
			e[13]=0;
			e[14]=0;
			out[15]=1;
		}

		Matrix4x4.createAffineTransformation=function(trans,rot,scale,out){
			var te=trans.elements;
			var re=rot.elements;
			var se=scale.elements;
			var oe=out.elements;
			var x=re[0],y=re[1],z=re[2],w=re[3],x2=x+x,y2=y+y,z2=z+z;
			var xx=x *x2,xy=x *y2,xz=x *z2,yy=y *y2,yz=y *z2,zz=z *z2;
			var wx=w *x2,wy=w *y2,wz=w *z2,sx=se[0],sy=se[1],sz=se[2];
			oe[0]=(1-(yy+zz))*sx;
			oe[1]=(xy+wz)*sx;
			oe[2]=(xz-wy)*sx;
			oe[3]=0;
			oe[4]=(xy-wz)*sy;
			oe[5]=(1-(xx+zz))*sy;
			oe[6]=(yz+wx)*sy;
			oe[7]=0;
			oe[8]=(xz+wy)*sz;
			oe[9]=(yz-wx)*sz;
			oe[10]=(1-(xx+yy))*sz;
			oe[11]=0;
			oe[12]=te[0];
			oe[13]=te[1];
			oe[14]=te[2];
			oe[15]=1;
		}

		Matrix4x4.createLookAt=function(eye,target,up,out){
			var oE=out.elements;
			var xaxis=Matrix4x4._tempVector0;
			var yaxis=Matrix4x4._tempVector1;
			var zaxis=Matrix4x4._tempVector2;
			Vector3.subtract(eye,target,zaxis);
			Vector3.normalize(zaxis,zaxis);
			Vector3.cross(up,zaxis,xaxis);
			Vector3.normalize(xaxis,xaxis);
			Vector3.cross(zaxis,xaxis,yaxis);
			out.identity();
			oE[0]=xaxis.x;oE[4]=xaxis.y;oE[8]=xaxis.z;
			oE[1]=yaxis.x;oE[5]=yaxis.y;oE[9]=yaxis.z;
			oE[2]=zaxis.x;oE[6]=zaxis.y;oE[10]=zaxis.z;
			oE[12]=-Vector3.dot(xaxis,eye);
			oE[13]=-Vector3.dot(yaxis,eye);
			oE[14]=-Vector3.dot(zaxis,eye);
		}

		Matrix4x4.createPerspective=function(fov,aspect,near,far,out){
			var oe=out.elements;
			var yScale=1.0 / Math.tan(fov *0.5);
			var q=far / (near-far);
			oe[0]=yScale / aspect;
			oe[5]=yScale;
			oe[10]=q;
			oe[11]=-1.0;
			oe[14]=q *near;
			oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[12]=oe[13]=oe[15]=0;
		}

		Matrix4x4.createOrthogonal=function(left,right,bottom,top,near,far,out){
			var oe=out.elements;
			var lr=1 / (left-right);
			var bt=1 / (bottom-top);
			var nf=1 / (near-far);
			oe[1]=oe[2]=oe[3]=oe[4]=oe[6]=oe[7]=oe[8]=oe[9]=oe[11]=0;
			oe[15]=1;
			oe[0]=-2 *lr;
			oe[5]=-2 *bt;
			oe[10]=2 *nf;
			oe[12]=(left+right)*lr;
			oe[13]=(top+bottom)*bt;
			oe[14]=(far+near)*nf;
		}

		Matrix4x4.translation=function(v3,out){
			var ve=v3.elements;
			var oe=out.elements;
			oe[0]=oe[5]=oe[10]=oe[15]=1;
			oe[12]=ve[0];
			oe[13]=ve[1];
			oe[14]=ve[2];
		}

		__static(Matrix4x4,
		['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();},'_tempVector0',function(){return this._tempVector0=new Vector3();},'_tempVector1',function(){return this._tempVector1=new Vector3();},'_tempVector2',function(){return this._tempVector2=new Vector3();},'_tempQuaternion',function(){return this._tempQuaternion=new Quaternion();},'DEFAULT',function(){return this.DEFAULT=new Matrix4x4();}
		]);
		return Matrix4x4;
	})()


	/**
	*<code>OrientedBoundBox</code> 类用于创建OBB包围盒。
	*/
	//class laya.d3.math.OrientedBoundBox
	var OrientedBoundBox=(function(){
		function OrientedBoundBox(extents,transformation){
			this.extents=null;
			this.transformation=null;
			this.extents=extents;
			this.transformation=transformation;
		}

		__class(OrientedBoundBox,'laya.d3.math.OrientedBoundBox');
		var __proto=OrientedBoundBox.prototype;
		/**
		*获取OBB包围盒的8个顶点。
		*@param corners 返回顶点的输出队列。
		*/
		__proto.getCorners=function(corners){
			var extentsE=this.extents.elements;
			corners.length=8;
			var xve=OrientedBoundBox._tempV30.elements;
			var yve=OrientedBoundBox._tempV31.elements;
			var zve=OrientedBoundBox._tempV32.elements;
			xve[0]=extentsE[0];
			xve[1]=xve[2]=0;
			yve[1]=extentsE[1];
			yve[0]=yve[2]=0;
			zve[2]=extentsE[2];
			zve[0]=zve[1]=0;
			Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
			Vector3.TransformNormal(OrientedBoundBox._tempV32,this.transformation,OrientedBoundBox._tempV32);
			var center=OrientedBoundBox._tempV33;
			this.transformation.getTranslationVector(center);
			Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[0]);
			Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[1]);
			Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[2]);
			Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[3]);
			Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[4]);
			Vector3.add(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[5]);
			Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[6]);
			Vector3.subtract(center,OrientedBoundBox._tempV30,OrientedBoundBox._tempV34);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV31,OrientedBoundBox._tempV34);
			Vector3.add(OrientedBoundBox._tempV34,OrientedBoundBox._tempV32,corners[7]);
		}

		/**
		*变换该包围盒的矩阵信息。
		*@param mat 矩阵
		*/
		__proto.transform=function(mat){
			Matrix4x4.multiply(this.transformation,mat,this.transformation);
		}

		/**
		*缩放该包围盒
		*@param scaling 各轴的缩放比。
		*/
		__proto.scale=function(scaling){
			Vector3.multiply(this.extents,scaling,this.extents);
		}

		/**
		*平移该包围盒。
		*@param translation 平移参数
		*/
		__proto.translate=function(translation){
			this.transformation.getTranslationVector(OrientedBoundBox._tempV30);
			Vector3.add(OrientedBoundBox._tempV30,translation,OrientedBoundBox._tempV31);
			this.transformation.setTranslationVector(OrientedBoundBox._tempV31);
		}

		/**
		*该包围盒的尺寸。
		*@param out 输出
		*/
		__proto.Size=function(out){
			Vector3.scale(this.extents,2,out);
		}

		/**
		*该包围盒需要考虑的尺寸
		*@param out 输出
		*/
		__proto.getSize=function(out){
			var extentsE=this.extents.elements;
			OrientedBoundBox._tempV30.x=extentsE[0];
			OrientedBoundBox._tempV31.y=extentsE[1];
			OrientedBoundBox._tempV32.z=extentsE[2];
			Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV32);
			var oe=out.elements;
			oe[0]=Vector3.scalarLength(OrientedBoundBox._tempV30);
			oe[1]=Vector3.scalarLength(OrientedBoundBox._tempV31);
			oe[2]=Vector3.scalarLength(OrientedBoundBox._tempV32);
		}

		/**
		*该包围盒需要考虑尺寸的平方
		*@param out 输出
		*/
		__proto.getSizeSquared=function(out){
			var extentsE=this.extents.elements;
			OrientedBoundBox._tempV30.x=extentsE[0];
			OrientedBoundBox._tempV31.y=extentsE[1];
			OrientedBoundBox._tempV32.z=extentsE[2];
			Vector3.TransformNormal(OrientedBoundBox._tempV30,this.transformation,OrientedBoundBox._tempV30);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV31);
			Vector3.TransformNormal(OrientedBoundBox._tempV31,this.transformation,OrientedBoundBox._tempV32);
			var oe=out.elements;
			oe[0]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV30);
			oe[1]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV31);
			oe[2]=Vector3.scalarLengthSquared(OrientedBoundBox._tempV32);
		}

		/**
		*该包围盒的几何中心
		*/
		__proto.getCenter=function(center){
			this.transformation.getTranslationVector(center);
		}

		/**
		*该包围盒是否包含空间中一点
		*@param point 点
		*@return 返回位置关系
		*/
		__proto.containsPoint=function(point){
			var extentsE=this.extents.elements;
			var extentsEX=extentsE[0];
			var extentsEY=extentsE[1];
			var extentsEZ=extentsE[2];
			this.transformation.invert(OrientedBoundBox._tempM0);
			Vector3.transformCoordinate(point,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
			var _tempV30e=OrientedBoundBox._tempV30.elements;
			var _tempV30ex=Math.abs(_tempV30e[0]);
			var _tempV30ey=Math.abs(_tempV30e[1]);
			var _tempV30ez=Math.abs(_tempV30e[2]);
			if (MathUtils3D.nearEqual(_tempV30ex,extentsEX)&& MathUtils3D.nearEqual(_tempV30ey,extentsEY)&& MathUtils3D.nearEqual(_tempV30ez,extentsEZ))
				return /*laya.d3.math.ContainmentType.Intersects*/2;
			if (_tempV30ex < extentsEX && _tempV30ey < extentsEY && _tempV30ez < extentsEZ)
				return /*laya.d3.math.ContainmentType.Contains*/1;
			else
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}

		/**
		*该包围盒是否包含空间中多点
		*@param point 点
		*@return 返回位置关系
		*/
		__proto.containsPoints=function(points){
			var extentse=this.extents.elements;
			var extentsex=extentse[0];
			var extentsey=extentse[1];
			var extentsez=extentse[2];
			this.transformation.invert(OrientedBoundBox._tempM0);
			var containsAll=true;
			var containsAny=false;
			for (var i=0;i < points.length;i++){
				Vector3.transformCoordinate(points[i],OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
				var _tempV30e=OrientedBoundBox._tempV30.elements;
				var _tempV30ex=Math.abs(_tempV30e[0]);
				var _tempV30ey=Math.abs(_tempV30e[1]);
				var _tempV30ez=Math.abs(_tempV30e[2]);
				if (MathUtils3D.nearEqual(_tempV30ex,extentsex)&& MathUtils3D.nearEqual(_tempV30ey,extentsey)&& MathUtils3D.nearEqual(_tempV30ez,extentsez))
					containsAny=true;
				if (_tempV30ex < extentsex && _tempV30ey < extentsey && extentsez < _tempV30ez)
					containsAny=true;
				else
				containsAll=false;
			}
			if (containsAll)
				return /*laya.d3.math.ContainmentType.Contains*/1;
			else if (containsAny)
			return /*laya.d3.math.ContainmentType.Intersects*/2;
			else
			return /*laya.d3.math.ContainmentType.Disjoint*/0;
		}

		/**
		*该包围盒是否包含空间中一包围球
		*@param sphere 包围球
		*@param ignoreScale 是否考虑该包围盒的缩放
		*@return 返回位置关系
		*/
		__proto.containsSphere=function(sphere,ignoreScale){
			(ignoreScale===void 0)&& (ignoreScale=false);
			var extentsE=this.extents.elements;
			var extentsEX=extentsE[0];
			var extentsEY=extentsE[1];
			var extentsEZ=extentsE[2];
			var sphereR=sphere.radius;
			this.transformation.invert(OrientedBoundBox._tempM0);
			Vector3.transformCoordinate(sphere.center,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
			var locRadius=NaN;
			if (ignoreScale){
				locRadius=sphereR;
				}else {
				Vector3.scale(Vector3.UnitX,sphereR,OrientedBoundBox._tempV31);
				Vector3.TransformNormal(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0,OrientedBoundBox._tempV31);
				locRadius=Vector3.scalarLength(OrientedBoundBox._tempV31);;;
			}
			Vector3.scale(this.extents,-1,OrientedBoundBox._tempV32);
			Vector3.Clamp(OrientedBoundBox._tempV30,OrientedBoundBox._tempV32,this.extents,OrientedBoundBox._tempV33);
			var distance=Vector3.distanceSquared(OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
			if (distance > locRadius *locRadius)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			var tempV30e=OrientedBoundBox._tempV30.elements;
			var tempV30ex=tempV30e[0];
			var tempV30ey=tempV30e[1];
			var tempV30ez=tempV30e[2];
			var tempV32e=OrientedBoundBox._tempV32.elements;
			var tempV32ex=tempV32e[0];
			var tempV32ey=tempV32e[1];
			var tempV32ez=tempV32e[2];
			if ((((tempV32ex+locRadius <=tempV30ex)&& (tempV30ex <=extentsEX-locRadius))&& ((extentsEX-tempV32ex > locRadius)&& (tempV32ey+locRadius <=tempV30ey)))&& (((tempV30ey <=extentsEY-locRadius)&& (extentsEY-tempV32ey > locRadius))&& (((tempV32ez+locRadius <=tempV30ez)&& (tempV30ez <=extentsEZ-locRadius))&& (extentsEZ-tempV32ez > locRadius)))){
				return /*laya.d3.math.ContainmentType.Contains*/1;
			}
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		}

		/**
		*该包围盒是否包含空间中另一OBB包围盒
		*@param obb OBB包围盒
		*@return 返回位置关系
		*/
		__proto.containsOrientedBoundBox=function(obb){
			var i=0,k=0;
			obb.getCorners(OrientedBoundBox._corners);
			var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
			if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
				return cornersCheck;
			var sizeAe=this.extents.elements;
			obb.extents.cloneTo(OrientedBoundBox._tempV35);
			var sizeBe=OrientedBoundBox._tempV35.elements;
			OrientedBoundBox._getRows(this.transformation,OrientedBoundBox._rows1);
			OrientedBoundBox._getRows(obb.transformation,OrientedBoundBox._rows2);
			var extentA=NaN,extentB=NaN,separation=NaN,dotNumber=NaN;
			for (i=0;i < 3;i++){
				for (k=0;k < 3;k++){
					dotNumber=Vector3.dot(OrientedBoundBox._rows1[i],OrientedBoundBox._rows2[k]);
					OrientedBoundBox._tempM0.setElementByRowColumn(i,k,dotNumber);
					OrientedBoundBox._tempM1.setElementByRowColumn(i,k,Math.abs(dotNumber));
				}
			}
			obb.getCenter(OrientedBoundBox._tempV34);
			this.getCenter(OrientedBoundBox._tempV36);
			Vector3.subtract(OrientedBoundBox._tempV34,OrientedBoundBox._tempV36,OrientedBoundBox._tempV30);
			var vsepAe=OrientedBoundBox._tempV31.elements;
			vsepAe[0]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[0]);
			vsepAe[1]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[1]);
			vsepAe[2]=Vector3.dot(OrientedBoundBox._tempV30,OrientedBoundBox._rows1[2]);
			var _tempV32e=OrientedBoundBox._tempV32.elements;
			var _tempV33e=OrientedBoundBox._tempV33.elements;
			for (i=0;i < 3;i++){
				_tempV32e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(i,0);
				_tempV32e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(i,1);
				_tempV32e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(i,2);
				extentA=sizeAe[i];
				extentB=Vector3.dot(OrientedBoundBox._tempV35,OrientedBoundBox._tempV32);
				separation=Math.abs(vsepAe[i]);
				if (separation > extentA+extentB)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
			}
			for (k=0;k < 3;k++){
				_tempV32e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(0,k);
				_tempV32e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(1,k);
				_tempV32e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(2,k);
				_tempV33e[0]=OrientedBoundBox._tempM0.getElementByRowColumn(0,k);
				_tempV33e[1]=OrientedBoundBox._tempM0.getElementByRowColumn(1,k);
				_tempV33e[2]=OrientedBoundBox._tempM0.getElementByRowColumn(2,k);
				extentA=Vector3.dot(this.extents,OrientedBoundBox._tempV32);
				extentB=sizeBe[k];
				separation=Math.abs(Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV33));
				if (separation > extentA+extentB)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
			}
			for (i=0;i < 3;i++){
				for (k=0;k < 3;k++){
					var i1=(i+1)% 3,i2=(i+2)% 3;
					var k1=(k+1)% 3,k2=(k+2)% 3;
					extentA=sizeAe[i1] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k)+sizeBe[i2] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k);
					extentB=sizeAe[k1] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k2)+sizeBe[k2] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k1);
					separation=Math.abs(vsepAe[i2] *OrientedBoundBox._tempM0.getElementByRowColumn(i1,k)-vsepAe[i1] *OrientedBoundBox._tempM0.getElementByRowColumn(i2,k));
					if (separation > extentA+extentB)
						return /*laya.d3.math.ContainmentType.Disjoint*/0;
				}
			}
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		}

		/**
		*该包围盒是否包含空间中一条线
		*@param point1 点1
		*@param point2 点2
		*@return 返回位置关系
		*/
		__proto.containsLine=function(point1,point2){
			OrientedBoundBox._corners[0]=point1;
			OrientedBoundBox._corners[1]=point2;
			var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
			if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
				return cornersCheck;
			var extentsE=this.extents.elements;
			var extentsX=extentsE[0];
			var extentsY=extentsE[1];
			var extentsZ=extentsE[2];
			this.transformation.invert(OrientedBoundBox._tempM0);
			Vector3.transformCoordinate(point1,OrientedBoundBox._tempM0,OrientedBoundBox._tempV30);
			Vector3.transformCoordinate(point2,OrientedBoundBox._tempM0,OrientedBoundBox._tempV31);
			Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
			Vector3.scale(OrientedBoundBox._tempV32,0.5,OrientedBoundBox._tempV32);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV32,OrientedBoundBox._tempV33);
			var _tempV33e=OrientedBoundBox._tempV33.elements;
			var _tempV33X=_tempV33e[0];
			var _tempV33Y=_tempV33e[1];
			var _tempV33Z=_tempV33e[2];
			var _tempV34e=OrientedBoundBox._tempV34.elements;
			var _tempV34X=_tempV34e[0]=Math.abs(_tempV33e[0]);
			var _tempV34Y=_tempV34e[1]=Math.abs(_tempV33e[1]);
			var _tempV34Z=_tempV34e[2]=Math.abs(_tempV33e[2]);
			var _tempV32e=OrientedBoundBox._tempV32.elements;
			var _tempV32X=_tempV32e[0];
			var _tempV32Y=_tempV32e[1];
			var _tempV32Z=_tempV32e[2];
			if (Math.abs(_tempV32X)> extentsX+_tempV34X)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (Math.abs(_tempV32Y)> extentsY+_tempV34Y)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (Math.abs(_tempV32Z)> extentsZ+_tempV34Z)
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (Math.abs(_tempV32Y *_tempV33Z-_tempV32Z *_tempV33Y)> (extentsY *_tempV34Z+extentsZ *_tempV34Y))
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (Math.abs(_tempV32X *_tempV33Z-_tempV32Z *_tempV33X)> (extentsX *_tempV34Z+extentsZ *_tempV34X))
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			if (Math.abs(_tempV32X *_tempV33Y-_tempV32Y *_tempV33X)> (extentsX *_tempV34Y+extentsY *_tempV34X))
				return /*laya.d3.math.ContainmentType.Disjoint*/0;
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		}

		/**
		*该包围盒是否包含空间中另一OBB包围盒
		*@param box 包围盒
		*@return 返回位置关系
		*/
		__proto.containsBoundBox=function(box){
			var i=0,k=0;
			var min=box.min;
			var max=box.max;
			box.getCorners(OrientedBoundBox._corners);
			var cornersCheck=this.containsPoints(OrientedBoundBox._corners);
			if (cornersCheck !=/*laya.d3.math.ContainmentType.Disjoint*/0)
				return cornersCheck;
			Vector3.subtract(max,min,OrientedBoundBox._tempV30);
			Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
			Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV30);
			Vector3.subtract(max,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
			var sizeAe=this.extents.elements;
			var sizeBe=OrientedBoundBox._tempV31.elements;
			OrientedBoundBox._getRows(this.transformation,OrientedBoundBox._rows1);
			this.transformation.invert(OrientedBoundBox._tempM0);
			var extentA=NaN,extentB=NaN,separation=NaN,dotNumber=NaN;
			for (i=0;i < 3;i++){
				for (k=0;k < 3;k++){
					OrientedBoundBox._tempM1.setElementByRowColumn(i,k,Math.abs(OrientedBoundBox._tempM0.getElementByRowColumn(i,k)));
				}
			}
			this.getCenter(OrientedBoundBox._tempV35);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV35,OrientedBoundBox._tempV32);
			var vsepAe=OrientedBoundBox._tempV31.elements;
			vsepAe[0]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[0]);
			vsepAe[1]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[1]);
			vsepAe[2]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[2]);
			var _tempV33e=OrientedBoundBox._tempV33.elements;
			var _tempV34e=OrientedBoundBox._tempV34.elements;
			for (i=0;i < 3;i++){
				_tempV33e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(i,0);
				_tempV33e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(i,1);
				_tempV33e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(i,2);
				extentA=sizeAe[i];
				extentB=Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
				separation=Math.abs(vsepAe[i]);
				if (separation > extentA+extentB)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
			}
			for (k=0;k < 3;k++){
				_tempV33e[0]=OrientedBoundBox._tempM1.getElementByRowColumn(0,k);
				_tempV33e[1]=OrientedBoundBox._tempM1.getElementByRowColumn(1,k);
				_tempV33e[2]=OrientedBoundBox._tempM1.getElementByRowColumn(2,k);
				_tempV34e[0]=OrientedBoundBox._tempM0.getElementByRowColumn(0,k);
				_tempV34e[1]=OrientedBoundBox._tempM0.getElementByRowColumn(1,k);
				_tempV34e[2]=OrientedBoundBox._tempM0.getElementByRowColumn(2,k);
				extentA=Vector3.dot(this.extents,OrientedBoundBox._tempV33);
				extentB=sizeBe[k];
				separation=Math.abs(Vector3.dot(OrientedBoundBox._tempV31,OrientedBoundBox._tempV34));
				if (separation > extentA+extentB)
					return /*laya.d3.math.ContainmentType.Disjoint*/0;
			}
			for (i=0;i < 3;i++){
				for (k=0;k < 3;k++){
					var i1=(i+1)% 3,i2=(i+2)% 3;
					var k1=(k+1)% 3,k2=(k+2)% 3;
					extentA=sizeAe[i1] *OrientedBoundBox._tempM1.getElementByRowColumn(i2,k)+sizeAe[i2] *OrientedBoundBox._tempM1.getElementByRowColumn(i1,k);
					extentB=sizeBe[k1] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k2)+sizeBe[k2] *OrientedBoundBox._tempM1.getElementByRowColumn(i,k1);
					separation=Math.abs(vsepAe[i2] *OrientedBoundBox._tempM0.getElementByRowColumn(i1,k)-vsepAe[i1] *OrientedBoundBox._tempM0.getElementByRowColumn(i2,k));
					if (separation > extentA+extentB)
						return /*laya.d3.math.ContainmentType.Disjoint*/0;
				}
			}
			return /*laya.d3.math.ContainmentType.Intersects*/2;
		}

		/**
		*该包围盒是否与空间中另一射线相交
		*@param ray
		*@param out
		*@return
		*/
		__proto.intersectsRay=function(ray,out){
			Vector3.scale(this.extents,-1,OrientedBoundBox._tempV30);
			this.transformation.invert(OrientedBoundBox._tempM0);
			Vector3.TransformNormal(ray.direction,OrientedBoundBox._tempM0,OrientedBoundBox._ray.direction);
			Vector3.transformCoordinate(ray.origin,OrientedBoundBox._tempM0,OrientedBoundBox._ray.origin);
			OrientedBoundBox._boxBound1.min=OrientedBoundBox._tempV30;
			OrientedBoundBox._boxBound1.max=this.extents;
			var intersects=Collision.intersectsRayAndBoxRP(OrientedBoundBox._ray,OrientedBoundBox._boxBound1,out);
			if (intersects!==-1)
				Vector3.transformCoordinate(out,this.transformation,out);
			return intersects;
		}

		__proto._getLocalCorners=function(corners){
			corners.length=8;
			var extentsE=this.extents.elements;
			OrientedBoundBox._tempV30.x=extentsE[0];
			OrientedBoundBox._tempV31.y=extentsE[1];
			OrientedBoundBox._tempV32.z=extentsE[2];
			Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[0]);
			Vector3.add(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[1]);
			Vector3.subtract(OrientedBoundBox._tempV31,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
			Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV30,corners[2]);
			Vector3.subtract(OrientedBoundBox._tempV31,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
			Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[3]);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			Vector3.add(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[4]);
			Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV33);
			Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV32,corners[5]);
			Vector3.scale(corners[0],-1,corners[6]);
			Vector3.subtract(OrientedBoundBox._tempV32,OrientedBoundBox._tempV30,OrientedBoundBox._tempV33);
			Vector3.subtract(OrientedBoundBox._tempV33,OrientedBoundBox._tempV31,corners[7]);
		}

		/**
		*判断两个包围盒是否相等
		*@param obb obb包围盒
		*@return Boolean
		*/
		__proto.equals=function(obb){
			return this.extents==obb.extents && this.transformation==obb.transformation;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			this.extents.cloneTo(dest.extents);
			this.transformation.cloneTo(dest.transformation);
		}

		OrientedBoundBox.createByBoundBox=function(box,out){
			var min=box.min;
			var max=box.max;
			Vector3.subtract(max,min,OrientedBoundBox._tempV30);
			Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
			Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
			Vector3.subtract(max,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
			Matrix4x4.translation(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0);
			var extents=OrientedBoundBox._tempV32.clone();
			var transformation=OrientedBoundBox._tempM0.clone();
			out.extents=extents;
			out.transformation=transformation;
		}

		OrientedBoundBox.createByMinAndMaxVertex=function(min,max){
			Vector3.subtract(max,min,OrientedBoundBox._tempV30);
			Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
			Vector3.add(min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV31);
			Vector3.subtract(max,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
			Matrix4x4.translation(OrientedBoundBox._tempV31,OrientedBoundBox._tempM0);
			var obb=new OrientedBoundBox(OrientedBoundBox._tempV32,OrientedBoundBox._tempM0);
			return obb;
		}

		OrientedBoundBox._getRows=function(mat,out){
			out.length=3;
			var mate=mat.elements;
			var row0e=out[0].elements;
			row0e[0]=mate[0];
			row0e[1]=mate[1];
			row0e[2]=mate[2];
			var row1e=out[1].elements;
			row1e[0]=mate[4];
			row1e[1]=mate[5];
			row1e[2]=mate[6];
			var row2e=out[2].elements;
			row2e[0]=mate[8];
			row2e[1]=mate[9];
			row2e[2]=mate[10];
		}

		OrientedBoundBox.getObbtoObbMatrix4x4=function(a,b,noMatrixScaleApplied,out){
			var at=a.transformation;
			var bt=b.transformation;
			if (noMatrixScaleApplied){
				OrientedBoundBox._getRows(at,OrientedBoundBox._rows1);
				OrientedBoundBox._getRows(bt,OrientedBoundBox._rows2);
				for (var i=0;i < 3;i++){
					for (var k=0;k < 3;k++){
						out.setElementByRowColumn(i,k,Vector3.dot(OrientedBoundBox._rows2[i],OrientedBoundBox._rows1[k]));
					}
				}
				b.getCenter(OrientedBoundBox._tempV30);
				a.getCenter(OrientedBoundBox._tempV31);
				Vector3.subtract(OrientedBoundBox._tempV30,OrientedBoundBox._tempV31,OrientedBoundBox._tempV32);
				var AtoBMe=out.elements;
				AtoBMe[12]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[0]);
				AtoBMe[13]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[1]);
				AtoBMe[14]=Vector3.dot(OrientedBoundBox._tempV32,OrientedBoundBox._rows1[2]);
				AtoBMe[15]=1;
				}else {
				at.invert(OrientedBoundBox._tempM0);
				Matrix4x4.multiply(bt,OrientedBoundBox._tempM0,out);
			}
		}

		OrientedBoundBox.merge=function(a,b,noMatrixScaleApplied){
			var ae=a.extents;
			var at=a.transformation;
			OrientedBoundBox.getObbtoObbMatrix4x4(a,b,noMatrixScaleApplied,OrientedBoundBox._tempM0);
			b._getLocalCorners(OrientedBoundBox._corners);
			Vector3.transformCoordinate(OrientedBoundBox._corners[0],OrientedBoundBox._tempM0,OrientedBoundBox._corners[0]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[1],OrientedBoundBox._tempM0,OrientedBoundBox._corners[1]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[2],OrientedBoundBox._tempM0,OrientedBoundBox._corners[2]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[3],OrientedBoundBox._tempM0,OrientedBoundBox._corners[3]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[4],OrientedBoundBox._tempM0,OrientedBoundBox._corners[4]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[5],OrientedBoundBox._tempM0,OrientedBoundBox._corners[5]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[6],OrientedBoundBox._tempM0,OrientedBoundBox._corners[6]);
			Vector3.transformCoordinate(OrientedBoundBox._corners[7],OrientedBoundBox._tempM0,OrientedBoundBox._corners[7]);
			Vector3.scale(ae,-1,OrientedBoundBox._boxBound1.min);
			ae.cloneTo(OrientedBoundBox._boxBound1.max);
			BoundBox.createfromPoints(OrientedBoundBox._corners,OrientedBoundBox._boxBound2);
			BoundBox.merge(OrientedBoundBox._boxBound2,OrientedBoundBox._boxBound1,OrientedBoundBox._boxBound3);
			var box3Min=OrientedBoundBox._boxBound3.min;
			var box3Max=OrientedBoundBox._boxBound3.max;
			Vector3.subtract(box3Max,box3Min,OrientedBoundBox._tempV30);
			Vector3.scale(OrientedBoundBox._tempV30,0.5,OrientedBoundBox._tempV30);
			Vector3.add(box3Min,OrientedBoundBox._tempV30,OrientedBoundBox._tempV32);
			Vector3.subtract(box3Max,OrientedBoundBox._tempV32,ae);
			Vector3.transformCoordinate(OrientedBoundBox._tempV32,at,OrientedBoundBox._tempV33);
		}

		OrientedBoundBox._corners=[];
		OrientedBoundBox._rows1=[];
		OrientedBoundBox._rows2=[];
		__static(OrientedBoundBox,
		['_tempV30',function(){return this._tempV30=new Vector3();},'_tempV31',function(){return this._tempV31=new Vector3();},'_tempV32',function(){return this._tempV32=new Vector3();},'_tempV33',function(){return this._tempV33=new Vector3();},'_tempV34',function(){return this._tempV34=new Vector3();},'_tempV35',function(){return this._tempV35=new Vector3();},'_tempV36',function(){return this._tempV36=new Vector3();},'_tempM0',function(){return this._tempM0=new Matrix4x4();},'_tempM1',function(){return this._tempM1=new Matrix4x4();},'_ray',function(){return this._ray=new Ray(new Vector3(),new Vector3());},'_boxBound1',function(){return this._boxBound1=new BoundBox(new Vector3(),new Vector3());},'_boxBound2',function(){return this._boxBound2=new BoundBox(new Vector3(),new Vector3());},'_boxBound3',function(){return this._boxBound3=new BoundBox(new Vector3(),new Vector3());}
		]);
		return OrientedBoundBox;
	})()


	/**
	*<code>Plane</code> 类用于创建平面。
	*/
	//class laya.d3.math.Plane
	var Plane=(function(){
		function Plane(normal,d){
			this.normal=null;
			this.distance=NaN;
			(d===void 0)&& (d=0);
			this.normal=normal;
			this.distance=d;
		}

		__class(Plane,'laya.d3.math.Plane');
		var __proto=Plane.prototype;
		/**
		*更改平面法线向量的系数，使之成单位长度。
		*/
		__proto.normalize=function(){
			var normalE=this.normal.elements;
			var normalEX=normalE[0];
			var normalEY=normalE[1];
			var normalEZ=normalE[2];
			var magnitude=1 / Math.sqrt(normalEX *normalEX+normalEY *normalEY+normalEZ *normalEZ);
			normalE[0]=normalEX *magnitude;
			normalE[1]=normalEY *magnitude;
			normalE[2]=normalEZ *magnitude;
			this.distance *=magnitude;
		}

		Plane.createPlaneBy3P=function(point1,point2,point3){
			var point1e=point1.elements;
			var point2e=point2.elements;
			var point3e=point3.elements;
			var x1=point2e[0]-point1e[0];
			var y1=point2e[1]-point1e[1];
			var z1=point2e[2]-point1e[2];
			var x2=point3e[0]-point1e[0];
			var y2=point3e[1]-point1e[1];
			var z2=point3e[2]-point1e[2];
			var yz=(y1 *z2)-(z1 *y2);
			var xz=(z1 *x2)-(x1 *z2);
			var xy=(x1 *y2)-(y1 *x2);
			var invPyth=1 / (Math.sqrt((yz *yz)+(xz *xz)+(xy *xy)));
			var x=yz *invPyth;
			var y=xz *invPyth;
			var z=xy *invPyth;
			var TEMPVec3e=Plane._TEMPVec3.elements;
			TEMPVec3e[0]=x;
			TEMPVec3e[1]=y;
			TEMPVec3e[2]=z;
			var d=-((x *point1e[0])+(y *point1e[1])+(z *point1e[2]));
			var plane=new Plane(Plane._TEMPVec3,d);
			return plane;
		}

		Plane.PlaneIntersectionType_Back=0;
		Plane.PlaneIntersectionType_Front=1;
		Plane.PlaneIntersectionType_Intersecting=2;
		__static(Plane,
		['_TEMPVec3',function(){return this._TEMPVec3=new Vector3();}
		]);
		return Plane;
	})()


	/**
	*<code>Quaternion</code> 类用于创建四元数。
	*/
	//class laya.d3.math.Quaternion
	var Quaternion=(function(){
		function Quaternion(x,y,z,w){
			this.elements=new Float32Array(4);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=1);
			this.elements[0]=x;
			this.elements[1]=y;
			this.elements[2]=z;
			this.elements[3]=w;
		}

		__class(Quaternion,'laya.d3.math.Quaternion');
		var __proto=Quaternion.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*根据缩放值缩放四元数
		*@param scale 缩放值
		*@param out 输出四元数
		*/
		__proto.scaling=function(scaling,out){
			var e=out.elements;
			var f=this.elements;
			e[0]=f[0] *scaling;
			e[1]=f[1] *scaling;
			e[2]=f[2] *scaling;
			e[3]=f[3] *scaling;
		}

		/**
		*归一化四元数
		*@param out 输出四元数
		*/
		__proto.normalize=function(out){
			var e=out.elements;
			var f=this.elements;
			var x=f[0],y=f[1],z=f[2],w=f[3];
			var len=x *x+y *y+z *z+w *w;
			if (len > 0){
				len=1 / Math.sqrt(len);
				e[0]=x *len;
				e[1]=y *len;
				e[2]=z *len;
				e[3]=w *len;
			}
		}

		/**
		*计算四元数的长度
		*@return 长度
		*/
		__proto.length=function(){
			var f=this.elements;
			var x=f[0],y=f[1],z=f[2],w=f[3];
			return Math.sqrt(x *x+y *y+z *z+w *w);
		}

		/**
		*根据绕X轴的角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateX=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			var bx=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw+aw *bx;
			e[1]=ay *bw+az *bx;
			e[2]=az *bw-ay *bx;
			e[3]=aw *bw-ax *bx;
		}

		/**
		*根据绕Y轴的制定角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateY=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3],by=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw-az *by;
			e[1]=ay *bw+aw *by;
			e[2]=az *bw+ax *by;
			e[3]=aw *bw-ay *by;
		}

		/**
		*根据绕Z轴的制定角度旋转四元数
		*@param rad 角度
		*@param out 输出四元数
		*/
		__proto.rotateZ=function(rad,out){
			var e=out.elements;
			var f=this.elements;
			rad *=0.5;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3],bz=Math.sin(rad),bw=Math.cos(rad);
			e[0]=ax *bw+ay *bz;
			e[1]=ay *bw-ax *bz;
			e[2]=az *bw+aw *bz;
			e[3]=aw *bw-az *bz;
		}

		/**
		*分解四元数到欧拉角（顺序为Yaw、Pitch、Roll），参考自http://xboxforums.create.msdn.com/forums/p/4574/23988.aspx#23988,问题绕X轴翻转超过±90度时有，会产生瞬间反转
		*@param quaternion 源四元数
		*@param out 欧拉角值
		*/
		__proto.getYawPitchRoll=function(out){
			Vector3.transformQuat(Vector3.ForwardRH,this,Quaternion.TEMPVector31);
			Vector3.transformQuat(Vector3.Up,this,Quaternion.TEMPVector32);
			var upe=Quaternion.TEMPVector32.elements;
			Quaternion.angleTo(Vector3.ZERO,Quaternion.TEMPVector31,Quaternion.TEMPVector33);
			var anglee=Quaternion.TEMPVector33.elements;
			if (anglee[0]==Math.PI / 2){
				anglee[1]=Quaternion.arcTanAngle(upe[2],upe[0]);
				anglee[2]=0;
				}else if (anglee[0]==-Math.PI / 2){
				anglee[1]=Quaternion.arcTanAngle(-upe[2],-upe[0]);
				anglee[2]=0;
				}else {
				Matrix4x4.createRotationY(-anglee[1],Quaternion.TEMPMatrix0);
				Matrix4x4.createRotationX(-anglee[0],Quaternion.TEMPMatrix1);
				Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix0,Quaternion.TEMPVector32);
				Vector3.transformCoordinate(Quaternion.TEMPVector32,Quaternion.TEMPMatrix1,Quaternion.TEMPVector32);
				anglee[2]=Quaternion.arcTanAngle(upe[1],-upe[0]);
			}
			if (anglee[1] <=-Math.PI)
				anglee[1]=Math.PI;
			if (anglee[2] <=-Math.PI)
				anglee[2]=Math.PI;
			if (anglee[1] >=Math.PI && anglee[2] >=Math.PI){
				anglee[1]=0;
				anglee[2]=0;
				anglee[0]=Math.PI-anglee[0];
			};
			var oe=out.elements;
			oe[0]=anglee[1];
			oe[1]=anglee[0];
			oe[2]=anglee[2];
		}

		/**
		*求四元数的逆
		*@param out 输出四元数
		*/
		__proto.invert=function(out){
			var e=out.elements;
			var f=this.elements;
			var a0=f[0],a1=f[1],a2=f[2],a3=f[3];
			var dot=a0 *a0+a1 *a1+a2 *a2+a3 *a3;
			var invDot=dot ? 1.0 / dot :0;
			e[0]=-a0 *invDot;
			e[1]=-a1 *invDot;
			e[2]=-a2 *invDot;
			e[3]=a3 *invDot;
		}

		/**
		*设置四元数为单位算数
		*@param out 输出四元数
		*/
		__proto.identity=function(){
			var e=this.elements;
			e[0]=0;
			e[1]=0;
			e[2]=0;
			e[3]=1;
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var i,s,d;
			s=this.elements;
			d=destObject.elements;
			if (s===d){
				return;
			}
			for (i=0;i < 4;++i){
				d[i]=s[i];
			}
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=/*__JS__ */new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		__proto.equals=function(b){
			var ae=this.elements;
			var be=b.elements;
			return MathUtils3D.nearEqual(ae[0],be[0])&& MathUtils3D.nearEqual(ae[1],be[1])&& MathUtils3D.nearEqual(ae[2],be[2])&& MathUtils3D.nearEqual(ae[3],be[3]);
		}

		/**
		*计算长度的平方。
		*@return 长度的平方。
		*/
		__proto.lengthSquared=function(){
			var x=this.elements[0];
			var y=this.elements[1];
			var z=this.elements[2];
			var w=this.elements[3];
			return (x *x)+(y *y)+(z *z)+(w *w);
		}

		/**
		*获取四元数的x值
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
		});

		/**
		*获取四元数的y值
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
		});

		/**
		*获取四元数的z值
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
		});

		/**
		*获取四元数的w值
		*/
		__getset(0,__proto,'w',function(){
			return this.elements[3];
		});

		Quaternion.createFromYawPitchRoll=function(yaw,pitch,roll,out){
			var halfRoll=roll *0.5;
			var halfPitch=pitch *0.5;
			var halfYaw=yaw *0.5;
			var sinRoll=Math.sin(halfRoll);
			var cosRoll=Math.cos(halfRoll);
			var sinPitch=Math.sin(halfPitch);
			var cosPitch=Math.cos(halfPitch);
			var sinYaw=Math.sin(halfYaw);
			var cosYaw=Math.cos(halfYaw);
			var oe=out.elements;
			oe[0]=(cosYaw *sinPitch *cosRoll)+(sinYaw *cosPitch *sinRoll);
			oe[1]=(sinYaw *cosPitch *cosRoll)-(cosYaw *sinPitch *sinRoll);
			oe[2]=(cosYaw *cosPitch *sinRoll)-(sinYaw *sinPitch *cosRoll);
			oe[3]=(cosYaw *cosPitch *cosRoll)+(sinYaw *sinPitch *sinRoll);
		}

		Quaternion.multiply=function(left,right,out){
			var le=left.elements;
			var re=right.elements;
			var oe=out.elements;
			var lx=le[0];
			var ly=le[1];
			var lz=le[2];
			var lw=le[3];
			var rx=re[0];
			var ry=re[1];
			var rz=re[2];
			var rw=re[3];
			var a=(ly *rz-lz *ry);
			var b=(lz *rx-lx *rz);
			var c=(lx *ry-ly *rx);
			var d=(lx *rx+ly *ry+lz *rz);
			oe[0]=(lx *rw+rx *lw)+a;
			oe[1]=(ly *rw+ry *lw)+b;
			oe[2]=(lz *rw+rz *lw)+c;
			oe[3]=lw *rw-d;
		}

		Quaternion.arcTanAngle=function(x,y){
			if (x==0){
				if (y==1)
					return Math.PI / 2;
				return-Math.PI / 2;
			}
			if (x > 0)
				return Math.atan(y / x);
			if (x < 0){
				if (y > 0)
					return Math.atan(y / x)+Math.PI;
				return Math.atan(y / x)-Math.PI;
			}
			return 0;
		}

		Quaternion.angleTo=function(from,location,angle){
			Vector3.subtract(location,from,Quaternion.TEMPVector30);
			Vector3.normalize(Quaternion.TEMPVector30,Quaternion.TEMPVector30);
			angle.elements[0]=Math.asin(Quaternion.TEMPVector30.y);
			angle.elements[1]=Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z,-Quaternion.TEMPVector30.x);
		}

		Quaternion.createFromAxisAngle=function(axis,rad,out){
			var e=out.elements;
			var f=axis.elements;
			rad=rad *0.5;
			var s=Math.sin(rad);
			e[0]=s *f[0];
			e[1]=s *f[1];
			e[2]=s *f[2];
			e[3]=Math.cos(rad);
		}

		Quaternion.createFromMatrix3x3=function(sou,out){
			var e=out.elements;
			var f=sou.elements;
			var fTrace=f[0]+f[4]+f[8];
			var fRoot;
			if (fTrace > 0.0){
				fRoot=Math.sqrt(fTrace+1.0);
				e[3]=0.5 *fRoot;
				fRoot=0.5 / fRoot;
				e[0]=(f[5]-f[7])*fRoot;
				e[1]=(f[6]-f[2])*fRoot;
				e[2]=(f[1]-f[3])*fRoot;
				}else {
				var i=0;
				if (f[4] > f[0])
					i=1;
				if (f[8] > f[i *3+i])
					i=2;
				var j=(i+1)% 3;
				var k=(i+2)% 3;
				fRoot=Math.sqrt(f[i *3+i]-f[j *3+j]-f[k *3+k]+1.0);
				e[i]=0.5 *fRoot;
				fRoot=0.5 / fRoot;
				e[3]=(f[j *3+k]-f[k *3+j])*fRoot;
				e[j]=(f[j *3+i]+f[i *3+j])*fRoot;
				e[k]=(f[k *3+i]+f[i *3+k])*fRoot;
			}
			return;
		}

		Quaternion.createFromMatrix4x4=function(mat,out){
			var me=mat.elements;
			var oe=out.elements;
			var sqrt;
			var half;
			var scale=me[0]+me[5]+me[10];
			if (scale > 0.0){
				sqrt=Math.sqrt(scale+1.0);
				oe[3]=sqrt *0.5;
				sqrt=0.5 / sqrt;
				oe[0]=(me[6]-me[9])*sqrt;
				oe[1]=(me[8]-me[2])*sqrt;
				oe[2]=(me[1]-me[4])*sqrt;
				}else if ((me[0] >=me[5])&& (me[0] >=me[10])){
				sqrt=Math.sqrt(1.0+me[0]-me[5]-me[10]);
				half=0.5 / sqrt;
				oe[0]=0.5 *sqrt;
				oe[1]=(me[1]+me[4])*half;
				oe[2]=(me[2]+me[8])*half;
				oe[3]=(me[6]-me[9])*half;
				}else if (me[5] > me[10]){
				sqrt=Math.sqrt(1.0+me[5]-me[0]-me[10]);
				half=0.5 / sqrt;
				oe[0]=(me[4]+me[1])*half;
				oe[1]=0.5 *sqrt;
				oe[2]=(me[9]+me[6])*half;
				oe[3]=(me[8]-me[2])*half;
				}else {
				sqrt=Math.sqrt(1.0+me[10]-me[0]-me[5]);
				half=0.5 / sqrt;
				oe[0]=(me[8]+me[2])*half;
				oe[1]=(me[9]+me[6])*half;
				oe[2]=0.5 *sqrt;
				oe[3]=(me[1]-me[4])*half;
			}
		}

		Quaternion.slerp=function(left,right,t,out){
			var a=left.elements;
			var b=right.elements;
			var oe=out.elements;
			var ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];
			var omega,cosom,sinom,scale0,scale1;
			cosom=ax *bx+ay *by+az *bz+aw *bw;
			if (cosom < 0.0){
				cosom=-cosom;
				bx=-bx;
				by=-by;
				bz=-bz;
				bw=-bw;
			}
			if ((1.0-cosom)> 0.000001){
				omega=Math.acos(cosom);
				sinom=Math.sin(omega);
				scale0=Math.sin((1.0-t)*omega)/ sinom;
				scale1=Math.sin(t *omega)/ sinom;
				}else {
				scale0=1.0-t;
				scale1=t;
			}
			oe[0]=scale0 *ax+scale1 *bx;
			oe[1]=scale0 *ay+scale1 *by;
			oe[2]=scale0 *az+scale1 *bz;
			oe[3]=scale0 *aw+scale1 *bw;
			return oe;
		}

		Quaternion.lerp=function(left,right,t,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
			e[3]=aw+t *(g[3]-aw);
		}

		Quaternion.add=function(left,right,out){
			var e=out.elements;
			var f=left.elements;
			var g=right.elements;
			e[0]=f[0]+g[0];
			e[1]=f[1]+g[1];
			e[2]=f[2]+g[2];
			e[3]=f[3]+g[3];
		}

		Quaternion.dot=function(left,right){
			var f=left.elements;
			var g=right.elements;
			return f[0] *g[0]+f[1] *g[1]+f[2] *g[2]+f[3] *g[3];
		}

		Quaternion.rotationLookAt=function(forward,up,out){
			Quaternion.lookAt(Vector3.ZERO,forward,up,out);
		}

		Quaternion.lookAt=function(eye,target,up,out){
			Matrix3x3.lookAt(eye,target,up,Quaternion._tempMatrix3x3);
			Quaternion.rotationMatrix(Quaternion._tempMatrix3x3,out);
		}

		Quaternion.invert=function(value,out){
			var vE=value.elements;
			var oE=out.elements;
			var lengthSq=value.lengthSquared();
			if (!MathUtils3D.isZero(lengthSq)){
				lengthSq=1.0 / lengthSq;
				oE[0]=-vE[0] *lengthSq;
				oE[1]=-vE[1] *lengthSq;
				oE[2]=-vE[2] *lengthSq;
				oE[3]=vE[3] *lengthSq;
			}
		}

		Quaternion.rotationMatrix=function(matrix3x3,out){
			var me=matrix3x3.elements;
			var m11=me[0];
			var m12=me[1];
			var m13=me[2];
			var m21=me[3];
			var m22=me[4];
			var m23=me[5];
			var m31=me[6];
			var m32=me[7];
			var m33=me[8];
			var oe=out.elements;
			var sqrt=NaN,half=NaN;
			var scale=m11+m22+m33;
			if (scale > 0){
				sqrt=Math.sqrt(scale+1);
				oe[3]=sqrt *0.5;
				sqrt=0.5 / sqrt;
				oe[0]=(m23-m32)*sqrt;
				oe[1]=(m31-m13)*sqrt;
				oe[2]=(m12-m21)*sqrt;
				}else if ((m11 >=m22)&& (m11 >=m33)){
				sqrt=Math.sqrt(1+m11-m22-m33);
				half=0.5 / sqrt;
				oe[0]=0.5 *sqrt;
				oe[1]=(m12+m21)*half;
				oe[2]=(m13+m31)*half;
				oe[3]=(m23-m32)*half;
				}else if (m22 > m33){
				sqrt=Math.sqrt(1+m22-m11-m33);
				half=0.5 / sqrt;
				oe[0]=(m21+m12)*half;
				oe[1]=0.5 *sqrt;
				oe[2]=(m32+m23)*half;
				oe[3]=(m31-m13)*half;
				}else {
				sqrt=Math.sqrt(1+m33-m11-m22);
				half=0.5 / sqrt;
				oe[0]=(m31+m13)*half;
				oe[1]=(m32+m23)*half;
				oe[2]=0.5 *sqrt;
				oe[3]=(m12-m21)*half;
			}
		}

		Quaternion.DEFAULT=new Quaternion();
		__static(Quaternion,
		['TEMPVector30',function(){return this.TEMPVector30=new Vector3();},'TEMPVector31',function(){return this.TEMPVector31=new Vector3();},'TEMPVector32',function(){return this.TEMPVector32=new Vector3();},'TEMPVector33',function(){return this.TEMPVector33=new Vector3();},'TEMPMatrix0',function(){return this.TEMPMatrix0=new Matrix4x4();},'TEMPMatrix1',function(){return this.TEMPMatrix1=new Matrix4x4();},'_tempMatrix3x3',function(){return this._tempMatrix3x3=new Matrix3x3();}
		]);
		return Quaternion;
	})()


	/**
	*<code>Rand</code> 类用于通过32位无符号整型随机种子创建随机数。
	*/
	//class laya.d3.math.Rand
	var Rand=(function(){
		function Rand(seed){
			this._temp=new Uint32Array(1);
			this.seeds=new Uint32Array(4);
			this.seeds[0]=seed;
			this.seeds[1]=this.seeds[0] *0x6C078965+1;
			this.seeds[2]=this.seeds[1] *0x6C078965+1;
			this.seeds[3]=this.seeds[2] *0x6C078965+1;
		}

		__class(Rand,'laya.d3.math.Rand');
		var __proto=Rand.prototype;
		/**
		*获取无符号32位整形随机数。
		*@return 无符号32位整形随机数。
		*/
		__proto.getUint=function(){
			this._temp[0]=this.seeds[0] ^ (this.seeds[0] << 11);
			this.seeds[0]=this.seeds[1];
			this.seeds[1]=this.seeds[2];
			this.seeds[2]=this.seeds[3];
			this.seeds[3]=(this.seeds[3] ^ (this.seeds[3] >>> 19))^ (this._temp[0] ^ (this._temp[0] >>> 8));
			return this.seeds[3];
		}

		/**
		*获取0到1之间的浮点随机数。
		*@return 0到1之间的浮点随机数。
		*/
		__proto.getFloat=function(){
			this.getUint();
			return (this.seeds[3] & 0x007FFFFF)*(1.0 / 8388607.0);
		}

		/**
		*获取-1到1之间的浮点随机数。
		*@return-1到1之间的浮点随机数。
		*/
		__proto.getSignedFloat=function(){
			return this.getFloat()*2.0-1.0;
		}

		/**
		*设置随机种子。
		*@param seed 随机种子。
		*/
		/**
		*获取随机种子。
		*@return 随机种子。
		*/
		__getset(0,__proto,'seed',function(){
			return this.seeds[0];
			},function(seed){
			this.seeds[0]=seed;
			this.seeds[1]=this.seeds[0] *0x6C078965+1;
			this.seeds[2]=this.seeds[1] *0x6C078965+1;
			this.seeds[3]=this.seeds[2] *0x6C078965+1;
		});

		Rand.getFloatFromInt=function(v){
			return (v & 0x007FFFFF)*(1.0 / 8388607.0)
		}

		Rand.getByteFromInt=function(v){
			return (v & 0x007FFFFF)>>> 15;
		}

		return Rand;
	})()


	/**
	*<code>Rand</code> 类用于通过128位整型种子创建随机数,算法来自:https://github.com/AndreasMadsen/xorshift。
	*/
	//class laya.d3.math.RandX
	var RandX=(function(){
		function RandX(seed){
			this._state0U=NaN;
			this._state0L=NaN;
			this._state1U=NaN;
			this._state1L=NaN;
			if (!((seed instanceof Array))|| seed.length!==4)
				throw new Error('Rand:Seed must be an array with 4 numbers');
			this._state0U=seed[0] | 0;
			this._state0L=seed[1] | 0;
			this._state1U=seed[2] | 0;
			this._state1L=seed[3] | 0;
		}

		__class(RandX,'laya.d3.math.RandX');
		var __proto=RandX.prototype;
		/**
		*通过2x32位的数组，返回64位的随机数。
		*@return 64位的随机数。
		*/
		__proto.randomint=function(){
			var s1U=this._state0U,s1L=this._state0L;
			var s0U=this._state1U,s0L=this._state1L;
			var sumL=(s0L >>> 0)+(s1L >>> 0);
			var resU=(s0U+s1U+(sumL / 2 >>> 31))>>> 0;
			var resL=sumL >>> 0;
			this._state0U=s0U;
			this._state0L=s0L;
			var t1U=0,t1L=0;
			var t2U=0,t2L=0;
			var a1=23;
			var m1=0xFFFFFFFF << (32-a1);
			t1U=(s1U << a1)| ((s1L & m1)>>> (32-a1));
			t1L=s1L << a1;
			s1U=s1U ^ t1U;
			s1L=s1L ^ t1L;
			t1U=s1U ^ s0U;
			t1L=s1L ^ s0L;
			var a2=18;
			var m2=0xFFFFFFFF >>> (32-a2);
			t2U=s1U >>> a2;
			t2L=(s1L >>> a2)| ((s1U & m2)<< (32-a2));
			t1U=t1U ^ t2U;
			t1L=t1L ^ t2L;
			var a3=5;
			var m3=0xFFFFFFFF >>> (32-a3);
			t2U=s0U >>> a3;
			t2L=(s0L >>> a3)| ((s0U & m3)<< (32-a3));
			t1U=t1U ^ t2U;
			t1L=t1L ^ t2L;
			this._state1U=t1U;
			this._state1L=t1L;
			return [resU,resL];
		}

		/**
		*返回[0,1)之间的随机数。
		*@return
		*/
		__proto.random=function(){
			var t2=this.randomint();
			var t2U=t2[0];
			var t2L=t2[1];
			var eU=0x3FF << (52-32);
			var eL=0;
			var a1=12;
			var m1=0xFFFFFFFF >>> (32-a1);
			var sU=t2U >>> a1;
			var sL=(t2L >>> a1)| ((t2U & m1)<< (32-a1));
			var xU=eU | sU;
			var xL=eL | sL;
			RandX._CONVERTION_BUFFER.setUint32(0,xU,false);
			RandX._CONVERTION_BUFFER.setUint32(4,xL,false);
			var d=/*__JS__ */Rand._CONVERTION_BUFFER.getFloat64(0,false);
			return d-1;
		}

		__static(RandX,
		['_CONVERTION_BUFFER',function(){return this._CONVERTION_BUFFER=new DataView(new ArrayBuffer(8));},'defaultRand',function(){return this.defaultRand=/*__JS__ */new Rand([0,Date.now()/ 65536,0,Date.now()% 65536]);}
		]);
		return RandX;
	})()


	/**
	*<code>Ray</code> 类用于创建射线。
	*/
	//class laya.d3.math.Ray
	var Ray=(function(){
		function Ray(origin,direction){
			this.origin=null;
			this.direction=null;
			this.origin=origin;
			this.direction=direction;
		}

		__class(Ray,'laya.d3.math.Ray');
		return Ray;
	})()


	/**
	*<code>Vector2</code> 类用于创建二维向量。
	*/
	//class laya.d3.math.Vector2
	var Vector2=(function(){
		function Vector2(x,y){
			this.elements=new Float32Array(2);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			var v=this.elements;
			v[0]=x;
			v[1]=y;
		}

		__class(Vector2,'laya.d3.math.Vector2');
		var __proto=Vector2.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destVector2=destObject;
			var destE=destVector2.elements;
			var s=this.elements;
			destE[0]=s[0];
			destE[1]=s[1];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destVector2=/*__JS__ */new this.constructor();
			this.cloneTo(destVector2);
			return destVector2;
		}

		/**
		*设置X轴坐标。
		*@param value X轴坐标。
		*/
		/**
		*获取X轴坐标。
		*@return X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
			},function(value){
			this.elements[0]=value;
		});

		/**
		*设置Y轴坐标。
		*@param value Y轴坐标。
		*/
		/**
		*获取Y轴坐标。
		*@return Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
			},function(value){
			this.elements[1]=value;
		});

		Vector2.scale=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			e[0]=f[0] *b;
			e[1]=f[1] *b;
		}

		__static(Vector2,
		['ZERO',function(){return this.ZERO=new Vector2(0.0,0.0);},'ONE',function(){return this.ONE=new Vector2(1.0,1.0);}
		]);
		return Vector2;
	})()


	/**
	*<code>Vector3</code> 类用于创建三维向量。
	*/
	//class laya.d3.math.Vector3
	var Vector3=(function(){
		function Vector3(x,y,z){
			this.elements=new Float32Array(3);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			var v=this.elements;
			v[0]=x;
			v[1]=y;
			v[2]=z;
		}

		__class(Vector3,'laya.d3.math.Vector3');
		var __proto=Vector3.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destVector3=destObject;
			var destE=destVector3.elements;
			var s=this.elements;
			destE[0]=s[0];
			destE[1]=s[1];
			destE[2]=s[2];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destVector3=/*__JS__ */new this.constructor();
			this.cloneTo(destVector3);
			return destVector3;
		}

		__proto.toDefault=function(){
			this.elements[0]=0;
			this.elements[1]=0;
			this.elements[2]=0;
		}

		/**
		*设置X轴坐标。
		*@param value X轴坐标。
		*/
		/**
		*获取X轴坐标。
		*@return X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
			},function(value){
			this.elements[0]=value;
		});

		/**
		*设置Y轴坐标。
		*@param value Y轴坐标。
		*/
		/**
		*获取Y轴坐标。
		*@return Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
			},function(value){
			this.elements[1]=value;
		});

		/**
		*设置Z轴坐标。
		*@param value Z轴坐标。
		*/
		/**
		*获取Z轴坐标。
		*@return Z轴坐标。
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
			},function(value){
			this.elements[2]=value;
		});

		Vector3.distanceSquared=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			return (x *x)+(y *y)+(z *z);
		}

		Vector3.distance=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			return Math.sqrt((x *x)+(y *y)+(z *z));
		}

		Vector3.min=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.min(f[0],g[0]);
			e[1]=Math.min(f[1],g[1]);
			e[2]=Math.min(f[2],g[2]);
		}

		Vector3.max=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.max(f[0],g[0]);
			e[1]=Math.max(f[1],g[1]);
			e[2]=Math.max(f[2],g[2]);
		}

		Vector3.transformQuat=function(source,rotation,out){
			var destination=out.elements;
			var se=source.elements;
			var re=rotation.elements;
			var x=se[0],y=se[1],z=se[2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
			ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
			destination[0]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
			destination[1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
			destination[2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
		}

		Vector3.scalarLength=function(a){
			var f=a.elements;
			var x=f[0],y=f[1],z=f[2];
			return Math.sqrt(x *x+y *y+z *z);
		}

		Vector3.scalarLengthSquared=function(a){
			var f=a.elements;
			var x=f[0],y=f[1],z=f[2];
			return x *x+y *y+z *z;
		}

		Vector3.normalize=function(s,out){
			var se=s.elements;
			var oe=out.elements;
			var x=se[0],y=se[1],z=se[2];
			var len=x *x+y *y+z *z;
			if (len > 0){
				len=1 / Math.sqrt(len);
				oe[0]=se[0] *len;
				oe[1]=se[1] *len;
				oe[2]=se[2] *len;
			}
		}

		Vector3.multiply=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=f[0] *g[0];
			e[1]=f[1] *g[1];
			e[2]=f[2] *g[2];
		}

		Vector3.scale=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			e[0]=f[0] *b;
			e[1]=f[1] *b;
			e[2]=f[2] *b;
		}

		Vector3.lerp=function(a,b,t,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements;
			var ax=f[0],ay=f[1],az=f[2];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
		}

		Vector3.transformV3ToV3=function(vector,transform,result){
			var intermediate=new Vector4();
			Vector3.transformV3ToV4(vector,transform,intermediate);
			var intermediateElem=intermediate.elements;
			var resultElem=result.elements;
			resultElem[0]=intermediateElem[0];
			resultElem[1]=intermediateElem[1];
			resultElem[2]=intermediateElem[2];
		}

		Vector3.transformV3ToV4=function(vector,transform,result){
			var vectorElem=vector.elements;
			var vectorX=vectorElem[0];
			var vectorY=vectorElem[1];
			var vectorZ=vectorElem[2];
			var transformElem=transform.elements;
			var resultElem=result.elements;
			resultElem[0]=(vectorX *transformElem[0])+(vectorY *transformElem[4])+(vectorZ *transformElem[8])+transformElem[12];
			resultElem[1]=(vectorX *transformElem[1])+(vectorY *transformElem[5])+(vectorZ *transformElem[9])+transformElem[13];
			resultElem[2]=(vectorX *transformElem[2])+(vectorY *transformElem[6])+(vectorZ *transformElem[10])+transformElem[14];
			resultElem[3]=(vectorX *transformElem[3])+(vectorY *transformElem[7])+(vectorZ *transformElem[11])+transformElem[15];
		}

		Vector3.TransformNormal=function(normal,transform,result){
			var normalElem=normal.elements;
			var normalX=normalElem[0];
			var normalY=normalElem[1];
			var normalZ=normalElem[2];
			var transformElem=transform.elements;
			var resultElem=result.elements;
			resultElem[0]=(normalX *transformElem[0])+(normalY *transformElem[4])+(normalZ *transformElem[8]);
			resultElem[1]=(normalX *transformElem[1])+(normalY *transformElem[5])+(normalZ *transformElem[9]);
			resultElem[2]=(normalX *transformElem[2])+(normalY *transformElem[6])+(normalZ *transformElem[10]);
		}

		Vector3.transformCoordinate=function(coordinate,transform,result){
			var vectorElem=Vector3.TEMPVec4.elements;
			var coordinateElem=coordinate.elements;
			var coordinateX=coordinateElem[0];
			var coordinateY=coordinateElem[1];
			var coordinateZ=coordinateElem[2];
			var transformElem=transform.elements;
			vectorElem[0]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12];
			vectorElem[1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13];
			vectorElem[2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14];
			vectorElem[3]=1.0 / ((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
			var resultElem=result.elements;
			resultElem[0]=vectorElem[0] *vectorElem[3];
			resultElem[1]=vectorElem[1] *vectorElem[3];
			resultElem[2]=vectorElem[2] *vectorElem[3];
		}

		Vector3.Clamp=function(value,min,max,out){
			var valuee=value.elements;
			var x=valuee[0];
			var y=valuee[1];
			var z=valuee[2];
			var mine=min.elements;
			var mineX=mine[0];
			var mineY=mine[1];
			var mineZ=mine[2];
			var maxe=max.elements;
			var maxeX=maxe[0];
			var maxeY=maxe[1];
			var maxeZ=maxe[2];
			var oute=out.elements;
			x=(x > maxeX)? maxeX :x;
			x=(x < mineX)? mineX :x;
			y=(y > maxeY)? maxeY :y;
			y=(y < mineY)? mineY :y;
			z=(z > maxeZ)? maxeZ :z;
			z=(z < mineZ)? mineZ :z;
			oute[0]=x;
			oute[1]=y;
			oute[2]=z;
		}

		Vector3.add=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=f[0]+g[0];
			e[1]=f[1]+g[1];
			e[2]=f[2]+g[2];
		}

		Vector3.subtract=function(a,b,o){
			var oe=o.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0]-be[0];
			oe[1]=ae[1]-be[1];
			oe[2]=ae[2]-be[2];
		}

		Vector3.cross=function(a,b,o){
			var ae=a.elements;
			var be=b.elements;
			var oe=o.elements;
			var ax=ae[0],ay=ae[1],az=ae[2],bx=be[0],by=be[1],bz=be[2];
			oe[0]=ay *bz-az *by;
			oe[1]=az *bx-ax *bz;
			oe[2]=ax *by-ay *bx;
		}

		Vector3.dot=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2]);
			return r;
		}

		Vector3.equals=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			return MathUtils3D.nearEqual(Math.abs(ae[0]),Math.abs(be[0]))
			&& MathUtils3D.nearEqual(Math.abs(ae[1]),Math.abs(be[1]))
			&& MathUtils3D.nearEqual(Math.abs(ae[2]),Math.abs(be[2]));
		}

		__static(Vector3,
		['ZERO',function(){return this.ZERO=new Vector3(0.0,0.0,0.0);},'ONE',function(){return this.ONE=new Vector3(1.0,1.0,1.0);},'NegativeUnitX',function(){return this.NegativeUnitX=new Vector3(-1,0,0);},'UnitX',function(){return this.UnitX=new Vector3(1,0,0);},'UnitY',function(){return this.UnitY=new Vector3(0,1,0);},'UnitZ',function(){return this.UnitZ=new Vector3(0,0,1);},'ForwardRH',function(){return this.ForwardRH=new Vector3(0,0,-1);},'ForwardLH',function(){return this.ForwardLH=new Vector3(0,0,1);},'Up',function(){return this.Up=new Vector3(0,1,0);},'TEMPVec4',function(){return this.TEMPVec4=new Vector4();}
		]);
		return Vector3;
	})()


	/**
	*<code>Vector4</code> 类用于创建四维向量。
	*/
	//class laya.d3.math.Vector4
	var Vector4=(function(){
		function Vector4(x,y,z,w){
			this.elements=new Float32Array(4);
			(x===void 0)&& (x=0);
			(y===void 0)&& (y=0);
			(z===void 0)&& (z=0);
			(w===void 0)&& (w=0);
			var v=this.elements;
			v[0]=x;
			v[1]=y;
			v[2]=z;
			v[3]=w;
		}

		__class(Vector4,'laya.d3.math.Vector4');
		var __proto=Vector4.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destVector4=destObject;
			var destE=destVector4.elements;
			var s=this.elements;
			destE[0]=s[0];
			destE[1]=s[1];
			destE[2]=s[2];
			destE[3]=s[3];
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destVector4=/*__JS__ */new this.constructor();
			this.cloneTo(destVector4);
			return destVector4;
		}

		/**
		*求四维向量的长度。
		*@return 长度。
		*/
		__proto.length=function(){
			return Math.sqrt(this.x *this.x+this.y *this.y+this.z *this.z+this.w *this.w);
		}

		/**
		*求四维向量长度的平方。
		*@return 长度的平方。
		*/
		__proto.lengthSquared=function(){
			return this.x *this.x+this.y *this.y+this.z *this.z+this.w *this.w;
		}

		/**
		*设置X轴坐标。
		*@param value X轴坐标。
		*/
		/**
		*获取X轴坐标。
		*@return X轴坐标。
		*/
		__getset(0,__proto,'x',function(){
			return this.elements[0];
			},function(value){
			this.elements[0]=value;
		});

		/**
		*设置Y轴坐标。
		*@param value Y轴坐标。
		*/
		/**
		*获取Y轴坐标。
		*@return Y轴坐标。
		*/
		__getset(0,__proto,'y',function(){
			return this.elements[1];
			},function(value){
			this.elements[1]=value;
		});

		/**
		*设置Z轴坐标。
		*@param value Z轴坐标。
		*/
		/**
		*获取Z轴坐标。
		*@return Z轴坐标。
		*/
		__getset(0,__proto,'z',function(){
			return this.elements[2];
			},function(value){
			this.elements[2]=value;
		});

		/**
		*设置W轴坐标。
		*@param value W轴坐标。
		*/
		/**
		*获取W轴坐标。
		*@return W轴坐标。
		*/
		__getset(0,__proto,'w',function(){
			return this.elements[3];
			},function(value){
			this.elements[3]=value;
		});

		Vector4.lerp=function(a,b,t,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements;
			var ax=f[0],ay=f[1],az=f[2],aw=f[3];
			e[0]=ax+t *(g[0]-ax);
			e[1]=ay+t *(g[1]-ay);
			e[2]=az+t *(g[2]-az);
			e[3]=aw+t *(g[3]-aw);
		}

		Vector4.transformByM4x4=function(vector4,m4x4,out){
			var ve=vector4.elements;
			var vx=ve[0];
			var vy=ve[1];
			var vz=ve[2];
			var vw=ve[3];
			var me=m4x4.elements;
			var oe=out.elements;
			oe[0]=vx *me[0]+vy *me[4]+vz *me[8]+vw *me[12];
			oe[1]=vx *me[1]+vy *me[5]+vz *me[9]+vw *me[13];
			oe[2]=vx *me[2]+vy *me[6]+vz *me[10]+vw *me[14];
			oe[3]=vx *me[3]+vy *me[7]+vz *me[11]+vw *me[15];
		}

		Vector4.equals=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			return MathUtils3D.nearEqual(Math.abs(ae[0]),Math.abs(be[0]))&& MathUtils3D.nearEqual(Math.abs(ae[1]),Math.abs(be[1]))&& MathUtils3D.nearEqual(Math.abs(ae[2]),Math.abs(be[2]))&& MathUtils3D.nearEqual(Math.abs(ae[3]),Math.abs(be[3]));
		}

		Vector4.normalize=function(s,out){
			var se=s.elements;
			var oe=out.elements;
			var len=/*if err,please use iflash.method.xmlLength()*/s.length();
			if (len > 0){
				oe[0]=se[0] *len;
				oe[1]=se[1] *len;
				oe[2]=se[2] *len;
				oe[3]=se[3] *len;
			}
		}

		Vector4.add=function(a,b,out){
			var oe=out.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0]+be[0];
			oe[1]=ae[1]+be[1];
			oe[2]=ae[2]+be[2];
			oe[3]=ae[3]+be[3];
		}

		Vector4.subtract=function(a,b,out){
			var oe=out.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0]-be[0];
			oe[1]=ae[1]-be[1];
			oe[2]=ae[2]-be[2];
			oe[3]=ae[3]-be[3];
		}

		Vector4.multiply=function(a,b,out){
			var oe=out.elements;
			var ae=a.elements;
			var be=b.elements;
			oe[0]=ae[0] *be[0];
			oe[1]=ae[1] *be[1];
			oe[2]=ae[2] *be[2];
			oe[3]=ae[3] *be[3];
		}

		Vector4.scale=function(a,b,out){
			var oe=out.elements;
			var ae=a.elements;
			oe[0]=ae[0] *b;
			oe[1]=ae[1] *b;
			oe[2]=ae[2] *b;
			oe[3]=ae[3] *b;
		}

		Vector4.Clamp=function(value,min,max,out){
			var valuee=value.elements;
			var x=valuee[0];
			var y=valuee[1];
			var z=valuee[2];
			var w=valuee[3];
			var mine=min.elements;
			var mineX=mine[0];
			var mineY=mine[1];
			var mineZ=mine[2];
			var mineW=mine[3];
			var maxe=max.elements;
			var maxeX=maxe[0];
			var maxeY=maxe[1];
			var maxeZ=maxe[2];
			var maxeW=maxe[3];
			var oute=out.elements;
			x=(x > maxeX)? maxeX :x;
			x=(x < mineX)? mineX :x;
			y=(y > maxeY)? maxeY :y;
			y=(y < mineY)? mineY :y;
			z=(z > maxeZ)? maxeZ :z;
			z=(z < mineZ)? mineZ :z;
			w=(w > maxeW)? maxeW :w;
			w=(w < mineW)? mineW :w;
			oute[0]=x;
			oute[1]=y;
			oute[2]=z;
			oute[3]=w;
		}

		Vector4.distanceSquared=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			var w=value1e[3]-value2e[3];
			return (x *x)+(y *y)+(z *z)+(w *w);
		}

		Vector4.distance=function(value1,value2){
			var value1e=value1.elements;
			var value2e=value2.elements;
			var x=value1e[0]-value2e[0];
			var y=value1e[1]-value2e[1];
			var z=value1e[2]-value2e[2];
			var w=value1e[3]-value2e[3];
			return Math.sqrt((x *x)+(y *y)+(z *z)+(w *w));
		}

		Vector4.dot=function(a,b){
			var ae=a.elements;
			var be=b.elements;
			var r=(ae[0] *be[0])+(ae[1] *be[1])+(ae[2] *be[2])+(ae[3] *be[3]);
			return r;
		}

		Vector4.min=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.min(f[0],g[0]);
			e[1]=Math.min(f[1],g[1]);
			e[2]=Math.min(f[2],g[2]);
			e[3]=Math.min(f[3],g[3]);
		}

		Vector4.max=function(a,b,out){
			var e=out.elements;
			var f=a.elements;
			var g=b.elements
			e[0]=Math.max(f[0],g[0]);
			e[1]=Math.max(f[1],g[1]);
			e[2]=Math.max(f[2],g[2]);
			e[3]=Math.max(f[3],g[3]);
		}

		__static(Vector4,
		['ZERO',function(){return this.ZERO=new Vector4();},'ONE',function(){return this.ONE=new Vector4(1.0,1.0,1.0,1.0);},'UnitX',function(){return this.UnitX=new Vector4(1.0,0.0,0.0,0.0);},'UnitY',function(){return this.UnitY=new Vector4(0.0,1.0,0.0,0.0);},'UnitZ',function(){return this.UnitZ=new Vector4(0.0,0.0,1.0,0.0);},'UnitW',function(){return this.UnitW=new Vector4(0.0,0.0,0.0,1.0);}
		]);
		return Vector4;
	})()


	/**
	*<code>Viewport</code> 类用于创建视口。
	*/
	//class laya.d3.math.Viewport
	var Viewport=(function(){
		function Viewport(x,y,width,height){
			//this.x=NaN;
			//this.y=NaN;
			//this.width=NaN;
			//this.height=NaN;
			//this.minDepth=NaN;
			//this.maxDepth=NaN;
			this.minDepth=0.0;
			this.maxDepth=1.0;
			this.x=x;
			this.y=y;
			this.width=width;
			this.height=height;
		}

		__class(Viewport,'laya.d3.math.Viewport');
		var __proto=Viewport.prototype;
		/**
		*变换一个三维向量。
		*@param source 源三维向量。
		*@param matrix 变换矩阵。
		*@param vector 输出三维向量。
		*/
		__proto.project=function(source,matrix,out){
			Vector3.transformV3ToV3(source,matrix,out);
			var sourceEleme=source.elements;
			var matrixEleme=matrix.elements;
			var outEleme=out.elements;
			var a=(((sourceEleme[0] *matrixEleme[3])+(sourceEleme[1] *matrixEleme[7]))+(sourceEleme[2] *matrixEleme[11]))+matrixEleme[15];
			if (a!==1.0){
				outEleme[0]=outEleme[0] / a;
				outEleme[1]=outEleme[1] / a;
				outEleme[2]=outEleme[2] / a;
			}
			outEleme[0]=(((outEleme[0]+1.0)*0.5)*this.width)+this.x;
			outEleme[1]=(((-outEleme[1]+1.0)*0.5)*this.height)+this.y;
			outEleme[2]=(outEleme[2] *(this.maxDepth-this.minDepth))+this.minDepth;
		}

		/**
		*反变换一个三维向量。
		*@param source 源三维向量。
		*@param matrix 变换矩阵。
		*@param vector 输出三维向量。
		*/
		__proto.unprojectFromMat=function(source,matrix,out){
			var sourceEleme=source.elements;
			var matrixEleme=matrix.elements;
			var outEleme=out.elements;
			outEleme[0]=(((sourceEleme[0]-this.x)/ (this.width))*2.0)-1.0;
			outEleme[1]=-((((sourceEleme[1]-this.y)/ (this.height))*2.0)-1.0);
			var halfDepth=(this.maxDepth-this.minDepth)/ 2;
			outEleme[2]=(sourceEleme[2]-this.minDepth-halfDepth)/ halfDepth;
			var a=(((outEleme[0] *matrixEleme[3])+(outEleme[1] *matrixEleme[7]))+(outEleme[2] *matrixEleme[11]))+matrixEleme[15];
			Vector3.transformV3ToV3(out,matrix,out);
			if (a!==1.0){
				outEleme[0]=outEleme[0] / a;
				outEleme[1]=outEleme[1] / a;
				outEleme[2]=outEleme[2] / a;
			}
		}

		/**
		*反变换一个三维向量。
		*@param source 源三维向量。
		*@param projection 透视投影矩阵。
		*@param view 视图矩阵。
		*@param world 世界矩阵,可设置为null。
		*@param out 输出向量。
		*/
		__proto.unprojectFromWVP=function(source,projection,view,world,out){
			Matrix4x4.multiply(projection,view,Viewport._tempMatrix4x4);
			(world)&& (Matrix4x4.multiply(Viewport._tempMatrix4x4,world,Viewport._tempMatrix4x4));
			Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4);
			this.unprojectFromMat(source,Viewport._tempMatrix4x4,out);
		}

		__static(Viewport,
		['_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();}
		]);
		return Viewport;
	})()


	/**
	*<code>SubMesh</code> 类用于创建子网格数据模板。
	*/
	//class laya.d3.resource.models.SubMesh
	var SubMesh=(function(){
		function SubMesh(mesh){
			this._mesh=null;
			this._boneIndicesList=null;
			this._subIndexBufferStart=null;
			this._subIndexBufferCount=null;
			this._skinAnimationDatas=null;
			this._bufferUsage=null;
			this._indexInMesh=0;
			this._vertexBuffer=null;
			this._vertexBufferStart=0;
			this.__vertexBufferCount=0;
			this._indexBuffer=null;
			this._indexBufferStart=0;
			this._indexBufferCount=0;
			this._bufferUsage={};
			this._mesh=mesh;
			this._boneIndicesList=[];
			this._subIndexBufferStart=[];
			this._subIndexBufferCount=[];
		}

		__class(SubMesh,'laya.d3.resource.models.SubMesh');
		var __proto=SubMesh.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true,"laya.resource.IDispose":true})
		/**
		*@private
		*/
		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer;
			else
			return null;
		}

		/**
		*@private
		*/
		__proto._getIndexBuffer=function(){
			return this._indexBuffer;
		}

		/**
		*@private
		*/
		__proto._beforeRender=function(state){
			this._vertexBuffer._bind();
			this._indexBuffer._bind();
			return true;
		}

		/**NATIVE*/
		__proto._renderRuntime=function(conchGraphics3D,renderElement,state){
			var material=renderElement._material,owner=renderElement._sprite3D;
			conchGraphics3D.drawSubmesh(renderElement._conchSubmesh,0,/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,0,this._indexBuffer.indexCount);
		}

		/**
		*@private
		*渲染。
		*@param state 渲染状态。
		*/
		__proto._render=function(state){
			var indexCount=0;
			var renderElement=state.renderElement;
			if (this._indexBufferCount > 1){
				var boneIndicesListCount=this._boneIndicesList.length;
				if (boneIndicesListCount > 0){
					for (var i=0;i < boneIndicesListCount;i++){
						if (this._skinAnimationDatas){
							renderElement._shaderValue.setValue(/*laya.d3.component.animation.SkinAnimations.BONES*/0,this._skinAnimationDatas[i]);
							state._shader.uploadRenderElementUniforms(renderElement._shaderValue.data);
						}
						WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._subIndexBufferCount[i],/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._subIndexBufferStart[i] *2);
					}
					}else {
					if (this._skinAnimationDatas){
						renderElement._shaderValue.setValue(/*laya.d3.component.animation.SkinAnimations.BONES*/0,this._skinAnimationDatas[0]);
						state._shader.uploadRenderElementUniforms(renderElement._shaderValue.data);
					}
					WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._indexBufferCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._indexBufferStart *2);
				}
				indexCount=this._indexBufferCount;
				}else {
				indexCount=this._indexBuffer.indexCount;
				if (this._skinAnimationDatas){
					renderElement._shaderValue.setValue(/*laya.d3.component.animation.SkinAnimations.BONES*/0,this._skinAnimationDatas[0]);
					state._shader.uploadRenderElementUniforms(renderElement._shaderValue.data);
				}
				WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
			}
			Stat.drawCall++;
			Stat.trianglesFaces+=indexCount / 3;
		}

		/**
		*<p>彻底清理资源。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.dispose=function(){
			this._boneIndicesList=null;
			this._indexBuffer.dispose();
			this._vertexBuffer.dispose();
		}

		/**
		*@private
		*/
		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		/**
		*@private
		*/
		__getset(0,__proto,'indexOfHost',function(){
			return this._indexInMesh;
		});

		/**
		*@private
		*/
		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer.indexCount / 3;
		});

		return SubMesh;
	})()


	//class laya.d3.shader.ShaderCompile3D
	var ShaderCompile3D=(function(){
		var ShaderScriptBlock;
		function ShaderCompile3D(name,vs,ps,attributeMap,uniformMap,includeFiles){
			//this._name=NaN;
			//this._VS=null;
			//this._PS=null;
			//this._VSTXT=null;
			//this._PSTXT=null;
			//this._attributeMap=null;
			//this._renderElementUniformMap=null;
			//this._materialUniformMap=null;
			//this._spriteUniformMap=null;
			//this._cameraUniformMap=null;
			//this._sceneUniformMap=null;
			//this.sharders=null;
			this._curMaterialDefinePower=1;
			this._curSpriteDefinePower=3;
			this._materialInt2name=[];
			this._spriteInt2name=[];
			//this._conchShader=null;
			this._name=name;
			this._renderElementUniformMap={};
			this._materialUniformMap={};
			this._spriteUniformMap={};
			this._cameraUniformMap={};
			this._sceneUniformMap={};
			this.sharders=[];
			this._VSTXT=vs;
			this._PSTXT=ps;
			this._spriteInt2name[ /*laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_RECEIVE_SHADOW*/0x1]="RECEIVESHADOW";
			this._spriteInt2name[ /*laya.d3.core.RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV*/0x2]="SCALEOFFSETLIGHTINGMAPUV";
			this._spriteInt2name[SkinAnimations.SHADERDEFINE_BONE]="BONE";
			this._materialInt2name[BaseMaterial.SHADERDEFINE_ALPHATEST]="ALPHATEST";
			function split (str){
				var words=str.split(' ');
				var out=[];
				for (var i=0;i < words.length;i++)
				words[i].length > 0 && out.push(words[i]);
				return out;
			}
			function c (script){
				var before=script;
				script=script.replace(ShaderCompile3D.DEFINEREG,"");
				var i=0,n=0,ofs=0,words,condition;
				var top=new ShaderScriptBlock(0,null,null,null);
				var parent=top;
				var lines=script.split('\n');
				for (i=0,n=lines.length;i < n;i++){
					var line=lines[i];
					if (line.indexOf("#ifdef")>=0){
						words=split(line);
						parent=new ShaderScriptBlock(1,words[1],"",parent);
						continue ;
					}
					if (line.indexOf("#if")>=0){
						words=split(line);
						parent=new ShaderScriptBlock(1,words[1],"",parent);
						continue ;
					}
					if (line.indexOf("#else")>=0){
						condition=parent.condition;
						parent=new ShaderScriptBlock(2,null,"",parent.parent);
						parent.condition=condition;
						continue ;
					}
					if (line.indexOf("#endif")>=0){
						parent=parent.parent;
						continue ;
					}
					if (line.indexOf("#include")>=0){
						words=split(line);
						var fname=words[1];
						var chr=fname.charAt(0);
						if (chr==='"' || chr==="'"){
							fname=fname.substr(1,fname.length-2);
							ofs=fname.lastIndexOf(chr);
							if (ofs > 0)fname=fname.substr(0,ofs);
						}
						ofs=words[0].indexOf('?');
						var str=ofs > 0 ? words[0].substr(ofs+1):null;
						new ShaderScriptBlock(1,str,includeFiles[fname],parent);
						if (Render.isConchNode){
							var tmp=str.match(ShaderCompile3D.INCLUDE);
							var sz=tmp.length;
							if (sz==1){
								str=str.replace(tmp[0],"defined("+tmp[0]+")");
								}else if (sz > 1){
								var tobj={};
								for (var j=0;j < sz;j++){
									var _name=tmp[j];
									if (!tobj[_name]){
										str=str.replace(_name,"defined("+_name+")");
										tobj[_name]=true;
									}
								}
							};
							var result="#if "+str;
							result+=("\n"+includeFiles[fname]+"\n");
							result+="#endif";
							before=before.replace(line,result);
						}
						continue ;
					}
					if (parent.childs.length > 0 && parent.childs[parent.childs.length-1].type===0){
						parent.childs[parent.childs.length-1].text+="\n"+line;
					}else new ShaderScriptBlock(0,null,line,parent);
				}
				Render.isConchNode && (top["sd"]=before);
				return top;
			}
			this._VS=c(vs);
			this._PS=c(ps);
			this._attributeMap=attributeMap;
			var renderElementUnifCount=0,materialUnifCount=0,spriteUnifCount=0;
			var key;
			for (key in uniformMap){
				var uniformParam=uniformMap[key];
				switch (uniformParam[1]){
					case /*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0:
						this._renderElementUniformMap[key]=uniformParam[0];
						break ;
					case /*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1:
						this._materialUniformMap[key]=uniformParam[0];
						break ;
					case /*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2:
						this._spriteUniformMap[key]=uniformParam[0];
						break ;
					case /*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3:
						this._cameraUniformMap[key]=uniformParam[0];
						break ;
					case /*laya.d3.shader.Shader3D.PERIOD_SCENE*/4:
						this._sceneUniformMap[key]=uniformParam[0];
						break ;
					default :
						throw new Error("ShaderCompile3D: period is unkonw.");
					}
			}
			if (Render.isConchNode){
				this._conchShader=/*__JS__ */new ConchShader();
				this._conchShader.setSrc(this._VS["sd"],this._PS["sd"]);
				delete this._VS["sd"];
				delete this._PS["sd"];
				var conchAttrElements=[];
				for (key in this._attributeMap){
					conchAttrElements.push({name:key,elementUsage:this._attributeMap[key]});
				}
				this._conchShader.setAttrDeclare(conchAttrElements);
				var conchUniformElements=[];
				for (key in uniformMap){
					var tempArray=uniformMap[key];
					conchUniformElements.push({name:key,elementUsage:tempArray[0],periodType:tempArray[1]});
				}
				this._conchShader.setUniformDeclare(conchUniformElements);
			}
		}

		__class(ShaderCompile3D,'laya.d3.shader.ShaderCompile3D');
		var __proto=ShaderCompile3D.prototype;
		/**
		*根据宏动态生成shader文件，支持#include?COLOR_FILTER "parts/ColorFilter_ps_logic.glsl";条件嵌入文件
		*@param name
		*@param vs
		*@param ps
		*@param define 宏定义，格式:{name:value...}
		*@return
		*/
		__proto.withCompile=function(nameID,publicDefine,spriteDefine,materialDefine){
			var shader;
			var publicDefShaders=this.sharders[nameID],spriteDefShaders,materialDefShaders;
			if (publicDefShaders){
				spriteDefShaders=publicDefShaders[publicDefine];
				if (spriteDefShaders){
					materialDefShaders=spriteDefShaders[spriteDefine];
					if (materialDefShaders){
						shader=materialDefShaders[materialDefine];
						if (shader)
							return shader;
						}else {
						materialDefShaders=spriteDefShaders[spriteDefine]=[];
					}
					}else {
					spriteDefShaders=publicDefShaders[publicDefine]=[];
					materialDefShaders=spriteDefShaders[spriteDefine]=[];
				}
				}else {
				publicDefShaders=this.sharders[nameID]=[];
				spriteDefShaders=publicDefShaders[publicDefine]=[];
				materialDefShaders=spriteDefShaders[spriteDefine]=[];
			};
			var publicDefGroup=this.definesToNameDic(publicDefine,ShaderCompile3D._globalInt2name);
			var spriteDefGroup=this.definesToNameDic(spriteDefine,this._spriteInt2name);
			var materialDefGroup=this.definesToNameDic(materialDefine,this._materialInt2name);
			if (laya.d3.shader.ShaderCompile3D.debugMode){
				var publicDefGroupStr="",key;
				for (key in publicDefGroup)
				publicDefGroupStr+=key+" ";
				var spriteDefGroupStr="";
				for (key in spriteDefGroup)
				spriteDefGroupStr+=key+" ";
				var materialDefGroupStr="";
				for (key in materialDefGroup)
				materialDefGroupStr+=key+" ";
				console.log("ShaderCompile3DDebugMode---(Name:"+Shader3D.nameKey.getName(nameID)+" PublicDefine:"+publicDefine+" SpriteDefine:"+spriteDefine+" MaterialDefine:"+materialDefine+" PublicDefineGroup:"+publicDefGroupStr+" SpriteDefineGroup:"+spriteDefGroupStr+"MaterialDefineGroup: "+materialDefGroupStr+")---ShaderCompile3DDebugMode");
			}
			shader=this.createShader(publicDefGroup,spriteDefGroup,materialDefGroup);
			materialDefShaders[materialDefine]=shader;
			return shader;
		}

		__proto.createShader=function(publicDefine,spriteDefine,materialDefine){
			var defMap={};
			var defineStr="",key;
			if (publicDefine){
				for (key in publicDefine){
					defineStr+="#define "+key+"\n";
					defMap[key]=true;
				}
			}
			if (spriteDefine){
				for (key in spriteDefine){
					defineStr+="#define "+key+"\n";
					defMap[key]=true;
				}
			}
			if (materialDefine){
				for (key in materialDefine){
					defineStr+="#define "+key+"\n";
					defMap[key]=true;
				}
			};
			var vs=this._VS.toscript(defMap,[]);
			var ps=this._PS.toscript(defMap,[]);
			return Shader3D.create(defineStr+vs.join('\n'),defineStr+ps.join('\n'),this._attributeMap,this._sceneUniformMap,this._cameraUniformMap,this._spriteUniformMap,this._materialUniformMap,this._renderElementUniformMap);
		}

		/**
		*通过宏定义预编译shader。
		*@param spriteIntToNameDic 精灵宏定义数组。
		*@param publicDefine 公共宏定义值。
		*@param spriteDefine 精灵宏定义值。
		*@param materialDefine 材质宏定义值。
		*/
		__proto.precompileShaderWithShaderDefine=function(publicDefine,spriteDefine,materialDefine){
			this.withCompile(this._name,publicDefine,spriteDefine,materialDefine);
		}

		/**
		*注册材质宏定义。
		*@param name 宏定义名称。
		*@return
		*/
		__proto.registerMaterialDefine=function(name){
			var value=Math.pow(2,this._curMaterialDefinePower++);
			this._materialInt2name[value]=name;
			if (Render.isConchNode){
				/*__JS__ */conch.regShaderDefine&&conch.regShaderDefine(name,value);
			}
			return value;
		}

		/**
		*注册精灵宏定义。
		*@param name 宏定义名称。
		*@return
		*/
		__proto.registerSpriteDefine=function(name){
			var value=Math.pow(2,this._curSpriteDefinePower++);
			this._spriteInt2name[value]=name;
			if (Render.isConchNode){
				/*__JS__ */conch.regShaderDefine&&conch.regShaderDefine(name,value);
			}
			return value;
		}

		__proto.definesToNameDic=function(value,int2Name){
			var o={};
			var d=1;
			for (var i=0;i < 32;i++){
				d=1 << i;
				if (d > value)break ;
				if (value & d){
					var name=int2Name[d];
					name && (o[name]="");
				}
			}
			return o;
		}

		ShaderCompile3D.__init__=function(){
			ShaderCompile3D._globalRegDefine("FSHIGHPRECISION",ShaderCompile3D.SHADERDEFINE_FSHIGHPRECISION);
			ShaderCompile3D._globalRegDefine("VR",ShaderCompile3D.SHADERDEFINE_VR);
			ShaderCompile3D._globalRegDefine("FOG",ShaderCompile3D.SHADERDEFINE_FOG);
			ShaderCompile3D._globalRegDefine("DIRECTIONLIGHT",ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
			ShaderCompile3D._globalRegDefine("POINTLIGHT",ShaderCompile3D.SHADERDEFINE_POINTLIGHT);
			ShaderCompile3D._globalRegDefine("SPOTLIGHT",ShaderCompile3D.SHADERDEFINE_SPOTLIGHT);
			ShaderCompile3D._globalRegDefine("UV",ShaderCompile3D.SHADERDEFINE_UV0);
			ShaderCompile3D._globalRegDefine("COLOR",ShaderCompile3D.SHADERDEFINE_COLOR);
			ShaderCompile3D._globalRegDefine("UV1",ShaderCompile3D.SHADERDEFINE_UV1);
			ShaderCompile3D._globalRegDefine("CASTSHADOW",ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW);
			ShaderCompile3D._globalRegDefine("SHADOWMAP_PSSM1",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
			ShaderCompile3D._globalRegDefine("SHADOWMAP_PSSM2",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
			ShaderCompile3D._globalRegDefine("SHADOWMAP_PSSM3",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
			ShaderCompile3D._globalRegDefine("SHADOWMAP_PCF_NO",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
			ShaderCompile3D._globalRegDefine("SHADOWMAP_PCF1",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
			ShaderCompile3D._globalRegDefine("SHADOWMAP_PCF2",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
			ShaderCompile3D._globalRegDefine("SHADOWMAP_PCF3",ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
			ShaderCompile3D._globalRegDefine("DEPTHFOG",ShaderCompile3D.SAHDERDEFINE_DEPTHFOG);
		}

		ShaderCompile3D._globalRegDefine=function(name,value){
			ShaderCompile3D._globalInt2name[value]=name;
		}

		ShaderCompile3D.add=function(nameID,vs,ps,attributeMap,uniformMap){
			return laya.d3.shader.ShaderCompile3D._preCompileShader[nameID]=new ShaderCompile3D(nameID,vs,ps,attributeMap,uniformMap,Shader3D._includeFiles);
		}

		ShaderCompile3D.get=function(name){
			return laya.d3.shader.ShaderCompile3D._preCompileShader[Shader3D.nameKey.getID(name)];
		}

		ShaderCompile3D.debugMode=false;
		ShaderCompile3D.SHADERDEFINE_FSHIGHPRECISION=0x1;
		ShaderCompile3D.SHADERDEFINE_VR=0x2;
		ShaderCompile3D.SHADERDEFINE_FOG=0x4;
		ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT=0x8;
		ShaderCompile3D.SHADERDEFINE_POINTLIGHT=0x10;
		ShaderCompile3D.SHADERDEFINE_SPOTLIGHT=0x20;
		ShaderCompile3D.SHADERDEFINE_UV0=0x40;
		ShaderCompile3D.SHADERDEFINE_COLOR=0x80;
		ShaderCompile3D.SHADERDEFINE_UV1=0x100;
		ShaderCompile3D.SAHDERDEFINE_DEPTHFOG=0x10000;
		ShaderCompile3D._globalInt2name=[];
		ShaderCompile3D._preCompileShader={};
		ShaderCompile3D.IFDEF_NO=0;
		ShaderCompile3D.IFDEF_YES=1;
		ShaderCompile3D.IFDEF_ELSE=2;
		__static(ShaderCompile3D,
		['DEFINEREG',function(){return this.DEFINEREG=new RegExp("defined(?=\\((.*?)\\))","g");},'INCLUDE',function(){return this.INCLUDE=new RegExp("\\w+","g");}
		]);
		ShaderCompile3D.__init$=function(){
			//class ShaderScriptBlock
			ShaderScriptBlock=(function(){
				function ShaderScriptBlock(type,condition,text,parent){
					//this.type=0;
					//this.condition=null;
					//this.text=null;
					//this.parent=null;
					this.childs=new Array;
					this.type=type;
					this.text=text;
					this.parent=parent;
					parent && parent.childs.push(this);
					if (!condition){
						if (this.type==/*laya.webgl.utils.ShaderCompile.IFDEF_YES*/1){
							this.type=/*laya.webgl.utils.ShaderCompile.IFDEF_NO*/0;
						}
						return;
					};
					var newcondition="";
					var preIsParam=false,isParam=false;
					for (var i=0,n=condition.length;i < n;i++){
						var c=condition.charAt(i);
						isParam="!&|() \t".indexOf(c)< 0;
						if (preIsParam !=isParam){
							isParam && (newcondition+="this.");
							preIsParam=isParam;
						}
						newcondition+=c;
					}
					this.condition=RunDriver.createShaderCondition(newcondition);
				}
				__class(ShaderScriptBlock,'');
				var __proto=ShaderScriptBlock.prototype;
				__proto.toscript=function(def,out){
					if (this.type===/*laya.webgl.utils.ShaderCompile.IFDEF_NO*/0){
						this.text && out.push(this.text);
					}
					if (this.childs.length < 1 && !this.text)return out;
					if (this.type!==/*laya.webgl.utils.ShaderCompile.IFDEF_NO*/0){
						var ifdef=!!this.condition.call(def);
						this.type===/*laya.webgl.utils.ShaderCompile.IFDEF_ELSE*/2 && (ifdef=!ifdef);
						if (!ifdef)return out;
						this.text && out.push(this.text);
					}
					this.childs.length > 0 && this.childs.forEach(function(o,index,arr){
						o.toscript(def,out)
					});
					return out;
				}
				return ShaderScriptBlock;
			})()
		}

		return ShaderCompile3D;
	})()


	/**
	*@private
	*<code>Shader3D</code> 主要用数组的方式保存shader变量定义，后期合并ShaderValue不使用for in，性能较高。
	*/
	//class laya.d3.shader.ValusArray
	var ValusArray=(function(){
		function ValusArray(){
			this._data=null;
			this._data=[];
		}

		__class(ValusArray,'laya.d3.shader.ValusArray');
		var __proto=ValusArray.prototype;
		__proto.setValue=function(name,value){
			this._data[name]=value;
		}

		__getset(0,__proto,'data',function(){
			return this._data;
		});

		return ValusArray;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.shadowMap.ParallelSplitShadowMap
	var ParallelSplitShadowMap=(function(){
		function ParallelSplitShadowMap(){
			//this.lastNearPlane=NaN;
			//this.lastFieldOfView=NaN;
			//this.lastAspectRatio=NaN;
			this._currentPSSM=-1;
			this._numberOfPSSM=3;
			this._maxDistance=200.0;
			this._ratioOfDistance=1.0 / this._numberOfPSSM;
			this._statesDirty=true;
			this._lightCulling=null;
			this._renderTarget=null;
			this._lightVPMatrix=null;
			this._lightCameras=null;
			this._shadowQuenes=null;
			this._shadowMapTextureSize=1024;
			this._scene=null;
			this._PCFType=0;
			this._shaderValueLightVP=null;
			this._shaderValueVPs=null;
			this._spiltDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
			this._globalParallelLightDir=new Vector3(0,-1,0);
			this._boundingSphere=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
			this._boundingBox=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
			this._frustumPos=new Array((/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1)*4);
			this._uniformDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
			this._logDistance=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
			this._dimension=new Array(/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3+1);
			this._tempLookAt3=new Vector3();
			this._tempLookAt4=new Vector4();
			this._tempValue=new Vector4();
			this._tempPos=new Vector3();
			this._tempLightUp=new Vector3();
			this._tempMin=new Vector4();
			this._tempMax=new Vector4();
			this._tempMatrix44=new Matrix4x4;
			this._splitFrustumCulling=new BoundFrustum(Matrix4x4.DEFAULT);
			this._tempScaleMatrix44=new Matrix4x4;
			this._shadowPCFOffset=new Vector2(1.0 / 1024.0,1.0 / 1024.0);
			this._shaderValueDistance=new Vector4();
			var i=0;
			for (i=0;i < this._spiltDistance.length;i++){
				this._spiltDistance[i]=0.0;
			}
			for (i=0;i < this._dimension.length;i++){
				this._dimension[i]=new Vector2();
			}
			for (i=0;i < this._frustumPos.length;i++){
				this._frustumPos[i]=new Vector3();
			}
			for (i=0;i < this._boundingBox.length;i++){
				this._boundingBox[i]=new BoundBox(new Vector3(),new Vector3());
			}
			for (i=0;i < this._boundingSphere.length;i++){
				this._boundingSphere[i]=new BoundSphere(new Vector3(),0.0);
			}
			Matrix4x4.createScaling(new Vector3(0.5,0.5,1.0),this._tempScaleMatrix44);
			this._tempScaleMatrix44.elements[12]=0.5;
			this._tempScaleMatrix44.elements[13]=0.5;
		}

		__class(ParallelSplitShadowMap,'laya.d3.shadowMap.ParallelSplitShadowMap');
		var __proto=ParallelSplitShadowMap.prototype;
		__proto.setInfo=function(scene,maxDistance,globalParallelDir,shadowMapTextureSize,numberOfPSSM,PCFType){
			if (numberOfPSSM > /*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3){
				this._numberOfPSSM=/*CLASS CONST:laya.d3.shadowMap.ParallelSplitShadowMap.MAX_PSSM_COUNT*/3;
			}
			this._scene=scene;
			this._maxDistance=maxDistance;
			this.PSSMNum=numberOfPSSM;
			this._globalParallelLightDir=globalParallelDir;
			this._ratioOfDistance=1.0 / this._numberOfPSSM;
			for (var i=0;i < this._spiltDistance.length;i++){
				this._spiltDistance[i]=0.0;
			}
			this._shadowMapTextureSize=shadowMapTextureSize;
			this._shadowPCFOffset.x=1.0 / this._shadowMapTextureSize;
			this._shadowPCFOffset.y=1.0 / this._shadowMapTextureSize;
			this.setPCFType(PCFType);
			this._statesDirty=true;
		}

		__proto.setPCFType=function(PCFtype){
			this._PCFType=PCFtype;
			switch (this._PCFType){
				case 0:
					this._scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
					break ;
				case 1:
					this._scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
					break ;
				case 2:
					this._scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
					break ;
				case 3:
					this._scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1);
					this._scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2);
					break ;
				}
		}

		__proto.getPCFType=function(){
			return this._PCFType;
		}

		__proto.setFarDistance=function(value){
			if (this._maxDistance !=value){
				this._maxDistance=value;
				this._statesDirty=true;
			}
		}

		__proto.getFarDistance=function(){
			return this._maxDistance;
		}

		__proto._setGlobalParallelLightDir=function(dir){
			this._globalParallelLightDir=dir;
		}

		__proto.getGlobalParallelLightDir=function(){
			return this._globalParallelLightDir;
		}

		__proto.getCurrentPSSM=function(){
			return this._currentPSSM;
		}

		__proto.getLightCamera=function(index){
			return this._lightCameras[index];
		}

		/**
		*@private
		*/
		__proto._beginSampler=function(index,sceneCamera){
			if (index < 0 || index > this._numberOfPSSM)
				throw new Error("ParallelSplitShadowMap: beginSample invalid index");
			this._currentPSSM=index;
			this._update(sceneCamera);
		}

		/**
		*@private
		*/
		__proto.endSampler=function(sceneCamera){
			this._currentPSSM=-1;
		}

		/**
		*@private
		*/
		__proto._calcAllLightCameraInfo=function(sceneCamera){
			if (this._numberOfPSSM===1){
				this._beginSampler(0,sceneCamera);
				this.endSampler(sceneCamera);
				}else {
				for (var i=0,n=this._numberOfPSSM+1;i < n;i++){
					this._beginSampler(i,sceneCamera);
					this.endSampler(sceneCamera);
				}
			}
		}

		/**
		*@private
		*/
		__proto._recalculate=function(nearPlane,fieldOfView,aspectRatio){
			this._calcSplitDistance(nearPlane);
			this._calcBoundingBox(fieldOfView,aspectRatio);
			this._rebuildRenderInfo();
		}

		/**
		*@private
		*/
		__proto._update=function(sceneCamera){
			var nearPlane=sceneCamera.nearPlane;
			var fieldOfView=sceneCamera.fieldOfView;
			var aspectRatio=(sceneCamera).aspectRatio;
			if (this._statesDirty || this.lastNearPlane!==nearPlane || this.lastFieldOfView!==fieldOfView || this.lastAspectRatio!==aspectRatio){
				this._recalculate(nearPlane,fieldOfView,aspectRatio);
				this._uploadShaderValue();
				this._statesDirty=false;
				this.lastNearPlane=nearPlane;
				this.lastFieldOfView=fieldOfView;
				this.lastAspectRatio=aspectRatio;
			}
			this._calcLightViewProject(sceneCamera);
		}

		/**
		*@private
		*/
		__proto._uploadShaderValue=function(){
			var scene=this._scene;
			switch (this._numberOfPSSM){
				case 1:
					scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
					scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
					scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
					break ;
				case 2:
					scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
					scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
					scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
					break ;
				case 3:
					scene.addShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
					scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
					scene.removeShaderDefine(laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
					break ;
				};
			var sceneSV=scene._shaderValues;
			sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWDISTANCE*/21,this._shaderValueDistance.elements);
			sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWLIGHTVIEWPROJECT*/22,this._shaderValueLightVP);
			sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWMAPPCFOFFSET*/23,this._shadowPCFOffset.elements);
			switch (this._numberOfPSSM){
				case 3:
					sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE1*/24,this.getRenderTarget(1).source);
					sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE2*/25,this.getRenderTarget(2).source);
					sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE3*/26,this.getRenderTarget(3).source);
					break ;
				case 2:
					sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE1*/24,this.getRenderTarget(1).source);
					sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE2*/25,this.getRenderTarget(2).source);
					break ;
				case 1:
					sceneSV.setValue(/*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE1*/24,this.getRenderTarget(1).source);
					break ;
				}
		}

		/**
		*@private
		*/
		__proto._calcSplitDistance=function(nearPlane){
			var far=this._maxDistance;
			var invNumberOfPSSM=1.0 / this._numberOfPSSM;
			var i=0;
			for (i=0;i <=this._numberOfPSSM;i++){
				this._uniformDistance[i]=nearPlane+(far-nearPlane)*i *invNumberOfPSSM;
			};
			var farDivNear=far / nearPlane;
			for (i=0;i <=this._numberOfPSSM;i++){
				var n=Math.pow(farDivNear,i *invNumberOfPSSM);
				this._logDistance[i]=nearPlane *n;
			}
			for (i=0;i <=this._numberOfPSSM;i++){
				this._spiltDistance[i]=this._uniformDistance[i] *this._ratioOfDistance+this._logDistance[i] *(1.0-this._ratioOfDistance);
			}
			this._shaderValueDistance.x=this._spiltDistance[1];
			this._shaderValueDistance.y=this._spiltDistance[2];
			this._shaderValueDistance.z=this._spiltDistance[3];
			this._shaderValueDistance.w=this._spiltDistance[4];
		}

		/**
		*@private
		*/
		__proto._calcBoundingBox=function(fieldOfView,aspectRatio){
			var fov=3.1415926 *fieldOfView / 180.0;
			var halfTanValue=Math.tan(fov / 2.0);
			var height=NaN;
			var width=NaN;
			var distance=NaN;
			var i=0;
			for (i=0;i <=this._numberOfPSSM;i++){
				distance=this._spiltDistance[i];
				height=distance *halfTanValue;
				width=height *aspectRatio;
				var temp=this._frustumPos[i *4+0].elements;
				temp[0]=-width;
				temp[1]=-height;
				temp[2]=-distance;
				temp=this._frustumPos[i *4+1].elements;
				temp[0]=width;
				temp[1]=-height;
				temp[2]=-distance;
				temp=this._frustumPos[i *4+2].elements;
				temp[0]=-width;
				temp[1]=height;
				temp[2]=-distance;
				temp=this._frustumPos[i *4+3].elements;
				temp[0]=width;
				temp[1]=height;
				temp[2]=-distance;
				temp=this._dimension[i].elements;
				temp[0]=width;
				temp[1]=height;
			};
			var d;
			var min;
			var max;
			var center;
			for (i=1;i <=this._numberOfPSSM;i++){
				d=this._dimension[i].elements;
				min=this._boundingBox[i].min.elements;
				min[0]=-d[0];
				min[1]=-d[1];
				min[2]=-this._spiltDistance[i];
				max=this._boundingBox[i].max.elements;
				max[0]=d[0];
				max[1]=d[1];
				max[2]=-this._spiltDistance[i-1];
				center=this._boundingSphere[i].center.elements;
				center[0]=(min[0]+max[0])*0.5;
				center[1]=(min[1]+max[1])*0.5;
				center[2]=(min[2]+max[2])*0.5;
				this._boundingSphere[i].radius=Math.sqrt(Math.pow(max[0]-min[0],2)+Math.pow(max[1]-min[1],2)+Math.pow(max[2]-min[2],2))*0.5;
			}
			min=this._boundingBox[0].min.elements;
			d=this._dimension[this._numberOfPSSM].elements;
			min[0]=-d[0];
			min[1]=-d[1];
			min[2]=-this._spiltDistance[this._numberOfPSSM];
			max=this._boundingBox[0].max.elements;
			max[0]=d[0];
			max[1]=d[1];
			max[2]=-this._spiltDistance[0];
			center=this._boundingSphere[0].center.elements;
			center[0]=(min[0]+max[0])*0.5;
			center[1]=(min[1]+max[1])*0.5;
			center[2]=(min[2]+max[2])*0.5;
			this._boundingSphere[0].radius=Math.sqrt(Math.pow(max[0]-min[0],2)+Math.pow(max[1]-min[1],2)+Math.pow(max[2]-min[2],2))*0.5;
		}

		__proto.calcSplitFrustum=function(sceneCamera){
			if (this._currentPSSM > 0){
				Matrix4x4.createPerspective(3.1416 *sceneCamera.fieldOfView / 180.0,(sceneCamera).aspectRatio,this._spiltDistance[this._currentPSSM-1],this._spiltDistance[this._currentPSSM],this._tempMatrix44);
				}else {
				Matrix4x4.createPerspective(3.1416 *sceneCamera.fieldOfView / 180.0,(sceneCamera).aspectRatio,this._spiltDistance[0],this._spiltDistance[this._numberOfPSSM],this._tempMatrix44);
			}
			Matrix4x4.multiply(this._tempMatrix44,(sceneCamera).viewMatrix,this._tempMatrix44);
			this._splitFrustumCulling.matrix=this._tempMatrix44;
		}

		/**
		*@private
		*/
		__proto._rebuildRenderInfo=function(){
			var nNum=this._numberOfPSSM+1;
			var i=0;
			if (this._renderTarget==null){
				this._renderTarget=__newvec(nNum);
				this._renderTarget[0]=null;
				for (i=1;i < nNum;i++){
					this._renderTarget[i]=new RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5,false,false,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600);
				}
				}else if (this._renderTarget.length !=nNum){
				this.disposeAllRenderTarget();
				this._renderTarget.length=nNum;
				this._renderTarget[0]=null;
				for (i=1;i < nNum;i++){
					this._renderTarget[i]=new RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5,false,false,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600);
				}
				}else {
				for (i=1;i < nNum;i++){
					if (this._renderTarget[i]==null || this._renderTarget[i].width !=this._shadowMapTextureSize || this._renderTarget[i].height !=this._shadowMapTextureSize){
						if (this._renderTarget[i] !=null){
							this._renderTarget[i].dispose();
						}
						this._renderTarget[i]=new RenderTexture(this._shadowMapTextureSize,this._shadowMapTextureSize,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5,false,false,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600);
					}
				}
			}
			if (this._lightCulling==null || this._lightCulling.length !=nNum){
				if (this._lightCulling){
					this._lightCulling.length=nNum;
					}else {
					this._lightCulling=__newvec(nNum);
				}
				for (i=0;i < this._lightCulling.length;i++){
					this._lightCulling[i]=new BoundFrustum(Matrix4x4.DEFAULT);
				}
			}
			if (this._lightVPMatrix==null || this._lightVPMatrix.length !=nNum){
				if (this._lightVPMatrix){
					this._lightVPMatrix.length=nNum;
					}else {
					this._lightVPMatrix=__newvec(nNum);
				}
				for (i=0;i < this._lightVPMatrix.length;i++){
					this._lightVPMatrix[i]=new Matrix4x4();
				}
			}
			if (this._lightCameras==null || this._lightCameras.length !=nNum){
				if (this._lightCameras){
					this._lightCameras.length=nNum;
					}else {
					this._lightCameras=__newvec(nNum);
				}
				for (i=0;i < this._lightCameras.length;i++){
					this._lightCameras[i]=new Camera();
					this._lightCameras[i].name="lightCamera"+i;
				}
			}
			if (this._shadowQuenes==null || this._shadowQuenes.length !=this._numberOfPSSM){
				if (this._shadowQuenes){
					this._shadowQuenes.length=this._numberOfPSSM;
					}else {
					this._shadowQuenes=__newvec(this._numberOfPSSM);
				}
				for (i=0;i < this._shadowQuenes.length;i++){
					this._shadowQuenes[i]=new RenderQueue(this._scene);
				}
			}
			if (this._shaderValueVPs==null || this._shaderValueVPs.length !=nNum){
				if (this._shaderValueVPs){
					this._shaderValueVPs.length=nNum;
					}else {
					this._shaderValueVPs=__newvec(nNum);
				}
				this._shaderValueLightVP=new Float32Array(nNum *16);
				for (i=0;i < nNum;i++){
					this._shaderValueVPs[i]=new Float32Array(this._shaderValueLightVP.buffer,i *64);
				}
			}
		}

		/**
		*@private
		*/
		__proto._calcLightViewProject=function(sceneCamera){
			var boundSphere=this._boundingSphere[this._currentPSSM];
			var cameraMatViewInv=sceneCamera.transform.worldMatrix;
			var radius=boundSphere.radius;
			boundSphere.center.cloneTo(this._tempLookAt3);
			Vector3.transformV3ToV4(this._tempLookAt3,cameraMatViewInv,this._tempLookAt4);
			var lookAt3Element=this._tempLookAt3.elements;
			var lookAt4Element=this._tempLookAt4.elements;
			lookAt3Element[0]=lookAt4Element[0];
			lookAt3Element[1]=lookAt4Element[1];
			lookAt3Element[2]=lookAt4Element[2];
			var lightUpElement=this._tempLightUp.elements;
			var sceneCameraDir=sceneCamera.forward.elements;
			lightUpElement[0]=sceneCameraDir[0];
			lightUpElement[1]=1.0;
			lightUpElement[2]=sceneCameraDir[2];
			Vector3.normalize(this._tempLightUp,this._tempLightUp);
			Vector3.scale(this._globalParallelLightDir,boundSphere.radius *4,this._tempPos);
			Vector3.subtract(this._tempLookAt3,this._tempPos,this._tempPos);
			var curLightCamera=this._lightCameras[this._currentPSSM];
			curLightCamera.transform.position=this._tempPos;
			curLightCamera.transform.lookAt(this._tempLookAt3,this._tempLightUp,false);
			var tempMaxElements=this._tempMax.elements;
			var tempMinElements=this._tempMin.elements;
			tempMaxElements[0]=tempMaxElements[1]=tempMaxElements[2]=-100000.0;
			tempMaxElements[3]=1.0;
			tempMinElements[0]=tempMinElements[1]=tempMinElements[2]=100000.0;
			tempMinElements[3]=1.0;
			Matrix4x4.multiply(curLightCamera.viewMatrix,cameraMatViewInv,this._tempMatrix44);
			var tempValueElement=this._tempValue.elements;
			var corners=__newvec(8,null);
			this._boundingBox[this._currentPSSM].getCorners(corners);
			for (var i=0;i < 8;i++){
				var frustumPosElements=corners[i].elements;
				tempValueElement[0]=frustumPosElements[0];
				tempValueElement[1]=frustumPosElements[1];
				tempValueElement[2]=frustumPosElements[2];
				tempValueElement[3]=1.0;
				Vector4.transformByM4x4(this._tempValue,this._tempMatrix44,this._tempValue);
				tempMinElements[0]=(tempValueElement[0] < tempMinElements[0])? tempValueElement[0] :tempMinElements[0];
				tempMinElements[1]=(tempValueElement[1] < tempMinElements[1])? tempValueElement[1] :tempMinElements[1];
				tempMinElements[2]=(tempValueElement[2] < tempMinElements[2])? tempValueElement[2] :tempMinElements[2];
				tempMaxElements[0]=(tempValueElement[0] > tempMaxElements[0])? tempValueElement[0] :tempMaxElements[0];
				tempMaxElements[1]=(tempValueElement[1] > tempMaxElements[1])? tempValueElement[1] :tempMaxElements[1];
				tempMaxElements[2]=(tempValueElement[2] > tempMaxElements[2])? tempValueElement[2] :tempMaxElements[2];
			}
			Vector4.add(this._tempMax,this._tempMin,this._tempValue);
			tempValueElement[0] *=0.5;
			tempValueElement[1] *=0.5;
			tempValueElement[2] *=0.5;
			tempValueElement[3]=1;
			Vector4.transformByM4x4(this._tempValue,curLightCamera.transform.worldMatrix,this._tempValue);
			var distance=Math.abs(-this._tempMax.z);
			var farPlane=distance > this._maxDistance ? distance :this._maxDistance;
			Vector3.scale(this._globalParallelLightDir,farPlane,this._tempPos);
			var tempPosElement=this._tempPos.elements;
			tempPosElement[0]=tempValueElement[0]-tempPosElement[0];
			tempPosElement[1]=tempValueElement[1]-tempPosElement[1];
			tempPosElement[2]=tempValueElement[2]-tempPosElement[2];
			curLightCamera.transform.position=this._tempPos;
			curLightCamera.transform.lookAt(this._tempLookAt3,this._tempLightUp,false);
			Matrix4x4.createOrthogonal(tempMinElements[0],tempMaxElements[0],tempMinElements[1],tempMaxElements[1],1.0,farPlane+0.5 *(tempMaxElements[2]-tempMinElements[2]),curLightCamera.projectionMatrix);
			curLightCamera.projectionViewMatrix.cloneTo(this._lightVPMatrix[this._currentPSSM]);
			this._lightCulling[this._currentPSSM].matrix=this._lightVPMatrix[this._currentPSSM];
			ParallelSplitShadowMap.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44,this._lightVPMatrix[this._currentPSSM],this._shaderValueVPs[this._currentPSSM]);
		}

		__proto.getLightFrustumCulling=function(currentPSSM){
			return this._lightCulling[currentPSSM];
		}

		__proto.getSplitFrustumCulling=function(){
			return this._splitFrustumCulling;
		}

		__proto.getSplitDistance=function(index){
			return this._spiltDistance[index];
		}

		__proto.setShadowMapTextureSize=function(size){
			if (size!==this._shadowMapTextureSize){
				this._shadowMapTextureSize=size;
				this._shadowPCFOffset.x=1 / this._shadowMapTextureSize;
				this._shadowPCFOffset.y=1 / this._shadowMapTextureSize;
				this._statesDirty=true;
			}
		}

		__proto.getShadowMapTextureSize=function(){
			return this._shadowMapTextureSize;
		}

		__proto.beginRenderTarget=function(index){
			this._renderTarget[index].start();
		}

		__proto.endRenderTarget=function(index){
			this._renderTarget[index].end();
		}

		__proto.getRenderTarget=function(index){
			return this._renderTarget[index];
		}

		__proto.disposeAllRenderTarget=function(){
			for (var i=0,n=this._numberOfPSSM+1;i < n;i++){
				if (this._renderTarget[i]){
					this._renderTarget[i].dispose();
					this._renderTarget[i]=null;
				}
			}
		}

		__getset(0,__proto,'PSSMNum',function(){
			return this._numberOfPSSM;
			},function(value){
			value=value > 0 ? value :1;
			value=value <=3 ? value :3;
			if (this._numberOfPSSM !=value){
				this._numberOfPSSM=value;
				this._ratioOfDistance=1.0 / this._numberOfPSSM;
				this._statesDirty=true;
			}
		});

		ParallelSplitShadowMap.multiplyMatrixOutFloat32Array=function(left,right,out){
			var i,a,b,ai0,ai1,ai2,ai3;
			a=left.elements;
			b=right.elements;
			for (i=0;i < 4;i++){
				ai0=a[i];
				ai1=a[i+4];
				ai2=a[i+8];
				ai3=a[i+12];
				out[i]=ai0 *b[0]+ai1 *b[1]+ai2 *b[2]+ai3 *b[3];
				out[i+4]=ai0 *b[4]+ai1 *b[5]+ai2 *b[6]+ai3 *b[7];
				out[i+8]=ai0 *b[8]+ai1 *b[9]+ai2 *b[10]+ai3 *b[11];
				out[i+12]=ai0 *b[12]+ai1 *b[13]+ai2 *b[14]+ai3 *b[15];
			}
		}

		ParallelSplitShadowMap.SHADERDEFINE_RECEIVE_SHADOW=0x1;
		ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW=0x200;
		ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1=0x400;
		ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2=0x800;
		ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3=0x1000;
		ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF_NO=0x2000;
		ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF1=0x4000;
		ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF2=0x8000;
		ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PCF3=0x10000;
		ParallelSplitShadowMap.MAX_PSSM_COUNT=3;
		return ParallelSplitShadowMap;
	})()


	/**
	*<code>TerrainLeaf</code> Terrain的叶子节点
	*/
	//class laya.d3.terrain.TerrainLeaf
	var TerrainLeaf=(function(){
		function TerrainLeaf(){
			this._boundingSphere=null;
			this._boundingBox=null;
			this._sizeOfY=null;
			this._currentLODLevel=0;
			this._lastDistanceToEye=NaN;
			this._originalBoundingSphere=null;
			this._originalBoundingBox=null;
			this._originalBoundingBoxCorners=null;
			this._bUseStrip=false;
			this._gridSize=NaN;
			this._beginGridX=0;
			this._beginGridZ=0;
			this._LODError=null;
			TerrainLeaf.__init__();
			this._currentLODLevel=0;
		}

		__class(TerrainLeaf,'laya.d3.terrain.TerrainLeaf');
		var __proto=TerrainLeaf.prototype;
		__proto.calcVertextNorml=function(x,z,terrainHeightData,heighDataWidth,heightDataHeight,normal){
			var dZ=0,dX=0;
			dX=TerrainLeaf.getHeightFromTerrainHeightData (x-1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData (x-1,z ,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData (x-1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData (x+1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData (x+1,z ,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dX+=TerrainLeaf.getHeightFromTerrainHeightData (x+1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dZ=TerrainLeaf.getHeightFromTerrainHeightData (x-1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData (x ,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData (x+1,z-1,terrainHeightData,heighDataWidth,heightDataHeight)*-1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData (x-1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData (x ,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			dZ+=TerrainLeaf.getHeightFromTerrainHeightData (x+1,z+1,terrainHeightData,heighDataWidth,heightDataHeight)*1.0;
			normal.x=-dX;
			normal.y=6;
			normal.z=-dZ;
			Vector3.normalize(normal,normal);
		}

		__proto.calcVertextNormlUV=function(x,z,terrainWidth,terrainHeight,normal){
			normal.x=x/terrainWidth;
			normal.y=z/terrainHeight;
			normal.z=z/terrainHeight;
		}

		__proto.calcVertextBuffer=function(offsetChunkX,offsetChunkZ,beginX,beginZ,girdSize,vertextBuffer,offset,strideSize,terrainHeightData,heighDataWidth,heightDataHeight){
			this._gridSize=girdSize;
			this._beginGridX=offsetChunkX *TerrainLeaf.CHUNK_GRID_NUM+beginX;
			this._beginGridZ=offsetChunkZ *TerrainLeaf.CHUNK_GRID_NUM+beginZ;
			var nNum=offset *strideSize;
			var x=NaN,y=NaN,z=NaN;
			var minY=2147483647;
			var maxY=-2147483648;
			var normal=new Vector3();
			for(var i=0,s=TerrainLeaf.LEAF_GRID_NUM+1;i < s;i++){
				for(var j=0,s1=TerrainLeaf.LEAF_GRID_NUM+1;j < s1;j++){
					x=(this._beginGridX+j)*this._gridSize;
					z=(this._beginGridZ+i)*this._gridSize;
					y=terrainHeightData[ (this._beginGridZ+i)*(heighDataWidth)+(this._beginGridX+j)];
					minY=y < minY ? y :minY;
					maxY=y > maxY ? y :maxY;
					vertextBuffer[nNum]=x;nNum++;vertextBuffer[nNum]=y;nNum++;vertextBuffer[nNum]=z;nNum++;
					this.calcVertextNormlUV(this._beginGridX+j,this._beginGridZ+i,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;nNum++;vertextBuffer[nNum]=normal.y;nNum++;vertextBuffer[nNum]=normal.z;nNum++;
					vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;vertextBuffer[nNum]=(beginZ+i)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;
					vertextBuffer[nNum]=this._beginGridX+j;nNum++;vertextBuffer[nNum]=this._beginGridZ+i;nNum++;
				}
			}
			this._sizeOfY=new Vector2(minY-1,maxY+1);
			this.calcLODErrors(terrainHeightData,heighDataWidth,heightDataHeight);
			this.calcOriginalBoudingBoxAndSphere();
		}

		__proto.calcSkirtVertextBuffer=function(offsetChunkX,offsetChunkZ,beginX,beginZ,girdSize,vertextBuffer,offset,strideSize,terrainHeightData,heighDataWidth,heightDataHeight){
			this._gridSize=girdSize;
			this._beginGridX=offsetChunkX *TerrainLeaf.CHUNK_GRID_NUM+beginX;
			this._beginGridZ=offsetChunkZ *TerrainLeaf.CHUNK_GRID_NUM+beginZ;
			var nNum=offset *strideSize;
			var i=0,j=0,s=TerrainLeaf.LEAF_GRID_NUM+1;
			var x=NaN,y=NaN,z=NaN;
			var normal=new Vector3();
			var hZIndex=0;
			var hXIndex=0;
			var h=0;
			var zh=0;
			var xh=0;
			for (i=0;i < 2;i++){
				for (j=0;j < s;j++){
					x=(this._beginGridX+j)*this._gridSize;
					y=(i==1 ? terrainHeightData[ this._beginGridZ *heighDataWidth+(this._beginGridX+j)] :-this._gridSize);
					z=(this._beginGridZ+0)*this._gridSize;
					vertextBuffer[nNum]=x;nNum++;vertextBuffer[nNum]=y;nNum++;vertextBuffer[nNum]=z;nNum++;
					if (i==0){
						hZIndex=(this._beginGridZ-1);
					}
					else{
						hZIndex=this._beginGridZ;
					}
					this.calcVertextNormlUV(this._beginGridX+j,hZIndex,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;nNum++;vertextBuffer[nNum]=normal.y;nNum++;vertextBuffer[nNum]=normal.z;nNum++;
					vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;vertextBuffer[nNum]=(beginZ+0)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;
					vertextBuffer[nNum]=this._beginGridX+j;nNum++;vertextBuffer[nNum]=hZIndex;nNum++;
				}
			}
			for (i=0;i < 2;i++){
				for (j=0;j < s;j++){
					x=(this._beginGridX+j)*this._gridSize;
					y=(i==0 ? terrainHeightData[ (this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*(heighDataWidth)+(this._beginGridX+j)] :-this._gridSize);
					z=(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize;
					vertextBuffer[nNum]=x;nNum++;vertextBuffer[nNum]=y;nNum++;vertextBuffer[nNum]=z;nNum++;
					if (i==0){
						hZIndex=this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM;
					}
					else{
						hZIndex=(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM+1);
					}
					this.calcVertextNormlUV(this._beginGridX+j,hZIndex,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;nNum++;vertextBuffer[nNum]=normal.y;nNum++;vertextBuffer[nNum]=normal.z;nNum++;
					vertextBuffer[nNum]=(beginX+j)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;vertextBuffer[nNum]=(beginZ+TerrainLeaf.LEAF_GRID_NUM)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;
					vertextBuffer[nNum]=this._beginGridX+j;nNum++;vertextBuffer[nNum]=hZIndex;nNum++;
				}
			}
			for (i=0;i < 2;i++){
				for (j=0;j < s;j++){
					x=(this._beginGridX+0)*this._gridSize;
					y=(i==0 ? terrainHeightData[ (this._beginGridZ+j)*(heighDataWidth)+(this._beginGridX+0)] :-this._gridSize);
					z=(this._beginGridZ+j)*this._gridSize;
					vertextBuffer[nNum]=x;nNum++;vertextBuffer[nNum]=y;nNum++;vertextBuffer[nNum]=z;nNum++;
					if (i==0){
						hXIndex=this._beginGridX;
					}
					else{
						hXIndex=(this._beginGridX-1);
					}
					this.calcVertextNormlUV(hXIndex,this._beginGridZ+j,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;nNum++;vertextBuffer[nNum]=normal.y;nNum++;vertextBuffer[nNum]=normal.z;nNum++;
					vertextBuffer[nNum]=(beginX+0)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;vertextBuffer[nNum]=(beginZ+j)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;
					vertextBuffer[nNum]=hXIndex;nNum++;vertextBuffer[nNum]=this._beginGridZ+j;nNum++;
				}
			}
			for (i=0;i < 2;i++){
				for (j=0;j < s;j++){
					x=(this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize;
					y=(i==1 ? terrainHeightData[ (this._beginGridZ+j)*(heighDataWidth)+(this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)] :-this._gridSize);
					z=(this._beginGridZ+j)*this._gridSize;
					vertextBuffer[nNum]=x;nNum++;vertextBuffer[nNum]=y;nNum++;vertextBuffer[nNum]=z;nNum++;
					if (i==0){
						hXIndex=this._beginGridX+TerrainLeaf.LEAF_GRID_NUM+1;
					}
					else{
						hXIndex=this._beginGridX+TerrainLeaf.LEAF_GRID_NUM;
					}
					this.calcVertextNormlUV(hXIndex,this._beginGridZ+j,heighDataWidth,heightDataHeight,normal);
					vertextBuffer[nNum]=normal.x;nNum++;vertextBuffer[nNum]=normal.y;nNum++;vertextBuffer[nNum]=normal.z;nNum++;
					vertextBuffer[nNum]=(beginX+TerrainLeaf.LEAF_GRID_NUM)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;vertextBuffer[nNum]=(beginZ+j)/ TerrainLeaf.CHUNK_GRID_NUM;nNum++;
					vertextBuffer[nNum]=hXIndex;nNum++;vertextBuffer[nNum]=this._beginGridZ+j;nNum++;
				}
			}
		}

		__proto.calcOriginalBoudingBoxAndSphere=function(){
			var min=new Vector3(this._beginGridX *this._gridSize,this._sizeOfY.x,this._beginGridZ *this._gridSize);
			var max=new Vector3((this._beginGridX+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize,this._sizeOfY.y,(this._beginGridZ+TerrainLeaf.LEAF_GRID_NUM)*this._gridSize);
			this._originalBoundingBox=new BoundBox(min,max);
			var size=new Vector3();
			Vector3.subtract(max,min,size);
			Vector3.scale(size,0.5,size);
			var center=new Vector3();
			Vector3.add(min,size,center);
			this._originalBoundingSphere=new BoundSphere(center,Vector3.scalarLength(size));
			this._originalBoundingBoxCorners=__newvec(8,null);
			this._originalBoundingBox.getCorners(this._originalBoundingBoxCorners);
			this._boundingBox=new BoundBox(new Vector3(-0.5,-0.5,-0.5),new Vector3(0.5,0.5,0.5));
			this._boundingSphere=new BoundSphere(new Vector3(0,0,0),1);
		}

		__proto.calcLeafBoudingBox=function(worldMatrix){
			for (var i=0;i < 8;i++){
				Vector3.transformCoordinate(this._originalBoundingBoxCorners[i],worldMatrix,BaseRender._tempBoudingBoxCorners[i]);
			}
			BoundBox.createfromPoints(BaseRender._tempBoudingBoxCorners,this._boundingBox);
		}

		__proto.calcLeafBoudingSphere=function(worldMatrix,maxScale){
			Vector3.transformCoordinate(this._originalBoundingSphere.center,worldMatrix,this._boundingSphere.center);
			this._boundingSphere.radius=this._originalBoundingSphere.radius *maxScale;
		}

		__proto.calcLODErrors=function(terrainHeightData,heighDataWidth,heightDataHeight){
			this._LODError=new Float32Array(TerrainLeaf._maxLODLevel+1);
			var step=1;
			for (var i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
				var maxError=0;
				for (var y=0,n1=TerrainLeaf.LEAF_GRID_NUM;y < n1;y+=step){
					for (var x=0,n2=TerrainLeaf.LEAF_GRID_NUM;x < n2;x+=step){
						var z00=terrainHeightData[ (this._beginGridZ+y)*heighDataWidth+(this._beginGridX+x)];
						var z10=terrainHeightData[ (this._beginGridZ+y)*heighDataWidth+(this._beginGridX+x)+step];
						var z01=terrainHeightData[ (this._beginGridZ+y+step)*heighDataWidth+(this._beginGridX+x)];
						var z11=terrainHeightData[ (this._beginGridZ+y+step)*heighDataWidth+(this._beginGridX+x)+step];
						for (var j=0;j < step;j++){
							var ys=j / step;
							for (var k=0;k < step;k++){
								var xs=k / step;
								var z=terrainHeightData[ (this._beginGridZ+y+j)*heighDataWidth+(this._beginGridX+x)+k];
								var iz=(xs+ys <=1)?
								(z00+(z10-z00)*xs+(z01-z00)*ys):(z11+(z01-z11)*(1-xs)+(z10-z11)*(1-ys));
								var error=Math.abs(iz-z);
								maxError=Math.max(maxError,error);
							}
						}
					}
				}
				step *=2;
				this._LODError[i]=maxError;
			}
		}

		__proto.determineLod=function(eyePos,perspectiveFactor,tolerance,tolerAndPerspectiveChanged){
			var nDistanceToEye=Vector3.distance(eyePos,this._boundingSphere.center);
			var n=TerrainLeaf._maxLODLevel;
			if (!tolerAndPerspectiveChanged){
				if (this._lastDistanceToEye==nDistanceToEye){
					return this._currentLODLevel;
				}
				else if (this._lastDistanceToEye > nDistanceToEye){
					n=this._currentLODLevel;
				}
			}
			for (var i=n;i >=1;i--){
				if (Terrain.LOD_DISTANCE_FACTOR *this._LODError[i] / nDistanceToEye *perspectiveFactor < tolerance){
					this._currentLODLevel=i;
					break ;
				}
			}
			this._lastDistanceToEye=nDistanceToEye;
			return this._currentLODLevel;
		}

		TerrainLeaf.__init__=function(){
			if (!TerrainLeaf._bInit){
				var nLeafNum=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
				TerrainLeaf._planeLODIndex=__newvec(nLeafNum);
				var i=0,j=0,k=0,n=0,n1=0,nOffset=0;
				var nOriginIndexArray=null,nTempIndex=null;
				for (i=0;i < nLeafNum;i++){
					TerrainLeaf._planeLODIndex[i]=new Array(TerrainLeaf._maxLODLevel+1);
				}
				for (i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
					TerrainLeaf._planeLODIndex[0][i]=TerrainLeaf.calcPlaneLODIndex(i);
				}
				for (i=1;i < nLeafNum;i++){
					nOffset=i *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT;
					for (j=0,n1=TerrainLeaf._maxLODLevel+1;j < n1;j++){
						nOriginIndexArray=TerrainLeaf._planeLODIndex[0][j];
						nTempIndex=new Uint16Array(nOriginIndexArray.length);
						for (k=0;k < nOriginIndexArray.length;k++){
							nTempIndex[k]=nOriginIndexArray[k]+nOffset;
						}
						TerrainLeaf._planeLODIndex[i][j]=nTempIndex;
					}
				}
				TerrainLeaf._skirtLODIndex=__newvec(nLeafNum);
				for (i=0;i < nLeafNum;i++){
					TerrainLeaf._skirtLODIndex[i]=new Array(TerrainLeaf._maxLODLevel+1);
				}
				for (i=0,n=TerrainLeaf._maxLODLevel+1;i < n;i++){
					TerrainLeaf._skirtLODIndex[0][i]=TerrainLeaf.calcSkirtLODIndex(i);
				}
				for (i=1;i < nLeafNum;i++){
					nOffset=i *TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;
					for (j=0,n1=TerrainLeaf._maxLODLevel+1;j < n1;j++){
						nOriginIndexArray=TerrainLeaf._skirtLODIndex[0][j];
						nTempIndex=new Uint16Array(nOriginIndexArray.length);
						for (k=0;k < nOriginIndexArray.length;k++){
							nTempIndex[k]=nOriginIndexArray[k]+nOffset;
						}
						TerrainLeaf._skirtLODIndex[i][j]=nTempIndex;
					}
				}
				TerrainLeaf._bInit=true;
			}
		}

		TerrainLeaf.getPlaneLODIndex=function(leafIndex,LODLevel){
			return TerrainLeaf._planeLODIndex[leafIndex][LODLevel];
		}

		TerrainLeaf.getSkirtLODIndex=function(leafIndex,LODLevel){
			return TerrainLeaf._skirtLODIndex[leafIndex][LODLevel];
		}

		TerrainLeaf.calcPlaneLODIndex=function(level){
			if (level > TerrainLeaf._maxLODLevel)level=TerrainLeaf._maxLODLevel;
			var nGridNumAddOne=TerrainLeaf.LEAF_GRID_NUM+1;
			var nNum=0;
			var indexBuffer=null;
			var nLODGridNum=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2,level);
			indexBuffer=new Uint16Array(nLODGridNum *nLODGridNum *6);
			var nGridSpace=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / nLODGridNum;
			for (var i=0;i < TerrainLeaf.LEAF_GRID_NUM;i+=nGridSpace){
				for (var j=0;j < TerrainLeaf.LEAF_GRID_NUM;j+=nGridSpace){
					indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j;nNum++;
					indexBuffer[nNum]=i *nGridNumAddOne+j;nNum++;
					indexBuffer[nNum]=i *nGridNumAddOne+j+nGridSpace;nNum++;
					indexBuffer[nNum]=i *nGridNumAddOne+j+nGridSpace;nNum++;
					indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j+nGridSpace;nNum++;
					indexBuffer[nNum]=(i+nGridSpace)*nGridNumAddOne+j;nNum++;
				}
			}
			return indexBuffer;
		}

		TerrainLeaf.calcSkirtLODIndex=function(level){
			if (level > TerrainLeaf._maxLODLevel)level=TerrainLeaf._maxLODLevel;
			var nSkirtIndexOffset=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT;
			var nGridNumAddOne=TerrainLeaf.LEAF_GRID_NUM+1;
			var nNum=0;
			var indexBuffer=null;
			var nLODGridNum=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2,level);
			indexBuffer=new Uint16Array(nLODGridNum *4 *6);
			var nGridSpace=laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / nLODGridNum;
			for (var j=0;j < 4;j++){
				for (var i=0;i < TerrainLeaf.LEAF_GRID_NUM;i+=nGridSpace){
					indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i;nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+i;nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+i+nGridSpace;nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+i+nGridSpace;nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i+nGridSpace;nNum++;
					indexBuffer[nNum]=nSkirtIndexOffset+nGridNumAddOne+i;nNum++;
				}
				nSkirtIndexOffset+=nGridNumAddOne *2;
			}
			return indexBuffer;
		}

		TerrainLeaf.getHeightFromTerrainHeightData=function(x,z,terrainHeightData,heighDataWidth,heightDataHeight){
			x=x < 0 ? 0 :x;
			x=(x >=heighDataWidth)? heighDataWidth-1 :x;
			z=z < 0 ? 0 :z;
			z=(z >=heightDataHeight)? heightDataHeight-1 :z;
			return terrainHeightData[ z *heighDataWidth+x];
		}

		TerrainLeaf.CHUNK_GRID_NUM=64;
		TerrainLeaf.LEAF_GRID_NUM=32;
		TerrainLeaf._planeLODIndex=null
		TerrainLeaf._skirtLODIndex=null
		TerrainLeaf._bInit=false;
		__static(TerrainLeaf,
		['LEAF_PLANE_VERTEXT_COUNT',function(){return this.LEAF_PLANE_VERTEXT_COUNT=(TerrainLeaf.LEAF_GRID_NUM+1)*(TerrainLeaf.LEAF_GRID_NUM+1);},'LEAF_SKIRT_VERTEXT_COUNT',function(){return this.LEAF_SKIRT_VERTEXT_COUNT=(TerrainLeaf.LEAF_GRID_NUM+1)*2 *4;},'LEAF_VERTEXT_COUNT',function(){return this.LEAF_VERTEXT_COUNT=TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT+TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;},'LEAF_PLANE_MAX_INDEX_COUNT',function(){return this.LEAF_PLANE_MAX_INDEX_COUNT=TerrainLeaf.LEAF_GRID_NUM *TerrainLeaf.LEAF_GRID_NUM *6;},'LEAF_SKIRT_MAX_INDEX_COUNT',function(){return this.LEAF_SKIRT_MAX_INDEX_COUNT=TerrainLeaf.LEAF_GRID_NUM *4 *6;},'LEAF_MAX_INDEX_COUNT',function(){return this.LEAF_MAX_INDEX_COUNT=TerrainLeaf.LEAF_PLANE_MAX_INDEX_COUNT+TerrainLeaf.LEAF_SKIRT_MAX_INDEX_COUNT;},'_maxLODLevel',function(){return this._maxLODLevel=/*__JS__ */Math.log2(TerrainLeaf.LEAF_GRID_NUM);}
		]);
		return TerrainLeaf;
	})()


	/**
	*<code>DetailTextureInfo</code> 类用于描述地形细节纹理。
	*/
	//class laya.d3.terrain.unit.ChunkInfo
	var ChunkInfo=(function(){
		function ChunkInfo(){
			this.alphaMap=null;
			this.detailID=null;
			this.normalMap=null;
			;
		}

		__class(ChunkInfo,'laya.d3.terrain.unit.ChunkInfo');
		return ChunkInfo;
	})()


	/**
	*<code>DetailTextureInfo</code> 类用于描述地形细节纹理。
	*/
	//class laya.d3.terrain.unit.DetailTextureInfo
	var DetailTextureInfo=(function(){
		function DetailTextureInfo(){
			this.diffuseTexture=null;
			this.normalTexture=null;
			this.scale=null;
			this.offset=null;
			;
		}

		__class(DetailTextureInfo,'laya.d3.terrain.unit.DetailTextureInfo');
		return DetailTextureInfo;
	})()


	/**
	*<code>Physics</code> 类用于简单物理检测。
	*/
	//class laya.d3.utils.Physics
	var Physics=(function(){
		function Physics(){}
		__class(Physics,'laya.d3.utils.Physics');
		Physics.rayCast=function(ray,outHitInfo,distance,layer){
			(distance===void 0)&& (distance=Number.MAX_VALUE);
			(layer===void 0)&& (layer=0);
			Physics._outHitAllInfo.length=0;
			var colliders=Layer.getLayerByNumber(layer)._colliders;
			for (var i=0,n=colliders.length;i < n;i++){
				colliders[i].raycast(ray,Physics._outHitInfo,distance);
				if (Physics._outHitInfo.distance!==-1 && Physics._outHitInfo.distance <=distance){
					var outHit=new RaycastHit();
					Physics._outHitInfo.cloneTo(outHit);
					Physics._outHitAllInfo.push(outHit);
				}
			}
			if (Physics._outHitAllInfo.length==0){
				outHitInfo.sprite3D=null;
				outHitInfo.distance=-1;
				return;
			};
			var minDistance=Number.MAX_VALUE;
			var minIndex=0;
			for (var j=0;j < Physics._outHitAllInfo.length;j++){
				if (Physics._outHitAllInfo[j].distance < minDistance){
					minDistance=Physics._outHitAllInfo[j].distance;
					minIndex=j;
				}
			}
			Physics._outHitAllInfo[minIndex].cloneTo(outHitInfo);
		}

		Physics.rayCastAll=function(ray,outHitAllInfo,distance,layer){
			(distance===void 0)&& (distance=Number.MAX_VALUE);
			(layer===void 0)&& (layer=0);
			outHitAllInfo.length=0;
			var colliders=Layer.getLayerByNumber(layer)._colliders;
			for (var i=0,n=colliders.length;i < n;i++){
				Physics._outHitInfo.distance=-1;
				Physics._outHitInfo.sprite3D=null;
				colliders[i].raycast(ray,Physics._outHitInfo,distance);
				if (Physics._outHitInfo.distance!==-1 && Physics._outHitInfo.distance <=distance){
					var outHit=new RaycastHit();
					Physics._outHitInfo.cloneTo(outHit);
					outHitAllInfo.push(outHit);
				}
			}
		}

		Physics._outHitAllInfo=[];
		__static(Physics,
		['_outHitInfo',function(){return this._outHitInfo=new RaycastHit();}
		]);
		return Physics;
	})()


	/**
	*<code>Picker</code> 类用于创建拾取。
	*/
	//class laya.d3.utils.Picker
	var Picker=(function(){
		/**
		*创建一个 <code>Picker</code> 实例。
		*/
		function Picker(){}
		__class(Picker,'laya.d3.utils.Picker');
		Picker.calculateCursorRay=function(point,viewPort,projectionMatrix,viewMatrix,world,out){
			var x=point.elements[0];
			var y=point.elements[1];
			var nearSource=Picker._tempVector30;
			var nerSourceE=nearSource.elements;
			nerSourceE[0]=x;
			nerSourceE[1]=y;
			nerSourceE[2]=viewPort.minDepth;
			var farSource=Picker._tempVector31;
			var farSourceE=farSource.elements;
			farSourceE[0]=x;
			farSourceE[1]=y;
			farSourceE[2]=viewPort.maxDepth;
			var nearPoint=out.origin;
			var farPoint=Picker._tempVector32;
			viewPort.unprojectFromWVP(nearSource,projectionMatrix,viewMatrix,world,nearPoint);
			viewPort.unprojectFromWVP(farSource,projectionMatrix,viewMatrix,world,farPoint);
			var outDire=out.direction.elements;
			outDire[0]=farPoint.x-nearPoint.x;
			outDire[1]=farPoint.y-nearPoint.y;
			outDire[2]=farPoint.z-nearPoint.z;
			Vector3.normalize(out.direction,out.direction);
		}

		Picker.rayIntersectsPositionsAndIndices=function(ray,vertexDatas,vertexDeclaration,indices,outHitInfo){
			var vertexStrideFloatCount=vertexDeclaration.vertexStride / 4;
			var positionVertexElementOffset=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.POSITION0*/0).offset / 4;
			var closestIntersection=Number.MAX_VALUE;
			var closestTriangleVertexIndex1=-1;
			var closestTriangleVertexIndex2=-1;
			var closestTriangleVertexIndex3=-1;
			for (var j=0;j < indices.length;j+=3){
				var vertex1=Picker._tempVector35;
				var vertex1E=vertex1.elements;
				var vertex1Index=indices[j] *vertexStrideFloatCount;
				var vertex1PositionIndex=vertex1Index+positionVertexElementOffset;
				vertex1E[0]=vertexDatas[vertex1PositionIndex];
				vertex1E[1]=vertexDatas[vertex1PositionIndex+1];
				vertex1E[2]=vertexDatas[vertex1PositionIndex+2];
				var vertex2=Picker._tempVector36;
				var vertex2E=vertex2.elements;
				var vertex2Index=indices[j+1] *vertexStrideFloatCount;
				var vertex2PositionIndex=vertex2Index+positionVertexElementOffset;
				vertex2E[0]=vertexDatas[vertex2PositionIndex];
				vertex2E[1]=vertexDatas[vertex2PositionIndex+1];
				vertex2E[2]=vertexDatas[vertex2PositionIndex+2];
				var vertex3=Picker._tempVector37;
				var vertex3E=vertex3.elements;
				var vertex3Index=indices[j+2] *vertexStrideFloatCount;
				var vertex3PositionIndex=vertex3Index+positionVertexElementOffset;
				vertex3E[0]=vertexDatas[vertex3PositionIndex];
				vertex3E[1]=vertexDatas[vertex3PositionIndex+1];
				vertex3E[2]=vertexDatas[vertex3PositionIndex+2];
				var intersection=laya.d3.utils.Picker.rayIntersectsTriangle(ray,vertex1,vertex2,vertex3);
				if (!isNaN(intersection)&& intersection < closestIntersection){
					closestIntersection=intersection;
					closestTriangleVertexIndex1=vertex1Index;
					closestTriangleVertexIndex2=vertex2Index;
					closestTriangleVertexIndex3=vertex3Index;
				}
			}
			if (closestIntersection!==Number.MAX_VALUE){
				outHitInfo.distance=closestIntersection;
				Vector3.scale(ray.direction,closestIntersection,outHitInfo.position);
				Vector3.add(ray.origin,outHitInfo.position,outHitInfo.position);
				var trianglePositions=outHitInfo.trianglePositions;
				var position0=trianglePositions[0];
				var position1=trianglePositions[1];
				var position2=trianglePositions[2];
				var position0E=position0.elements;
				var position1E=position1.elements;
				var position2E=position2.elements;
				var closestVertex1PositionIndex=closestTriangleVertexIndex1+positionVertexElementOffset;
				position0E[0]=vertexDatas[closestVertex1PositionIndex];
				position0E[1]=vertexDatas[closestVertex1PositionIndex+1];
				position0E[2]=vertexDatas[closestVertex1PositionIndex+2];
				var closestVertex2PositionIndex=closestTriangleVertexIndex2+positionVertexElementOffset;
				position1E[0]=vertexDatas[closestVertex2PositionIndex];
				position1E[1]=vertexDatas[closestVertex2PositionIndex+1];
				position1E[2]=vertexDatas[closestVertex2PositionIndex+2];
				var closestVertex3PositionIndex=closestTriangleVertexIndex3+positionVertexElementOffset;
				position2E[0]=vertexDatas[closestVertex3PositionIndex];
				position2E[1]=vertexDatas[closestVertex3PositionIndex+1];
				position2E[2]=vertexDatas[closestVertex3PositionIndex+2];
				var normalVertexElement=vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3);
				if (normalVertexElement){
					var normalVertexElementOffset=normalVertexElement.offset / 4;
					var triangleNormals=outHitInfo.triangleNormals;
					var normal0=triangleNormals[0];
					var normal1=triangleNormals[1];
					var normal2=triangleNormals[2];
					var normal0E=normal0.elements;
					var normal1E=normal1.elements;
					var normal2E=normal2.elements;
					var closestVertex1NormalIndex=closestTriangleVertexIndex1+normalVertexElementOffset;
					normal0E[0]=vertexDatas[closestVertex1NormalIndex];
					normal0E[1]=vertexDatas[closestVertex1NormalIndex+1];
					normal0E[2]=vertexDatas[closestVertex1NormalIndex+2];
					var closestVertex2NormalIndex=closestTriangleVertexIndex2+normalVertexElementOffset;
					normal1E[0]=vertexDatas[closestVertex2NormalIndex];
					normal1E[1]=vertexDatas[closestVertex2NormalIndex+1];
					normal1E[2]=vertexDatas[closestVertex2NormalIndex+2];
					var closestVertex3NormalIndex=closestTriangleVertexIndex3+normalVertexElementOffset;
					normal2E[0]=vertexDatas[closestVertex3NormalIndex];
					normal2E[1]=vertexDatas[closestVertex3NormalIndex+1];
					normal2E[2]=vertexDatas[closestVertex3NormalIndex+2];
				}
				return true;
				}else {
				outHitInfo.position.toDefault();
				outHitInfo.distance=Number.MAX_VALUE;
				outHitInfo.trianglePositions[0].toDefault();
				outHitInfo.trianglePositions[1].toDefault();
				outHitInfo.trianglePositions[2].toDefault();
				outHitInfo.triangleNormals[0].toDefault();
				outHitInfo.triangleNormals[1].toDefault();
				outHitInfo.triangleNormals[2].toDefault();
				return false;
			}
		}

		Picker.rayIntersectsTriangle=function(ray,vertex1,vertex2,vertex3){
			var result;
			var edge1=Picker._tempVector30,edge2=Picker._tempVector31;
			Vector3.subtract(vertex2,vertex1,edge1);
			Vector3.subtract(vertex3,vertex1,edge2);
			var directionCrossEdge2=Picker._tempVector32;
			Vector3.cross(ray.direction,edge2,directionCrossEdge2);
			var determinant;
			determinant=Vector3.dot(edge1,directionCrossEdge2);
			if (determinant >-Number.MIN_VALUE && determinant < Number.MIN_VALUE){
				result=Number.NaN;
				return result;
			};
			var inverseDeterminant=1.0 / determinant;
			var distanceVector=Picker._tempVector33;
			Vector3.subtract(ray.origin,vertex1,distanceVector);
			var triangleU;
			triangleU=Vector3.dot(distanceVector,directionCrossEdge2);
			triangleU *=inverseDeterminant;
			if (triangleU < 0 || triangleU > 1){
				result=Number.NaN;
				return result;
			};
			var distanceCrossEdge1=Picker._tempVector34;
			Vector3.cross(distanceVector,edge1,distanceCrossEdge1);
			var triangleV;
			triangleV=Vector3.dot(ray.direction,distanceCrossEdge1);
			triangleV *=inverseDeterminant;
			if (triangleV < 0 || triangleU+triangleV > 1){
				result=Number.NaN;
				return result;
			};
			var rayDistance;
			rayDistance=Vector3.dot(edge2,distanceCrossEdge1);
			rayDistance *=inverseDeterminant;
			if (rayDistance < 0){
				result=Number.NaN;
				return result;
			}
			result=rayDistance;
			return result;
		}

		__static(Picker,
		['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempVector34',function(){return this._tempVector34=new Vector3();},'_tempVector35',function(){return this._tempVector35=new Vector3();},'_tempVector36',function(){return this._tempVector36=new Vector3();},'_tempVector37',function(){return this._tempVector37=new Vector3();}
		]);
		return Picker;
	})()


	/**
	*...
	*@author ...
	*/
	//class laya.d3.utils.RaycastHit
	var RaycastHit=(function(){
		function RaycastHit(){
			this.distance=NaN;
			this.trianglePositions=null;
			this.triangleNormals=null;
			this.position=null;
			this.sprite3D=null;
			this.distance=-1;
			this.trianglePositions=[new Vector3(),new Vector3(),new Vector3()];
			this.trianglePositions.length=3;
			this.triangleNormals=[new Vector3(),new Vector3(),new Vector3()];
			this.triangleNormals.length=3;
			this.position=new Vector3();
		}

		__class(RaycastHit,'laya.d3.utils.RaycastHit');
		var __proto=RaycastHit.prototype;
		__proto.cloneTo=function(dec){
			dec.distance=this.distance;
			this.trianglePositions[0].cloneTo(dec.trianglePositions[0]);
			this.trianglePositions[1].cloneTo(dec.trianglePositions[1]);
			this.trianglePositions[2].cloneTo(dec.trianglePositions[2]);
			this.triangleNormals[0].cloneTo(dec.triangleNormals[0]);
			this.triangleNormals[1].cloneTo(dec.triangleNormals[1]);
			this.triangleNormals[2].cloneTo(dec.triangleNormals[2]);
			this.position.cloneTo(dec.position);
			dec.sprite3D=this.sprite3D;
		}

		return RaycastHit;
	})()


	//class laya.d3.utils.Size
	var Size=(function(){
		function Size(width,height){
			this._width=0;
			this._height=0;
			this._width=width;
			this._height=height;
		}

		__class(Size,'laya.d3.utils.Size');
		var __proto=Size.prototype;
		__getset(0,__proto,'width',function(){
			if (this._width===-1)
				return RenderState.clientWidth;
			return this._width;
		});

		__getset(0,__proto,'height',function(){
			if (this._height===-1)
				return RenderState.clientHeight;
			return this._height;
		});

		__getset(1,Size,'fullScreen',function(){
			return new Size(-1,-1);
		});

		return Size;
	})()


	/**
	*<code>Utils3D</code> 类用于创建3D工具。
	*/
	//class laya.d3.utils.Utils3D
	var Utils3D=(function(){
		function Utils3D(){};
		__class(Utils3D,'laya.d3.utils.Utils3D');
		var __proto=Utils3D.prototype;
		/**
		*@private
		*/
		__proto.testTangent=function(renderElement,vertexBuffer,indeBuffer,bufferUsage){
			var vertexDeclaration=vertexBuffer.vertexDeclaration;
			var material=renderElement._material;
			if (material.normalTexture && !vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5)){
				var vertexDatas=vertexBuffer.getData();
				var newVertexDatas=laya.d3.utils.Utils3D.generateTangent(vertexDatas,vertexDeclaration.vertexStride / 4,vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.POSITION0*/0).offset / 4,vertexDeclaration.getVertexElementByUsage(/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2).offset / 4,indeBuffer.getData());
				vertexDeclaration=laya.d3.utils.Utils3D.getVertexTangentDeclaration(vertexDeclaration.getVertexElements());
				var newVB=VertexBuffer3D.create(vertexDeclaration,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
				newVB.setData(newVertexDatas);
				vertexBuffer.dispose();
				bufferUsage[ /*laya.d3.graphics.VertexElementUsage.TANGENT0*/5]=newVB;
				return newVB;
			}
			return vertexBuffer;
		}

		Utils3D._getTexturePath=function(path){
			var extenIndex=path.length-4;
			if (path.indexOf(".dds")==extenIndex || path.indexOf(".tga")==extenIndex || path.indexOf(".exr")==extenIndex || path.indexOf(".DDS")==extenIndex || path.indexOf(".TGA")==extenIndex || path.indexOf(".EXR")==extenIndex)
				path=path.substr(0,extenIndex)+".png";
			return path=URL.formatURL(path);
		}

		Utils3D._rotationTransformScaleSkinAnimation=function(tx,ty,tz,qx,qy,qz,qw,sx,sy,sz,outArray,outOffset){
			var re=Utils3D._tempArray16_0;
			var se=Utils3D._tempArray16_1;
			var tse=Utils3D._tempArray16_2;
			var x2=qx+qx;
			var y2=qy+qy;
			var z2=qz+qz;
			var xx=qx *x2;
			var yx=qy *x2;
			var yy=qy *y2;
			var zx=qz *x2;
			var zy=qz *y2;
			var zz=qz *z2;
			var wx=qw *x2;
			var wy=qw *y2;
			var wz=qw *z2;
			re[15]=1;
			re[0]=1-yy-zz;
			re[1]=yx+wz;
			re[2]=zx-wy;
			re[4]=yx-wz;
			re[5]=1-xx-zz;
			re[6]=zy+wx;
			re[8]=zx+wy;
			re[9]=zy-wx;
			re[10]=1-xx-yy;
			se[15]=1;
			se[0]=sx;
			se[5]=sy;
			se[10]=sz;
			var i,a,b,e,ai0,ai1,ai2,ai3;
			for (i=0;i < 4;i++){
				ai0=re[i];
				ai1=re[i+4];
				ai2=re[i+8];
				ai3=re[i+12];
				tse[i]=ai0;
				tse[i+4]=ai1;
				tse[i+8]=ai2;
				tse[i+12]=ai0 *tx+ai1 *ty+ai2 *tz+ai3;
			}
			for (i=0;i < 4;i++){
				ai0=tse[i];
				ai1=tse[i+4];
				ai2=tse[i+8];
				ai3=tse[i+12];
				outArray[i+outOffset]=ai0 *se[0]+ai1 *se[1]+ai2 *se[2]+ai3 *se[3];
				outArray[i+outOffset+4]=ai0 *se[4]+ai1 *se[5]+ai2 *se[6]+ai3 *se[7];
				outArray[i+outOffset+8]=ai0 *se[8]+ai1 *se[9]+ai2 *se[10]+ai3 *se[11];
				outArray[i+outOffset+12]=ai0 *se[12]+ai1 *se[13]+ai2 *se[14]+ai3 *se[15];
			}
		}

		Utils3D._applyMeshMaterials=function(meshSprite3D,mesh){
			var meshRender=meshSprite3D.meshRender;
			var shaderMaterials=meshRender.sharedMaterials;
			var meshMaterials=mesh.materials;
			for (var i=0,n=meshMaterials.length;i < n;i++)
			(shaderMaterials[i])|| (shaderMaterials[i]=meshMaterials[i]);
			meshRender.sharedMaterials=shaderMaterials;
		}

		Utils3D._loadParticle=function(settting,particle,innerResouMap){
			var anglelToRad=Math.PI / 180.0;
			var i=0,n=0;
			var material;
			var materialPath=settting.materialPath;
			if (materialPath){
				material=Loader.getRes(innerResouMap[materialPath]);
				}else {
				material=new ShurikenParticleMaterial();
				material.diffuseTexture=innerResouMap ? Loader.getRes(innerResouMap[settting.texturePath]):Texture2D.load(settting.texturePath);
			}
			particle.particleRender.sharedMaterial=material;
			var particleSystem=particle.particleSystem;
			particleSystem.isPerformanceMode=settting.isPerformanceMode;
			particleSystem.duration=settting.duration;
			particleSystem.looping=settting.looping;
			particleSystem.prewarm=settting.prewarm;
			particleSystem.startDelayType=settting.startDelayType;
			particleSystem.startDelay=settting.startDelay;
			particleSystem.startDelayMin=settting.startDelayMin;
			particleSystem.startDelayMax=settting.startDelayMax;
			particleSystem.startLifetimeType=settting.startLifetimeType;
			particleSystem.startLifetimeConstant=settting.startLifetimeConstant;
			particleSystem.startLifeTimeGradient=Utils3D._initStartLife(settting.startLifetimeGradient);
			particleSystem.startLifetimeConstantMin=settting.startLifetimeConstantMin;
			particleSystem.startLifetimeConstantMax=settting.startLifetimeConstantMax;
			particleSystem.startLifeTimeGradientMin=Utils3D._initStartLife(settting.startLifetimeGradientMin);
			particleSystem.startLifeTimeGradientMax=Utils3D._initStartLife(settting.startLifetimeGradientMax);
			particleSystem.startSpeedType=settting.startSpeedType;
			particleSystem.startSpeedConstant=settting.startSpeedConstant;
			particleSystem.startSpeedConstantMin=settting.startSpeedConstantMin;
			particleSystem.startSpeedConstantMax=settting.startSpeedConstantMax;
			particleSystem.threeDStartSize=settting.threeDStartSize;
			particleSystem.startSizeType=settting.startSizeType;
			particleSystem.startSizeConstant=settting.startSizeConstant;
			var startSizeConstantSeparateArray=settting.startSizeConstantSeparate;
			var startSizeConstantSeparateElement=particleSystem.startSizeConstantSeparate.elements;
			startSizeConstantSeparateElement[0]=startSizeConstantSeparateArray[0];
			startSizeConstantSeparateElement[1]=startSizeConstantSeparateArray[1];
			startSizeConstantSeparateElement[2]=startSizeConstantSeparateArray[2];
			particleSystem.startSizeConstantMin=settting.startSizeConstantMin;
			particleSystem.startSizeConstantMax=settting.startSizeConstantMax;
			var startSizeConstantMinSeparateArray=settting.startSizeConstantMinSeparate;
			var startSizeConstantMinSeparateElement=particleSystem.startSizeConstantMinSeparate.elements;
			startSizeConstantMinSeparateElement[0]=startSizeConstantMinSeparateArray[0];
			startSizeConstantMinSeparateElement[1]=startSizeConstantMinSeparateArray[1];
			startSizeConstantMinSeparateElement[2]=startSizeConstantMinSeparateArray[2];
			var startSizeConstantMaxSeparateArray=settting.startSizeConstantMaxSeparate;
			var startSizeConstantMaxSeparateElement=particleSystem.startSizeConstantMaxSeparate.elements;
			startSizeConstantMaxSeparateElement[0]=startSizeConstantMaxSeparateArray[0];
			startSizeConstantMaxSeparateElement[1]=startSizeConstantMaxSeparateArray[1];
			startSizeConstantMaxSeparateElement[2]=startSizeConstantMaxSeparateArray[2];
			particleSystem.threeDStartRotation=settting.threeDStartRotation;
			particleSystem.startRotationType=settting.startRotationType;
			particleSystem.startRotationConstant=settting.startRotationConstant *anglelToRad;
			var startRotationConstantSeparateArray=settting.startRotationConstantSeparate;
			var startRotationConstantSeparateElement=particleSystem.startRotationConstantSeparate.elements;
			startRotationConstantSeparateElement[0]=startRotationConstantSeparateArray[0] *anglelToRad;
			startRotationConstantSeparateElement[1]=startRotationConstantSeparateArray[1] *anglelToRad;
			startRotationConstantSeparateElement[2]=startRotationConstantSeparateArray[2] *anglelToRad;
			particleSystem.startRotationConstantMin=settting.startRotationConstantMin *anglelToRad;
			particleSystem.startRotationConstantMax=settting.startRotationConstantMax *anglelToRad;
			var startRotationConstantMinSeparateArray=settting.startRotationConstantMinSeparate;
			var startRotationConstantMinSeparateElement=particleSystem.startRotationConstantMinSeparate.elements;
			startRotationConstantMinSeparateElement[0]=startRotationConstantMinSeparateArray[0] *anglelToRad;
			startRotationConstantMinSeparateElement[1]=startRotationConstantMinSeparateArray[1] *anglelToRad;
			startRotationConstantMinSeparateElement[2]=startRotationConstantMinSeparateArray[2] *anglelToRad;
			var startRotationConstantMaxSeparateArray=settting.startRotationConstantMaxSeparate;
			var startRotationConstantMaxSeparateElement=particleSystem.startRotationConstantMaxSeparate.elements;
			startRotationConstantMaxSeparateElement[0]=startRotationConstantMaxSeparateArray[0] *anglelToRad;
			startRotationConstantMaxSeparateElement[1]=startRotationConstantMaxSeparateArray[1] *anglelToRad;
			startRotationConstantMaxSeparateElement[2]=startRotationConstantMaxSeparateArray[2] *anglelToRad;
			particleSystem.randomizeRotationDirection=settting.randomizeRotationDirection;
			particleSystem.startColorType=settting.startColorType;
			var startColorConstantArray=settting.startColorConstant;
			var startColorConstantElement=particleSystem.startColorConstant.elements;
			startColorConstantElement[0]=startColorConstantArray[0];
			startColorConstantElement[1]=startColorConstantArray[1];
			startColorConstantElement[2]=startColorConstantArray[2];
			startColorConstantElement[3]=startColorConstantArray[3];
			var startColorConstantMinArray=settting.startColorConstantMin;
			var startColorConstantMinElement=particleSystem.startColorConstantMin.elements;
			startColorConstantMinElement[0]=startColorConstantMinArray[0];
			startColorConstantMinElement[1]=startColorConstantMinArray[1];
			startColorConstantMinElement[2]=startColorConstantMinArray[2];
			startColorConstantMinElement[3]=startColorConstantMinArray[3];
			var startColorConstantMaxArray=settting.startColorConstantMax;
			var startColorConstantMaxElement=particleSystem.startColorConstantMax.elements;
			startColorConstantMaxElement[0]=startColorConstantMaxArray[0];
			startColorConstantMaxElement[1]=startColorConstantMaxArray[1];
			startColorConstantMaxElement[2]=startColorConstantMaxArray[2];
			startColorConstantMaxElement[3]=startColorConstantMaxArray[3];
			var gravityArray=settting.gravity;
			var gravityE=particleSystem.gravity.elements;
			gravityE[0]=gravityArray[0];
			gravityE[1]=gravityArray[1];
			gravityE[2]=gravityArray[2];
			particleSystem.gravityModifier=settting.gravityModifier;
			particleSystem.simulationSpace=settting.simulationSpace;
			particleSystem.scaleMode=settting.scaleMode;
			particleSystem.playOnAwake=settting.playOnAwake;
			particleSystem.maxParticles=settting.maxParticles;
			var autoRandomSeed=settting.autoRandomSeed;
			(autoRandomSeed!=null)&& (particleSystem.autoRandomSeed=autoRandomSeed);
			var randomSeed=settting.randomSeed;
			(randomSeed !=null)&& (particleSystem.randomSeed[0]=randomSeed);
			var emissionData=settting.emission;
			var emission=new Emission();
			emission.emissionRate=emissionData.emissionRate;
			var burstsData=emissionData.bursts;
			if (burstsData)
				for (i=0,n=burstsData.length;i < n;i++){
				var brust=burstsData[i];
				emission.addBurst(new Burst(brust.time,brust.min,brust.max));
			}
			emission.enbale=emissionData.enable;
			particleSystem.emission=emission;
			var shapeData=settting.shape;
			var shape;
			switch (shapeData.shapeType){
				case 0:;
					var sphereShape;
					shape=sphereShape=new SphereShape();
					sphereShape.radius=shapeData.sphereRadius;
					sphereShape.emitFromShell=shapeData.sphereEmitFromShell;
					sphereShape.randomDirection=shapeData.sphereRandomDirection;
					break ;
				case 1:;
					var hemiSphereShape;
					shape=hemiSphereShape=new HemisphereShape();
					hemiSphereShape.radius=shapeData.hemiSphereRadius;
					hemiSphereShape.emitFromShell=shapeData.hemiSphereEmitFromShell;
					hemiSphereShape.randomDirection=shapeData.hemiSphereRandomDirection;
					break ;
				case 2:;
					var coneShape;
					shape=coneShape=new ConeShape();
					coneShape.angle=shapeData.coneAngle *anglelToRad;
					coneShape.radius=shapeData.coneRadius;
					coneShape.length=shapeData.coneLength;
					coneShape.emitType=shapeData.coneEmitType;
					coneShape.randomDirection=shapeData.coneRandomDirection;
					break ;
				case 3:;
					var boxShape;
					shape=boxShape=new BoxShape();
					boxShape.x=shapeData.boxX;
					boxShape.y=shapeData.boxY;
					boxShape.z=shapeData.boxZ;
					boxShape.randomDirection=shapeData.boxRandomDirection;
					break ;
				case 7:;
					var circleShape;
					shape=circleShape=new CircleShape();
					circleShape.radius=shapeData.circleRadius;
					circleShape.arc=shapeData.circleArc *anglelToRad;
					circleShape.emitFromEdge=shapeData.circleEmitFromEdge;
					circleShape.randomDirection=shapeData.circleRandomDirection;
					break ;
				default :;
					var tempShape;
					shape=tempShape=new CircleShape();
					tempShape.radius=shapeData.circleRadius;
					tempShape.arc=shapeData.circleArc *anglelToRad;
					tempShape.emitFromEdge=shapeData.circleEmitFromEdge;
					tempShape.randomDirection=shapeData.circleRandomDirection;
					break ;
				}
			shape.enable=shapeData.enable;
			particleSystem.shape=shape;
			var velocityOverLifetimeData=settting.velocityOverLifetime;
			if (velocityOverLifetimeData){
				var velocityData=velocityOverLifetimeData.velocity;
				var velocity;
				switch (velocityData.type){
					case 0:;
						var constantData=velocityData.constant;
						velocity=GradientVelocity.createByConstant(new Vector3(constantData[0],constantData[1],constantData[2]));
						break ;
					case 1:
						velocity=GradientVelocity.createByGradient(Utils3D._initParticleVelocity(velocityData.gradientX),Utils3D._initParticleVelocity(velocityData.gradientY),Utils3D._initParticleVelocity(velocityData.gradientZ));
						break ;
					case 2:;
						var constantMinData=velocityData.constantMin;
						var constantMaxData=velocityData.constantMax;
						velocity=GradientVelocity.createByRandomTwoConstant(new Vector3(constantMinData[0],constantMinData[1],constantMinData[2]),new Vector3(constantMaxData[0],constantMaxData[1],constantMaxData[2]));
						break ;
					case 3:
						velocity=GradientVelocity.createByRandomTwoGradient(Utils3D._initParticleVelocity(velocityData.gradientXMin),Utils3D._initParticleVelocity(velocityData.gradientXMax),Utils3D._initParticleVelocity(velocityData.gradientYMin),Utils3D._initParticleVelocity(velocityData.gradientYMax),Utils3D._initParticleVelocity(velocityData.gradientZMin),Utils3D._initParticleVelocity(velocityData.gradientZMax));
						break ;
					};
				var velocityOverLifetime=new VelocityOverLifetime(velocity);
				velocityOverLifetime.space=velocityOverLifetimeData.space;
				velocityOverLifetime.enbale=velocityOverLifetimeData.enable;
				particleSystem.velocityOverLifetime=velocityOverLifetime;
			};
			var colorOverLifetimeData=settting.colorOverLifetime;
			if (colorOverLifetimeData){
				var colorData=colorOverLifetimeData.color;
				var color;
				switch (colorData.type){
					case 0:;
						var constColorData=colorData.constant;
						color=GradientColor.createByConstant(new Vector4(constColorData[0],constColorData[1],constColorData[2],constColorData[3]));
						break ;
					case 1:
						color=GradientColor.createByGradient(Utils3D._initParticleColor(colorData.gradient));
						break ;
					case 2:;
						var minConstColorData=colorData.constantMin;
						var maxConstColorData=colorData.constantMax;
						color=GradientColor.createByRandomTwoConstant(new Vector4(minConstColorData[0],minConstColorData[1],minConstColorData[2],minConstColorData[3]),new Vector4(maxConstColorData[0],maxConstColorData[1],maxConstColorData[2],maxConstColorData[3]));
						break ;
					case 3:
						color=GradientColor.createByRandomTwoGradient(Utils3D._initParticleColor(colorData.gradientMin),Utils3D._initParticleColor(colorData.gradientMax));
						break ;
					};
				var colorOverLifetime=new ColorOverLifetime(color);
				colorOverLifetime.enbale=colorOverLifetimeData.enable;
				particleSystem.colorOverLifetime=colorOverLifetime;
			};
			var sizeOverLifetimeData=settting.sizeOverLifetime;
			if (sizeOverLifetimeData){
				var sizeData=sizeOverLifetimeData.size;
				var size;
				switch (sizeData.type){
					case 0:
						if (sizeData.separateAxes){
							size=GradientSize.createByGradientSeparate(Utils3D._initParticleSize(sizeData.gradientX),Utils3D._initParticleSize(sizeData.gradientY),Utils3D._initParticleSize(sizeData.gradientZ));
							}else {
							size=GradientSize.createByGradient(Utils3D._initParticleSize(sizeData.gradient));
						}
						break ;
					case 1:
						if (sizeData.separateAxes){
							var constantMinSeparateData=sizeData.constantMinSeparate;
							var constantMaxSeparateData=sizeData.constantMaxSeparate;
							size=GradientSize.createByRandomTwoConstantSeparate(new Vector3(constantMinSeparateData[0],constantMinSeparateData[1],constantMinSeparateData[2]),new Vector3(constantMaxSeparateData[0],constantMaxSeparateData[1],constantMaxSeparateData[2]));
							}else {
							size=GradientSize.createByRandomTwoConstant(sizeData.constantMin,sizeData.constantMax);
						}
						break ;
					case 2:
						if (sizeData.separateAxes){
							size=GradientSize.createByRandomTwoGradientSeparate(Utils3D._initParticleSize(sizeData.gradientXMin),Utils3D._initParticleSize(sizeData.gradientYMin),Utils3D._initParticleSize(sizeData.gradientZMin),Utils3D._initParticleSize(sizeData.gradientXMax),Utils3D._initParticleSize(sizeData.gradientYMax),Utils3D._initParticleSize(sizeData.gradientZMax));
							}else {
							size=GradientSize.createByRandomTwoGradient(Utils3D._initParticleSize(sizeData.gradientMin),Utils3D._initParticleSize(sizeData.gradientMax));
						}
						break ;
					};
				var sizeOverLifetime=new SizeOverLifetime(size);
				sizeOverLifetime.enbale=sizeOverLifetimeData.enable;
				particleSystem.sizeOverLifetime=sizeOverLifetime;
			};
			var rotationOverLifetimeData=settting.rotationOverLifetime;
			if (rotationOverLifetimeData){
				var angularVelocityData=rotationOverLifetimeData.angularVelocity;
				var angularVelocity;
				switch (angularVelocityData.type){
					case 0:
						if (angularVelocityData.separateAxes){
							}else {
							angularVelocity=GradientAngularVelocity.createByConstant(angularVelocityData.constant *anglelToRad);
						}
						break ;
					case 1:
						if (angularVelocityData.separateAxes){
							}else {
							angularVelocity=GradientAngularVelocity.createByGradient(Utils3D._initParticleRotation(angularVelocityData.gradient));
						}
						break ;
					case 2:
						if (angularVelocityData.separateAxes){
							}else {
							angularVelocity=GradientAngularVelocity.createByRandomTwoConstant(angularVelocityData.constantMin *anglelToRad,angularVelocityData.constantMax *anglelToRad);
						}
						break ;
					case 3:
						if (angularVelocityData.separateAxes){
							}else {
							angularVelocity=GradientAngularVelocity.createByRandomTwoGradient(Utils3D._initParticleRotation(angularVelocityData.gradientMin),Utils3D._initParticleRotation(angularVelocityData.gradientMax));
						}
						break ;
					};
				var rotationOverLifetime=new RotationOverLifetime(angularVelocity);
				rotationOverLifetime.enbale=rotationOverLifetimeData.enable;
				particleSystem.rotationOverLifetime=rotationOverLifetime;
			};
			var textureSheetAnimationData=settting.textureSheetAnimation;
			if (textureSheetAnimationData){
				var frameData=textureSheetAnimationData.frame;
				var frameOverTime;
				switch (frameData.type){
					case 0:
						frameOverTime=FrameOverTime.createByConstant(frameData.constant);
						break ;
					case 1:
						frameOverTime=FrameOverTime.createByOverTime(Utils3D._initParticleFrame(frameData.overTime));
						break ;
					case 2:
						frameOverTime=FrameOverTime.createByRandomTwoConstant(frameData.constantMin,frameData.constantMax);
						break ;
					case 3:
						frameOverTime=FrameOverTime.createByRandomTwoOverTime(Utils3D._initParticleFrame(frameData.overTimeMin),Utils3D._initParticleFrame(frameData.overTimeMax));
						break ;
					};
				var startFrameData=textureSheetAnimationData.startFrame;
				var startFrame;
				switch (startFrameData.type){
					case 0:
						startFrame=StartFrame.createByConstant(startFrameData.constant);
						break ;
					case 1:
						startFrame=StartFrame.createByRandomTwoConstant(startFrameData.constantMin,startFrameData.constantMax);
						break ;
					};
				var textureSheetAnimation=new TextureSheetAnimation(frameOverTime,startFrame);
				textureSheetAnimation.enbale=textureSheetAnimationData.enable;
				var tilesData=textureSheetAnimationData.tiles;
				textureSheetAnimation.tiles=new Vector2(tilesData[0],tilesData[1]);
				textureSheetAnimation.type=textureSheetAnimationData.type;
				textureSheetAnimation.randomRow=textureSheetAnimationData.randomRow;
				textureSheetAnimation.cycles=textureSheetAnimationData.cycles;
				particleSystem.textureSheetAnimation=textureSheetAnimation;
			};
			var particleRender=particle.particleRender;
			particleRender.renderMode=settting.renderMode;
			particleRender.stretchedBillboardCameraSpeedScale=settting.stretchedBillboardCameraSpeedScale;
			particleRender.stretchedBillboardSpeedScale=settting.stretchedBillboardSpeedScale;
			particleRender.stretchedBillboardLengthScale=settting.stretchedBillboardLengthScale;
			particleRender.sortingFudge=settting.sortingFudge ? settting.sortingFudge :0.0;
			(particleSystem.playOnAwake)&& (particleSystem.play());
		}

		Utils3D._parseHierarchyProp=function(innerResouMap,node,json){
			var customProps=json.customProps;
			var transValue=customProps.translate;
			var loccalPosition=node.transform.localPosition;
			var loccalPositionElments=loccalPosition.elements;
			loccalPositionElments[0]=transValue[0];
			loccalPositionElments[1]=transValue[1];
			loccalPositionElments[2]=transValue[2];
			node.transform.localPosition=loccalPosition;
			var rotValue=customProps.rotation;
			var localRotation=node.transform.localRotation;
			var localRotationElement=localRotation.elements;
			localRotationElement[0]=rotValue[0];
			localRotationElement[1]=rotValue[1];
			localRotationElement[2]=rotValue[2];
			localRotationElement[3]=rotValue[3];
			node.transform.localRotation=localRotation;
			var scaleValue=customProps.scale;
			var localScale=node.transform.localScale;
			var localSceleElement=localScale.elements;
			localSceleElement[0]=scaleValue[0];
			localSceleElement[1]=scaleValue[1];
			localSceleElement[2]=scaleValue[2];
			node.transform.localScale=localScale;
			switch (json.type){
				case "Sprite3D":
					break ;
				case "MeshSprite3D":;
					var meshSprite3D=(node);
					var meshRender=meshSprite3D.meshRender;
					var lightmapIndex=customProps.lightmapIndex;
					(lightmapIndex!==null)&& (meshRender.lightmapIndex=lightmapIndex);
					var lightmapScaleOffsetArray=customProps.lightmapScaleOffset;
					if (lightmapScaleOffsetArray)
						meshRender.lightmapScaleOffset=new Vector4(lightmapScaleOffsetArray[0],lightmapScaleOffsetArray[1],lightmapScaleOffsetArray[2],lightmapScaleOffsetArray[3]);
					var mesh=Loader.getRes(innerResouMap[json.instanceParams.loadPath]);
					meshSprite3D.meshFilter.sharedMesh=mesh;
					if (mesh.loaded)
						meshRender.sharedMaterials=mesh.materials;
					else
					mesh.once(/*laya.events.Event.LOADED*/"loaded",meshSprite3D,meshSprite3D._applyMeshMaterials);
					break ;
				case "ShuriKenParticle3D":;
					var shuriKenParticle3D=(node);
					Utils3D._loadParticle(customProps,shuriKenParticle3D,innerResouMap);
					break ;
				}
		}

		Utils3D._parseHierarchyNode=function(json){
			switch (json.type){
				case "Sprite3D":
					return new Sprite3D();
					break ;
				case "MeshSprite3D":
					return new MeshSprite3D();
					break ;
				case "ShuriKenParticle3D":
					return new ShuriKenParticle3D();
					break ;
				default :
					throw new Error("Utils3D:unidentified class type in (.lh) file.");
				}
		}

		Utils3D._initStartLife=function(gradientData){
			var gradient=new GradientDataNumber();
			var startLifetimesData=gradientData.startLifetimes;
			for (var i=0,n=startLifetimesData.length;i < n;i++){
				var valueData=startLifetimesData[i];
				gradient.add(valueData.key,valueData.value);
			}
			return gradient
		}

		Utils3D._initParticleVelocity=function(gradientData){
			var gradient=new GradientDataNumber();
			var velocitysData=gradientData.velocitys;
			for (var i=0,n=velocitysData.length;i < n;i++){
				var valueData=velocitysData[i];
				gradient.add(valueData.key,valueData.value);
			}
			return gradient;
		}

		Utils3D._initParticleColor=function(gradientColorData){
			var gradientColor=new GradientDataColor();
			var alphasData=gradientColorData.alphas;
			var i=0,n=0;
			for (i=0,n=alphasData.length;i < n;i++){
				var alphaData=alphasData[i];
				gradientColor.addAlpha(alphaData.key,alphaData.value);
			};
			var rgbsData=gradientColorData.rgbs;
			for (i=0,n=rgbsData.length;i < n;i++){
				var rgbData=rgbsData[i];
				var rgbValue=rgbData.value;
				gradientColor.addRGB(rgbData.key,new Vector3(rgbValue[0],rgbValue[1],rgbValue[2]));
			}
			return gradientColor;
		}

		Utils3D._initParticleSize=function(gradientSizeData){
			var gradientSize=new GradientDataNumber();
			var sizesData=gradientSizeData.sizes;
			for (var i=0,n=sizesData.length;i < n;i++){
				var valueData=sizesData[i];
				gradientSize.add(valueData.key,valueData.value);
			}
			return gradientSize;
		}

		Utils3D._initParticleRotation=function(gradientData){
			var gradient=new GradientDataNumber();
			var angularVelocitysData=gradientData.angularVelocitys;
			for (var i=0,n=angularVelocitysData.length;i < n;i++){
				var valueData=angularVelocitysData[i];
				gradient.add(valueData.key,valueData.value / 180.0 *Math.PI);
			}
			return gradient;
		}

		Utils3D._initParticleFrame=function(overTimeFramesData){
			var overTimeFrame=new GradientDataInt();
			var framesData=overTimeFramesData.frames;
			for (var i=0,n=framesData.length;i < n;i++){
				var frameData=framesData[i];
				overTimeFrame.add(frameData.key,frameData.value);
			}
			return overTimeFrame;
		}

		Utils3D._computeBoneAndAnimationDatas=function(bones,curData,exData,outBonesDatas,outAnimationDatas){
			var offset=0;
			var matOffset=0;
			var len=exData.length / 2;
			var i;
			var parentOffset;
			var boneLength=bones.length;
			for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
				laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+7],curData[offset+8],curData[offset+9],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+0],curData[offset+1],curData[offset+2],outBonesDatas,matOffset);
				if (i !=0){
					parentOffset=bones[i].parentIndex *16;
					laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
				}
			}
			for (i=0;i < len;i+=16){
				laya.d3.utils.Utils3D.mulMatrixByArrayFast(outBonesDatas,i,exData,len+i,outAnimationDatas,i);
			}
		}

		Utils3D._computeAnimationDatas=function(exData,bonesDatas,outAnimationDatas){
			var len=exData.length / 2;
			for (var i=0;i < len;i+=16){
				laya.d3.utils.Utils3D.mulMatrixByArrayFast(bonesDatas,i,exData,len+i,outAnimationDatas,i);
			}
		}

		Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxix=function(bones,curData,inverGlobalBindPose,outBonesDatas,outAnimationDatas,boneIndexToMesh){
			var offset=0;
			var matOffset=0;
			var i;
			var parentOffset;
			var boneLength=bones.length;
			for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
				laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],outBonesDatas,matOffset);
				if (i !=0){
					parentOffset=bones[i].parentIndex *16;
					laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
				}
			};
			var n=inverGlobalBindPose.length;
			for (i=0;i < n;i++){
				laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas,boneIndexToMesh[i]*16,inverGlobalBindPose[i],outAnimationDatas,i *16);
			}
		}

		Utils3D._computeAnimationDatasByArrayAndMatrixFast=function(inverGlobalBindPose,bonesDatas,outAnimationDatas,boneIndexToMesh){
			for (var i=0,n=inverGlobalBindPose.length;i < n;i++)
			laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas,boneIndexToMesh[i] *16,inverGlobalBindPose[i],outAnimationDatas,i*16);
		}

		Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxixOld=function(bones,curData,inverGlobalBindPose,outBonesDatas,outAnimationDatas){
			var offset=0;
			var matOffset=0;
			var i;
			var parentOffset;
			var boneLength=bones.length;
			for (i=0;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++){
				laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(curData[offset+7],curData[offset+8],curData[offset+9],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+0],curData[offset+1],curData[offset+2],outBonesDatas,matOffset);
				if (i !=0){
					parentOffset=bones[i].parentIndex *16;
					laya.d3.utils.Utils3D.mulMatrixByArray(outBonesDatas,parentOffset,outBonesDatas,matOffset,outBonesDatas,matOffset);
				}
			};
			var n=inverGlobalBindPose.length;
			for (i=0;i < n;i++){
				var arrayOffset=i *16;
				laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas,arrayOffset,inverGlobalBindPose[i],outAnimationDatas,arrayOffset);
			}
		}

		Utils3D._computeAnimationDatasByArrayAndMatrixFastOld=function(inverGlobalBindPose,bonesDatas,outAnimationDatas){
			var n=inverGlobalBindPose.length;
			for (var i=0;i < n;i++){
				var arrayOffset=i *16;
				laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas,arrayOffset,inverGlobalBindPose[i],outAnimationDatas,arrayOffset);
			}
		}

		Utils3D._computeRootAnimationData=function(bones,curData,animationDatas){
			for (var i=0,offset=0,matOffset=0,boneLength=bones.length;i < boneLength;offset+=bones[i].keyframeWidth,matOffset+=16,i++)
			laya.d3.utils.Utils3D.createAffineTransformationArray(curData[offset+0],curData[offset+1],curData[offset+2],curData[offset+3],curData[offset+4],curData[offset+5],curData[offset+6],curData[offset+7],curData[offset+8],curData[offset+9],animationDatas,matOffset);
		}

		Utils3D.generateTangent=function(vertexDatas,vertexStride,positionOffset,uvOffset,indices){
			var tangentElementCount=3;
			var newVertexStride=vertexStride+tangentElementCount;
			var tangentVertexDatas=new Float32Array(newVertexStride *(vertexDatas.length / vertexStride));
			for (var i=0;i < indices.length;i+=3){
				var index1=indices[i+0];
				var index2=indices[i+1];
				var index3=indices[i+2];
				var position1Offset=vertexStride *index1+positionOffset;
				var position1=Utils3D._tempVector3_0;
				position1.x=vertexDatas[position1Offset+0];
				position1.y=vertexDatas[position1Offset+1];
				position1.z=vertexDatas[position1Offset+2];
				var position2Offset=vertexStride *index2+positionOffset;
				var position2=Utils3D._tempVector3_1;
				position2.x=vertexDatas[position2Offset+0];
				position2.y=vertexDatas[position2Offset+1];
				position2.z=vertexDatas[position2Offset+2];
				var position3Offset=vertexStride *index3+positionOffset;
				var position3=Utils3D._tempVector3_2;
				position3.x=vertexDatas[position3Offset+0];
				position3.y=vertexDatas[position3Offset+1];
				position3.z=vertexDatas[position3Offset+2];
				var uv1Offset=vertexStride *index1+uvOffset;
				var UV1X=vertexDatas[uv1Offset+0];
				var UV1Y=vertexDatas[uv1Offset+1];
				var uv2Offset=vertexStride *index2+uvOffset;
				var UV2X=vertexDatas[uv2Offset+0];
				var UV2Y=vertexDatas[uv2Offset+1];
				var uv3Offset=vertexStride *index3+uvOffset;
				var UV3X=vertexDatas[uv3Offset+0];
				var UV3Y=vertexDatas[uv3Offset+1];
				var lengthP2ToP1=Utils3D._tempVector3_3;
				Vector3.subtract(position2,position1,lengthP2ToP1);
				var lengthP3ToP1=Utils3D._tempVector3_4;
				Vector3.subtract(position3,position1,lengthP3ToP1);
				Vector3.scale(lengthP2ToP1,UV3Y-UV1Y,lengthP2ToP1);
				Vector3.scale(lengthP3ToP1,UV2Y-UV1Y,lengthP3ToP1);
				var tangent=Utils3D._tempVector3_5;
				Vector3.subtract(lengthP2ToP1,lengthP3ToP1,tangent);
				Vector3.scale(tangent,1.0 / ((UV2X-UV1X)*(UV3Y-UV1Y)-(UV2Y-UV1Y)*(UV3X-UV1X)),tangent);
				var j=0;
				for (j=0;j < vertexStride;j++)
				tangentVertexDatas[newVertexStride *index1+j]=vertexDatas[vertexStride *index1+j];
				for (j=0;j < tangentElementCount;j++)
				tangentVertexDatas[newVertexStride *index1+vertexStride+j]=+tangent.elements[j];
				for (j=0;j < vertexStride;j++)
				tangentVertexDatas[newVertexStride *index2+j]=vertexDatas[vertexStride *index2+j];
				for (j=0;j < tangentElementCount;j++)
				tangentVertexDatas[newVertexStride *index2+vertexStride+j]=+tangent.elements[j];
				for (j=0;j < vertexStride;j++)
				tangentVertexDatas[newVertexStride *index3+j]=vertexDatas[vertexStride *index3+j];
				for (j=0;j < tangentElementCount;j++)
				tangentVertexDatas[newVertexStride *index3+vertexStride+j]=+tangent.elements[j];
			}
			for (i=0;i < tangentVertexDatas.length;i+=newVertexStride){
				var tangentStartIndex=newVertexStride *i+vertexStride;
				var t=Utils3D._tempVector3_6;
				t.x=tangentVertexDatas[tangentStartIndex+0];
				t.y=tangentVertexDatas[tangentStartIndex+1];
				t.z=tangentVertexDatas[tangentStartIndex+2];
				Vector3.normalize(t,t);
				tangentVertexDatas[tangentStartIndex+0]=t.x;
				tangentVertexDatas[tangentStartIndex+1]=t.y;
				tangentVertexDatas[tangentStartIndex+2]=t.z;
			}
			return tangentVertexDatas;
		}

		Utils3D.getVertexTangentDeclaration=function(vertexElements){
			var position=false,normal=false,color=false,texcoord0=false,texcoord1=false,blendWeight=false,blendIndex=false;
			for (var i=0;i < vertexElements.length;i++){
				switch ((vertexElements [i]).elementUsage){
					case "POSITION":
						position=true;
						break ;
					case "NORMAL":
						normal=true;
						break ;
					case "COLOR":
						color=true;
						break ;
					case "UV":
						texcoord0=true;
						break ;
					case "UV1":
						texcoord1=true;
						break ;
					case "BLENDWEIGHT":
						blendWeight=true;
						break ;
					case "BLENDINDICES":
						blendIndex=true;
						break ;
					}
			};
			var vertexDeclaration;
			if (position && normal && color && texcoord0 && texcoord1 && blendWeight && blendIndex)
				vertexDeclaration=VertexPositionNormalColorTexture0Texture1SkinTangent.vertexDeclaration;
			if (position && normal && color && texcoord0 && blendWeight && blendIndex)
				vertexDeclaration=VertexPositionNormalColorTextureSkinTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTexture0Texture1SkinTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalTextureSkinTangent.vertexDeclaration;
			else if (position && normal && color && blendWeight && blendIndex)
			vertexDeclaration=VertexPositionNormalColorSkinTangent.vertexDeclaration;
			else if (position && normal && color && texcoord0 && texcoord1)
			vertexDeclaration=VertexPositionNormalColorTexture0Texture1Tangent.vertexDeclaration;
			else if (position && normal && color && texcoord0)
			vertexDeclaration=VertexPositionNormalColorTextureTangent.vertexDeclaration;
			else if (position && normal && texcoord0 && texcoord1)
			vertexDeclaration=VertexPositionNormalTexture0Texture1Tangent.vertexDeclaration;
			else if (position && normal && texcoord0)
			vertexDeclaration=VertexPositionNormalTextureTangent.vertexDeclaration;
			else if (position && normal && color)
			vertexDeclaration=VertexPositionNormalColorTangent.vertexDeclaration;
			return vertexDeclaration;
		}

		Utils3D.transformVector3ArrayByQuat=function(sourceArray,sourceOffset,rotation,outArray,outOffset){
			var re=rotation.elements;
			var x=sourceArray[sourceOffset],y=sourceArray[sourceOffset+1],z=sourceArray[sourceOffset+2],qx=re[0],qy=re[1],qz=re[2],qw=re[3],
			ix=qw *x+qy *z-qz *y,iy=qw *y+qz *x-qx *z,iz=qw *z+qx *y-qy *x,iw=-qx *x-qy *y-qz *z;
			outArray[outOffset]=ix *qw+iw *-qx+iy *-qz-iz *-qy;
			outArray[outOffset+1]=iy *qw+iw *-qy+iz *-qx-ix *-qz;
			outArray[outOffset+2]=iz *qw+iw *-qz+ix *-qy-iy *-qx;
		}

		Utils3D.mulMatrixByArray=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			if (outArray===rightArray){
				rightArray=Utils3D._tempArray16_3;
				for (i=0;i < 16;++i){
					rightArray[i]=outArray[outOffset+i];
				}
				rightOffset=0;
			}
			for (i=0;i < 4;i++){
				ai0=leftArray[leftOffset+i];
				ai1=leftArray[leftOffset+i+4];
				ai2=leftArray[leftOffset+i+8];
				ai3=leftArray[leftOffset+i+12];
				outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
				outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
				outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
				outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
			}
		}

		Utils3D.mulMatrixByArrayFast=function(leftArray,leftOffset,rightArray,rightOffset,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			for (i=0;i < 4;i++){
				ai0=leftArray[leftOffset+i];
				ai1=leftArray[leftOffset+i+4];
				ai2=leftArray[leftOffset+i+8];
				ai3=leftArray[leftOffset+i+12];
				outArray[outOffset+i]=ai0 *rightArray[rightOffset+0]+ai1 *rightArray[rightOffset+1]+ai2 *rightArray[rightOffset+2]+ai3 *rightArray[rightOffset+3];
				outArray[outOffset+i+4]=ai0 *rightArray[rightOffset+4]+ai1 *rightArray[rightOffset+5]+ai2 *rightArray[rightOffset+6]+ai3 *rightArray[rightOffset+7];
				outArray[outOffset+i+8]=ai0 *rightArray[rightOffset+8]+ai1 *rightArray[rightOffset+9]+ai2 *rightArray[rightOffset+10]+ai3 *rightArray[rightOffset+11];
				outArray[outOffset+i+12]=ai0 *rightArray[rightOffset+12]+ai1 *rightArray[rightOffset+13]+ai2 *rightArray[rightOffset+14]+ai3 *rightArray[rightOffset+15];
			}
		}

		Utils3D.mulMatrixByArrayAndMatrixFast=function(leftArray,leftOffset,rightMatrix,outArray,outOffset){
			var i,ai0,ai1,ai2,ai3;
			var rightMatrixE=rightMatrix.elements;
			var m11=rightMatrixE[0],m12=rightMatrixE[1],m13=rightMatrixE[2],m14=rightMatrixE[3];
			var m21=rightMatrixE[4],m22=rightMatrixE[5],m23=rightMatrixE[6],m24=rightMatrixE[7];
			var m31=rightMatrixE[8],m32=rightMatrixE[9],m33=rightMatrixE[10],m34=rightMatrixE[11];
			var m41=rightMatrixE[12],m42=rightMatrixE[13],m43=rightMatrixE[14],m44=rightMatrixE[15];
			var ai0LeftOffset=leftOffset;
			var ai1LeftOffset=leftOffset+4;
			var ai2LeftOffset=leftOffset+8;
			var ai3LeftOffset=leftOffset+12;
			var ai0OutOffset=outOffset;
			var ai1OutOffset=outOffset+4;
			var ai2OutOffset=outOffset+8;
			var ai3OutOffset=outOffset+12;
			for (i=0;i < 4;i++){
				ai0=leftArray[ai0LeftOffset+i];
				ai1=leftArray[ai1LeftOffset+i];
				ai2=leftArray[ai2LeftOffset+i];
				ai3=leftArray[ai3LeftOffset+i];
				outArray[ai0OutOffset+i]=ai0 *m11+ai1 *m12+ai2 *m13+ai3 *m14;
				outArray[ai1OutOffset+i]=ai0 *m21+ai1 *m22+ai2 *m23+ai3 *m24;
				outArray[ai2OutOffset+i]=ai0 *m31+ai1 *m32+ai2 *m33+ai3 *m34;
				outArray[ai3OutOffset+i]=ai0 *m41+ai1 *m42+ai2 *m43+ai3 *m44;
			}
		}

		Utils3D.createAffineTransformationArray=function(tX,tY,tZ,rX,rY,rZ,rW,sX,sY,sZ,outArray,outOffset){
			var x2=rX+rX,y2=rY+rY,z2=rZ+rZ;
			var xx=rX *x2,xy=rX *y2,xz=rX *z2,yy=rY *y2,yz=rY *z2,zz=rZ *z2;
			var wx=rW *x2,wy=rW *y2,wz=rW *z2;
			outArray[outOffset+0]=(1-(yy+zz))*sX;
			outArray[outOffset+1]=(xy+wz)*sX;
			outArray[outOffset+2]=(xz-wy)*sX;
			outArray[outOffset+3]=0;
			outArray[outOffset+4]=(xy-wz)*sY;
			outArray[outOffset+5]=(1-(xx+zz))*sY;
			outArray[outOffset+6]=(yz+wx)*sY;
			outArray[outOffset+7]=0;
			outArray[outOffset+8]=(xz+wy)*sZ;
			outArray[outOffset+9]=(yz-wx)*sZ;
			outArray[outOffset+10]=(1-(xx+yy))*sZ;
			outArray[outOffset+11]=0;
			outArray[outOffset+12]=tX;
			outArray[outOffset+13]=tY;
			outArray[outOffset+14]=tZ;
			outArray[outOffset+15]=1;
		}

		Utils3D.transformVector3ArrayToVector3ArrayCoordinate=function(source,sourceOffset,transform,result,resultOffset){
			var vectorElem=Utils3D._tempArray4_0;
			var coordinateX=source[sourceOffset+0];
			var coordinateY=source[sourceOffset+1];
			var coordinateZ=source[sourceOffset+2];
			var transformElem=transform.elements;
			vectorElem[0]=(coordinateX *transformElem[0])+(coordinateY *transformElem[4])+(coordinateZ *transformElem[8])+transformElem[12];
			vectorElem[1]=(coordinateX *transformElem[1])+(coordinateY *transformElem[5])+(coordinateZ *transformElem[9])+transformElem[13];
			vectorElem[2]=(coordinateX *transformElem[2])+(coordinateY *transformElem[6])+(coordinateZ *transformElem[10])+transformElem[14];
			vectorElem[3]=1.0 / ((coordinateX *transformElem[3])+(coordinateY *transformElem[7])+(coordinateZ *transformElem[11])+transformElem[15]);
			result[resultOffset+0]=vectorElem[0] *vectorElem[3];
			result[resultOffset+1]=vectorElem[1] *vectorElem[3];
			result[resultOffset+2]=vectorElem[2] *vectorElem[3];
		}

		Utils3D.transformLightingMapTexcoordByUV0Array=function(source,sourceOffset,lightingMapScaleOffset,result,resultOffset){
			var lightingMapScaleOffsetE=lightingMapScaleOffset.elements;
			result[resultOffset+0]=source[sourceOffset+0] *lightingMapScaleOffsetE[0]+lightingMapScaleOffsetE[2];
			result[resultOffset+1]=(source[sourceOffset+1]-1.0)*lightingMapScaleOffsetE[1]+lightingMapScaleOffsetE[3];
		}

		Utils3D.transformLightingMapTexcoordByUV1Array=function(source,sourceOffset,lightingMapScaleOffset,result,resultOffset){
			var lightingMapScaleOffsetE=lightingMapScaleOffset.elements;
			result[resultOffset+0]=source[sourceOffset+0] *lightingMapScaleOffsetE[0]+lightingMapScaleOffsetE[2];
			result[resultOffset+1]=1.0+source[sourceOffset+1] *lightingMapScaleOffsetE[1]+lightingMapScaleOffsetE[3];
		}

		Utils3D.convert3DCoordTo2DScreenCoord=function(source,out){
			var se=source.elements;
			var oe=out.elements;
			oe[0]=-RenderState.clientWidth / 2+se[0];
			oe[1]=RenderState.clientHeight / 2-se[1];
			oe[2]=se[2];
		}

		Utils3D.getURLVerion=function(url){
			var index=url.indexOf("?");
			return index >=0 ? url.substr(index):null;
		}

		Utils3D._tempVector3_0=new Vector3();
		Utils3D._tempVector3_1=new Vector3();
		Utils3D._tempVector3_2=new Vector3();
		Utils3D._tempVector3_3=new Vector3();
		Utils3D._tempVector3_4=new Vector3();
		Utils3D._tempVector3_5=new Vector3();
		Utils3D._tempVector3_6=new Vector3();
		Utils3D._tempArray4_0=new Float32Array(4);
		Utils3D._tempArray16_0=new Float32Array(16);
		Utils3D._tempArray16_1=new Float32Array(16);
		Utils3D._tempArray16_2=new Float32Array(16);
		Utils3D._tempArray16_3=new Float32Array(16);
		__static(Utils3D,
		['_typeToFunO',function(){return this._typeToFunO={"INT16":"writeInt16","SHORT":"writeInt16","UINT16":"writeUint16","UINT32":"writeUint32","FLOAT32":"writeFloat32","INT":"writeInt32","UINT":"writeUint32","BYTE":"writeByte","STRING":"writeUTFString"};}
		]);
		return Utils3D;
	})()


	/**
	*<code>Laya3D</code> 类用于初始化3D设置。
	*/
	//class Laya3D
	var Laya3D=(function(){
		/**
		*创建一个 <code>Laya3D</code> 实例。
		*/
		function Laya3D(){}
		__class(Laya3D,'Laya3D');
		Laya3D._changeWebGLSize=function(width,height){
			WebGL.onStageResize(width,height);
			RenderState.clientWidth=width;
			RenderState.clientHeight=height;
		}

		Laya3D._initShader=function(){
			Shader3D.addInclude("LightHelper.glsl","\nstruct DirectionLight\n{\n vec3 Direction;\n vec3 Diffuse;\n vec3 Ambient;\n vec3 Specular;\n};\n\nstruct PointLight\n{\n vec3 Diffuse;\n vec3 Ambient;\n vec3 Specular;\n vec3 Attenuation;\n vec3 Position;\n float Range;\n};\n\nstruct SpotLight\n{\n vec3 Diffuse;\n vec3 Ambient;\n vec3 Specular;\n vec3 Attenuation;\n vec3 Position;\n vec3 Direction;\n float Spot;\n float Range;\n};\n\n\nvoid  computeDirectionLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in DirectionLight dirLight,in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	dif=vec3(0.0);//不初始化在IOS中闪烁，PC中不会闪烁\n	amb=vec3(0.0);\n	spec=vec3(0.0);\n	vec3 lightVec=-normalize(dirLight.Direction);\n	\n	amb=matAmb*dirLight.Ambient;\n	\n	float  diffuseFactor=dot(lightVec, normal);\n	\n	if(diffuseFactor>0.0)\n	{\n	   vec3 v = reflect(-lightVec, normal);\n	   float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n	   \n	   dif = diffuseFactor * matDif * dirLight.Diffuse;\n	   spec = specFactor * matSpe.rgb * dirLight.Specular;\n	}\n	\n}\n\nvoid computePointLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in PointLight poiLight, in vec3 pos,in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	dif=vec3(0.0);\n	amb=vec3(0.0);\n	spec=vec3(0.0);\n	vec3 lightVec = poiLight.Position - pos;\n		\n	float d = length(lightVec);\n	\n	if( d > poiLight.Range )\n		return;\n		\n	lightVec /= d; \n	\n	amb = matAmb * poiLight.Ambient;	\n\n	float diffuseFactor = dot(lightVec, normal);\n\n	if( diffuseFactor > 0.0 )\n	{\n		vec3 v= reflect(-lightVec, normal);\n		float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n					\n		dif = diffuseFactor * matDif * poiLight.Diffuse;\n		spec = specFactor * matSpe.rgb * poiLight.Specular;\n	}\n\n	float attenuate = 1.0 / dot(poiLight.Attenuation, vec3(1.0, d, d*d));\n\n	dif *= attenuate;\n	spec*= attenuate;\n}\n\nvoid ComputeSpotLight(in vec3 matDif,in vec3 matAmb,in vec4 matSpe,in SpotLight spoLight,in vec3 pos, in vec3 normal,in vec3 toEye,out vec3 dif,out vec3 amb,out vec3 spec)\n{\n	amb = vec3(0.0);\n	dif =vec3(0.0);\n	spec= vec3(0.0);\n	vec3 lightVec = spoLight.Position - pos;\n		\n	float d = length(lightVec);\n	\n	if( d > spoLight.Range)\n		return;\n		\n	lightVec /= d; \n	\n	amb = matAmb * spoLight.Ambient;	\n\n	float diffuseFactor = dot(lightVec, normal);\n\n	if(diffuseFactor > 0.0)\n	{\n		vec3 v= reflect(-lightVec, normal);\n		float specFactor = pow(max(dot(v, toEye), 0.0), matSpe.w);\n					\n		dif = diffuseFactor * matDif * spoLight.Diffuse;\n		spec = specFactor * matSpe.rgb * spoLight.Specular;\n	}\n	\n	float spot = pow(max(dot(-lightVec, normalize(spoLight.Direction)), 0.0), spoLight.Spot);\n\n	float attenuate = spot/dot(spoLight.Attenuation, vec3(1.0, d, d*d));\n\n	amb *= spot;\n	dif *= attenuate;\n	spec*= attenuate;\n}\n\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent)\n{\n	vec3 normalT = 2.0*normalMapSample - 1.0;\n\n	// Build orthonormal basis.\n	vec3 N = normalize(unitNormal);\n	vec3 T = normalize(tangent- dot(tangent, N)*N);\n	vec3 B = cross(T, N);\n\n	mat3 TBN = mat3(T, B, N);\n\n	// Transform from tangent space to world space.\n	vec3 bumpedNormal = TBN*normalT;\n\n	return bumpedNormal;\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/LightHelper.glsl*/);
			Shader3D.addInclude("VRHelper.glsl","\nvec4 DistortFishEye(vec4 p)\n{\n    vec2 v = p.xy / p.w;\n    float radius = length(v);// Convert to polar coords\n    if (radius > 0.0)\n    {\n      float theta = atan(v.y,v.x);\n      \n      radius = pow(radius, 0.93);// Distort:\n\n      v.x = radius * cos(theta);// Convert back to Cartesian\n      v.y = radius * sin(theta);\n      p.xy = v.xy * p.w;\n    }\n    return p;\n}"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/VRHelper.glsl*/);
			Shader3D.addInclude("ShadowHelper.glsl","uniform sampler2D u_shadowMap1;\nuniform sampler2D u_shadowMap2;\nuniform sampler2D u_shadowMap3;\nuniform vec2	  u_shadowPCFoffset;\nuniform vec4     u_shadowPSSMDistance;\nvec4 packDepth(const in float depth)\n{\n	const vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n	const vec4 bitMask	= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n	vec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\n	res -= res.xxyz * bitMask;\n	return res;\n}\nfloat unpackDepth(const in vec4 rgbaDepth)\n{\n	const vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n	float depth = dot(rgbaDepth, bitShift);\n	return depth;\n}\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\n{\n	vec2 texelpos =texcoord / invsize;\n	vec2 lerps = fract( texelpos );\n	float sourcevals[4];\n	sourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\n	sourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\n	sourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\n	sourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\n	return mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\n}\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	int nPSNum = int(posViewZ>pssmDistance.x);\n	nPSNum += int(posViewZ>pssmDistance.y);\n	nPSNum += int(posViewZ>pssmDistance.z);\n	//真SB,webgl不支持在PS中直接访问数组\n	mat4 lightVP;\n	if( nPSNum == 0 )\n	{\n		lightVP = lightShadowVP[1];\n	}\n	else if( nPSNum == 1 )\n	{\n		lightVP = lightShadowVP[2];\n	}\n	else if( nPSNum == 2 )\n	{\n		lightVP = lightShadowVP[3];\n	}\n	vec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n	//为了效率，在CPU计算/2.0 + 0.5\n	//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n	vec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n	float fMyZ = vText.z - zBias;\n	/*\n	bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n	bool bInFrustum = all( bInFrustumVec );\n	bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n	bool bFrustumTest = all( bFrustumTestVec );\n	if ( bFrustumTest ) \n	*/\n	if( fMyZ <= 1.0 )\n	{\n		float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n		if ( nPSNum == 0 )\n		{\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,	fMyZ );\n			value = value/4.0;\n		} \n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF2\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n\n#endif\n#ifdef SHADOWMAP_PCF1\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			vec4 color = texture2D( shadowMap2,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n		else if( nPSNum == 2 )\n		{\n			vec4 color = texture2D( shadowMap3,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n		vec4 color;\n		if ( nPSNum == 0 )\n		{\n			color = texture2D( shadowMap1,vText.xy );\n		}\n		else if( nPSNum == 1 )\n		{\n			color = texture2D( shadowMap2,vText.xy );\n		}\n		else if( nPSNum == 2 )\n		{\n			color = texture2D( shadowMap3,vText.xy );\n		}\n		zdepth = unpackDepth(color);\n		value = float(fMyZ < zdepth);\n#endif\n	}\n	return value;\n}\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	int nPSNum = int(posViewZ>pssmDistance.x);\n	nPSNum += int(posViewZ>pssmDistance.y);\n	//真SB,webgl不支持在PS中直接访问数组\n	mat4 lightVP;\n	if( nPSNum == 0 )\n	{\n		lightVP = lightShadowVP[1];\n	}\n	else if( nPSNum == 1 )\n	{\n		lightVP = lightShadowVP[2];\n	}\n	vec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n	//为了效率，在CPU计算/2.0 + 0.5\n	//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n	vec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n	float fMyZ = vText.z - zBias;\n	/*\n	bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n	bool bInFrustum = all( bInFrustumVec );\n	bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n	bool bFrustumTest = all( bFrustumTestVec );\n	if ( bFrustumTest ) \n	*/\n	if( fMyZ <= 1.0 )\n	{\n		float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n		if ( nPSNum == 0 )\n		{\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,	fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,	fMyZ );\n			value = value/4.0;\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n#endif\n#ifdef SHADOWMAP_PCF2\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			value = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n		}\n#endif\n#ifdef SHADOWMAP_PCF1\n		if ( nPSNum == 0 )\n		{\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n		}\n		else if( nPSNum == 1 )\n		{\n			vec4 color = texture2D( shadowMap2,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n		}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n		vec4 color;\n		if ( nPSNum == 0 )\n		{\n			color = texture2D( shadowMap1,vText.xy );\n		}\n		else if( nPSNum == 1 )\n		{\n			color = texture2D( shadowMap2,vText.xy );\n		}\n		zdepth = unpackDepth(color);\n		value = float(fMyZ < zdepth);\n#endif\n	}\n	return value;\n}\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\n{\n	float value = 1.0;\n	if( posViewZ < pssmDistance.x )\n	{\n		vec3 vText = lightMVPPos.xyz / lightMVPPos.w;\n		float fMyZ = vText.z - zBias;\n		/*\n		bvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n		bool bInFrustum = all( bInFrustumVec );\n		bvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n		bool bFrustumTest = all( bFrustumTestVec );\n		*/\n		if ( fMyZ <= 1.0 ) \n		{\n			float zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n			value =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\n			value += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\n			value = value/4.0;\n#endif\n#ifdef SHADOWMAP_PCF2		\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF1\n			value = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF_NO		\n			vec4 color = texture2D( shadowMap1,vText.xy );\n			zdepth = unpackDepth(color);\n			value = float(fMyZ < zdepth);\n#endif\n		}\n	}\n	return value;\n}"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/ShadowHelper.glsl*/);
			Shader3D.addInclude("WaveFunction.glsl","\nuniform vec2 u_WaveInfoD[20];\nuniform vec4 u_WaveInfo[20];\n\nuniform float GEOWAVE_UV_SCALE ;//= 100.0;\nuniform float TEXWAVE_UV_SCALE ;//= 20.0; //每texwidth像素代表的实际距离\n/**\n	这里的计算都是\n*/\n\n/**\n* 计算一个波形\n*  开始计算的时候都按照z向上，最后输出的时候，颠倒一下。\n* @param tm {float} 毫秒\n*/\nvoid calcGerstnerWave(float curtm, vec3 pos, float deep, vec2 uv, out vec3 opos, out vec3 B, out vec3 T, out vec3 N, out float foamS){\n	float tm = curtm/1000.;\n	opos = pos;\n	vec3 wpos=vec3(0.);		//累加的位置\n	N=vec3(0.,0.,0.);	//输出的法线初始化一下\n	T=vec3(0.,0.,0.);\n	B=vec3(0.,0.,0.);\n	vec2 uvpos = uv*GEOWAVE_UV_SCALE;\n	vec2 cD ;//= D;\n	//float deepAtt = max(0.,min(deep,1.0));\n	//A*=deepAtt; //TODO\n	\n	for( int i=0; i<4; i++){\n		cD = u_WaveInfoD[i];//vec2(wi.winfo[0],wi.winfo[1]);// wi.vDir;\n		float Q = u_WaveInfo[i].x;//wi.QorK;\n		float A = u_WaveInfo[i].y;//wi.A;\n		float W = u_WaveInfo[i].z;//wi.omega;\n		float P = u_WaveInfo[i].w;//wi.phi;\n		float dop = dot(cD,uvpos);\n		float c = cos(dop*W - tm*P);//TODO 优化\n		float s = sin(dop*W - tm*P);\n		float AWs = A*W*s;\n		float AWc = A*W*c;\n		float _QxyAWs = -Q*cD.x*cD.y*AWs;\n		\n		wpos += vec3(Q*A*cD.x*c,\n					Q*A*cD.y*c,\n					A*s);\n		N += vec3(-cD.x*AWc,\n				-cD.y*AWc,\n				Q*AWs);//记得最后1-\n		T += vec3(_QxyAWs,\n				Q*cD.y*cD.y*AWs,//记得1-\n				cD.y*AWc\n			);\n		B += vec3(Q*cD.x*cD.x*AWs,//记得1-\n				_QxyAWs,\n				cD.x*AWc\n			);\n		//float v1 = exp(-tan((dop*W - tm*P)/2.+1.07));//除2，+pi/2 这样正好能对齐\n		float v1 = 0.5-sin((dop*W - tm*P)/1.+2.0)/2.;\n		foamS += pow(v1,9.)/4.;\n	}\n	T.y=1.-T.y; B.x=1.-B.x;N.z=1.-N.z;\n	opos += vec3(wpos.x,wpos.z*deep,wpos.y);\n	//y和z交换一下。现在根据uv计算的位置，所以直接交换yz就行。其他情况下有问题么\n	T.xyz=T.xzy;\n	B.xyz=B.xzy;\n	N.xyz=N.xzy;\n}\n\n\nvoid calcWave(float curtm, vec2 uv, out vec3 B, out vec3 T, out vec3 N){\n	float tm = curtm/1000.;\n	N=vec3(0.,0.,0.);	//输出的法线初始化一下\n	vec2 uvpos = uv*TEXWAVE_UV_SCALE; //TODO 这个范围是什么 就是1？\n	uvpos.y*=-1.;\n	vec2 cD;// = D;\n	const int NumWaves = 4;\n	float scale = 1./float(NumWaves);\n	for( int i=0; i<NumWaves; i++){\n		cD = u_WaveInfoD[i];//vec2(wi.winfo[0],wi.winfo[1]);// wi.vDir;\n		float k = 1.5;//u_WaveInfo[i].x;//wi.QorK; TODO  不知道为什么，这个取u_WaveInfo[i].x，在mi3w上就会闪。测试发现实际值也传过来了，就是1.5\n		float A = u_WaveInfo[i].y;//wi.A;\n		float W = u_WaveInfo[i].z;//wi.omega;\n		float P = u_WaveInfo[i].w;//wi.phi;\n		\n		float dop = dot(cD,uvpos);\n		float c = cos(dop*W - tm*P);//TODO 优化\n		float s = sin(dop*W - tm*P);\n		/*\n		float AWs = A*W*s;\n		float AWc = A*W*c;\n		float _QxyAWs = -Q*cD.x*cD.y*AWs;\n		\n		N += vec3(-cD.x*AWc,\n				-cD.y*AWc,\n				Q*AWs);//记得最后1-\n		*/\n		float kWAc = scale*c;//k*W*A*c;  为了提高精度，这里只保留sin，cos部分，实际使用的时候再乘回来。\n		//float kWAc = k*W*A*c;  \n		N += vec3(\n			-kWAc*cD.x*pow((s+1.)/2.,k-1.),\n			-kWAc*cD.y*pow((s+1.)/2.,k-1.),\n			1.\n		);\n	}\n	//N.z=1.-N.z;\n	//y和z交换一下。现在根据uv计算的位置，所以直接交换yz就行。其他情况下有问题么\n	N.xyz=N.xzy;\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/WaveFunction.glsl*/);
			var vs,ps;
			var attributeMap={'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,'a_Color':/*laya.d3.graphics.VertexElementUsage.COLOR0*/1,'a_Normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,'a_Texcoord1':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15,'a_TexcoordNext0':/*laya.d3.graphics.VertexElementUsage.NEXTTEXTURECOORDINATE0*/14,'a_BoneWeights':/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7,'a_BoneIndices':/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6,'a_Tangent0':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5};
			var uniformMap={'u_Bones':[ /*laya.d3.component.animation.SkinAnimations.BONES*/0,/*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0],
				'u_DiffuseTexture':[ /*laya.d3.core.material.StandardMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_SpecularTexture':[ /*laya.d3.core.material.StandardMaterial.SPECULARTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_NormalTexture':[ /*laya.d3.core.material.StandardMaterial.NORMALTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_AmbientTexture':[ /*laya.d3.core.material.StandardMaterial.AMBIENTTEXTURE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_ReflectTexture':[ /*laya.d3.core.material.StandardMaterial.REFLECTTEXTURE*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_AlphaTestValue':[ /*laya.d3.core.material.BaseMaterial.ALPHATESTVALUE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_Albedo':[ /*laya.d3.core.material.StandardMaterial.ALBEDO*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_UVMatrix':[ /*laya.d3.core.material.StandardMaterial.UVMATRIX*/13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_UVAge':[ /*laya.d3.core.material.StandardMaterial.UVAGE*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_UVAniAge':[ /*laya.d3.core.material.StandardMaterial.UVANIAGE*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_MaterialDiffuse':[ /*laya.d3.core.material.StandardMaterial.MATERIALDIFFUSE*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_MaterialAmbient':[ /*laya.d3.core.material.StandardMaterial.MATERIALAMBIENT*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_MaterialSpecular':[ /*laya.d3.core.material.StandardMaterial.MATERIALSPECULAR*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_MaterialReflect':[ /*laya.d3.core.material.StandardMaterial.MATERIALREFLECT*/12,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'u_LightmapScaleOffset':[ /*laya.d3.core.MeshSprite3D.LIGHTMAPSCALEOFFSET*/2,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_FogStart':[ /*laya.d3.core.scene.BaseScene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_FogRange':[ /*laya.d3.core.scene.BaseScene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_FogColor':[ /*laya.d3.core.scene.BaseScene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Direction':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRDIFFUSE*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Ambient':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRAMBIENT*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Specular':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRSPECULAR*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Position':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTPOS*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Range':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTRANGE*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Attenuation':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTATTENUATION*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTDIFFUSE*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Ambient':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTAMBIENT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Specular':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTSPECULAR*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Position':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTPOS*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Direction':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTDIRECTION*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Range':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTRANGE*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Spot':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTSPOT*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTATTENUATION*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTDIFFUSE*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Ambient':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTAMBIENT*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Specular':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTSPECULAR*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowMap1':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE1*/24,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowMap2':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE2*/25,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowMap3':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE3*/26,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowPSSMDistance':[ /*laya.d3.core.scene.BaseScene.SHADOWDISTANCE*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_lightShadowVP':[ /*laya.d3.core.scene.BaseScene.SHADOWLIGHTVIEWPROJECT*/22,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowPCFoffset':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPPCFOFFSET*/23,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
			var SIMPLE=Shader3D.nameKey.add("SIMPLE");
			vs="#include?VR \"VRHelper.glsl\";\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\n\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(COLOR)&&defined(SPECULARMAP)||defined(NORMALMAP)))\nattribute vec2 a_Texcoord0;\nvarying vec2 v_Texcoord0;\n  #ifdef MIXUV\n  attribute vec2 a_TexcoordNext0;\n  uniform float  u_UVAge;\n  #endif\n  #ifdef UVTRANSFORM \n  uniform mat4 u_UVMatrix;\n  #endif\n#endif\n\n#ifdef AMBIENTMAP\nattribute vec2 a_Texcoord1;\nuniform vec4 u_LightmapScaleOffset;\nvarying vec2 v_LightMapUV;\n#endif\n\n#ifdef COLOR\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n#endif\n\n#ifdef BONE\nattribute vec4 a_BoneIndices;\nattribute vec4 a_BoneWeights;\nconst int c_MaxBoneCount = 24;\nuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\nattribute vec3 a_Normal;\nvarying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP))&&defined(NORMALMAP)\nattribute vec3 a_Tangent0;\nvarying vec3 v_Tangent0;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(DEPTHFOG)||defined(REFLECTMAP)||defined(RECEIVESHADOW)\nuniform mat4 u_WorldMat;\nvarying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\nvoid main_castShadow()\n{\n#ifdef BONE\n	mat4 skinTransform=mat4(0.0);\n	skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n	skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n	vec4 position=skinTransform*a_Position;\n	#ifdef VR\n		gl_Position = DistortFishEye(u_MvpMatrix * position);\n	#else\n		gl_Position = u_MvpMatrix * position;\n	#endif\n#else\n	#ifdef VR\n		gl_Position = DistortFishEye(u_MvpMatrix * a_Position);\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n#endif\n \n//TODO没考虑UV动画呢\n#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n	v_Texcoord0=a_Texcoord0;\n#endif\n	v_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n#ifdef BONE\n	mat4 skinTransform=mat4(0.0);\n	skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n	skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n	vec4 position=skinTransform*a_Position;\n	#ifdef VR\n		gl_Position = DistortFishEye(u_MvpMatrix * position);\n	#else\n		gl_Position = u_MvpMatrix * position;\n	#endif\n#else\n	#ifdef VR\n		gl_Position = DistortFishEye(u_MvpMatrix * a_Position);\n	#else\n		gl_Position = u_MvpMatrix * a_Position;\n	#endif\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	mat3 worldMat;\n	#ifdef BONE\n		worldMat=mat3(u_WorldMat*skinTransform);\n	#else\n		worldMat=mat3(u_WorldMat);\n	#endif  \n	v_Normal=worldMat*a_Normal;\n	#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n		v_Tangent0=worldMat*a_Tangent0;\n	#endif\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(DEPTHFOG)||defined(RECEIVESHADOW)\n	#ifdef BONE\n		v_PositionWorld=(u_WorldMat*position).xyz;\n	#else\n		v_PositionWorld=(u_WorldMat*a_Position).xyz;\n	#endif\n#endif\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(COLOR)&&defined(SPECULARMAP)||defined(NORMALMAP)))\n	#ifdef MIXUV\n		v_Texcoord0=mix(a_Texcoord0,a_TexcoordNext0,u_UVAge);\n	#else\n		v_Texcoord0=a_Texcoord0;\n	#endif\n	#ifdef UVTRANSFORM\n		v_Texcoord0=(u_UVMatrix*vec4(v_Texcoord0,0.0,1.0)).xy;\n	#endif\n#endif\n\n#ifdef AMBIENTMAP\n	#ifdef SCALEOFFSETLIGHTINGMAPUV\n		#ifdef UV1\n			v_LightMapUV=vec2(a_Texcoord1.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,1.0+a_Texcoord1.y*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n		#else\n			v_LightMapUV=vec2(a_Texcoord0.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,(a_Texcoord0.y-1.0)*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n		#endif \n	#else\n		#ifdef UV1\n			v_LightMapUV=a_Texcoord1;\n		#else\n			v_LightMapUV=a_Texcoord0;\n		#endif \n	#endif \n#endif\n\n#ifdef COLOR\n	v_Color=a_Color;\n#endif\n\n#ifdef RECEIVESHADOW\n	v_posViewZ = gl_Position.w;\n	#ifdef SHADOWMAP_PSSM1 \n		v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n	#endif\n#endif\n}\n\nvoid main()\n{\n#ifdef CASTSHADOW\n	main_castShadow();\n#else\n	main_normal();\n#endif\n}"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/PixelSimpleTextureSkinnedMesh.vs*/;
			ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#include?DIRECTIONLIGHT||POINTLIGHT||SPOTLIGHT \"LightHelper.glsl\";\n\nuniform vec4 u_Albedo;\n\n#ifdef ALPHATEST\nuniform float u_AlphaTestValue;\n#endif\n\n#ifdef DIFFUSEMAP\nuniform sampler2D u_DiffuseTexture;\n#endif\n\n#ifdef REFLECTMAP\nuniform samplerCube u_ReflectTexture;\nuniform vec3 u_MaterialReflect;\n#endif\n\n#if   defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(COLOR)&&defined(SPECULARMAP)||defined(NORMALMAP)))\nvarying vec2 v_Texcoord0;\n#endif\n\n#ifdef AMBIENTMAP\nvarying vec2 v_LightMapUV;\nuniform sampler2D u_AmbientTexture;\n#endif\n\n#ifdef COLOR\nvarying vec4 v_Color;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\nuniform vec3 u_MaterialDiffuse;\nuniform vec4 u_MaterialSpecular;\n  #if (defined(DIFFUSEMAP)||defined(COLOR))&&defined(SPECULARMAP) \n  uniform sampler2D u_SpecularTexture;\n  #endif\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(AMBIENTMAP)\nuniform vec3 u_MaterialAmbient;\n#endif\n\n#if defined(FOG)||defined(DEPTHFOG)\nuniform float u_FogStart;\nuniform float u_FogRange;\nuniform vec3 u_FogColor;\n#endif\n\n#ifdef MIXUV\nuniform float  u_UVAniAge;\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\nvarying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\nuniform sampler2D u_NormalTexture;\nvarying vec3 v_Tangent0;\n#endif\n\n#ifdef DIRECTIONLIGHT\nuniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\nuniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\nuniform SpotLight u_SpotLight;\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(DEPTHFOG)||defined(REFLECTMAP)||(defined(RECEIVESHADOW)&&(defined(SHADOWMAP_PSM2)||defined(SHADOWMAP_PSM3)))\nuniform vec3 u_CameraPos;\n#endif\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(DEPTHFOG)||defined(REFLECTMAP)\nvarying vec3 v_PositionWorld;\n#endif\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\nvarying float v_posViewZ;\n\nvoid main_castShadow()\n{\n	//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\n	gl_FragColor=packDepth(v_posViewZ);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n		if( alpha < u_AlphaTestValue )\n		{\n			discard;\n		}\n	#endif\n}\nvoid main_normal()\n{\n#if defined(DIFFUSEMAP)&&!defined(COLOR)\n	gl_FragColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n#endif \n  \n#if defined(COLOR)&&!defined(DIFFUSEMAP)\n	gl_FragColor=v_Color;\n#endif \n  \n#if defined(DIFFUSEMAP)&&defined(COLOR)\n	vec4 texColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n	gl_FragColor=texColor*v_Color;\n#endif\n  \n#if !defined(DIFFUSEMAP)&&!defined(COLOR)\n	gl_FragColor=vec4(1.0,1.0,1.0,1.0);\n#endif \n  \n#ifdef AMBIENTMAP\n	gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_AmbientTexture, v_LightMapUV).rgb); \n#endif \n	gl_FragColor=gl_FragColor*u_Albedo;\n  \n#ifdef ALPHATEST\n	if(gl_FragColor.a-u_AlphaTestValue<0.0)\n		discard;\n#endif\n  \n  \n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n	vec3 normal;\n    #if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n		vec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\n		normal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent0));\n	#else\n		normal = normalize(v_Normal);\n    #endif\n#endif\n	\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	vec3 diffuse = vec3(0.0);\n	vec3 ambient = vec3(0.0);\n	vec3 specular= vec3(0.0);\n	vec3 dif, amb, spe;\n#endif\n  \n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(REFLECTMAP)\n	vec3 toEye;\n	#ifdef FOG\n		toEye=u_CameraPos-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n	#else\n		toEye=normalize(u_CameraPos-v_PositionWorld);\n	#endif\n#endif\n	\n#ifdef DIRECTIONLIGHT\n	computeDirectionLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_DirectionLight,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n	computePointLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_PointLight,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n	ComputeSpotLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_SpotLight,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef RECEIVESHADOW\n	float shadowValue = 1.0;\n	#ifdef SHADOWMAP_PSSM3\n		shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif\n	#ifdef SHADOWMAP_PSSM2\n		shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif \n	#ifdef SHADOWMAP_PSSM1\n		shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n	#endif\n#endif\n  \n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	#if (defined(DIFFUSEMAP)||defined(COLOR))&&defined(SPECULARMAP)\n		specular =specular*texture2D(u_SpecularTexture, v_Texcoord0).rgb;\n    #endif\n	#ifdef RECEIVESHADOW\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse*shadowValue) + specular*shadowValue,gl_FragColor.a);\n	#else\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse) + specular,gl_FragColor.a);\n	#endif\n#endif\n  \n#ifdef REFLECTMAP\n	vec3 incident = -toEye;\n	vec3 reflectionVector = reflect(incident,normal);\n	vec3 reflectionColor  = textureCube(u_ReflectTexture,reflectionVector).rgb;\n	gl_FragColor.rgb += u_MaterialReflect*reflectionColor;\n#endif\n  \n#ifdef FOG\n	float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n#ifdef DEPTHFOG\n	float lerpFact = (-v_PositionWorld.y-u_FogStart)/u_FogRange;\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\nvoid main()\n{\n#ifdef CASTSHADOW		\n	main_castShadow();\n#else\n  main_normal();\n#endif  \n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/PixelSimpleTextureSkinnedMesh.ps*/;
			var shaderCompile=ShaderCompile3D.add(SIMPLE,vs,ps,attributeMap,uniformMap);
			StandardMaterial.SHADERDEFINE_DIFFUSEMAP=shaderCompile.registerMaterialDefine("DIFFUSEMAP");
			StandardMaterial.SHADERDEFINE_NORMALMAP=shaderCompile.registerMaterialDefine("NORMALMAP");
			StandardMaterial.SHADERDEFINE_SPECULARMAP=shaderCompile.registerMaterialDefine("SPECULARMAP");
			StandardMaterial.SHADERDEFINE_EMISSIVEMAP=shaderCompile.registerMaterialDefine("EMISSIVEMAP");
			StandardMaterial.SHADERDEFINE_AMBIENTMAP=shaderCompile.registerMaterialDefine("AMBIENTMAP");
			StandardMaterial.SHADERDEFINE_REFLECTMAP=shaderCompile.registerMaterialDefine("REFLECTMAP");
			StandardMaterial.SHADERDEFINE_UVTRANSFORM=shaderCompile.registerMaterialDefine("UVTRANSFORM");
			var SIMPLEVEXTEX=Shader3D.nameKey.add("SIMPLEVEXTEX");
			vs="#include?DIRECTIONLIGHT||POINTLIGHT||SPOTLIGHT \"LightHelper.glsl\";\n\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\n\n#include?VR \"VRHelper.glsl\";\n\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(COLOR)&&defined(SPECULARMAP))\nattribute vec2 a_Texcoord0;\nvarying vec2 v_Texcoord0;\n  #ifdef MIXUV\n  attribute vec2 a_TexcoordNext0;\n  uniform float  u_UVAge;\n  #endif\n  #ifdef UVTRANSFORM\n  uniform mat4 u_UVMatrix;\n  #endif\n#endif\n\n#ifdef AMBIENTMAP\nattribute vec2 a_Texcoord1;\nuniform vec4 u_LightmapScaleOffset;\nvarying vec2 v_Texcoord1;\n#endif\n\n\n#ifdef COLOR\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n#endif\n\n#ifdef BONE\nattribute vec4 a_BoneIndices;\nattribute vec4 a_BoneWeights;\nconst int c_MaxBoneCount = 24;\nuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\nattribute vec3 a_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(REFLECTMAP)\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\n#endif\n\n#ifdef DIRECTIONLIGHT\nuniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\nuniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\nuniform SpotLight u_SpotLight;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\nuniform vec3 u_MaterialDiffuse;\nuniform vec4 u_MaterialSpecular;\n\nvarying vec3 v_Diffuse;\nvarying vec3 v_Ambient;\nvarying vec3 v_Specular;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(AMBIENTMAP)\nuniform vec3 u_MaterialAmbient;\n#endif\n\n#ifdef FOG\nvarying float v_ToEyeLength;\n#endif\n\n#ifdef REFLECTMAP\nvarying vec3 v_ToEye;\nvarying vec3 v_Normal;\n#endif\n\n\nvoid main()\n{\n #ifdef BONE\n mat4 skinTransform=mat4(0.0);\n skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n vec4 position=skinTransform*a_Position;\n   #ifdef VR\n   gl_Position = DistortFishEye(u_MvpMatrix * position);\n   #else\n   gl_Position = u_MvpMatrix * position;\n   #endif\n #else\n   #ifdef VR\n   gl_Position = DistortFishEye(u_MvpMatrix * a_Position);\n   #else\n   gl_Position = u_MvpMatrix * a_Position;\n   #endif\n #endif\n \n \n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\n  #ifdef BONE\n  vec3 normal=normalize( mat3(u_WorldMat*skinTransform)*a_Normal);\n  #else\n  vec3 normal=normalize( mat3(u_WorldMat)*a_Normal);\n  #endif\n \n  #ifdef REFLECTMAP\n  v_Normal=normal;\n  #endif\n#endif\n \n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n  v_Diffuse=vec3(0.0);\n  v_Ambient=vec3(0.0);\n  v_Specular=vec3(0.0);\n  vec3 dif, amb, spe;\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(REFLECTMAP)\n  #ifdef BONE\n  vec3 positionWorld=(u_WorldMat*position).xyz;\n  #else\n  vec3 positionWorld=(u_WorldMat*a_Position).xyz;\n  #endif\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||defined(REFLECTMAP)\nvec3 toEye;\n  #ifdef FOG\n  toEye=u_CameraPos-positionWorld;\n  v_ToEyeLength=length(toEye);\n  toEye/=v_ToEyeLength;\n  #else\n  toEye=normalize(u_CameraPos-positionWorld);\n  #endif\n \n  #ifdef REFLECTMAP\n  v_ToEye=toEye;\n  #endif\n#endif\n \n#ifdef DIRECTIONLIGHT\ncomputeDirectionLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_DirectionLight,normal,toEye, dif, amb, spe);\nv_Diffuse+=dif;\nv_Ambient+=amb;\nv_Specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\ncomputePointLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_PointLight,positionWorld,normal,toEye, dif, amb, spe);\nv_Diffuse+=dif;\nv_Ambient+=amb;\nv_Specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\nComputeSpotLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_SpotLight,positionWorld,normal,toEye, dif, amb, spe);\nv_Diffuse+=dif;\nv_Ambient+=amb;\nv_Specular+=spe;\n#endif\n  \n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(COLOR)&&defined(SPECULARMAP))\n  #ifdef MIXUV\n  v_Texcoord0=mix(a_Texcoord0,a_TexcoordNext0,u_UVAge);\n  #else\n  v_Texcoord0=a_Texcoord0;\n  #endif\n  #ifdef UVTRANSFORM\n  v_Texcoord0=(u_UVMatrix*vec4(v_Texcoord0,0.0,1.0)).xy;\n  #endif\n#endif\n\n#ifdef AMBIENTMAP\n  #ifdef SCALEOFFSETLIGHTINGMAPUV\n  v_Texcoord1=vec2(a_Texcoord1.x*u_LightmapScaleOffset.x+u_LightmapScaleOffset.z,1.0+a_Texcoord1.y*u_LightmapScaleOffset.y+u_LightmapScaleOffset.w);\n  #else\n  v_Texcoord1=a_Texcoord1;\n  #endif \n#endif\n  \n#ifdef COLOR\nv_Color=a_Color;\n#endif\n}"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/VertexSimpleTextureSkinnedMesh.vs*/;
			ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec4 u_Albedo;\n\n#ifdef ALPHATEST\nuniform float u_AlphaTestValue;\n#endif\n\n#ifdef DIFFUSEMAP\nuniform sampler2D u_DiffuseTexture;\n#endif\n\n#ifdef REFLECTMAP\nuniform samplerCube u_ReflectTexture;\nuniform vec3 u_MaterialReflect;\n#endif\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(COLOR)&&defined(SPECULARMAP))\nvarying vec2 v_Texcoord0;\n#endif\n\n#ifdef AMBIENTMAP\nvarying vec2 v_Texcoord1;\nuniform sampler2D u_AmbientTexture;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(AMBIENTMAP)\nuniform vec3 u_MaterialAmbient;\n#endif\n\n#ifdef COLOR\nvarying vec4 v_Color;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\nvarying vec3 v_Diffuse;\nvarying vec3 v_Ambient;\nvarying vec3 v_Specular;\n  #if (defined(DIFFUSEMAP)||defined(COLOR))&&defined(SPECULARMAP)\n  uniform sampler2D u_SpecularTexture;\n  #endif\n#endif\n\n#ifdef FOG\nuniform float u_FogStart;\nuniform float u_FogRange;\nuniform vec3 u_FogColor;\nvarying float v_ToEyeLength;\n#endif\n\n#ifdef MIXUV\nuniform float  u_UVAniAge;\n#endif\n\n#ifdef REFLECTMAP\nvarying vec3 v_Normal;\nvarying vec3 v_ToEye;\n#endif\n\n\nvoid main()\n{\n #if defined(DIFFUSEMAP)&&!defined(COLOR)\n gl_FragColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n #endif \n \n #if defined(COLOR)&&!defined(DIFFUSEMAP)\n gl_FragColor=v_Color;\n #endif \n \n #if defined(DIFFUSEMAP)&&defined(COLOR)\n vec4 texColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n gl_FragColor=texColor*v_Color;\n #endif\n \n #if !defined(DIFFUSEMAP)&&!defined(COLOR)\n gl_FragColor=vec4(1.0,1.0,1.0,1.0);\n #endif \n \n #ifdef AMBIENTMAP\n gl_FragColor.rgb=gl_FragColor.rgb*(u_MaterialAmbient+texture2D(u_AmbientTexture, v_Texcoord1).rgb);\n #endif \n \n gl_FragColor=gl_FragColor*u_Albedo;\n  \n #ifdef ALPHATEST\n   if(gl_FragColor.a-u_AlphaTestValue<0.0)\n    discard;\n #endif\n \n \n #ifdef REFLECTMAP\n vec3 normal=normalize(v_Normal);\n #endif 	\n\n  \n #if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n   #if (defined(DIFFUSEMAP)||defined(COLOR))&&defined(SPECULARMAP)\n   vec3 specular =v_Specular*texture2D(u_SpecularTexture,v_Texcoord0).rgb;\n   gl_FragColor =vec4( gl_FragColor.rgb*(v_Ambient + v_Diffuse)+specular,gl_FragColor.a);\n   #else\n   gl_FragColor =vec4( gl_FragColor.rgb*(v_Ambient + v_Diffuse)+v_Specular,gl_FragColor.a);\n   #endif\n #endif\n \n #ifdef REFLECTMAP\n vec3 incident = -v_ToEye;\n vec3 reflectionVector = reflect(incident,v_Normal);\n vec3 reflectionColor  = textureCube(u_ReflectTexture,reflectionVector).rgb;\n gl_FragColor.rgb += u_MaterialReflect*reflectionColor;\n #endif\n \n #ifdef FOG\n float lerpFact=clamp((v_ToEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n #endif\n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/VertexSimpleTextureSkinnedMesh.ps*/;
			shaderCompile=ShaderCompile3D.add(SIMPLEVEXTEX,vs,ps,attributeMap,uniformMap);
			attributeMap={'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,'a_Color':/*laya.d3.graphics.VertexElementUsage.COLOR0*/1};
			uniformMap={'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2]};
			var LINE=Shader3D.nameKey.add("LINE");
			vs="#include?VR \"VRHelper.glsl\";\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n\n\nvoid main()\n{\n  gl_Position = u_MvpMatrix * a_Position;\n  v_Color=a_Color;\n}"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/line.vs*/;
			ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\n\nvoid main()\n{\n  gl_FragColor=v_Color; \n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/line.ps*/;
			ShaderCompile3D.add(LINE,vs,ps,attributeMap,uniformMap);
			attributeMap={
				'a_position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
				'a_normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
				'tangent':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5,
				'binormal':/*laya.d3.graphics.VertexElementUsage.BINORMAL0*/4,
				'uv':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
				'a_BoneWeights':/*laya.d3.graphics.VertexElementUsage.BLENDWEIGHT0*/7,
				'a_BoneIndices':/*laya.d3.graphics.VertexElementUsage.BLENDINDICES0*/6,
				'a_Tangent0':/*laya.d3.graphics.VertexElementUsage.TANGENT0*/5};
			uniformMap={
				'u_Bones':[ /*laya.d3.component.animation.SkinAnimations.BONES*/0,/*laya.d3.shader.Shader3D.PERIOD_RENDERELEMENT*/0],
				'u_lodRect':[ /*laya.d3.core.BaseCamera.SIMLODINFO*/9,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'irrad_mat_red':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATR*/10,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'irrad_mat_green':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATG*/11,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'irrad_mat_blue':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATB*/12,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_hdrexposure':[ /*laya.d3.core.BaseCamera.HDREXPOSURE*/13,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_aoObjPos':[ /*laya.d3.core.material.PBRMaterial.AOOBJPOS*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texBaseColor':[ /*laya.d3.core.material.PBRMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texNormal':[ /*laya.d3.core.material.PBRMaterial.NORMALTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texPbrInfo':[ /*laya.d3.core.material.PBRMaterial.PBRINFOTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texPrefilterdEnv':[ /*laya.d3.core.BaseCamera.ENVIRONMENTSPECULAR*/8,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'texHSNoise':[ /*laya.d3.core.material.PBRMaterial.HSNOISETEXTURE*/15,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texPrefilterDiff':[ /*laya.d3.core.BaseCamera.ENVIRONMENTDIFFUSE*/7,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_AlphaTestValue':[ /*laya.d3.core.material.BaseMaterial.ALPHATESTVALUE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texBRDFLUT':[ /*laya.d3.core.material.PBRMaterial.PBRLUTTEXTURE*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_UVAniAge':[ /*laya.d3.core.material.PBRMaterial.UVANIAGE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_roughness':[ /*laya.d3.core.material.PBRMaterial.MATERIALROUGHNESS*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_metaless':[ /*laya.d3.core.material.PBRMaterial.MATERIALMETALESS*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_UVMatrix':[ /*laya.d3.core.material.PBRMaterial.UVMATRIX*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_UVAge':[ /*laya.d3.core.material.PBRMaterial.UVAGE*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'modelMatrix':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'mvp':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'cameraPosition':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_View':[ /*laya.d3.core.BaseCamera.VIEWMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_Project':[ /*laya.d3.core.BaseCamera.PROJECTMATRIX*/2,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_FogStart':[ /*laya.d3.core.scene.BaseScene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_FogRange':[ /*laya.d3.core.scene.BaseScene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_FogColor':[ /*laya.d3.core.scene.BaseScene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_DirectionLight.Direction':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRDIFFUSE*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_DirectionLight.Ambient':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRAMBIENT*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_DirectionLight.Specular':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRSPECULAR*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_PointLight.Position':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTPOS*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_PointLight.Range':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTRANGE*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_PointLight.Attenuation':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTATTENUATION*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_PointLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTDIFFUSE*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_PointLight.Ambient':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTAMBIENT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_PointLight.Specular':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTSPECULAR*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_SpotLight.Position':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTPOS*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_SpotLight.Direction':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTDIRECTION*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_SpotLight.Range':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTRANGE*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_SpotLight.Spot':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTSPOT*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTATTENUATION*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTDIFFUSE*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_SpotLight.Ambient':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTAMBIENT*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_SpotLight.Specular':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTSPECULAR*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_shadowMap1':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE1*/24,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowMap2':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE2*/25,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowMap3':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE3*/26,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowPSSMDistance':[ /*laya.d3.core.scene.BaseScene.SHADOWDISTANCE*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_lightShadowVP':[ /*laya.d3.core.scene.BaseScene.SHADOWLIGHTVIEWPROJECT*/22,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowPCFoffset':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPPCFOFFSET*/23,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
			var PBR=Shader3D.nameKey.add("PBR");
			vs="\nuniform mat4 modelMatrix;\n//uniform mat4 modelViewMatrix;\n//uniform mat4 projectionMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Project;\nuniform mat4 mvp;\n//uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\n#ifdef HAS_TANGENT\nattribute vec3 tangent;\nattribute vec3 binormal;\n#endif\nattribute vec2 uv;\n#ifdef BONE\nattribute vec4 a_BoneIndices;\nattribute vec4 a_BoneWeights;\nconst int c_MaxBoneCount = 24;\nuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying vec3 vLightDir;\nvarying vec3 vViewDir;\n#ifdef HAS_TANGENT\nvarying vec3 vWorldTangent;\nvarying vec3 vWorldBinormal;\n#endif\n\n#ifdef RECEIVESHADOW\nvarying float v_posViewZ;\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\nvoid main() {\n#ifdef BONE\n	mat4 skinTransform=mat4(0.0);\n	skinTransform += u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n	skinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n	skinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n	skinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n	gl_Position = mvp*skinTransform*vec4(a_position,1.);\n	mat4 modelMat = modelMatrix*skinTransform;\n#else\n	gl_Position = mvp*vec4(a_position,1.);\n	mat4 modelMat = modelMatrix;\n#endif	\n	vWorldPos = modelMat*vec4(a_position,1.);\n\n#ifdef CASTSHADOW \n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		vUv = uv;\n	#endif	\n#else\n    vUv = uv;\n	vWorldNorm = normalize((modelMat*vec4(a_normal,0.0)).xyz);\n	#ifdef HAS_TANGENT\n	vWorldTangent = normalize((modelMat*vec4(tangent,0.0)).xyz);\n	vWorldBinormal = normalize((modelMat*vec4(binormal,0.0)).xyz);\n	#endif\n    \n    vViewDir = (vWorldPos.xyz-cameraPosition);//这个不能normalize。否则无法线性差值了\n#ifdef RECEIVESHADOW\n	v_posViewZ = gl_Position.z;\n	#ifdef SHADOWMAP_PSSM1 \n		v_lightMVPPos = u_lightShadowVP[0] * vWorldPos;\n	#endif\n#endif	\n#endif\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/PBR.vs*/;
			ps="//#version 300 es\n\nprecision highp float;\nprecision lowp int;\n\nconst float PI = 3.14159265358979323846264;\nconst float _2PI = 6.2831853071796;\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\n#ifdef HAS_TANGENT\nvarying vec3 vWorldTangent;\nvarying vec3 vWorldBinormal;\n#endif\nvarying vec3 vViewDir;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\n//\nuniform sampler2D texBaseColor;\nuniform sampler2D texNormal;\n//预计算的贴图\nuniform sampler2D texPrefilterdEnv;\nuniform sampler2D texBRDFLUT;\nuniform sampler2D texPrefilterDiff;\n#ifdef HAS_PBRINFO\nuniform sampler2D texPbrInfo;   //Ao, Roughness, Metallic\n#endif\n#ifdef USE_GROUNDTRUTH\nuniform sampler2D texHSNoise;\n#endif\nuniform float u_hdrexposure;\nuniform float u_AlphaTestValue;\n\nuniform float u_roughness;\nuniform float u_metaless;\nconst float maxlv = 7.;	//现在只支持512分辨率的环境贴图\nconst int nmaxlv = 9;//\n//atlas\n//uniform vec4 u_lodRect[10];//现在只支持512分辨率的环境贴图，所以只有10个，[0]是原始， [9]是1x1.\n							//[u,v,w,h]。w,h都是0到1\n							\nuniform mat4 irrad_mat_red;\nuniform mat4 irrad_mat_green;\nuniform mat4 irrad_mat_blue;							\n\nuniform vec4 u_aoObjPos[2];\n\nvec3 u_lightColor = vec3(1.,1.,1.);\nvec3 u_diffuseColor = vec3(0.1,0.1,0.1);\nvec3 speccontrib = vec3(0.);\n\nconst float _maxu8 = 255.0;\nconst float _maxu16 = 65535.0;\nconst float _shift8 = 256.0;    //平移的话是*256而不是255\nvec2 _RGBAToU16(const in vec4 rgba){\n    return vec2((rgba.r*_maxu8+rgba.g*_maxu8*_shift8)/_maxu16, (rgba.b*_maxu8+rgba.a*_maxu8*_shift8)/_maxu16);\n}\nvec3 _RGBEToRGB( const in vec4 rgba ){\n    float f = pow(2.0, rgba.w * 255.0 - (128.0 + 8.0));\n    return rgba.rgb * (255.0 * f);\n}\n/*\nvec2 frexp(float value) {\n	float e = floor(log2(value));\n	float s = value/pow(2.,e);\n	return vec2(s,e);\n}\n*/\n\nvec2 frexp(float x){\n   float e = ceil(log2(x));\n   return vec2(x * exp2(-e),e);\n}\n\nvec4 _RGBtoRGBE(vec3 rgb){\n    float v = rgb.x;\n    if (rgb.y > v) v = rgb.y;  \n    if (rgb.z > v) v = rgb.z;  \n    if (v < 1e-32) {  \n        return vec4(0.0);\n    }  \n    else {\n        vec2 e = frexp(v);\n        v = e.x /v; //当某个值为v的时候，其尾数就是e[0]。 这里*256了，所以反向的时候有个/256即-(128+8)里的8\n                            //e[0]永远不会为1所以结果<256\n		return vec4(rgb.xyz*v, e.y+0.5);\n    }\n}\n\nfloat saturate(float v){\n    return min(max(v,0.),1.);\n}\n\nvec4 tex2dLod(sampler2D tex, float u, float v, float lod){\n	vec2 uv = vec2(u,v);\n	uv+=mod(gl_FragCoord.xy-vec2(0.5),2.0)*vec2(128.,0.);\n	return texture2D(tex,uv,lod-16.);//16=log(512)+log(128)\n}\n\n/*\n* 对一个全景图进行采样。假设x轴指向中心。\n*/\nvec4 texPanorama(sampler2D tex, const in vec3 dir){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return texture2D(tex,vec2(envu,envv));\n}\n\nvec4 texPanoramaLod(sampler2D tex, const in vec3 dir, float lod){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return tex2dLod(tex,envu,envv,lod);\n}\n\nvec4 ApproximateSpecularIBL( vec3 SpecularColor , float Roughness , float NoV, vec3 R){\n    vec4 PrefilteredColor = texPanoramaLod(texPrefilterdEnv, R, Roughness*maxlv);\n    PrefilteredColor.rgb = _RGBEToRGB(PrefilteredColor);\n    vec4 EnvBRDF = texture2D(texBRDFLUT,vec2(Roughness , NoV));//TODO lod\n    vec2 rg = _RGBAToU16(EnvBRDF);    \n    //原来的括号不对\n    speccontrib = (SpecularColor* rg.x + saturate( 50.0 * PrefilteredColor.g ) * rg.y);\n    return vec4(PrefilteredColor.rgb, speccontrib);\n}\n\nvec3 testDiff(vec3 dir){\n	return texPanorama(texPrefilterDiff, dir).rgb;\n}\n/*\n    计算sh光照。\n    使用level=2，所以需要9个系数。\n    https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n*/\nfloat environment_exposure = 1.0;\nvec3 diff_sh9(vec3 dir){\n	vec4 shDir = vec4(dir.x,-dir.z,dir.y,1.0);\n  return max(vec3(0.0), vec3(\n	dot(shDir, irrad_mat_red * shDir),\n	dot(shDir, irrad_mat_green * shDir),\n	dot(shDir, irrad_mat_blue * shDir)\n	)) * environment_exposure;	\n}\n\n#ifdef HAS_TANGENT\nvec3 applyNormalTex( vec3 norm, vec3 surf_norm ) {\n    vec3 mapN = norm * 2.0 - 1.0;\n    //mapN.xy = normalScale * mapN.xy;\n    mat3 tsn = mat3( vWorldTangent, vWorldBinormal, surf_norm );\n    return normalize( tsn * mapN );\n}\n#endif\n\n#ifdef USE_GROUNDTRUTH\n\nfloat G_Smith( float Roughness, float NoV, float NoL ){\n    float k= Roughness * sqrt(2.0/3.14159265);\n    float one_minus_k= 1.0 -k;\n    return ( NoL / (NoL * one_minus_k + k) ) * ( NoV / (NoV * one_minus_k + k));\n}\n/*\nvec2 Hammersley(int i, int NumSamples){\n    return hammersley2d(i,NumSamples);\n}\n*/\n//https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n//Image-Based Lighting\n//P4\n// N的作用是用来把生成的H转换到世界空间用。\nvec3 ImportanceSampleGGX( vec2 Xi, float Roughness, vec3 N ){\n    float a = Roughness * Roughness;\n    float Phi = 2. * PI * Xi.x;//与水平面x轴的夹角\n    float CosTheta = sqrt( (1. - Xi.y) / ( 1. + (a*a - 1.) * Xi.y ) );\n    float SinTheta = sqrt( 1. - CosTheta * CosTheta );\n    vec3 H;\n    //TODO 这里需要修改朝向么，坐标系\n    H.x = SinTheta * cos( Phi );\n    H.y = SinTheta * sin( Phi );\n    H.z = CosTheta;//Z向上，应该对应N\n    vec3 UpVector = abs(N.z) < 0.9999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);\n    vec3 TangentX = normalize( cross( UpVector,N ) );\n    vec3 TangentY = cross( N, TangentX );\n    // Tangent to world space\n    return TangentX * H.x + TangentY * H.y + N * H.z;\n}\n\n/*\n    环境贴图的预处理。\n    R 是入射灯光的朝向。\n    实际计算的时候用这个作为N来转换返回的H\n	TODO 以后换成SP的方式。\n*/\nvec3 PrefilterEnvMap( float Roughness , vec3 R ){\n    vec3 N = R;//TODO 用优化么\n    vec3 V = R;\n    vec3 PrefilteredColor = vec3(0.,0.,0.);\n    float TotalWeight = 0.;\n	float tx = 0.;\n	float ty = 0.;\n    const int NumSamples = 1024;\n	const float fNumSamples = 1024.0;\n    for( int i = 0; i < NumSamples; i++ ) {\n		float fi = float(i);\n        ty = floor(fi/32.0)/32.0;\n        tx = mod(fi,32.0)/32.0;\n        vec2 Xi = vec2(fi/fNumSamples,texture2D(texHSNoise,vec2(tx,ty)).r);// Hammersley( i, NumSamples );\n        vec3 H = ImportanceSampleGGX( Xi, Roughness , N );\n        vec3 L = 2. * dot( V, H ) * H - V;\n        float NoL = max( dot( N, L ),0. );\n        if( NoL > 0. ){\n            //vec4 SampleColor=texPanorama(texEnv, L);\n			vec4 SampleColor = texPanoramaLod(texPrefilterdEnv, L,0.);\n            SampleColor.rgb = _RGBEToRGB(SampleColor);\n            PrefilteredColor += SampleColor.rgb * NoL;\n            TotalWeight += NoL;\n        }\n    }\n    return PrefilteredColor / TotalWeight;\n}\n\n/*\n    BRDF部分的积分的预处理。\n    在排除F0以后，剩下的可以预计算了。\n    输入为 Roughness 和 cosθ。\n*/\nvec2 IntegrateBRDF( float Roughness , float NoV ){\n    vec3 N=vec3(0.,0.,1.);//TODO 为什么是 001呢\n    vec3 V;\n    V.x = sqrt( 1.0 - NoV * NoV ); // sin\n    V.y = 0.;\n    V.z = NoV; // cos\n    float A = 0.;\n    float B = 0.;\n	float tx = 0.;\n	float ty = 0.;\n    const int NumSamples = 1024;\n	const float fNumSamples = 1024.0;\n    for( int i = 0; i < NumSamples; i++ ){\n		float fi = float(i);\n        ty = floor(fi/32.0)/32.0;\n        tx = mod(fi,32.0)/32.0;\n        vec2 Xi = vec2(fi/fNumSamples,texture2D(texHSNoise,vec2(tx,ty)).r);// Hammersley( i, NumSamples );\n        vec3 H = ImportanceSampleGGX( Xi, Roughness , N );\n        vec3 L = 2. * dot( V, H ) * H - V;\n        float NoL = saturate( L.z );\n        float NoH = saturate( H.z );\n        float VoH = saturate( dot( V, H ) );\n        if( NoL > 0. ){\n            float G = G_Smith( Roughness , NoV, NoL );\n            float G_Vis = G * VoH / (NoH * NoV);\n            float Fc = pow( 1. - VoH, 5. );\n            A += (1. - Fc) * G_Vis; //F0的缩放部分 A*F0+B\n            B += Fc * G_Vis;        //F0的偏移部分\n        }\n    }\n    return vec2( A, B ) / fNumSamples;\n}\n\nvec4 pbrlight(vec3 normal, float rough, float NoV, vec3 R){\n    vec4 basecolor = texture2D(texBaseColor,vUv);\n	float metaless = 1.0; 	\n	const float ismetalinfov = (128./255.);\n	if(basecolor.a>=ismetalinfov){//这时候表示金属度\n		metaless = (basecolor.a-ismetalinfov)*2.;\n		basecolor.a = 1.0;\n	}else{\n		metaless = 0.;\n		basecolor.a = basecolor.a*2.0;\n	}\n	#ifdef FIX_METALESS\n	metaless = u_metaless;\n	#endif\n	#ifdef HAS_PBRINFO	\n	vec4 pbrinfo = texture2D(texPbrInfo, vUv);\n	#endif\n    //vec4 pbrinfo = texture2D(texORM,vUv);\n    const vec3 nonmetalF0 =vec3(0.05);\n    vec3 F0 =  mix(nonmetalF0, basecolor.rgb, metaless);\n    //vec4 color_spec = ApproximateSpecularIBL(F0,rough, NoV, R);\n    vec3 PrefilteredColor = PrefilterEnvMap( rough , R );\n    vec2 EnvBRDF = IntegrateBRDF( rough , NoV );\n	speccontrib =  F0 * EnvBRDF.x + EnvBRDF.y;\n	vec3 color_spec = PrefilteredColor * speccontrib;\n	vec3 color_diff=diff_sh9(normal);//testDiff(normal);//\n	vec3 outc = color_diff*mix(basecolor.rgb,vec3(0.),metaless)*(vec3(1.0)-speccontrib)+color_spec*u_hdrexposure;\n    return vec4(outc,basecolor.a);//TODO 这里应该没有括号\n}\n#else\nvec4 pbrlight(vec3 normal, float rough, float NoV, vec3 R){\n    vec4 basecolor = texture2D(texBaseColor,vUv);\n	float metaless = 1.0; 	\n	const float ismetalinfov = (128./255.);\n	if(basecolor.a>=ismetalinfov){//这时候表示金属度\n		metaless = (basecolor.a-ismetalinfov)*2.;\n		basecolor.a = 1.0;\n	}else{\n		metaless = 0.;\n		basecolor.a = basecolor.a*2.0;\n	}\n	#ifdef FIX_METALESS\n	metaless = u_metaless;\n	#endif\n	#ifdef HAS_PBRINFO	\n	vec4 pbrinfo = texture2D(texPbrInfo, vUv);\n	#endif\n    //vec4 pbrinfo = texture2D(texORM,vUv);\n    const vec3 nonmetalF0 =vec3(0.05);\n    vec3 F0 =  mix(nonmetalF0, basecolor.rgb, metaless);\n    //vec4 color_spec = ApproximateSpecularIBL(F0,rough, NoV, R);\n	\n    vec4 PrefilteredColor = texPanoramaLod(texPrefilterdEnv, R, rough*maxlv);\n    PrefilteredColor.rgb = _RGBEToRGB(PrefilteredColor);\n    vec4 EnvBRDF = texture2D(texBRDFLUT,vec2(rough , NoV));//TODO lod\n    vec2 rg = _RGBAToU16(EnvBRDF);    \n    //原来的括号不对\n    speccontrib = (F0* rg.x + saturate( 50.0 * PrefilteredColor.g ) * rg.y);\n	vec3 color_spec = PrefilteredColor.rgb*speccontrib;\n	\n	vec3 color_diff=diff_sh9(normal);//testDiff(normal);//\n	//return vec4(color_diff,basecolor.a);\n	//一起控制的话，diff总也不好\n	//vec3 outc = (color_diff*mix(basecolor.rgb,vec3(0.),metaless)+color_spec)*u_hdrexposure;\n	#ifdef HAS_PBRINFO\n	float ao = pbrinfo.r;\n	vec3 outc = (color_diff*mix(basecolor.rgb,vec3(0.),metaless)+color_spec*u_hdrexposure)*ao;\n	#else\n	vec3 outc = color_diff*mix(basecolor.rgb,vec3(0.),metaless)*(vec3(1.0)-speccontrib)+color_spec*u_hdrexposure;\n	#endif\n    return vec4(outc, basecolor.a);\n}\n#endif\n\nvec3 oldlight(vec4 normal, float NoV, vec3 R){\n    vec4 basecolor = texture2D(texBaseColor,vUv);\n    //vec4 pbrinfo = texture2D(texORM,vUv);\n	const vec3 lightdir=normalize(vec3(1.,1.,0.));\n	const vec3 spcecol = vec3(1.,0.8,0.8);\n	const vec3 amb = vec3(0.5);\n	vec3 diffv =  (vec3(saturate(dot(lightdir,normal.xyz)))+amb);\n	//vec3 spec = spcecol* pow(saturate(dot(R,lightdir)),(1.-pbrinfo.g)*5.);\n	return diffv*basecolor.rgb;//+spec;\n}\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\nvarying float v_posViewZ;\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\n\nfloat calcAO(vec3 worldpos,vec3 normal, vec3 surfacenorm){\n	//const vec4 u_aoObjPos = vec4(-0.2,0.11,0.0,.1);\n	float k = 1.;\n	for( int i=0; i<2; i++){\n		float r = u_aoObjPos[i].w;\n		float d = max(length(u_aoObjPos[i].xyz-worldpos),r);\n		k *= sqrt(d*d-r*r)/d;\n	}\n	return k;\n}\n\nvec2 packf(float v){\n	float iv = v*255.;\n	float l = mod(iv,256.)/255.;\n	float h = floor(iv/256.)/255.;\n	return vec2(h,l);\n}\n\nfloat unpackf(vec2 v){\n	return (v.x*255.*256.+v.y*255.)/255.;\n}\n\nvoid main() {\n#ifdef CASTSHADOW\n	gl_FragColor=packDepth(gl_FragCoord.w);\n	#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n		float alpha = texture2D(texBaseColor,vUv).w;\n		if( alpha < u_AlphaTestValue ){\n			discard;\n		}\n	#endif\n#else\n\n	#ifdef RECEIVESHADOW\n		float shadowValue = 1.0;\n		#ifdef SHADOWMAP_PSSM3\n			shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,vWorldPos.xyz,v_posViewZ,0.0001);\n		#endif\n		#ifdef SHADOWMAP_PSSM2\n			shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,vWorldPos.xyz,v_posViewZ,0.0001);\n		#endif \n		#ifdef SHADOWMAP_PSSM1\n			shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.0001);\n		#endif\n	#endif	\n	\n    vec3 normal =  normalize(vWorldNorm);\n	vec3 smoothnorm = normal;\n	vec4 normtex = texture2D( texNormal, vUv );\n	#ifdef HAS_TANGENT	\n	normal = applyNormalTex(normtex.xyz, normal);\n	#endif\n    vec3 view   = -normalize(vViewDir);\n    float NoV = saturate(dot( view, normal ));\n    vec3 R = 2. * NoV * normal - view;\n	float roughness = normtex.a;\n	#ifdef FIX_ROUGHNESS\n	roughness = u_roughness;\n	#endif\n	\n	#ifdef CLIPZ\n	if(vWorldPos.z>2.0 || vWorldPos.z<-2.0)\n		discard;\n	#endif\n	vec4 pbrl = pbrlight(normal,roughness,NoV,R);\n    gl_FragColor.rgb =  pbrl.rgb;\n	//gl_FragColor.rgb = oldlight(normtex,NoV,R);\n	#ifdef RECEIVESHADOW\n	gl_FragColor.rgb *= max(shadowValue,0.7);\n	#endif\n	\n	//gl_FragColor.rgb *= calcAO(vWorldPos.xyz, normal, smoothnorm);\n    gl_FragColor.a = pbrl.a;\n\n#endif\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/PBR.ps*/;
			shaderCompile=ShaderCompile3D.add(PBR,vs,ps,attributeMap,uniformMap);
			PBRMaterial.SHADERDEFINE_FIX_METALESS=shaderCompile.registerMaterialDefine("FIX_METALESS");
			PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS=shaderCompile.registerMaterialDefine("FIX_ROUGHNESS");
			PBRMaterial.SHADERDEFINE_HAS_TANGENT=shaderCompile.registerMaterialDefine("HAS_TANGENT");
			PBRMaterial.SHADERDEFINE_HAS_PBRINFO=shaderCompile.registerMaterialDefine("HAS_PBRINFO");
			PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH=shaderCompile.registerMaterialDefine("USE_GROUNDTRUTH");
			PBRMaterial.SHADERDEFINE_TEST_CLIPZ=shaderCompile.registerMaterialDefine("CLIPZ");
			attributeMap={
				'a_position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
				'a_normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
				'uv':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2
			};
			uniformMap={
				'irrad_mat_red':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATR*/10,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'irrad_mat_green':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATG*/11,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'irrad_mat_blue':[ /*laya.d3.core.BaseCamera.DIFFUSEIRRADMATB*/12,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_hdrexposure':[ /*laya.d3.core.BaseCamera.HDREXPOSURE*/13,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'texBaseColor':[ /*laya.d3.core.material.WaterMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texNormal':[ /*laya.d3.core.material.WaterMaterial.NORMALTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texSky':[ /*laya.d3.core.material.WaterMaterial.SKYTEXTURE*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texUnderWater':[ /*laya.d3.core.material.WaterMaterial.UNDERWATERTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texPrefilterdEnv':[ /*laya.d3.core.BaseCamera.ENVIRONMENTSPECULAR*/8,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'texPrefilterDiff':[ /*laya.d3.core.BaseCamera.ENVIRONMENTDIFFUSE*/7,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'texWaterDisp':[ /*laya.d3.core.material.WaterMaterial.VERTEXDISPTEXTURE*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texWaveDetail':[ /*laya.d3.core.material.WaterMaterial.DETAILTEXTURE*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texDeepColor':[ /*laya.d3.core.material.WaterMaterial.DEEPCOLORTEXTURE*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texWaterInfo':[ /*laya.d3.core.material.WaterMaterial.WATERINFO*/16,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'texFoam':[ /*laya.d3.core.material.WaterMaterial.FOAMTEXTURE*/17,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'GEOWAVE_UV_SCALE':[ /*laya.d3.core.material.WaterMaterial.GEOWAVE_UV_SCALE*/18,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'modelMatrix':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'mvp':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'cameraPosition':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_curTm':[ /*laya.d3.core.material.WaterMaterial.CURTM*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_scrsize':[ /*laya.d3.core.material.WaterMaterial.SCRSIZE*/15,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_WaveInfoD':[ /*laya.d3.core.material.WaterMaterial.WAVEINFOD*/13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_WaveInfo':[ /*laya.d3.core.material.WaterMaterial.WAVEINFO*/12,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_WaveMainDir':[ /*laya.d3.core.material.WaterMaterial.WAVEMAINDIR*/14,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_SeaColor':[ /*laya.d3.core.material.WaterMaterial.SEA_COLOR*/19,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_View':[ /*laya.d3.core.BaseCamera.VIEWMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_Project':[ /*laya.d3.core.BaseCamera.PROJECTMATRIX*/2,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_FogStart':[ /*laya.d3.core.scene.BaseScene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_FogRange':[ /*laya.d3.core.scene.BaseScene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_FogColor':[ /*laya.d3.core.scene.BaseScene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Direction':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRDIFFUSE*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Ambient':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRAMBIENT*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Specular':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRSPECULAR*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Position':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTPOS*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Range':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTRANGE*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Attenuation':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTATTENUATION*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTDIFFUSE*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Ambient':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTAMBIENT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Specular':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTSPECULAR*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Position':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTPOS*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Direction':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTDIRECTION*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Range':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTRANGE*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Spot':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTSPOT*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTATTENUATION*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTDIFFUSE*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Ambient':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTAMBIENT*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Specular':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTSPECULAR*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]
			};
			var Water=Shader3D.nameKey.add("Water");
			vs="\nuniform mat4 modelMatrix;\n//uniform mat4 modelViewMatrix;\n//uniform mat4 projectionMatrix;\nuniform mat4 u_View;\nuniform mat4 u_Project;\nuniform mat4 mvp;\n//uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\nuniform float u_curTm;\n\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 uv;\n//uniform sampler2D texWaterDisp;\nuniform sampler2D texWaterInfo;\nuniform float u_WaveMainDir;	//主波方向\n\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec3 vWorldTan;\nvarying vec3 vWorldBin;\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying vec3 vLightDir;\nvarying vec3 vViewDir;\nvarying vec3 vDisp;\nvarying float fDeep;\nvarying mat2 matUVTrans;\nvarying vec4 vWaterInfo;\nvarying float fFoam;\n\nconst float PI = 3.14159265358979323846264;\n\n#include \"WaveFunction.glsl\"\n\nvec2 getPosFromUV(vec2 uv){\n	return uv*50.;\n}\n\nvoid main() {\n	vec3 pos = a_position;\n	float tt = pos.y;\n	pos.y=pos.z; pos.z=-tt;\n    vUv = uv;\n	//vDisp = texture2D(texWaterDisp,uv).rgb;\n	//vec3 disp = vDisp;\n	\n	fDeep = -pos.y;\n	vWaterInfo = texture2D(texWaterInfo,uv);\n	fDeep = vWaterInfo.r;\n	\n	pos.y=0.0;\n	\n	//计算波形\n	vec3 opos, T,B,N;\n	float foams=0.;\n	calcGerstnerWave(u_curTm, pos,fDeep, uv,opos,B,T,N,foams);\n	fFoam = foams;\n	gl_Position = mvp*vec4(opos,1.);\n	mat4 modelMat = modelMatrix;\n	vWorldPos = modelMat*vec4(opos,1.);\n\n	vWorldNorm = normalize((modelMatrix*vec4(N,0.0)).xyz);\n	vWorldTan = normalize((modelMatrix*vec4(T,0.0)).xyz);\n	vWorldBin = normalize((modelMatrix*vec4(B,0.0)).xyz);\n    vViewDir = vWorldPos.xyz-cameraPosition; //这个不能取normalize，否则会引入非线性\n	\n	float s = sin(u_WaveMainDir);\n	float c = cos(u_WaveMainDir);\n	matUVTrans = mat2(c,-s,s,c);\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/water.vs*/;
			ps="//#version 300 es\n\nprecision highp float;\nprecision lowp int;\n\nconst float PI = 3.14159265358979323846264;\nconst float _2PI = 6.2831853071796;\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec3 vWorldTan;\nvarying vec3 vWorldBin;\nvarying vec3 vViewDir;//入射。pos-cam\nvarying vec4 vViewPos;\nvarying vec4 vWorldPos;\nvarying vec3 vDisp;\n//varying float fDeep;\nvarying mat2 matUVTrans;\nvarying vec4 vWaterInfo;\nmat3 matTBNOff;//\n\n//\nuniform sampler2D texBaseColor;\nuniform sampler2D texNormal;\n#ifdef CUBE_ENV\nuniform samplerCube texSky;\n#else\nuniform sampler2D texSky;\n#endif\nuniform sampler2D texUnderWater;\nuniform sampler2D texWaveDetail;\n//uniform sampler2D texDeepColor;\nuniform sampler2D texFoam;\nvarying float fFoam;\nuniform float u_curTm;\nuniform vec2 u_scrsize;\nuniform vec3 u_SeaColor;//\n\nconst int NumTexWaves=4;\nconst float Amp_over_L = 0.01;\n//const vec3 SEA_COLOR1 = vec3(0.0292,0.672,0.7467);//大洋\n//const vec3 SEA_COLOR2 = vec3(0,0.927,0.43);//近海\n\nconst float _maxu8 = 255.0;\nconst float _maxu16 = 65535.0;\nconst float _shift8 = 256.0;    //平移的话是*256而不是255\nvec2 _RGBAToU16(const in vec4 rgba){\n    return vec2((rgba.r*_maxu8+rgba.g*_maxu8*_shift8)/_maxu16, (rgba.b*_maxu8+rgba.a*_maxu8*_shift8)/_maxu16);\n}\nvec3 _RGBEToRGB( const in vec4 rgba ){\n    float f = pow(2.0, rgba.w * 255.0 - (128.0 + 8.0));\n    return rgba.rgb * (255.0 * f);\n}\n\nfloat saturate(float v){\n    return min(max(v,0.),1.);\n}\n\n/*\n	各种 ToneMap\n*/\n//Reinhard\nvec3 ReinhardToneMapping(vec3 color, float adapted_lum) {\n    const float MIDDLE_GREY = 1.;\n    color *= MIDDLE_GREY / adapted_lum;\n    return color / (1.0 + color);\n}\n\n//CE2\nvec3 CEToneMapping(vec3 color, float adapted_lum){\n    return 1. - exp(-adapted_lum * color);\n}\n\n//UC2\nvec3 F1(vec3 x){\n	const float A = 0.22;\n	const float B = 0.30;\n	const float C = 0.10;\n	const float D = 0.20;\n	const float E = 0.01;\n	const float F = 0.30;\n \n	return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n\nvec3 Uncharted2ToneMapping(vec3 color, float adapted_lum){\n	const vec3 WHITE = vec3(11.2);\n	return F1(1.6 * adapted_lum * color) / F1(WHITE);\n}\n\n//ACES\nvec3 ACESToneMapping(vec3 color, float adapted_lum){\n	const float A = 2.51;\n	const float B = 0.03;\n	const float C = 2.43;\n	const float D = 0.59;\n	const float E = 0.14;\n\n	color *= adapted_lum;\n	return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\n/*\n* 对一个全景图进行采样。假设x轴指向中心。\n*/\nvec4 texPanorama(sampler2D tex, const in vec3 dir){\n	float envu = atan(dir.z,dir.x)/_2PI+0.5; 	\n	float envv = acos(dir.y)/PI;//(1.0-dir.y)/2.0;\n	return texture2D(tex,vec2(envu,envv));\n}\n\n/*\n	与位于0点的测试棒的相交测试交点\n	这个是瞎写的，只是为了测试\n*/\nbool hitClydiner(vec3 pos, vec3 dir, out vec3 hitpos, out vec3 hitnormal){\n	const float r = 0.5;\n	float a = dir.x*dir.x+dir.z*dir.z;\n	float b = 2.*dir.x*pos.x+2.*dir.z*pos.z;\n	float c = pos.x*pos.x+pos.z*pos.z-r*r;\n	float d = b*b-4.*a*c;\n	if(d>=0.0){\n		float t = (-b+sqrt(d))/2./a;\n		t =min(t, (-b-sqrt(d))/2./a);\n		hitpos = pos+dir*t;\n		return true;\n	}\n	/*\n	vec3 v1 = normalize(cross(dir,vec3(0.,1.,0.)));//公垂线\n	float dist = dot(pos,v1);//最短距离\n	if(abs(dist)<r){\n		return true;\n	}\n	*/\n	return false;\n}\n\n///* 根据散射公式来计算某个方向的颜色 *///\n//\nfloat phase_function(float costheta, float g, float g2){\n	return 1.5*( (1.0-g2) / (2.0+g2) ) * (1.0+costheta*costheta) / pow(1.0+g2-2.0*g*costheta, 1.5);	\n}\n\nconst float _density = .2;\nconst vec3 _vLightDir=vec3(0.,-1.,0.);//必须是规格化的\nconst int _SAMPLENUM = 20;\nconst float _K1 = 1.0;\nconst float _g = -0.93;\n//\nvec3 calcScatter(vec3 start, vec3 dir, vec3 end){\n	float len = length(end-start);\n	float costheta = dot(dir,_vLightDir);\n	float g2 = _g*_g;\n	float K = _K1*len*_density*phase_function(costheta,_g,g2);\n	//用分段的方式来积分\n	float dlen = len/float(_SAMPLENUM);//距离平分\n	float ddeep = (start.y-end.y)/float(_SAMPLENUM);//深度平分\n	float sum=0.;\n	for( int i=0; i<_SAMPLENUM; i++){\n		float fi = float(i);\n		float v1 = exp(-_density*(dlen+ddeep)*fi);//TODO 应该可以用分析法计算出来\n		sum += v1;\n	}\n	return vec3(K*sum);\n}\n///* 根据散射公式来计算某个方向的亮度  END *///\n\nconst float cDeep = -4.;	//假设水的深度\nvec3 getShuiDiColor(vec3 pos, vec3 dir, vec3 normal){\n	//一个无限大的水底，黑白格纹理。纹理长度为1米\n	float t = ( cDeep-pos.y )/dir.y;\n	if(t<0.) return vec3(1.,0.,0.);//TEST\n	bool bhit = false;\n	vec3 hitpos;\n	vec3 hitcolor;\n	vec3 hn;\n	/*\n	if(hitClydiner(pos,dir,hitpos,hn) && hitpos.y>cDeep && hitpos.y<pos.y){\n		bhit=true;\n		hitcolor = vec3(.8,.8,.8);\n\n	}else\n	*/\n	{\n		hitpos = pos+dir*t;\n		vec3 hp = floor(hitpos);\n		float a = mod((hp.x+hp.z),2.);\n		//hitcolor = (a<.9)?vec3(0.,0.,0.):vec3(1.,1.,1.);\n		//hitcolor = texture2D(texUnderWater,hitpos.xz/10.).rgb;\n	}\n	\n	hitcolor = texture2D(texUnderWater, gl_FragCoord.xy/u_scrsize+normal.xz/8.).rgb;\n	return hitcolor;\n	/*\n	float l = length(hitpos-pos);\n	//return texture2D(texDeepColor,vec2(min(max(l/400.,0.),1.),0.5)).rgb;\n	//return SEA_COLOR1*calcScatter(pos,dir,hitpos);\n	float left = pow(0.8,l);//假设透过率为80%，则到达水底的时候的光强。\n	return mix(hitcolor,u_SeaColor,1.-left);\n	*/\n}\n\n/*\n	view已经normalize了\n*/\nvec3 getRefractColor(vec3 view,vec3 normal){\n	vec3 T = refract(-view, normal, 0.7);\n	return getShuiDiColor(vWorldPos.xyz,T,normal); \n}\n\nvec4 calcWaterC(vec3 view, vec3 normal, float von, vec3 R, float rough){\n	if(dot(R,vec3(0.,1.,0.))<0.){\n		R = -R;\n	}\n	vec3 refr = getRefractColor(-view,normal);\n	float F0=0.02;\n	//菲涅尔，越大反射越强\n	float f =  F0+(1.0-F0)*exp2((-5.55473*von-6.98316)*von);\n	//float f = F0+(1.0-F0)*pow(1.-von,5.);\n	//能看到水底的程度。反射剩余的*水中的衰减\n	//float a = (1.-f)*(1.-deepk);\n#ifdef CUBE_ENV\n	vec4 reflc = textureCube(texSky,R);\n#else\n	vec4 reflc = texPanorama(texSky, R);\n#endif\n#ifdef HDR_ENV\n	vec3 refl = _RGBEToRGB(reflc)*f;\n#else\n	vec3 refl = reflc.rgb*f;\n#endif\n	//return vec4(refl*(1.-rough),1.);\n	\n	//vec3 refl = reflc.rgb*f;\n	vec3 final = refr+refl*(max(0.,1.-rough));// mix(refr,refl,f);\n#ifdef HDR_ENV\n	final = ACESToneMapping(final,1.);//TODO 这个要uniform传入\n#endif\n	return vec4(final,f);\n}\n\nvoid main() {\n    vec3 normal =  normalize(vWorldNorm);\n	//如果uv=1为100米，希望每个细节纹理表示20米的小波形，则uv缩放是 100/20。细节纹理内部也要用这个值，即pos=uv*20\n	vec2 ruv = matUVTrans*vUv;\n	vec3 detailNorm = texture2D(texWaveDetail,fract(ruv*5.)).rgb*2.-vec3(1.);//TODO uv怎么算\n	float texNormScale = 2.*PI*float(NumTexWaves)*Amp_over_L*2.5;\n	detailNorm *= vec3(texNormScale,1.,texNormScale);\n	//旋转\n	//细节纹理来自rendertarget，因此需要颠倒z\n	\n	matTBNOff = mat3(matUVTrans[0][0],0.,matUVTrans[1][0],\n	0.,1.,0.,\n	matUVTrans[0][1],0.,matUVTrans[1][1]\n	);\n	\n	/*\n	matTBNOff = mat3(0.,0.,1.,\n	0.,1.,0.,\n	-1.,0.,0.\n	);\n	*/\n\n    mat3 tsn = mat3( vWorldBin, normal, vWorldTan);	\n    //normal = normalize(tsn * matTBNOff * detailNorm);\n	normal = normalize(tsn * detailNorm); //这个应该更正确。因为本身方向就是根据uv算的，如果是静态图片才需要转换。\n	//vec4 normtex = texture2D( texNormal, vUv );\n    vec3 view   = -normalize(vViewDir);//view 是指向camera的\n    float NoV = saturate(dot( view, normal ));\n    //vec3 R = 2. * NoV * normal - view;\n	\n	vec4 foamc = (texture2D(texFoam,vUv*50.)+texture2D(texFoam,vUv*20.))/2.;\n	float nearcoast = 1.-vWaterInfo.r;\n	float foams = (nearcoast/4.+fFoam)*2.*nearcoast;\n	\n	vec3 R = reflect(-view,normal);\n	vec4 wc = calcWaterC(view, normal,NoV,R, foams);\n\n\n	#ifdef SHOW_NORMAL\n	gl_FragColor.rgb = normal;\n	#else\n	gl_FragColor.rgb = wc.rgb;//normalize(detailNorm).rrr;//((normal)+vec3(0.0))/1.;//normalize(normal).rgb;//texture2D(texWaveDetail,vUv).rgb;// fracColor * texture2D(texUnderWater, vUv*20.0).rgb;// vec3(1.0);//pbrl.rgb;\n	#endif\n    gl_FragColor.a = 1.0;//wc.a;\n	gl_FragColor.rgb = mix(gl_FragColor.rgb,vec3(1.),foamc.a*foams);\n	//if(mod(vUv.x*100.,1.0)<0.02 || mod(vUv.y*100.,1.0)<0.02) gl_FragColor.rgb=vec3(0.5,.5,.5);\n	gl_FragColor.a = foamc.r;\n	//gl_FragColor.rgb = detailNorm;\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/water.ps*/;
			shaderCompile=ShaderCompile3D.add(Water,vs,ps,attributeMap,uniformMap);
			WaterMaterial.SHADERDEFINE_CUBE_ENV=shaderCompile.registerMaterialDefine("CUBE_ENV");
			WaterMaterial.SHADERDEFINE_HDR_ENV=shaderCompile.registerMaterialDefine("HDR_ENV");
			WaterMaterial.SHADERDEFINE_SHOW_NORMAL=shaderCompile.registerMaterialDefine("SHOW_NORMAL");
			attributeMap={'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,'a_Texcoord':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2};
			uniformMap={'u_BlendTexture':[ /*laya.d3.core.material.StandardMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_LayerTexture0':[ /*laya.d3.core.material.StandardMaterial.NORMALTEXTURE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_LayerTexture1':[ /*laya.d3.core.material.StandardMaterial.SPECULARTEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_LayerTexture2':[ /*laya.d3.core.material.StandardMaterial.EMISSIVETEXTURE*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_LayerTexture3':[ /*laya.d3.core.material.StandardMaterial.AMBIENTTEXTURE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Albedo':[ /*laya.d3.core.material.StandardMaterial.ALBEDO*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Ambient':[ /*laya.d3.core.material.StandardMaterial.MATERIALAMBIENT*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_UVMatrix':[ /*laya.d3.core.material.StandardMaterial.UVMATRIX*/13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_FogStart':[ /*laya.d3.core.scene.BaseScene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_FogRange':[ /*laya.d3.core.scene.BaseScene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],'u_FogColor':[ /*laya.d3.core.scene.BaseScene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4]};
			var TERRAIN=Shader3D.nameKey.add("TERRAIN");
			vs="#include?VR \"VRHelper.glsl\";\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_UVMatrix;\n\n#if defined(DIFFUSEMAP)&&defined(NORMALMAP)&&defined(SPECULARMAP)&&defined(EMISSIVEMAP)&&defined(AMBIENTMAP)\nattribute vec2 a_Texcoord;\nvarying vec2 v_Texcoord;\nvarying vec2 v_TiledTexcoord;\n#endif\n\n#ifdef FOG\nuniform mat4 u_WorldMat;\nvarying vec3 v_PositionWorld;\n#endif\n\n\nvoid main()\n{\n #ifdef VR\n gl_Position = DistortFishEye(u_MvpMatrix * a_Position);\n #else\n gl_Position = u_MvpMatrix * a_Position;\n #endif\n \n #ifdef FOG\n v_PositionWorld=(u_WorldMat*a_Position).xyz;\n #endif\n \n #if defined(DIFFUSEMAP)&&defined(NORMALMAP)&&defined(SPECULARMAP)&&defined(EMISSIVEMAP)&&defined(AMBIENTMAP)\n v_Texcoord=a_Texcoord;\n v_TiledTexcoord=(u_UVMatrix*vec4(a_Texcoord,0.0,1.0)).xy;\n #endif\n}"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/modelTerrain.vs*/;
			ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec4 u_Albedo;\nuniform vec3 u_Ambient;\n\n#ifdef FOG\nuniform vec3 u_CameraPos;\nvarying vec3 v_PositionWorld;\n\nuniform float u_FogStart;\nuniform float u_FogRange;\nuniform vec3 u_FogColor;\n#endif\n\n#if defined(DIFFUSEMAP)&&defined(NORMALMAP)&&defined(SPECULARMAP)&&defined(EMISSIVEMAP)&&defined(AMBIENTMAP)\n  varying vec2 v_Texcoord;\n  varying vec2 v_TiledTexcoord;\n  uniform sampler2D u_BlendTexture;\n  uniform sampler2D u_LayerTexture0;\n  uniform sampler2D u_LayerTexture1;\n  uniform sampler2D u_LayerTexture2;\n  uniform sampler2D u_LayerTexture3;\n#endif\n\nvoid main()\n{	\n  #if defined(DIFFUSEMAP)&&defined(NORMALMAP)&&defined(SPECULARMAP)&&defined(EMISSIVEMAP)&&defined(AMBIENTMAP)\n  vec4 blend=texture2D(u_BlendTexture, v_Texcoord);\n  vec4 c0=texture2D(u_LayerTexture0, v_TiledTexcoord);\n  vec4 c1=texture2D(u_LayerTexture1, v_TiledTexcoord);\n  vec4 c2=texture2D(u_LayerTexture2, v_TiledTexcoord);\n  vec4 c3=texture2D(u_LayerTexture3, v_TiledTexcoord);\n  vec4 texColor = c0;\n  texColor = mix(texColor, c1, blend.r);\n  texColor = mix(texColor, c2, blend.g);\n  texColor = mix(texColor, c3, blend.b);\n  gl_FragColor=vec4(texColor.rgb*u_Ambient.rgb*blend.a,1.0);\n  gl_FragColor=gl_FragColor*u_Albedo;\n  #endif \n  \n  #ifdef FOG\n  vec3 toEye=u_CameraPos-v_PositionWorld;\n  float toEyeLength=length(toEye);\n  \n  float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n  gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n  #endif\n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/modelTerrain.ps*/;
			shaderCompile=ShaderCompile3D.add(TERRAIN,vs,ps,attributeMap,uniformMap);
			StandardMaterial.SHADERDEFINE_DIFFUSEMAP=shaderCompile.registerMaterialDefine("DIFFUSEMAP");
			StandardMaterial.SHADERDEFINE_NORMALMAP=shaderCompile.registerMaterialDefine("NORMALMAP");
			StandardMaterial.SHADERDEFINE_SPECULARMAP=shaderCompile.registerMaterialDefine("SPECULARMAP");
			StandardMaterial.SHADERDEFINE_EMISSIVEMAP=shaderCompile.registerMaterialDefine("EMISSIVEMAP");
			StandardMaterial.SHADERDEFINE_AMBIENTMAP=shaderCompile.registerMaterialDefine("AMBIENTMAP");
			StandardMaterial.SHADERDEFINE_REFLECTMAP=shaderCompile.registerMaterialDefine("REFLECTMAP");
			StandardMaterial.SHADERDEFINE_UVTRANSFORM=shaderCompile.registerMaterialDefine("UVTRANSFORM");
			attributeMap={'a_CornerTextureCoordinate':/*laya.d3.graphics.VertexElementUsage.CORNERTEXTURECOORDINATE0*/17,'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,'a_Velocity':/*laya.d3.graphics.VertexElementUsage.VELOCITY0*/18,'a_StartColor':/*laya.d3.graphics.VertexElementUsage.STARTCOLOR0*/19,'a_EndColor':/*laya.d3.graphics.VertexElementUsage.ENDCOLOR0*/25,'a_SizeRotation':/*laya.d3.graphics.VertexElementUsage.SIZEROTATION0*/27,'a_Radius':/*laya.d3.graphics.VertexElementUsage.RADIUS0*/28,'a_Radian':/*laya.d3.graphics.VertexElementUsage.RADIAN0*/29,'a_AgeAddScale':/*laya.d3.graphics.VertexElementUsage.STARTLIFETIME*/26,'a_Time':/*laya.d3.graphics.VertexElementUsage.TIME0*/33};
			uniformMap={'u_CurrentTime':[ /*laya.d3.core.material.ParticleMaterial.CURRENTTIME*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Duration':[ /*laya.d3.core.material.ParticleMaterial.DURATION*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Gravity':[ /*laya.d3.core.material.ParticleMaterial.GRAVITY*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_EndVelocity':[ /*laya.d3.core.material.ParticleMaterial.ENDVELOCITY*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_texture':[ /*laya.d3.core.material.ParticleMaterial.DIFFUSETEXTURE*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_View':[ /*laya.d3.core.BaseCamera.VIEWMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_Projection':[ /*laya.d3.core.BaseCamera.PROJECTMATRIX*/2,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_ViewportScale':[ /*laya.d3.core.material.ParticleMaterial.VIEWPORTSCALE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1]};
			var PARTICLE=Shader3D.nameKey.add("PARTICLE");
			shaderCompile=ShaderCompile3D.add(PARTICLE,ParticleShader.vs,ParticleShader.ps,attributeMap,uniformMap);
			ParticleMaterial.SHADERDEFINE_PARTICLE3D=shaderCompile.registerMaterialDefine("PARTICLE3D");
			attributeMap={'a_CornerTextureCoordinate':/*laya.d3.graphics.VertexElementUsage.CORNERTEXTURECOORDINATE0*/17,'a_PositionStartLifeTime':/*laya.d3.graphics.VertexElementUsage.POSITIONSTARTLIFETIME*/30,'a_DirectionTime':/*laya.d3.graphics.VertexElementUsage.DIRECTIONTIME*/32,'a_StartColor':/*laya.d3.graphics.VertexElementUsage.STARTCOLOR0*/19,'a_EndColor':/*laya.d3.graphics.VertexElementUsage.ENDCOLOR0*/25,'a_StartSize':/*laya.d3.graphics.VertexElementUsage.STARTSIZE*/20,'a_StartRotation0':/*laya.d3.graphics.VertexElementUsage.STARTROTATION0*/22,'a_StartRotation1':/*laya.d3.graphics.VertexElementUsage.STARTROTATION1*/23,'a_StartRotation2':/*laya.d3.graphics.VertexElementUsage.STARTROTATION2*/24,'a_StartSpeed':/*laya.d3.graphics.VertexElementUsage.STARTSPEED*/31,'a_Random0':/*laya.d3.graphics.VertexElementUsage.RANDOM0*/34,'a_Random1':/*laya.d3.graphics.VertexElementUsage.RANDOM1*/35,'a_SimulationWorldPostion':/*laya.d3.graphics.VertexElementUsage.SIMULATIONWORLDPOSTION*/36};
			uniformMap={'u_SimulationSpace':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SIMULATIONSPACE*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Tintcolor':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.TINTCOLOR*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_ThreeDStartRotation':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.THREEDSTARTROTATION*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_ScalingMode':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SCALINGMODE*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_CurrentTime':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.CURRENTTIME*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Gravity':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.GRAVITY*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_texture':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.DIFFUSETEXTURE*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_StretchedBillboardLengthScale':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.STRETCHEDBILLBOARDLENGTHSCALE*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_StretchedBillboardSpeedScale':[ /*laya.d3.core.particleShuriKen.ShurikenParticleMaterial.STRETCHEDBILLBOARDSPEEDSCALE*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_WorldPosition':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.WORLDPOSITION*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_WorldRotationMat':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.WORLDROTATIONMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_PositionScale':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.POSITIONSCALE*/4,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SizeScale':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SIZESCALE*/5,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ColorOverLifeGradientAlphas':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/15,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ColorOverLifeGradientColors':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/16,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_MaxColorOverLifeGradientAlphas':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS*/17,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_MaxColorOverLifeGradientColors':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS*/18,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLVelocityConst':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/6,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLVelocityGradientX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/7,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLVelocityGradientY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/8,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLVelocityGradientZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/9,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLVelocityConstMax':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONSTMAX*/10,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLVelocityGradientMaxX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX*/11,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLVelocityGradientMaxY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX*/12,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLVelocityGradientMaxZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX*/13,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_VOLSpaceType':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLSPACETYPE*/14,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SOLSizeGradient':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENT*/19,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SOLSizeGradientX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTX*/20,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SOLSizeGradientY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTY*/21,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SOLSizeGradientZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZ*/22,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SOLSizeGradientMax':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientMax*/23,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SOLSizeGradientMaxX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTXMAX*/24,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SOLSizeGradientMaxY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTYMAX*/25,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_SOLSizeGradientMaxZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZMAX*/26,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityConst':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONST*/27,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityConstSeprarate':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE*/28,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityGradient':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT*/29,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityGradientX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX*/30,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityGradientY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY*/31,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityGradientZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ*/32,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityConstMax':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX*/33,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityConstMaxSeprarate':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE*/34,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityGradientMax':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX*/35,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityGradientMaxX':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX*/36,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityGradientMaxY':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX*/37,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_ROLAngularVelocityGradientMaxZ':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX*/38,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_TSACycles':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES*/39,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_TSASubUVLength':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH*/40,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_TSAGradientUVs':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS*/41,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_TSAMaxGradientUVs':[ /*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS*/42,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],'u_CameraDirection':[ /*laya.d3.core.BaseCamera.CAMERADIRECTION*/5,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_CameraUp':[ /*laya.d3.core.BaseCamera.CAMERAUP*/6,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_View':[ /*laya.d3.core.BaseCamera.VIEWMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],'u_Projection':[ /*laya.d3.core.BaseCamera.PROJECTMATRIX*/2,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3]};
			var PARTICLESHURIKEN=Shader3D.nameKey.add("PARTICLESHURIKEN");
			vs="attribute vec4 a_CornerTextureCoordinate;\nattribute vec4 a_PositionStartLifeTime;\nattribute vec4 a_DirectionTime;\nattribute vec4 a_StartColor;\nattribute vec3 a_StartSize;\nattribute vec3 a_StartRotation0;\nattribute vec3 a_StartRotation1;\nattribute vec3 a_StartRotation2;\nattribute float a_StartSpeed;\n#ifdef defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||definedSIZEOVERLIFETIMERANDOMCURVESSEPERATE||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n  attribute vec4 a_Random0;\n#endif\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  attribute vec4 a_Random1;\n#endif\nattribute vec3 a_SimulationWorldPostion;\n\nvarying float v_Discard;\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\n\nuniform float u_CurrentTime;\nuniform vec3 u_Gravity;\n\nuniform vec3 u_WorldPosition;\nuniform mat4 u_WorldRotationMat;\nuniform bool u_ThreeDStartRotation;\nuniform int u_ScalingMode;\nuniform vec3 u_PositionScale;\nuniform vec3 u_SizeScale;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\nuniform vec3 u_CameraUp;\n\nuniform  float u_StretchedBillboardLengthScale;\nuniform  float u_StretchedBillboardSpeedScale;\nuniform int u_SimulationSpace;\n\n#ifdef defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  int  u_VOLSpaceType;\n#endif\n#ifdef defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\n  uniform  vec3 u_VOLVelocityConst;\n#endif\n#ifdef defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n  uniform  vec3 u_VOLVelocityConstMax;\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\n#endif\n\n#ifdef COLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n#ifdef RANDOMCOLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n\n\n#ifdef defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\n#endif\n#ifdef defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\n#endif\n\n\n#ifdef ROTATIONOVERLIFETIME\n  #ifdef defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  float u_ROLAngularVelocityConst;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  float u_ROLAngularVelocityConstMax;\n  #endif\n  #ifdef defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\n  #endif\n#endif\n#ifdef ROTATIONOVERLIFETIMESEPERATE\n  #ifdef defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\n  #endif\n  #ifdef defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];//x为key,y为旋转\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];//x为key,y为旋转\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];//x为key,y为旋转\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];//x为key,y为旋转\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];//x为key,y为旋转\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];//x为key,y为旋转\n  #endif\n#endif\n\n#ifdef defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\n  uniform  float u_TSACycles;\n  uniform  vec2 u_TSASubUVLength;\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\n#endif\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\n#endif\n\n \n#ifdef defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n	float curValue;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientNumber=gradientNumbers[i];\n		float key=gradientNumber.x;\n		if(key>=normalizedAge)\n		{\n			vec2 lastGradientNumber=gradientNumbers[i-1];\n			float lastKey=lastGradientNumber.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			curValue=mix(lastGradientNumber.y,gradientNumber.y,age);\n			break;\n		}\n	}\n	return curValue;\n}\n#endif\n\n#ifdef VELOCITYOVERLIFETIME\n//float getTotalPositionFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n//{\n//	float totalPosition=0.0;\n//	for(int i=1;i<4;i++)\n//	{\n//		vec2 gradientNumber=gradientNumbers[i];\n//		float key=gradientNumber.x;\n//		vec2 lastGradientNumber=gradientNumbers[i-1];\n//		float lastValue=lastGradientNumber.y;\n//		\n//		if(key>=normalizedAge){\n//			float lastKey=lastGradientNumber.x;\n//			float age=(normalizedAge-lastKey)/(key-lastKey);\n//			\n//			float velocity=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0;\n//			totalPosition+=velocity*a_PositionStartLifeTime.w*(normalizedAge-lastKey);//TODO:计算POSITION时可用优化，用已计算好速度\n//			break;\n//		}\n//		else{\n//			float velocity=(lastValue+gradientNumber.y)/2.0;\n//			totalPosition+=velocity*a_PositionStartLifeTime.w*(key-lastGradientNumber.x);\n//		}\n//	}\n//	return totalPosition;\n//}\n#endif\n\n#ifdef defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n	float totalValue=0.0;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientNumber=gradientNumbers[i];\n		float key=gradientNumber.x;\n		vec2 lastGradientNumber=gradientNumbers[i-1];\n		float lastValue=lastGradientNumber.y;\n		\n		if(key>=normalizedAge){\n			float lastKey=lastGradientNumber.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			totalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_PositionStartLifeTime.w*(normalizedAge-lastKey);\n			break;\n		}\n		else{\n			totalValue+=(lastValue+gradientNumber.y)/2.0*a_PositionStartLifeTime.w*(key-lastGradientNumber.x);\n		}\n	}\n	return totalValue;\n}\n#endif\n\n#ifdef defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\n{\n	vec4 overTimeColor;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientAlpha=gradientAlphas[i];\n		float alphaKey=gradientAlpha.x;\n		if(alphaKey>=normalizedAge)\n		{\n			vec2 lastGradientAlpha=gradientAlphas[i-1];\n			float lastAlphaKey=lastGradientAlpha.x;\n			float age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\n			overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n			break;\n		}\n	}\n	\n	for(int i=1;i<4;i++)\n	{\n		vec4 gradientColor=gradientColors[i];\n		float colorKey=gradientColor.x;\n		if(colorKey>=normalizedAge)\n		{\n			vec4 lastGradientColor=gradientColors[i-1];\n			float lastColorKey=lastGradientColor.x;\n			float age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\n			overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n			break;\n		}\n	}\n	return overTimeColor;\n}\n#endif\n\n\n#ifdef defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\n{\n	float overTimeFrame;\n	for(int i=1;i<4;i++)\n	{\n		vec2 gradientFrame=gradientFrames[i];\n		float key=gradientFrame.x;\n		if(key>=normalizedAge)\n		{\n			vec2 lastGradientFrame=gradientFrames[i-1];\n			float lastKey=lastGradientFrame.x;\n			float age=(normalizedAge-lastKey)/(key-lastKey);\n			overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n			break;\n		}\n	}\n	return floor(overTimeFrame);\n}\n#endif\n\n#ifdef defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\nvec3 computeParticleLifeVelocity(in float normalizedAge)\n{\n  vec3 outLifeVelocity;\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\n	 outLifeVelocity=u_VOLVelocityConst; \n  #endif\n  #ifdef VELOCITYOVERLIFETIMECURVE\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n	 outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\n	                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\n					 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n  #endif\n					\n  return outLifeVelocity;\n} \n#endif\n\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge)\n{\n   vec3 startPosition;\n   vec3 lifePosition;\n   #ifdef defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	#ifdef VELOCITYOVERLIFETIMECONSTANT\n		  startPosition=startVelocity*age;\n		  lifePosition=lifeVelocity*age;\n	#endif\n	#ifdef VELOCITYOVERLIFETIMECURVE\n		  startPosition=startVelocity*age;\n		  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n	#endif\n	#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n		  startPosition=startVelocity*age;\n		  lifePosition=lifeVelocity*age;\n	#endif\n	#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n		  startPosition=startVelocity*age;\n		  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\n	      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\n	      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n	#endif\n	\n	vec3 finalPosition;\n	if(u_VOLSpaceType==0){\n	  if(u_ScalingMode!=2)\n	   finalPosition =mat3(u_WorldRotationMat)*(u_PositionScale*(a_PositionStartLifeTime.xyz+startPosition+lifePosition));\n	  else\n	   finalPosition =mat3(u_WorldRotationMat)*(u_PositionScale*a_PositionStartLifeTime.xyz+startPosition+lifePosition);\n	}\n	else{\n	  if(u_ScalingMode!=2)\n	    finalPosition = mat3(u_WorldRotationMat)*(u_PositionScale*(a_PositionStartLifeTime.xyz+startPosition))+lifePosition;\n	  else\n	    finalPosition = mat3(u_WorldRotationMat)*(u_PositionScale*a_PositionStartLifeTime.xyz+startPosition)+lifePosition;\n	}\n  #else\n	 startPosition=startVelocity*age;\n	 vec3 finalPosition;\n	 if(u_ScalingMode!=2)\n	   finalPosition = mat3(u_WorldRotationMat)*(u_PositionScale*(a_PositionStartLifeTime.xyz+startPosition));\n	 else\n	   finalPosition = mat3(u_WorldRotationMat)*(u_PositionScale*a_PositionStartLifeTime.xyz+startPosition);\n  #endif\n  \n  if(u_SimulationSpace==0)\n    finalPosition=finalPosition+a_SimulationWorldPostion;\n  else if(u_SimulationSpace==1) \n    finalPosition=finalPosition+u_WorldPosition;\n  \n  finalPosition+=u_Gravity*age*normalizedAge;//计算受重力影响的位置//TODO:移除\n \n  return  finalPosition;\n}\n\n\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\n{\n	#ifdef COLOROVERLIFETIME\n	  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\n	#endif\n	\n	#ifdef RANDOMCOLOROVERLIFETIME\n	  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\n	#endif\n\n    return color;\n}\n\nvec2 computeParticleSize(in vec2 size,in float normalizedAge)\n{\n	#ifdef SIZEOVERLIFETIMECURVE\n		size*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVES\n	    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n	#endif\n	#ifdef SIZEOVERLIFETIMECURVESEPERATE\n		size*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\n	#endif\n	#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n	    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n	    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\n	#endif\n	return size;\n}\n\nvec3 computeParticleRotation(in vec3 rotation,in float age,in float normalizedAge)//TODO:不分轴是否无需计算XY，Billboard模式下好像是,待确认。\n{ \n	#ifdef ROTATIONOVERLIFETIME\n	#ifdef ROTATIONOVERLIFETIMECONSTANT\n			float ageRot=u_ROLAngularVelocityConst*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			float ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n		#endif\n	#endif\n	#ifdef ROTATIONOVERLIFETIMESEPERATE\n	#ifdef ROTATIONOVERLIFETIMECONSTANT\n			vec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\n	        rotation+=ageRot;\n		#endif\n		#ifdef ROTATIONOVERLIFETIMECURVE\n			rotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\n		#endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n			vec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\n	        rotation+=ageRot;\n	    #endif\n		#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n			rotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\n	        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\n	        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n		#endif\n	#endif\n	return rotation;\n}\n\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\n{ \n	#ifdef TEXTURESHEETANIMATIONCURVE\n		float cycleNormalizedAge=normalizedAge*u_TSACycles;\n		float frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\n		float totalULength=frame*u_TSASubUVLength.x;\n		float floorTotalULength=floor(totalULength);\n	    uv.x=uv.x+totalULength-floorTotalULength;\n		uv.y=uv.y+floorTotalULength*u_TSASubUVLength.y;\n    #endif\n	#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n		float cycleNormalizedAge=normalizedAge*u_TSACycles;\n		float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n	    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\n		float totalULength=frame*u_TSASubUVLength.x;\n		float floorTotalULength=floor(totalULength);\n	    uv.x=uv.x+totalULength-floorTotalULength;\n		uv.y=uv.y+floorTotalULength*u_TSASubUVLength.y;\n    #endif\n	return uv;\n}\n\nvoid main()\n{\n   float age = u_CurrentTime - a_DirectionTime.w;\n   float normalizedAge = age/a_PositionStartLifeTime.w;\n   vec3 lifeVelocity;\n   if(normalizedAge<1.0){ \n	  vec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\n   #ifdef defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	  lifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\n   #endif \n	  \n   vec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge);//计算粒子位置\n   vec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n   \n   #ifdef SPHERHBILLBOARD\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\n	    corner*=computeParticleSize(a_StartSize.xy,normalizedAge);\n		if(u_ThreeDStartRotation){\n		  center += u_SizeScale.xzy*(mat3(a_StartRotation0,a_StartRotation1,a_StartRotation2)*(corner.x*sideVector+corner.y*upVector));\n		}\n		else{\n		  vec3 rotationAng = computeParticleRotation(a_StartRotation0, age,normalizedAge);\n		  float rot=rotationAng.z;\n          float c = cos(rot);\n          float s = sin(rot);\n          mat2 rotation= mat2(c, -s, s, c);\n		  corner=rotation*corner;\n		  center += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n		}\n       \n   #endif\n   \n   #ifdef STRETCHEDBILLBOARD\n	vec3 velocity;\n	#ifdef defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n	    if(u_VOLSpaceType==0)\n		  velocity=mat3(u_WorldRotationMat)*(u_SizeScale*(startVelocity+lifeVelocity));\n	    else\n		  velocity=mat3(u_WorldRotationMat)*(u_SizeScale*startVelocity)+lifeVelocity;\n    #else\n	    velocity= mat3(u_WorldRotationMat)*(u_SizeScale*startVelocity);\n    #endif   \n        vec3 cameraUpVector =normalize(velocity);\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n	    vec2 size=computeParticleSize(a_StartSize.xy,normalizedAge);\n	    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n	    corner=rotaionZHalfPI*corner;\n	    corner.y=corner.y-abs(corner.y);\n	    float speed=length(velocity);//TODO:\n	    //center +=u_SizeScale.xzy*(size.x*corner.x*sideVector+(cameraUpVector*speed*u_StretchedBillboardSpeedScale+cameraUpVector*size.y*u_StretchedBillboardLengthScale)*corner.y);//TODO:要改良吧\n		center +=u_SizeScale.xzy*size.x*corner.x*sideVector+((cameraUpVector*speed)*u_StretchedBillboardSpeedScale+cameraUpVector*size.y*u_StretchedBillboardLengthScale)*corner.y;//待确认\n   #endif\n   \n   #ifdef HORIZONTALBILLBOARD\n        const vec3 cameraUpVector=vec3(0.0,0.0,-1.0);\n	    const vec3 sideVector = vec3(1.0,0.0,0.0);\n		corner*=computeParticleSize(a_StartSize.xy,normalizedAge);\n		vec3 rotationAng = computeParticleRotation(a_StartRotation0, age,normalizedAge);\n	    float rot=rotationAng.z;\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n	    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef VERTICALBILLBOARD\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n		corner*=computeParticleSize(a_StartSize.xy,normalizedAge);\n		vec3 rotationAng = computeParticleRotation(a_StartRotation0, age,normalizedAge);\n		float rot=rotationAng.z;\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n	    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n      gl_Position=u_Projection*u_View*vec4(center,1.0);\n      v_Color = computeParticleColor(a_StartColor, normalizedAge);\n      v_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\n      v_Discard=0.0;\n   }\n   else\n   {\n      v_Discard=1.0;\n   }\n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/ParticleShuriKen.vs*/;
			ps="#ifdef FSHIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying float v_Discard;\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\nuniform vec4 u_Tintcolor;\n\n\nvoid main()\n{	\n	#ifdef DIFFUSEMAP\n	  if(v_Discard!=0.0)\n         discard;\n	  gl_FragColor=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\n	#else\n	  gl_FragColor=vec4(0.0);\n	#endif\n}"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/ParticleShuriKen.ps*/;
			shaderCompile=ShaderCompile3D.add(PARTICLESHURIKEN,vs,ps,attributeMap,uniformMap);
			ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=shaderCompile.registerMaterialDefine("DIFFUSEMAP");
			ShuriKenParticle3D.SHADERDEFINE_SPHERHBILLBOARD=shaderCompile.registerSpriteDefine("SPHERHBILLBOARD");
			ShuriKenParticle3D.SHADERDEFINE_STRETCHEDBILLBOARD=shaderCompile.registerSpriteDefine("STRETCHEDBILLBOARD");
			ShuriKenParticle3D.SHADERDEFINE_HORIZONTALBILLBOARD=shaderCompile.registerSpriteDefine("HORIZONTALBILLBOARD");
			ShuriKenParticle3D.SHADERDEFINE_VERTICALBILLBOARD=shaderCompile.registerSpriteDefine("VERTICALBILLBOARD");
			ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=shaderCompile.registerSpriteDefine("COLOROVERLIFETIME");
			ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=shaderCompile.registerSpriteDefine("RANDOMCOLOROVERLIFETIME");
			ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=shaderCompile.registerSpriteDefine("VELOCITYOVERLIFETIMECONSTANT");
			ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=shaderCompile.registerSpriteDefine("VELOCITYOVERLIFETIMECURVE");
			ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=shaderCompile.registerSpriteDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT");
			ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=shaderCompile.registerSpriteDefine("VELOCITYOVERLIFETIMERANDOMCURVE");
			ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=shaderCompile.registerSpriteDefine("TEXTURESHEETANIMATIONCURVE");
			ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=shaderCompile.registerSpriteDefine("TEXTURESHEETANIMATIONRANDOMCURVE");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIME");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMESEPERATE");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMECONSTANT");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMECURVE");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMERANDOMCONSTANTS");
			ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=shaderCompile.registerSpriteDefine("ROTATIONOVERLIFETIMERANDOMCURVES");
			ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=shaderCompile.registerSpriteDefine("SIZEOVERLIFETIMECURVE");
			ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=shaderCompile.registerSpriteDefine("SIZEOVERLIFETIMECURVESEPERATE");
			ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=shaderCompile.registerSpriteDefine("SIZEOVERLIFETIMERANDOMCURVES");
			ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=shaderCompile.registerSpriteDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE");
			attributeMap={'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,'a_Time':/*laya.d3.graphics.VertexElementUsage.TIME0*/33};
			uniformMap={'u_Texture':[ /*laya.d3.core.material.GlitterMaterial.DIFFUSETEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Albedo':[ /*laya.d3.core.material.GlitterMaterial.ALBEDO*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_CurrentTime':[ /*laya.d3.core.material.GlitterMaterial.CURRENTTIME*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Color':[ /*laya.d3.core.material.GlitterMaterial.UNICOLOR*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_Duration':[ /*laya.d3.core.material.GlitterMaterial.DURATION*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2]};
			var GLITTER=Shader3D.nameKey.add("GLITTER");
			vs="attribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\nattribute float a_Time;\n\nuniform mat4 u_MvpMatrix;\nuniform  float u_CurrentTime;\nuniform  vec4 u_Color;\nuniform float u_Duration;\n\nvarying vec2 v_Texcoord;\nvarying vec4 v_Color;\n\n\nvoid main()\n{\n  gl_Position = u_MvpMatrix * a_Position;\n  \n  float age = u_CurrentTime-a_Time;\n  float normalizedAge = clamp(age / u_Duration,0.0,1.0);\n   \n  v_Texcoord=a_Texcoord0;\n  \n  v_Color=u_Color;\n  v_Color.a*=1.0-normalizedAge;\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/Glitter.vs*/;
			ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec4 u_Albedo;\nuniform sampler2D u_Texture;\n\nvarying vec2 v_Texcoord;\nvarying vec4 v_Color;\n\n\nvoid main()\n{	\n  gl_FragColor=texture2D(u_Texture, v_Texcoord)*v_Color;\n  gl_FragColor=gl_FragColor*u_Albedo;\n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/Glitter.ps*/;
			shaderCompile=ShaderCompile3D.add(GLITTER,vs,ps,attributeMap,uniformMap);
			attributeMap={'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0};
			uniformMap={'u_Intensity':[ /*laya.d3.resource.models.Sky.INTENSITY*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_AlphaBlending':[ /*laya.d3.resource.models.Sky.ALPHABLENDING*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_CubeTexture':[ /*laya.d3.resource.models.Sky.DIFFUSETEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_MvpMatrix':[ /*laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE*/4,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3]};
			var skyBox=Shader3D.nameKey.add("SkyBox");
			vs="attribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nvarying vec3 v_Texcoord;\n\n\nvoid main()\n{\n  gl_Position = (u_MvpMatrix*a_Position).xyww;\n  v_Texcoord=a_Position.xyz;\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/SkyBox.vs*/;
			ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform float u_Intensity;\nuniform float u_AlphaBlending;\nuniform samplerCube u_CubeTexture;\n\nvarying vec3 v_Texcoord;\n\n\nvoid main()\n{	\n  gl_FragColor=vec4(textureCube(u_CubeTexture, v_Texcoord).rgb*u_Intensity,u_AlphaBlending);\n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/SkyBox.ps*/;
			ShaderCompile3D.add(skyBox,vs,ps,attributeMap,uniformMap);
			attributeMap={'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2};
			uniformMap={'u_Intensity':[ /*laya.d3.resource.models.Sky.INTENSITY*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_AlphaBlending':[ /*laya.d3.resource.models.Sky.ALPHABLENDING*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_texture':[ /*laya.d3.resource.models.Sky.DIFFUSETEXTURE*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],'u_MvpMatrix':[ /*laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE*/4,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3]};
			var skyDome=Shader3D.nameKey.add("SkyDome");
			vs="attribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\nuniform mat4 u_MvpMatrix;\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{\n  gl_Position = (u_MvpMatrix*a_Position).xyww;\n  v_Texcoord = a_Texcoord0;\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/SkyDome.vs*/;
			ps="#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform float u_Intensity;\nuniform float u_AlphaBlending;\nuniform sampler2D u_texture;\n\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{	\n  gl_FragColor=vec4(texture2D(u_texture, v_Texcoord).rgb*u_Intensity,u_AlphaBlending);\n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/SkyDome.ps*/;
			ShaderCompile3D.add(skyDome,vs,ps,attributeMap,uniformMap);
			attributeMap={'a_Position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
				'a_Normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
				'a_Texcoord0':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2,
				'a_Texcoord1':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE1*/15};
			uniformMap={'u_MvpMatrix':[ /*laya.d3.core.Sprite3D.MVPMATRIX*/1,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'u_WorldMat':[ /*laya.d3.core.Sprite3D.WORLDMATRIX*/0,/*laya.d3.shader.Shader3D.PERIOD_SPRITE*/2],
				'u_SplatAlphaTexture':[ /*laya.d3.core.material.TerrainMaterial.SPLATALPHATEXTURE*/0,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_NormalTexture':[ /*laya.d3.core.material.TerrainMaterial.NORMALTEXTURE*/1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_DiffuseTexture1':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSETEXTURE1*/2,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_DiffuseTexture2':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSETEXTURE2*/3,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_DiffuseTexture3':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSETEXTURE3*/4,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_DiffuseTexture4':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSETEXTURE4*/5,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_DiffuseScale1':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSESCALE1*/6,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_DiffuseScale2':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSESCALE2*/7,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_DiffuseScale3':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSESCALE3*/8,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_DiffuseScale4':[ /*laya.d3.core.material.TerrainMaterial.DIFFUSESCALE4*/9,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_MaterialDiffuse':[ /*laya.d3.core.material.TerrainMaterial.MATERIALDIFFUSE*/11,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_MaterialAmbient':[ /*laya.d3.core.material.TerrainMaterial.MATERIALAMBIENT*/10,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_MaterialSpecular':[ /*laya.d3.core.material.TerrainMaterial.MATERIALSPECULAR*/12,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_CameraPos':[ /*laya.d3.core.BaseCamera.CAMERAPOS*/0,/*laya.d3.shader.Shader3D.PERIOD_CAMERA*/3],
				'u_FogStart':[ /*laya.d3.core.scene.BaseScene.FOGSTART*/1,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_FogRange':[ /*laya.d3.core.scene.BaseScene.FOGRANGE*/2,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_FogColor':[ /*laya.d3.core.scene.BaseScene.FOGCOLOR*/0,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Direction':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRECTION*/3,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRDIFFUSE*/4,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Ambient':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRAMBIENT*/5,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_DirectionLight.Specular':[ /*laya.d3.core.scene.BaseScene.LIGHTDIRSPECULAR*/6,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Position':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTPOS*/7,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Range':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTRANGE*/8,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Attenuation':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTATTENUATION*/9,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTDIFFUSE*/10,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Ambient':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTAMBIENT*/11,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_PointLight.Specular':[ /*laya.d3.core.scene.BaseScene.POINTLIGHTSPECULAR*/12,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Position':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTPOS*/13,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Direction':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTDIRECTION*/14,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Range':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTRANGE*/16,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Spot':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTSPOT*/15,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Attenuation':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTATTENUATION*/17,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Diffuse':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTDIFFUSE*/18,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Ambient':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTAMBIENT*/19,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_SpotLight.Specular':[ /*laya.d3.core.scene.BaseScene.SPOTLIGHTSPECULAR*/20,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowMap1':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE1*/24,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowMap2':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE2*/25,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowMap3':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPTEXTURE3*/26,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowPSSMDistance':[ /*laya.d3.core.scene.BaseScene.SHADOWDISTANCE*/21,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_lightShadowVP':[ /*laya.d3.core.scene.BaseScene.SHADOWLIGHTVIEWPROJECT*/22,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4],
				'u_shadowPCFoffset':[ /*laya.d3.core.scene.BaseScene.SHADOWMAPPCFOFFSET*/23,/*laya.d3.shader.Shader3D.PERIOD_SCENE*/4] };
			var terrain=Shader3D.nameKey.add("Terrain");
			vs="attribute vec4 a_Position;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	attribute vec3 a_Normal;\n	varying vec3 v_Normal;\n	uniform mat4 u_WorldMat;\n	varying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n\nattribute vec2 a_Texcoord0;\nattribute vec2 a_Texcoord1;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\nuniform mat4 u_MvpMatrix;\n\nvoid main()\n{\n	gl_Position = u_MvpMatrix * a_Position;\n	v_Texcoord0=a_Texcoord0;\n	v_Texcoord1=a_Texcoord1;\n	\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	v_PositionWorld=(u_WorldMat*a_Position).xyz;\n	v_Normal=a_Normal;\n#endif\n	\n#ifdef RECEIVESHADOW\n	v_posViewZ = gl_Position.w;\n	#ifdef SHADOWMAP_PSSM1 \n		v_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n	#endif\n#endif\n\n}"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/Terrain.vs*/;
			ps="#ifdef FSHIGHPRECISION\n	precision highp float;\n#else\n	precision mediump float;\n#endif\n\n#include?DIRECTIONLIGHT||POINTLIGHT||SPOTLIGHT \"LightHelper.glsl\";\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	uniform vec3 u_MaterialDiffuse;\n	uniform vec4 u_MaterialSpecular;\n	uniform vec3 u_MaterialAmbient;\n	uniform vec3 u_CameraPos;\n	varying vec3 v_Normal;\n	varying vec3 v_PositionWorld;\n#endif\n\n#ifdef FOG\n	uniform float u_FogStart;\n	uniform float u_FogRange;\n	uniform vec3 u_FogColor;\n#endif\n\n\n#ifdef DIRECTIONLIGHT\n	uniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n	uniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n	uniform SpotLight u_SpotLight;\n#endif\n\n#include \"ShadowHelper.glsl\"\n#ifdef RECEIVESHADOW\n	#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n	uniform mat4 u_lightShadowVP[4];\n	#endif\n	#ifdef SHADOWMAP_PSSM1 \n	varying vec4 v_lightMVPPos;\n	#endif\n#endif\nvarying float v_posViewZ;\n\n\nuniform sampler2D u_SplatAlphaTexture;\nuniform sampler2D u_NormalTexture;\nuniform sampler2D u_DiffuseTexture1;\nuniform sampler2D u_DiffuseTexture2;\nuniform sampler2D u_DiffuseTexture3;\nuniform sampler2D u_DiffuseTexture4;\nuniform vec2 u_DiffuseScale1;\nuniform vec2 u_DiffuseScale2;\nuniform vec2 u_DiffuseScale3;\nuniform vec2 u_DiffuseScale4;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\n\nvoid main()\n{\n#ifdef DETAIL_NUM1\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz;\n#endif\n#ifdef DETAIL_NUM2\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-splatAlpha.r) + color2.xyz * splatAlpha.r;\n#endif\n#ifdef DETAIL_NUM3\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord1/u_DiffuseScale3);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-(splatAlpha.r+splatAlpha.g)) + color2.xyz * splatAlpha.r + color3.xyz * splatAlpha.g;\n#endif\n#ifdef DETAIL_NUM4\n	vec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord1/u_DiffuseScale1);\n	vec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord1/u_DiffuseScale2);\n	vec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord1/u_DiffuseScale3);\n	vec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord1/u_DiffuseScale4);\n	vec4 splatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n	gl_FragColor.xyz = color1.xyz * (1.0-(splatAlpha.r+splatAlpha.g+splatAlpha.b))+ color2.xyz * splatAlpha.r + color3.xyz * splatAlpha.g + color4.xyz * splatAlpha.b;\n#endif\n	gl_FragColor.w = splatAlpha.a;\n	\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n    vec3 normal = texture2D(u_NormalTexture,v_Normal.xy).xyz;\n	normal = normal*2.0 - vec3(1.0);\n	vec3 diffuse = vec3(0.0);\n	vec3 ambient = vec3(0.0);\n	vec3 specular= vec3(0.0);\n	vec3 dif, amb, spe;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n	vec3 toEye;\n	#ifdef FOG\n		toEye=u_CameraPos-v_PositionWorld;\n		float toEyeLength=length(toEye);\n		toEye/=toEyeLength;\n	#else\n		toEye=normalize(u_CameraPos-v_PositionWorld);\n	#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n	computeDirectionLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_DirectionLight,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n	computePointLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_PointLight,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n	ComputeSpotLight(u_MaterialDiffuse,u_MaterialAmbient,u_MaterialSpecular,u_SpotLight,v_PositionWorld,normal,toEye, dif, amb, spe);\n	diffuse+=dif;\n	ambient+=amb;\n	specular+=spe;\n#endif\n\n#ifdef RECEIVESHADOW\n	float shadowValue = 1.0;\n	#ifdef SHADOWMAP_PSSM3\n		shadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif\n	#ifdef SHADOWMAP_PSSM2\n		shadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n	#endif \n	#ifdef SHADOWMAP_PSSM1\n		shadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n	#endif\n#endif\n	\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n	#ifdef RECEIVESHADOW\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse*shadowValue) + specular * shadowValue,gl_FragColor.a);\n	#else\n		gl_FragColor =vec4( gl_FragColor.rgb*(ambient + diffuse) + specular, gl_FragColor.a);\n	#endif\n#endif\n\n#ifdef FOG\n	float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n	gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/shader/files/Terrain.ps*/;
			var terrainCompile3D=ShaderCompile3D.add(terrain,vs,ps,attributeMap,uniformMap);
			TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=terrainCompile3D.registerMaterialDefine("DETAIL_NUM1");
			TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=terrainCompile3D.registerMaterialDefine("DETAIL_NUM2");
			TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=terrainCompile3D.registerMaterialDefine("DETAIL_NUM4");
			TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=terrainCompile3D.registerMaterialDefine("DETAIL_NUM3");
		}

		Laya3D._initResourceLoad=function(){
			var createMap=LoaderManager.createMap;
			createMap["lh"]=[Sprite3D,/*CLASS CONST:Laya3D.SPRITE3DHIERARCHY*/"SPRITE3DHIERARCHY"];
			createMap["lm"]=[Mesh,/*CLASS CONST:Laya3D.MESH*/"MESH"];
			createMap["lmat"]=[StandardMaterial,/*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"];
			createMap["lpbr"]=[PBRMaterial,/*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"];
			createMap["ltc"]=[TextureCube,/*CLASS CONST:Laya3D.TEXTURECUBE*/"TEXTURECUBE"];
			createMap["jpg"]=[Texture2D,"nativeimage"];
			createMap["jpeg"]=[Texture2D,"nativeimage"];
			createMap["png"]=[Texture2D,"nativeimage"];
			createMap["lsani"]=[AnimationTemplet,/*laya.net.Loader.BUFFER*/"arraybuffer"];
			createMap["lrani"]=[AnimationTemplet,/*laya.net.Loader.BUFFER*/"arraybuffer"];
			createMap["raw"]=[DataTexture2D,/*laya.net.Loader.BUFFER*/"arraybuffer"];
			createMap["mipmaps"]=[DataTexture2D,/*laya.net.Loader.BUFFER*/"arraybuffer"];
			createMap["thdata"]=[TerrainHeightData,/*laya.net.Loader.BUFFER*/"arraybuffer"];
			createMap["json"]=[TerrainRes,/*laya.net.Loader.JSON*/"json"];
			createMap["ani"]=[AnimationTemplet,/*laya.net.Loader.BUFFER*/"arraybuffer"];
			createMap["lani"]=[AnimationTemplet,/*laya.net.Loader.BUFFER*/"arraybuffer"];
			Loader.parserMap[ /*CLASS CONST:Laya3D.SPRITE3DHIERARCHY*/"SPRITE3DHIERARCHY"]=Laya3D._loadSprite3DHierarchy;
			Loader.parserMap[ /*CLASS CONST:Laya3D.MESH*/"MESH"]=Laya3D._loadMesh;
			Loader.parserMap[ /*CLASS CONST:Laya3D.MATERIAL*/"MATERIAL"]=Laya3D._loadMaterial;
			Loader.parserMap[ /*CLASS CONST:Laya3D.TEXTURECUBE*/"TEXTURECUBE"]=Laya3D._loadTextureCube;
		}

		Laya3D.READ_BLOCK=function(){
			Laya3D._readData.pos+=4;
			return true;
		}

		Laya3D.READ_DATA=function(){
			Laya3D._DATA.offset=Laya3D._readData.getUint32();
			Laya3D._DATA.size=Laya3D._readData.getUint32();
			return true;
		}

		Laya3D.READ_STRINGS=function(){
			var materialUrls=[];
			var _STRINGS={offset:0,size:0};
			_STRINGS.offset=Laya3D._readData.getUint16();
			_STRINGS.size=Laya3D._readData.getUint16();
			var ofs=Laya3D._readData.pos;
			Laya3D._readData.pos=_STRINGS.offset+Laya3D._DATA.offset;
			for (var i=0;i < _STRINGS.size;i++){
				var string=Laya3D._readData.readUTFString();
				if (string.lastIndexOf(".lmat")!==-1 || string.lastIndexOf(".lpbr")!==-1)
					materialUrls.push(string);
			}
			return materialUrls;
		}

		Laya3D._getSprite3DHierarchyInnerUrls=function(hierarchyNode,urls,urlMap,urlVersion,hierarchyBasePath){
			var path;
			var clas;
			switch (hierarchyNode.type){
				case "MeshSprite3D":
					path=hierarchyNode.instanceParams.loadPath;
					clas=Mesh;
					break ;
				case "ShuriKenParticle3D":;
					var materialPath=hierarchyNode.customProps.materialPath;
					if (materialPath){
						path=materialPath;
						clas=ShurikenParticleMaterial;
						}else {
						path=hierarchyNode.customProps.texturePath;
						clas=Texture2D;
					}
					break ;
				}
			if (path){
				var formatSubUrl=URL.formatURL(path,hierarchyBasePath);
				(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
				urls.push({url:formatSubUrl,clas:clas});
				urlMap[path]=formatSubUrl;
			};
			var children=hierarchyNode.child;
			for (var i=0,n=children.length;i < n;i++)
			Laya3D._getSprite3DHierarchyInnerUrls(children[i],urls,urlMap,urlVersion,hierarchyBasePath);
		}

		Laya3D._loadSprite3DHierarchy=function(loader){
			var lmLoader=new Loader();
			lmLoader.on(/*laya.events.Event.COMPLETE*/"complete",null,Laya3D._onSprite3DHierarchylhLoaded,[loader]);
			lmLoader.load(loader.url,/*laya.net.Loader.TEXT*/"text",false,null,true);
		}

		Laya3D._onSprite3DHierarchylhLoaded=function(loader,lhData){
			var url=loader.url;
			var urlVersion=Utils3D.getURLVerion(url);
			var hierarchyBasePath=URL.getPath(URL.formatURL(url));
			var urls=[];
			var urlMap={};
			var hierarchyData=JSON.parse(lhData);
			Laya3D._getSprite3DHierarchyInnerUrls(hierarchyData,urls,urlMap,urlVersion,hierarchyBasePath);
			var urlCount=urls.length;
			var totalProcessCount=urlCount+1;
			var lhWeight=1 / totalProcessCount;
			Laya3D._onProcessChange(loader,0,lhWeight,1.0);
			if (urlCount > 0){
				var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,lhWeight,urlCount / totalProcessCount],false);
				Laya3D._innerSprite3DHierarchyLoaderManager.create(urls,Handler.create(null,Laya3D._onSprite3DMeshsLoaded,[loader,processHandler,lhData,urlMap]),processHandler);
				}else {
				Laya3D._onSprite3DMeshsLoaded(loader,null,lhData,null);
			}
		}

		Laya3D._onSprite3DMeshsLoaded=function(loader,processHandler,lhData,urlMap){
			loader.endLoad([lhData,urlMap]);
			(processHandler)&& (processHandler.recover());
		}

		Laya3D._loadMesh=function(loader){
			var lmLoader=new Loader();
			lmLoader.on(/*laya.events.Event.COMPLETE*/"complete",null,Laya3D._onMeshLmLoaded,[loader]);
			lmLoader.load(loader.url,/*laya.net.Loader.BUFFER*/"arraybuffer",false,null,true);
		}

		Laya3D._onMeshLmLoaded=function(loader,lmData){
			var url=loader.url;
			var urlVersion=Utils3D.getURLVerion(url);
			var meshBasePath=URL.getPath(URL.formatURL(url));
			var urls;
			var urlMap={};
			var formatSubUrl;
			var i=0,n=0,count=0;
			Laya3D._readData=new Byte(lmData);
			Laya3D._readData.pos=0;
			var version=Laya3D._readData.readUTFString();
			switch (version){
				case "LAYAMODEL:02":;
					var dataOffset=Laya3D._readData.getUint32();
					Laya3D._readData.pos=Laya3D._readData.pos+4;
					count=Laya3D._readData.getUint16();
					Laya3D._readData.pos=Laya3D._readData.pos+count *8;
					var offset=Laya3D._readData.getUint32();
					count=Laya3D._readData.getUint16();
					Laya3D._readData.pos=dataOffset+offset;
					urls=[];
					for (i=0;i < count;i++){
						var string=Laya3D._readData.readUTFString();
						if (string.lastIndexOf(".lmat")!==-1)
							urls.push(string);
					}
					break ;
				default :
					Laya3D.READ_BLOCK();
					for (i=0;i < 2;i++){
						var index=Laya3D._readData.getUint16();
						var blockName=Laya3D._strings[index];
						var fn=Laya3D["READ_"+blockName];
						if (fn==null)throw new Error("model file err,no this function:"+index+" "+blockName);
						if (i===1)
							urls=fn.call();
						else
						fn.call()
					}
				}
			for (i=0,n=urls.length;i < n;i++){
				var subUrl=urls[i];
				formatSubUrl=URL.formatURL(subUrl,meshBasePath);
				(urlVersion)&& (formatSubUrl=formatSubUrl+urlVersion);
				urls[i]=formatSubUrl;
				urlMap[subUrl]=formatSubUrl;
			};
			var urlCount=1;
			var totalProcessCount=urlCount+1;
			var lmatWeight=1 / totalProcessCount;
			Laya3D._onProcessChange(loader,0,lmatWeight,1.0);
			var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,lmatWeight,urlCount / totalProcessCount],false);
			Laya3D._innerMeshLoaderManager.create(urls,Handler.create(null,Laya3D._onMeshMateialLoaded,[loader,processHandler,lmData,urlMap]),processHandler);
		}

		Laya3D._onMeshMateialLoaded=function(loader,processHandler,lmData,urlMap){
			loader.endLoad([lmData,urlMap]);
			processHandler.recover();
		}

		Laya3D._getMaterialTexturePath=function(path,urlVersion,materialBath){
			var extenIndex=path.length-4;
			if (path.indexOf(".dds")==extenIndex || path.indexOf(".tga")==extenIndex || path.indexOf(".exr")==extenIndex || path.indexOf(".DDS")==extenIndex || path.indexOf(".TGA")==extenIndex || path.indexOf(".EXR")==extenIndex)
				path=path.substr(0,extenIndex)+".png";
			path=URL.formatURL(path,materialBath);
			(urlVersion)&& (path=path+urlVersion);
			return path;
		}

		Laya3D._loadMaterial=function(loader){
			var lmatLoader=new Loader();
			lmatLoader.on(/*laya.events.Event.COMPLETE*/"complete",null,Laya3D._onMaterilLmatLoaded,[loader]);
			lmatLoader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
		}

		Laya3D._onMaterilLmatLoaded=function(loader,lmatData){
			var url=loader.url;
			var urlVersion=Utils3D.getURLVerion(url);
			var materialBasePath=URL.getPath(URL.formatURL(url));
			var urls=[];
			var urlMap={};
			var customProps=lmatData.customProps;
			var formatSubUrl;
			var version=lmatData.version;
			if (version){
				switch (version){
					case "LAYAMATERIAL:01":;
						var textures=lmatData.props.textures;
						for (var i=0,n=textures.length;i < n;i++){
							var path=textures[i].path;
							if (path){
								formatSubUrl=Laya3D._getMaterialTexturePath(path,urlVersion,materialBasePath);
								urls.push(formatSubUrl);
								urlMap[path]=formatSubUrl;
							}
						}
						break ;
					default :
						throw new Error("Laya3D:unkonwn version.");
					}
				}else {
				var diffuseTexture=customProps.diffuseTexture.texture2D;
				if (diffuseTexture){
					formatSubUrl=Laya3D._getMaterialTexturePath(diffuseTexture,urlVersion,materialBasePath);
					urls.push(formatSubUrl);
					urlMap[diffuseTexture]=formatSubUrl;
				}
				if (customProps.normalTexture){
					var normalTexture=customProps.normalTexture.texture2D;
					if (normalTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(normalTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[normalTexture]=formatSubUrl;
					}
				}
				if (customProps.specularTexture){
					var specularTexture=customProps.specularTexture.texture2D;
					if (specularTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(specularTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[specularTexture]=formatSubUrl;
					}
				}
				if (customProps.emissiveTexture){
					var emissiveTexture=customProps.emissiveTexture.texture2D;
					if (emissiveTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(emissiveTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[emissiveTexture]=formatSubUrl;
					}
				}
				if (customProps.ambientTexture){
					var ambientTexture=customProps.ambientTexture.texture2D;
					if (ambientTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(ambientTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[ambientTexture]=formatSubUrl;
					}
				}
				if (customProps.reflectTexture){
					var reflectTexture=customProps.reflectTexture.texture2D;
					if (reflectTexture){
						formatSubUrl=Laya3D._getMaterialTexturePath(reflectTexture,urlVersion,materialBasePath);
						urls.push(formatSubUrl);
						urlMap[reflectTexture]=formatSubUrl;
					}
				}
			};
			var urlCount=urls.length;
			var totalProcessCount=urlCount+1;
			var lmatWeight=1 / totalProcessCount;
			Laya3D._onProcessChange(loader,0,lmatWeight,1.0);
			if (urlCount > 0){
				var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,lmatWeight,urlCount / totalProcessCount],false);
				Laya3D._innerMaterialLoaderManager.create(urls,Handler.create(null,Laya3D._onMateialTexturesLoaded,[loader,processHandler,lmatData,urlMap]),processHandler,Texture2D);
				}else {
				Laya3D._onMateialTexturesLoaded(loader,null,lmatData,null);
			}
		}

		Laya3D._onMateialTexturesLoaded=function(loader,processHandler,lmatData,urlMap){
			loader.endLoad([lmatData,urlMap]);
			(processHandler)&& (processHandler.recover());
		}

		Laya3D._loadTextureCube=function(loader){
			var ltcLoader=new Loader();
			ltcLoader.on(/*laya.events.Event.COMPLETE*/"complete",null,Laya3D._onTextureCubeLtcLoaded,[loader]);
			ltcLoader.load(loader.url,/*laya.net.Loader.JSON*/"json",false,null,true);
		}

		Laya3D._onTextureCubeLtcLoaded=function(loader,ltcData){
			var ltcBasePath=URL.getPath(URL.formatURL(loader.url));
			var urls=[URL.formatURL(ltcData.px,ltcBasePath),URL.formatURL(ltcData.nx,ltcBasePath),URL.formatURL(ltcData.py,ltcBasePath),URL.formatURL(ltcData.ny,ltcBasePath),URL.formatURL(ltcData.pz,ltcBasePath),URL.formatURL(ltcData.nz,ltcBasePath)];
			var ltcWeight=1.0 / 7.0;
			Laya3D._onProcessChange(loader,0,ltcWeight,1.0);
			var processHandler=Handler.create(null,Laya3D._onProcessChange,[loader,ltcWeight,6 / 7],false);
			Laya3D._innerTextureCubeLoaderManager.load(urls,Handler.create(null,Laya3D._onTextureCubeImagesLoaded,[loader,urls,processHandler]),processHandler,"nativeimage");
		}

		Laya3D._onTextureCubeImagesLoaded=function(loader,urls,processHandler){
			var images=[];
			images.length=6;
			for (var i=0;i < 6;i++){
				var url=urls[i];
				images[i]=Loader.getRes(url);
				Loader.clearRes(url);
			}
			loader.endLoad(images);
			processHandler.recover();
		}

		Laya3D._onProcessChange=function(loader,offset,weight,process){
			process=offset+process *weight;
			(process < 1.0)&& (loader.event(/*laya.events.Event.PROGRESS*/"progress",process));
		}

		Laya3D.init=function(width,height,antialias,alpha,premultipliedAlpha,stencil){
			(antialias===void 0)&& (antialias=false);
			(alpha===void 0)&& (alpha=false);
			(premultipliedAlpha===void 0)&& (premultipliedAlpha=true);
			(stencil===void 0)&& (stencil=true);
			Config.isAntialias=antialias;
			Config.isAlpha=alpha;
			Config.premultipliedAlpha=premultipliedAlpha;
			Config.isStencil=stencil;
			if (!Render.isConchNode && !WebGL.enable()){
				alert("Laya3D init error,must support webGL!");
				return;
			}
			RunDriver.changeWebGLSize=Laya3D._changeWebGLSize;
			Render.is3DMode=true;
			Laya3D._innerTextureCubeLoaderManager.maxLoader=1;
			Laya3D._innerMaterialLoaderManager.maxLoader=1;
			Laya3D._innerMeshLoaderManager.maxLoader=1;
			Laya3D._innerSprite3DHierarchyLoaderManager.maxLoader=1;
			Laya.init(width,height);
			Layer.__init__();
			ShaderCompile3D.__init__();
			Laya3D._initShader();
			Laya3D._initResourceLoad();
			if (Laya3D.debugMode || OctreeNode.debugMode)
				Laya3D._debugPhasorSprite=new PhasorSpriter3D();
		}

		Laya3D.SPRITE3DHIERARCHY="SPRITE3DHIERARCHY";
		Laya3D.MESH="MESH";
		Laya3D.MATERIAL="MATERIAL";
		Laya3D.PBRMATERIAL="PBRMTL";
		Laya3D.TEXTURECUBE="TEXTURECUBE";
		Laya3D._readData=null
		Laya3D._debugPhasorSprite=null
		Laya3D.debugMode=false;
		__static(Laya3D,
		['_DATA',function(){return this._DATA={offset:0,size:0};},'_strings',function(){return this._strings=['BLOCK','DATA',"STRINGS"];},'_innerTextureCubeLoaderManager',function(){return this._innerTextureCubeLoaderManager=new LoaderManager();},'_innerMaterialLoaderManager',function(){return this._innerMaterialLoaderManager=new LoaderManager();},'_innerMeshLoaderManager',function(){return this._innerMeshLoaderManager=new LoaderManager();},'_innerSprite3DHierarchyLoaderManager',function(){return this._innerSprite3DHierarchyLoaderManager=new LoaderManager();}
		]);
		return Laya3D;
	})()


	/**
	*<code>Component3D</code> 类用于创建组件的父类。
	*/
	//class laya.d3.component.Component3D extends laya.events.EventDispatcher
	var Component3D=(function(_super){
		function Component3D(){
			this._destroyed=false;
			this._id=0;
			this._cachedOwnerLayerMask=0;
			this._cachedOwnerActiveInHierarchy=false;
			this._enable=false;
			this._owner=null;
			this.started=false;
			Component3D.__super.call(this);
			this._destroyed=false;
			this._id=Component3D._uniqueIDCounter;
			Component3D._uniqueIDCounter++;
		}

		__class(Component3D,'laya.d3.component.Component3D',_super);
		var __proto=Component3D.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IUpdate":true,"laya.resource.IDestroy":true})
		/**
		*@private
		*owner蒙版变化事件处理。
		*@param mask 蒙版值。
		*/
		__proto._onLayerChanged=function(layer){
			this._cachedOwnerLayerMask=layer.mask;
		}

		/**
		*@private
		*owner启用变化事件处理。
		*@param enable 是否启用。
		*/
		__proto._onActiveHierarchyChanged=function(active){
			this._cachedOwnerActiveInHierarchy=active;
		}

		/**
		*@private
		*初始化组件。
		*@param owner 所属Sprite3D节点。
		*/
		__proto._initialize=function(owner){
			this._owner=owner;
			this.enable=true;
			this.started=false;
			this._cachedOwnerLayerMask=owner.layer.mask;
			this._owner.on(/*laya.events.Event.LAYER_CHANGED*/"layerchanged",this,this._onLayerChanged);
			this._cachedOwnerActiveInHierarchy=owner.activeInHierarchy;
			this._owner.on(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onActiveHierarchyChanged);
			this._load(owner);
		}

		/**
		*@private
		*销毁组件。
		*/
		__proto._destroy=function(){
			this._unload(this.owner);
			this._owner=null;
			this._destroyed=true;
		}

		/**
		*@private
		*载入组件时执行,可重写此函数。
		*/
		__proto._load=function(owner){}
		/**
		*@private
		*在任意第一次更新时执行,可重写此函数。
		*/
		__proto._start=function(state){}
		/**
		*@private
		*更新组件,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._update=function(state){}
		/**
		*@private
		*更新的最后阶段执行,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._lateUpdate=function(state){}
		/**
		*@private
		*渲染前设置组件相关参数,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._preRenderUpdate=function(state){}
		/**
		*@private
		*渲染的最后阶段执行,可重写此函数。
		*@param state 渲染状态参数。
		*/
		__proto._postRenderUpdate=function(state){}
		/**
		*@private
		*卸载组件时执行,可重写此函数。
		*/
		__proto._unload=function(owner){
			this.offAll();
		}

		/**
		*获取唯一标识ID。
		*@return 唯一标识ID。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*获取是否已销毁。
		*@return 是否已销毁。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		/**
		*获取所属Sprite3D节点。
		*@return 所属Sprite3D节点。
		*/
		__getset(0,__proto,'owner',function(){
			return this._owner;
		});

		/**
		*设置是否启用。
		*@param value 是否启动
		*/
		/**
		*获取是否启用。
		*@return 是否启动。
		*/
		__getset(0,__proto,'enable',function(){
			return this._enable;
			},function(value){
			if (this._enable!==value){
				this._enable=value;
				this.event(/*laya.events.Event.ENABLE_CHANGED*/"enablechanged",this._enable);
			}
		});

		/**
		*获取是否为单实例组件。
		*@return 是否为单实例组件。
		*/
		__getset(0,__proto,'isSingleton',function(){
			return Component3D._isSingleton;
		});

		Component3D._isSingleton=true;
		Component3D._uniqueIDCounter=1;
		return Component3D;
	})(EventDispatcher)


	/**
	*<code>GeometryFilter</code> 类用于创建集合体过滤器,抽象类不允许实例。
	*/
	//class laya.d3.core.GeometryFilter extends laya.events.EventDispatcher
	var GeometryFilter=(function(_super){
		function GeometryFilter(){
			this._destroyed=false;
			GeometryFilter.__super.call(this);
			this._destroyed=false;
		}

		__class(GeometryFilter,'laya.d3.core.GeometryFilter',_super);
		var __proto=GeometryFilter.prototype;
		Laya.imps(__proto,{"laya.resource.IDestroy":true})
		/**
		*@private
		*/
		__proto._destroy=function(){
			this.offAll();
			this._destroyed=true;
		}

		/**@private */
		__getset(0,__proto,'_isAsyncLoaded',function(){
			return true;
		});

		/**
		*@private
		*/
		__getset(0,__proto,'_originalBoundingBoxCorners',function(){
			throw new Error("BaseRender: must override it.");
		});

		/**
		*@private
		*/
		__getset(0,__proto,'_originalBoundingSphere',function(){
			throw new Error("BaseRender: must override it.");
		});

		/**
		*@private
		*/
		__getset(0,__proto,'_originalBoundingBox',function(){
			throw new Error("BaseRender: must override it.");
		});

		/**
		*获取是否已销毁。
		*@return 是否已销毁。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		return GeometryFilter;
	})(EventDispatcher)


	/**
	*<code>Render</code> 类用于渲染器的父类，抽象类不允许示例。
	*/
	//class laya.d3.core.render.BaseRender extends laya.events.EventDispatcher
	var BaseRender=(function(_super){
		function BaseRender(owner){
			this._destroyed=false;
			this._enable=false;
			this._receiveShadow=false;
			this._boundingSphere=null;
			this._boundingBox=null;
			this._boundingBoxCenter=null;
			this._boundingSphereNeedChange=false;
			this._boundingBoxNeedChange=false;
			this._boundingBoxCenterNeedChange=false;
			this._octreeNodeNeedChange=false;
			this._materials=null;
			this._owner=null;
			this._renderElements=null;
			this._distanceForSort=NaN;
			this._treeNode=null;
			this.sortingFudge=NaN;
			this.castShadow=false;
			BaseRender.__super.call(this);
			this._destroyed=false;
			this._owner=owner;
			this._enable=true;
			this._boundingBox=new BoundBox(new Vector3(),new Vector3());
			this._boundingBoxCenter=new Vector3();
			this._boundingSphere=new BoundSphere(new Vector3(),0);
			this._boundingSphereNeedChange=true;
			this._boundingBoxNeedChange=true;
			this._boundingBoxCenterNeedChange=true;
			this._octreeNodeNeedChange=true;
			this._materials=[];
			this.sortingFudge=0.0;
			this._renderElements=[];
			this._owner.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatNeedChange);
		}

		__class(BaseRender,'laya.d3.core.render.BaseRender',_super);
		var __proto=BaseRender.prototype;
		Laya.imps(__proto,{"laya.resource.IDestroy":true})
		/**
		*@private
		*/
		__proto._onWorldMatNeedChange=function(){
			this._boundingSphereNeedChange=true;
			this._boundingBoxNeedChange=true;
			this._boundingBoxCenterNeedChange=true;
			this._octreeNodeNeedChange=true;
		}

		/**
		*@private
		*/
		__proto._calculateBoundingSphere=function(){
			throw("BaseRender: must override it.");
		}

		/**
		*@private
		*/
		__proto._calculateBoundingBox=function(){
			throw("BaseRender: must override it.");
		}

		/**
		*@private
		*/
		__proto._updateOctreeNode=function(){
			var treeNode=this._treeNode;
			if (treeNode && this._octreeNodeNeedChange){
				treeNode.updateObject(this);
				this._octreeNodeNeedChange=false;
			}
		}

		/**
		*@private
		*/
		__proto._destroy=function(){
			this.offAll();
			this._owner=null;
			this._materials=null;
			this._boundingBox=null;
			this._boundingBoxCenter=null;
			this._boundingSphere=null;
			this._destroyed=true;
		}

		/**
		*设置是否可用。
		*@param value 是否可用。
		*/
		/**
		*获取是否可用。
		*@return 是否可用。
		*/
		__getset(0,__proto,'enable',function(){
			return this._enable;
			},function(value){
			this._enable=value;
			this.event(/*laya.events.Event.ENABLE_CHANGED*/"enablechanged",[this,value]);
		});

		/**
		*获取包围球,不允许修改其值。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundingSphere',function(){
			if (this._boundingSphereNeedChange){
				this._calculateBoundingSphere();
				this._boundingSphereNeedChange=false;
			}
			return this._boundingSphere;
		});

		/**
		*设置第一个实例材质。
		*@param value 第一个实例材质。
		*/
		/**
		*返回第一个实例材质,第一次使用会拷贝实例对象。
		*@return 第一个实例材质。
		*/
		__getset(0,__proto,'material',function(){
			var material=this._materials[0];
			if (material && !material._isInstance){
				var instanceMaterial=/*__JS__ */new material.constructor();
				material.cloneTo(instanceMaterial);
				instanceMaterial.name=instanceMaterial.name+"(Instance)";
				instanceMaterial._isInstance=true;
				this._materials[0]=instanceMaterial;
				this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,0,instanceMaterial]);
			}
			return this._materials[0];
			},function(value){
			this._materials[0]=value;
			this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,0,value]);
		});

		/**
		*设置实例材质列表。
		*@param value 实例材质列表。
		*/
		/**
		*获取潜拷贝实例材质列表,第一次使用会拷贝实例对象。
		*@return 浅拷贝实例材质列表。
		*/
		__getset(0,__proto,'materials',function(){
			for (var i=0,n=this._materials.length;i < n;i++){
				var material=this._materials[i];
				if (!material._isInstance){
					var instanceMaterial=/*__JS__ */new material.constructor();
					material.cloneTo(instanceMaterial);
					instanceMaterial.name=instanceMaterial.name+"(Instance)";
					instanceMaterial._isInstance=true;
					this._materials[i]=instanceMaterial;
					this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,i,instanceMaterial]);
				}
			}
			return this._materials.slice();
			},function(value){
			if (!value)
				throw new Error("MeshRender: materials value can't be null.");
			this._materials=value;
			for (var i=0,n=value.length;i < n;i++)
			this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,i,value[i]]);
		});

		/**
		*设置第一个材质。
		*@param value 第一个材质。
		*/
		/**
		*返回第一个材质。
		*@return 第一个材质。
		*/
		__getset(0,__proto,'sharedMaterial',function(){
			return this._materials[0];
			},function(value){
			this._materials[0]=value;
			this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,0,value]);
		});

		/**
		*设置是否接收阴影属性
		*/
		/**
		*获得是否接收阴影属性
		*/
		__getset(0,__proto,'receiveShadow',function(){
			return this._receiveShadow;
			},function(value){
			if (this._receiveShadow!==value){
				this._receiveShadow=value;
				if (value)
					this._owner._addShaderDefine(/*laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_RECEIVE_SHADOW*/0x1);
				else
				this._owner._removeShaderDefine(/*laya.d3.shadowMap.ParallelSplitShadowMap.SHADERDEFINE_RECEIVE_SHADOW*/0x1);
			}
		});

		/**
		*获取包围盒,不允许修改其值。
		*@return 包围盒。
		*/
		__getset(0,__proto,'boundingBox',function(){
			if (this._boundingBoxNeedChange){
				this._calculateBoundingBox();
				this._boundingBoxNeedChange=false;
			}
			return this._boundingBox;
		});

		/**
		*设置材质列表。
		*@param value 材质列表。
		*/
		/**
		*获取浅拷贝材质列表。
		*@return 浅拷贝材质列表。
		*/
		__getset(0,__proto,'sharedMaterials',function(){
			var materials=this._materials.slice();
			return materials;
			},function(value){
			if (!value)
				throw new Error("MeshRender: shadredMaterials value can't be null.");
			this._materials=value;
			for (var i=0,n=value.length;i < n;i++)
			this.event(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",[this,i,value[i]]);
		});

		/**
		*获取包围盒中心,不允许修改其值。
		*@return 包围盒中心。
		*/
		__getset(0,__proto,'boundingBoxCenter',function(){
			if (this._boundingBoxCenterNeedChange){
				var boundBox=this.boundingBox;
				Vector3.add(boundBox.min,boundBox.max,this._boundingBoxCenter);
				Vector3.scale(this._boundingBoxCenter,0.5,this._boundingBoxCenter);
				this._boundingBoxCenterNeedChange=false;
			}
			return this._boundingBoxCenter;
		});

		/**
		*获取是否已销毁。
		*@return 是否已销毁。
		*/
		__getset(0,__proto,'destroyed',function(){
			return this._destroyed;
		});

		__static(BaseRender,
		['_tempBoudingBoxCorners',function(){return this._tempBoudingBoxCorners=/*new vector.<>*/[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];}
		]);
		return BaseRender;
	})(EventDispatcher)


	/**
	*<code>Transform3D</code> 类用于实现3D变换。
	*/
	//class laya.d3.core.Transform3D extends laya.events.EventDispatcher
	var Transform3D=(function(_super){
		function Transform3D(owner){
			this._owner=null;
			this._preWorldTransformModifyID=-1;
			this._localUpdate=false;
			this._worldUpdate=true;
			this._positionUpdate=true;
			this._rotationUpdate=true;
			this._scaleUpdate=true;
			this._parent=null;
			this.pivot=null;
			Transform3D.__super.call(this);
			this._localPosition=new Vector3();
			this._localRotation=new Quaternion(0,0,0,1);
			this._localScale=new Vector3(1,1,1);
			this._localMatrix=new Matrix4x4();
			this._position=new Vector3();
			this._rotation=new Quaternion(0,0,0,1);
			this._scale=new Vector3(1,1,1);
			this._worldMatrix=new Matrix4x4();
			this._forward=new Vector3();
			this._up=new Vector3();
			this._right=new Vector3();
			this._owner=owner;
		}

		__class(Transform3D,'laya.d3.core.Transform3D',_super);
		var __proto=Transform3D.prototype;
		/**
		*@private
		*/
		__proto._updateLocalMatrix=function(){
			if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0)){
				var scalePivot=Transform3D._tempVector30;
				Vector3.multiply(this.pivot,this._localScale,scalePivot);
				var scaleOffsetPosition=Transform3D._tempVector31;
				Vector3.subtract(scalePivot,this.pivot,scaleOffsetPosition);
				var rotationOffsetPosition=Transform3D._tempVector32;
				Vector3.transformQuat(scalePivot,this._localRotation,rotationOffsetPosition);
				Vector3.subtract(rotationOffsetPosition,scalePivot,rotationOffsetPosition);
				var resultLocalPosition=Transform3D._tempVector33;
				Vector3.subtract(this._localPosition,scaleOffsetPosition,resultLocalPosition);
				Vector3.subtract(resultLocalPosition,rotationOffsetPosition,resultLocalPosition);
				Matrix4x4.createAffineTransformation(resultLocalPosition,this._localRotation,this._localScale,this._localMatrix);
				}else {
				Matrix4x4.createAffineTransformation(this._localPosition,this._localRotation,this._localScale,this._localMatrix);
			}
		}

		/**
		*@private
		*/
		__proto._onLocalTransform=function(){
			this._localUpdate=true;
		}

		/**
		*@private
		*/
		__proto._onWorldPositionRotationTransform=function(){
			if (!this._worldUpdate || !this._positionUpdate || !this._rotationUpdate){
				this._worldUpdate=this._positionUpdate=this._rotationUpdate=true;
				this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
				for (var i=0,n=this._owner._childs.length;i < n;i++)
				(this._owner._childs [i]).transform._onWorldPositionRotationTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldPositionScaleTransform=function(){
			if (!this._worldUpdate || !this._positionUpdate || !this._scaleUpdate){
				this._worldUpdate=this._positionUpdate=this._scaleUpdate=true;
				this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
				for (var i=0,n=this._owner._childs.length;i < n;i++)
				(this._owner._childs [i]).transform._onWorldPositionScaleTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldPositionTransform=function(){
			if (!this._worldUpdate || !this._positionUpdate){
				this._worldUpdate=this._positionUpdate=true;
				this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
				for (var i=0,n=this._owner._childs.length;i < n;i++)
				(this._owner._childs [i]).transform._onWorldPositionTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldRotationTransform=function(){
			if (!this._worldUpdate || !this._rotationUpdate){
				this._worldUpdate=this._rotationUpdate=true;
				this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
				for (var i=0,n=this._owner._childs.length;i < n;i++)
				(this._owner._childs [i]).transform._onWorldRotationTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldScaleTransform=function(){
			if (!this._worldUpdate || !this._scaleUpdate){
				this._worldUpdate=this._scaleUpdate=true;
				this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
				for (var i=0,n=this._owner._childs.length;i < n;i++)
				(this._owner._childs [i]).transform._onWorldScaleTransform();
			}
		}

		/**
		*@private
		*/
		__proto._onWorldTransform=function(){
			if (!this._worldUpdate || !this._positionUpdate || !this._rotationUpdate || !this._scaleUpdate){
				this._worldUpdate=this._positionUpdate=this._rotationUpdate=this._scaleUpdate=true;
				this.event(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged");
				for (var i=0,n=this._owner._childs.length;i < n;i++)
				(this._owner._childs [i]).transform._onWorldTransform();
			}
		}

		/**
		*平移变换。
		*@param translation 移动距离。
		*@param isLocal 是否局部空间。
		*/
		__proto.translate=function(translation,isLocal){
			(isLocal===void 0)&& (isLocal=true);
			if (isLocal){
				Matrix4x4.createFromQuaternion(this.localRotation,Transform3D._tempMatrix0);
				Vector3.transformCoordinate(translation,Transform3D._tempMatrix0,Transform3D._tempVector30);
				Vector3.add(this.localPosition,Transform3D._tempVector30,this._localPosition);
				this.localPosition=this._localPosition;
				}else {
				Vector3.add(this.position,translation,this._position);
				this.position=this._position;
			}
		}

		/**
		*旋转变换。
		*@param rotations 旋转幅度。
		*@param isLocal 是否局部空间。
		*@param isRadian 是否弧度制。
		*/
		__proto.rotate=function(rotation,isLocal,isRadian){
			(isLocal===void 0)&& (isLocal=true);
			(isRadian===void 0)&& (isRadian=true);
			var rot;
			if (!isRadian){
				Vector3.scale(rotation,Math.PI / 180,Transform3D._tempVector30);
				rot=Transform3D._tempVector30;
				}else {
				rot=rotation;
			}
			Quaternion.createFromYawPitchRoll(rot.y,rot.x,rot.z,Transform3D._tempQuaternion0);
			if (isLocal){
				Quaternion.multiply(this._localRotation,Transform3D._tempQuaternion0,this._localRotation);
				this.localRotation=this._localRotation;
				}else {
				Quaternion.multiply(Transform3D._tempQuaternion0,this.rotation,this._rotation);
				this.rotation=this._rotation;
			}
		}

		/**
		*观察目标位置。
		*@param target 观察目标。
		*@param up 向上向量。
		*@param isLocal 是否局部空间。
		*/
		__proto.lookAt=function(target,up,isLocal){
			(isLocal===void 0)&& (isLocal=false);
			var targetE=target.elements;
			var eyeE;
			if (isLocal){
				eyeE=this._localPosition.elements;
				if (Math.abs(eyeE[0]-targetE[0])< MathUtils3D.zeroTolerance && Math.abs(eyeE[1]-targetE[1])< MathUtils3D.zeroTolerance && Math.abs(eyeE[2]-targetE[2])< MathUtils3D.zeroTolerance)
					return;
				Quaternion.lookAt(this._localPosition,target,up,this._localRotation);
				this._localRotation.invert(this._localRotation);
				this.localRotation=this._localRotation;
				}else {
				var worldPosition=this.position;
				eyeE=worldPosition.elements;
				if (Math.abs(eyeE[0]-targetE[0])< MathUtils3D.zeroTolerance && Math.abs(eyeE[1]-targetE[1])< MathUtils3D.zeroTolerance && Math.abs(eyeE[2]-targetE[2])< MathUtils3D.zeroTolerance)
					return;
				Quaternion.lookAt(worldPosition,target,up,this._rotation);
				this._rotation.invert(this._rotation);
				this.rotation=this._rotation;
			}
		}

		/**
		*@private
		*/
		__getset(0,__proto,'_isFrontFaceInvert',function(){
			var scale=this.scale;
			var isInvert=scale.x < 0;
			(scale.y < 0)&& (isInvert=!isInvert);
			(scale.z < 0)&& (isInvert=!isInvert);
			return isInvert;
		});

		/**
		*设置局部旋转。
		*@param value 局部旋转。
		*/
		/**
		*获取局部旋转。
		*@return 局部旋转。
		*/
		__getset(0,__proto,'localRotation',function(){
			return this._localRotation;
			},function(value){
			this._localRotation=value;
			this._localRotation.normalize(this._localRotation);
			this._onLocalTransform();
			if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
				this._onWorldPositionRotationTransform();
			else
			this._onWorldRotationTransform();
		});

		/**
		*设置世界矩阵。
		*@param value 世界矩阵。
		*/
		/**
		*获取世界矩阵。
		*@return 世界矩阵。
		*/
		__getset(0,__proto,'worldMatrix',function(){
			if (!this._worldUpdate)
				return this._worldMatrix;
			if (this._parent !=null)
				Matrix4x4.multiply(this._parent.worldMatrix,this.localMatrix,this._worldMatrix);
			else
			this.localMatrix.cloneTo(this._worldMatrix);
			this._worldUpdate=false;
			return this._worldMatrix;
			},function(value){
			if (this._parent===null){
				value.cloneTo(this._localMatrix);
				}else {
				this._parent.worldMatrix.invert(this._localMatrix);
				Matrix4x4.multiply(this._localMatrix,value,this._localMatrix);
			}
			this.localMatrix=this._localMatrix;
		});

		/**
		*获取世界矩阵是否需要更新。
		*@return 世界矩阵是否需要更新。
		*/
		__getset(0,__proto,'worldNeedUpdate',function(){
			return this._worldUpdate;
		});

		/**
		*设置局部矩阵。
		*@param value 局部矩阵。
		*/
		/**
		*获取局部矩阵。
		*@return 局部矩阵。
		*/
		__getset(0,__proto,'localMatrix',function(){
			if (this._localUpdate){
				this._updateLocalMatrix();
				this._localUpdate=false;
			}
			return this._localMatrix;
			},function(value){
			this._localMatrix=value;
			this._localMatrix.decomposeTransRotScale(this._localPosition,this._localRotation,this._localScale);
			this._onWorldTransform();
		});

		/**
		*设置局部位置。
		*@param value 局部位置。
		*/
		/**
		*获取局部位置。
		*@return 局部位置。
		*/
		__getset(0,__proto,'localPosition',function(){
			return this._localPosition;
			},function(value){
			this._localPosition=value;
			this._onLocalTransform();
			this._onWorldPositionTransform();
		});

		/**
		*设置局部缩放。
		*@param value 局部缩放。
		*/
		/**
		*获取局部缩放。
		*@return 局部缩放。
		*/
		__getset(0,__proto,'localScale',function(){
			return this._localScale;
			},function(value){
			this._localScale=value;
			this._onLocalTransform();
			if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
				this._onWorldPositionScaleTransform();
			else
			this._onWorldScaleTransform();
		});

		/**
		*设置世界位置。
		*@param value 世界位置。
		*/
		/**
		*获取世界位置。
		*@return 世界位置。
		*/
		__getset(0,__proto,'position',function(){
			if (!this._positionUpdate)
				return this._position;
			if (this._parent!==null){
				var worldMatElem=this.worldMatrix.elements;
				this._position.elements[0]=worldMatElem[12];
				this._position.elements[1]=worldMatElem[13];
				this._position.elements[2]=worldMatElem[14];
				}else {
				this._localPosition.cloneTo(this._position);
			}
			this._positionUpdate=false;
			return this._position;
			},function(value){
			if (this._parent!==null){
				this._parent.worldMatrix.invert(Transform3D._tempMatrix0);
				Vector3.transformCoordinate(value,Transform3D._tempMatrix0,this._localPosition);
				this.localPosition=this._localPosition;
				}else {
				value.cloneTo(this._localPosition);
				this.localPosition=this._localPosition;
			}
		});

		/**
		*设置局部空间的旋转角度。
		*@param value 欧拉角的旋转值，顺序为x、y、z。
		*/
		__getset(0,__proto,'localRotationEuler',null,function(value){
			Quaternion.createFromYawPitchRoll(value.y,value.x,value.z,this._localRotation);
			this._onLocalTransform();
			if (this.pivot && (this.pivot.x!==0 || this.pivot.y!==0 || this.pivot.z!==0))
				this._onWorldPositionRotationTransform();
			else
			this._onWorldRotationTransform();
		});

		/**
		*设置世界旋转。
		*@param value 世界旋转。
		*/
		/**
		*获取世界旋转。
		*@return 世界旋转。
		*/
		__getset(0,__proto,'rotation',function(){
			if (!this._rotationUpdate)
				return this._rotation;
			if (this._parent!==null){
				this.worldMatrix.decomposeTransRotScale(this._position,this._rotation,this._scale);
				}else {
				this._localRotation.cloneTo(this._rotation);
			}
			this._rotationUpdate=false;
			return this._rotation;
			},function(value){
			if (this._parent!==null){
				this._parent.rotation.invert(Transform3D._tempQuaternion0);
				Quaternion.multiply(value,Transform3D._tempQuaternion0,this._localRotation);
				this.localRotation=this._localRotation;
				}else {
				value.cloneTo(this._localRotation);
				this.localRotation=this._localRotation;
			}
		});

		/**
		*获取世界缩放。
		*@return 世界缩放。
		*/
		__getset(0,__proto,'scale',function(){
			if (!this._scaleUpdate)
				return this._scale;
			if (this._parent!==null){
				Vector3.multiply(this._parent.scale,this._localScale,this._scale);
				}else {
				this._localScale.cloneTo(this._scale);
			}
			this._scaleUpdate=false;
			return this._scale;
		});

		/**
		*设置局部空间的旋转角度。
		*@param 欧拉角的旋转值，顺序为x、y、z。
		*/
		__getset(0,__proto,'rotationEuler',null,function(value){
			Quaternion.createFromYawPitchRoll(value.y,value.x,value.z,this._rotation);
			this.rotation=this._rotation;
		});

		/**
		*获取向前方向。
		*@return 向前方向。
		*/
		__getset(0,__proto,'forward',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._forward.elements[0]=-worldMatElem[8];
			this._forward.elements[1]=-worldMatElem[9];
			this._forward.elements[2]=-worldMatElem[10];
			return this._forward;
		});

		/**
		*获取向上方向。
		*@return 向上方向。
		*/
		__getset(0,__proto,'up',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._up.elements[0]=worldMatElem[4];
			this._up.elements[1]=worldMatElem[5];
			this._up.elements[2]=worldMatElem[6];
			return this._up;
		});

		/**
		*获取向右方向。
		*@return 向右方向。
		*/
		__getset(0,__proto,'right',function(){
			var worldMatElem=this.worldMatrix.elements;
			this._right.elements[0]=worldMatElem[0];
			this._right.elements[1]=worldMatElem[1];
			this._right.elements[2]=worldMatElem[2];
			return this._right;
		});

		/**
		*设置父3D变换。
		*@param value 父3D变换。
		*/
		__getset(0,__proto,'parent',null,function(value){
			this._parent=value;
			(value)&& (this._onWorldTransform());
		});

		__static(Transform3D,
		['_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempQuaternion0',function(){return this._tempQuaternion0=new Quaternion();},'_tempMatrix0',function(){return this._tempMatrix0=new Matrix4x4();}
		]);
		return Transform3D;
	})(EventDispatcher)


	/**
	*<code>TransformUV</code> 类用于实现UV变换。
	*/
	//class laya.d3.core.TransformUV extends laya.events.EventDispatcher
	var TransformUV=(function(_super){
		function TransformUV(){
			this._rotation=0;
			//this._tiling=null;
			this._matNeedUpdte=false;
			TransformUV.__super.call(this);
			this._matrix=new Matrix4x4();
			this._offset=new Vector2();
			this._tiling=new Vector2(1.0,1.0);
		}

		__class(TransformUV,'laya.d3.core.TransformUV',_super);
		var __proto=TransformUV.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*@private
		*/
		__proto._updateMatrix=function(){
			TransformUV._tempOffsetV3.elements[0]=this._offset.x;
			TransformUV._tempOffsetV3.elements[1]=this._offset.y;
			Quaternion.createFromYawPitchRoll(0,0,this._rotation,TransformUV._tempRotationQua);
			TransformUV._tempTitlingV3.elements[0]=this._tiling.x;
			TransformUV._tempTitlingV3.elements[1]=this._tiling.y;
			Matrix4x4.createAffineTransformation(TransformUV._tempOffsetV3,TransformUV._tempRotationQua,TransformUV._tempTitlingV3,this._matrix);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			destObject._matrix=this._matrix.clone();
			destObject._offset=this._offset.clone();
			destObject._rotation=this._rotation;
			destObject._tiling=this._tiling.clone();
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=/*__JS__ */new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		/**
		*获取变换矩阵。
		*@return 变换矩阵。
		*/
		__getset(0,__proto,'matrix',function(){
			if (this._matNeedUpdte){
				this._updateMatrix();
				this._matNeedUpdte=false;
			}
			return this._matrix;
		});

		/**
		*设置平铺次数。
		*@param value 平铺次数。
		*/
		/**
		*获取平铺次数。
		*@return 平铺次数。
		*/
		__getset(0,__proto,'tiling',function(){
			return this._tiling;
			},function(value){
			this._tiling=value;
			this._matNeedUpdte=true;
		});

		/**
		*设置偏移。
		*@param value 偏移。
		*/
		/**
		*获取偏移。
		*@return 偏移。
		*/
		__getset(0,__proto,'offset',function(){
			return this._offset;
			},function(value){
			this._offset=value;
			this._matNeedUpdte=true;
		});

		/**
		*设置旋转。
		*@param value 旋转。
		*/
		/**
		*获取旋转。
		*@return 旋转。
		*/
		__getset(0,__proto,'rotation',function(){
			return this._rotation;
			},function(value){
			this._rotation=value;
			this._matNeedUpdte=true;
		});

		__static(TransformUV,
		['_tempOffsetV3',function(){return this._tempOffsetV3=new Vector3(0,0,0);},'_tempRotationQua',function(){return this._tempRotationQua=new Quaternion();},'_tempTitlingV3',function(){return this._tempTitlingV3=new Vector3(1,1,1);}
		]);
		return TransformUV;
	})(EventDispatcher)


	/**
	*<code>EmitterBox</code> 类用于盒发射器。
	*/
	//class laya.d3.core.particle.EmitterBox extends laya.particle.emitter.EmitterBase
	var EmitterBox=(function(_super){
		function EmitterBox(particle3D){
			this._settings=null;
			this._particle3D=null;
			EmitterBox.__super.call(this);
			this._resultPosition=new Vector3();
			this._resultVelocity=new Vector3();
			this.centerPosition=new Vector3();
			this.size=new Vector3();
			this.velocity=new Vector3();
			this.velocityAddVariance=new Vector3();
			this._particle3D=particle3D;
			var setting=particle3D.templet.settings;
			for (var i=0;i < 3;i++){
				this.centerPosition.elements[i]=setting.boxEmitterCenterPosition[i];
				this.size.elements[i]=setting.boxEmitterSize[i];
				this.velocity.elements[i]=setting.boxEmitterVelocity[i];
				this.velocityAddVariance.elements[i]=setting.boxEmitterVelocityAddVariance[i];
			}
			this.emissionRate=setting.emissionRate;
		}

		__class(EmitterBox,'laya.d3.core.particle.EmitterBox',_super);
		var __proto=EmitterBox.prototype;
		/**
		*@private
		*/
		__proto._randomPositionOnBox=function(){
			var rpe=this._resultPosition.elements;
			var cpe=this.centerPosition.elements;
			var se=this.size.elements;
			rpe[0]=cpe[0]+se[0] *(Math.random()-0.5);
			rpe[1]=cpe[1]+se[1] *(Math.random()-0.5);
			rpe[2]=cpe[2]+se[2] *(Math.random()-0.5);
			return this._resultPosition;
		}

		/**
		*@private
		*/
		__proto._randomVelocityOnBox=function(){
			var rve=this._resultVelocity.elements;
			var ve=this.velocity.elements;
			var vve=this.velocityAddVariance.elements;
			rve[0]=ve[0]+vve[0] *Math.random();
			rve[1]=ve[1]+vve[1] *Math.random();
			rve[2]=ve[2]+vve[2] *Math.random();
			return this._resultVelocity;
		}

		/**
		*盒发射器发射函数。
		*/
		__proto.emit=function(){
			_super.prototype.emit.call(this);
			this._particle3D.templet.addParticle(this._randomPositionOnBox(),this._randomVelocityOnBox());
		}

		/**
		*更新盒粒子发射器。
		*@param state 渲染相关状态参数。
		*/
		__proto.update=function(state){
			this.advanceTime(state.elapsedTime / 1000);
		}

		return EmitterBox;
	})(EmitterBase)


	/**
	*<code>EmitterPoint</code> 类用于点发射器。
	*/
	//class laya.d3.core.particle.EmitterPoint extends laya.particle.emitter.EmitterBase
	var EmitterPoint=(function(_super){
		function EmitterPoint(particle3D){
			this._settings=null;
			this._particle3D=null;
			EmitterPoint.__super.call(this);
			this._resultPosition=new Vector3();
			this._resultVelocity=new Vector3();
			this.position=new Vector3();
			this.positionVariance=new Vector3();
			this.velocity=new Vector3();
			this.velocityAddVariance=new Vector3();
			this._particle3D=particle3D;
			var setting=particle3D.templet.settings;
			for (var i=0;i < 3;i++){
				this.position.elements[i]=setting.pointEmitterPosition[i];
				this.positionVariance.elements[i]=setting.pointEmitterPositionVariance[i];
				this.velocity.elements[i]=setting.pointEmitterVelocity[i];
				this.velocityAddVariance.elements[i]=setting.pointEmitterVelocityAddVariance[i];
			}
			this.emissionRate=setting.emissionRate;
		}

		__class(EmitterPoint,'laya.d3.core.particle.EmitterPoint',_super);
		var __proto=EmitterPoint.prototype;
		/**
		*@private
		*/
		__proto._randomPositionOnPoint=function(){
			var rpe=this._resultPosition.elements;
			var pe=this.position.elements;
			var pve=this.positionVariance.elements;
			rpe[0]=pe[0]+pve[0] *(Math.random()-0.5)*2;
			rpe[1]=pe[1]+pve[1] *(Math.random()-0.5)*2;
			rpe[2]=pe[2]+pve[2] *(Math.random()-0.5)*2;
			return this._resultPosition;
		}

		/**
		*@private
		*/
		__proto._randomVelocityOnPoint=function(){
			var rve=this._resultVelocity.elements;
			var ve=this.velocity.elements;
			var vve=this.velocityAddVariance.elements;
			rve[0]=ve[0]+vve[0] *Math.random();
			rve[1]=ve[1]+vve[1] *Math.random();
			rve[2]=ve[2]+vve[2] *Math.random();
			return this._resultVelocity;
		}

		/**
		*点发射器发射函数。
		*/
		__proto.emit=function(){
			_super.prototype.emit.call(this);
			this._particle3D.templet.addParticle(this._randomPositionOnPoint(),this._randomVelocityOnPoint());
		}

		/**
		*更新点粒子发射器。
		*@param state 渲染相关状态参数。
		*/
		__proto.update=function(state){
			this.advanceTime(state.elapsedTime / 1000);
		}

		return EmitterPoint;
	})(EmitterBase)


	/**
	*<code>EmitterRing</code> 类用于环发射器。
	*/
	//class laya.d3.core.particle.EmitterRing extends laya.particle.emitter.EmitterBase
	var EmitterRing=(function(_super){
		function EmitterRing(particle3D){
			this._settings=null;
			this._particle3D=null;
			this.radius=30;
			this.velocity=0;
			this.velocityAddVariance=0;
			this.up=2;
			EmitterRing.__super.call(this);
			this._resultPosition=new Vector3();
			this._resultVelocity=new Vector3();
			this._direction=new Vector3();
			this.centerPosition=new Vector3();
			this._particle3D=particle3D;
			var setting=particle3D.templet.settings;
			for (var i=0;i < 3;i++){
				this.centerPosition.elements[i]=setting.ringEmitterCenterPosition[i];
			}
			this.radius=setting.ringEmitterRadius
			this.velocity=setting.ringEmitterVelocity
			this.velocityAddVariance=setting.ringEmitterVelocityAddVariance
			this.emissionRate=setting.emissionRate;
		}

		__class(EmitterRing,'laya.d3.core.particle.EmitterRing',_super);
		var __proto=EmitterRing.prototype;
		/**
		*@private
		*/
		__proto._randomPointOnRing=function(){
			var angle=Math.random()*Math.PI *2;
			var x=Math.cos(angle);
			var y=Math.sin(angle);
			var rpe=this._resultPosition.elements;
			var cpe=this.centerPosition.elements;
			switch (this.up){
				case 0:
					rpe[0]=cpe[0]+0;
					rpe[1]=cpe[1]+x *this.radius;
					rpe[2]=cpe[2]+y *this.radius;
					break ;
				case 1:
					rpe[0]=cpe[0]+x *this.radius;
					rpe[1]=cpe[1]+0;
					rpe[2]=cpe[2]+y *this.radius;
					break ;
				case 2:
					rpe[0]=cpe[0]+x *this.radius;
					rpe[1]=cpe[1]+y *this.radius;
					rpe[2]=cpe[2]+0;
					break ;
				}
			return this._resultPosition;
		}

		/**
		*@private
		*/
		__proto._randomVelocityOnRing=function(){
			var rve=this._resultVelocity.elements;
			this._resultPosition.cloneTo(this._direction);
			Vector3.normalize(this._direction,this._direction);
			var de=this._direction.elements;
			rve[0]=de[0] *(this.velocity+this.velocityAddVariance *Math.random());
			rve[1]=de[1] *(this.velocity+this.velocityAddVariance *Math.random());
			rve[2]=de[2] *(this.velocity+this.velocityAddVariance *Math.random());
			return this._resultVelocity;
		}

		/**
		*环发射器发射函数。
		*/
		__proto.emit=function(){
			_super.prototype.emit.call(this);
			this._particle3D.templet.addParticle(this._randomPointOnRing(),this._randomVelocityOnRing());
		}

		/**
		*更新环粒子发射器。
		*@param state 渲染相关状态参数。
		*/
		__proto.update=function(elapsedTime){
			this.advanceTime(elapsedTime / 1000);
		}

		return EmitterRing;
	})(EmitterBase)


	/**
	*<code>EmitterSphere</code> 类用于球发射器。
	*/
	//class laya.d3.core.particle.EmitterSphere extends laya.particle.emitter.EmitterBase
	var EmitterSphere=(function(_super){
		function EmitterSphere(particle3D){
			this._settings=null;
			this._particle3D=null;
			this.radius=1;
			this.velocity=0;
			this.velocityAddVariance=0;
			EmitterSphere.__super.call(this);
			this._reultPosition=new Vector3();
			this._resultVelocity=new Vector3();
			this._direction=new Vector3();
			this.centerPosition=new Vector3();
			this._particle3D=particle3D;
			var setting=particle3D.templet.settings;
			for (var i=0;i < 3;i++){
				this.centerPosition.elements[i]=setting.sphereEmitterCenterPosition[i];
			}
			this.radius=setting.sphereEmitterRadius
			this.velocity=setting.sphereEmitterVelocity
			this.velocityAddVariance=setting.sphereEmitterVelocityAddVariance
			this.emissionRate=setting.emissionRate;
		}

		__class(EmitterSphere,'laya.d3.core.particle.EmitterSphere',_super);
		var __proto=EmitterSphere.prototype;
		/**
		*@private
		*/
		__proto._randomPositionOnSphere=function(){
			var angleVer=Math.random()*Math.PI *2;
			var angleHor=Math.random()*Math.PI *2;
			var r=Math.cos(angleVer)*this.radius;
			var y=Math.sin(angleVer)*this.radius;
			var x=Math.cos(angleHor)*r;
			var z=Math.sin(angleHor)*r;
			var rpe=this._reultPosition.elements;
			var cpe=this.centerPosition.elements;
			rpe[0]=cpe[0]+x;
			rpe[1]=cpe[1]+y;
			rpe[2]=cpe[2]+z;
			return this._reultPosition;
		}

		/**
		*@private
		*/
		__proto._randomVelocityOnSphere=function(){
			var rve=this._resultVelocity.elements;
			this._reultPosition.cloneTo(this._direction);
			Vector3.normalize(this._direction,this._direction);
			var de=this._direction.elements;
			rve[0]=de[0] *(this.velocity+this.velocityAddVariance *Math.random());
			rve[1]=de[1] *(this.velocity+this.velocityAddVariance *Math.random());
			rve[2]=de[2] *(this.velocity+this.velocityAddVariance *Math.random());
			return this._resultVelocity;
		}

		/**
		*球发射器发射函数。
		*/
		__proto.emit=function(){
			_super.prototype.emit.call(this);
			this._particle3D.templet.addParticle(this._randomPositionOnSphere(),this._randomVelocityOnSphere());
		}

		/**
		*更新球粒子发射器。
		*@param state 渲染相关状态参数。
		*/
		__proto.update=function(state){
			this.advanceTime(state.elapsedTime / 1000);
		}

		return EmitterSphere;
	})(EmitterBase)


	/**
	*<code>SplineCurvePosition</code> 类用于通过顶点创建闪光插值。
	*/
	//class laya.d3.core.glitter.SplineCurvePosition extends laya.d3.core.glitter.SplineCurvePositionVelocity
	var SplineCurvePosition=(function(_super){
		/**
		*创建一个 <code>SplineCurvePosition</code> 实例。
		*/
		function SplineCurvePosition(){
			SplineCurvePosition.__super.call(this);
		}

		__class(SplineCurvePosition,'laya.d3.core.glitter.SplineCurvePosition',_super);
		var __proto=SplineCurvePosition.prototype;
		/**
		*@private
		*计算速度。
		*/
		__proto._CalcVelocity=function(left,right,out){
			Vector3.subtract(left,right,out);
			Vector3.scale(out,0.5,out);
		}

		/**
		*初始化插值所需信息。
		*@param lastPosition0 顶点0的上次位置。
		*@param position0 顶点0的位置。
		*@param lastPosition1 顶点1的上次位置。
		*@param position1 顶点1的位置。
		*/
		__proto.Init=function(lastPosition0,position0,lastPosition1,position1){
			this._CalcVelocity(position0,lastPosition0,this._tempVector30);
			this._CalcVelocity(position1,lastPosition1,this._tempVector31);
			_super.prototype.Init.call(this,position0,this._tempVector30,position1,this._tempVector31);
		}

		return SplineCurvePosition;
	})(SplineCurvePositionVelocity)


	/**
	*<code>BoxShape</code> 类用于创建球形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.BoxShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var BoxShape=(function(_super){
		function BoxShape(){
			this.x=NaN;
			this.y=NaN;
			this.z=NaN;
			BoxShape.__super.call(this);
			this.x=1.0;
			this.y=1.0;
			this.z=1.0;
			this.randomDirection=false;
		}

		__class(BoxShape,'laya.d3.core.particleShuriKen.module.shape.BoxShape',_super);
		var __proto=BoxShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=-this.x *0.5;
			minE[1]=-this.y *0.5;
			minE[2]=-this.z *0.5;
			var maxE=boundBox.max.elements;
			maxE[0]=this.x *0.5;
			maxE[1]=this.y *0.5;
			maxE[2]=this.z *0.5;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=0.0;
			minE[1]=0.0;
			minE[2]=0.0;
			var maxE=boundBox.max.elements;
			maxE[0]=0.0;
			maxE[1]=1.0;
			maxE[2]=0.0;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			var rpE=position.elements;
			var rdE=direction.elements;
			if (rand){
				rand.seed=randomSeeds[16];
				ShapeUtils._randomPointInsideHalfUnitBox(position,rand);
				randomSeeds[16]=rand.seed;
				}else {
				ShapeUtils._randomPointInsideHalfUnitBox(position);
			}
			rpE[0]=this.x *rpE[0];
			rpE[1]=this.y *rpE[1];
			rpE[2]=this.z *rpE[2];
			if (this.randomDirection){
				if (rand){
					rand.seed=randomSeeds[17];
					ShapeUtils._randomPointUnitSphere(direction,rand);
					randomSeeds[17]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitSphere(direction);
				}
				}else {
				rdE[0]=0.0;
				rdE[1]=0.0;
				rdE[2]=1.0;
			}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.x=this.x;
			destShape.y=this.y;
			destShape.z=this.z;
			destShape.randomDirection=this.randomDirection;
		}

		return BoxShape;
	})(BaseShape)


	/**
	*<code>CircleShape</code> 类用于创建环形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.CircleShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var CircleShape=(function(_super){
		function CircleShape(){
			this.radius=NaN;
			this.arc=NaN;
			this.emitFromEdge=false;
			CircleShape.__super.call(this);
			this.radius=1.0;
			this.arc=360.0 / 180.0 *Math.PI;
			this.emitFromEdge=false;
			this.randomDirection=false;
		}

		__class(CircleShape,'laya.d3.core.particleShuriKen.module.shape.CircleShape',_super);
		var __proto=CircleShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[2]=-this.radius;
			minE[1]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[2]=this.radius;
			maxE[1]=0;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=-1;
			minE[2]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=1;
			maxE[2]=0;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			var rpE=position.elements;
			var positionPointE=CircleShape._tempPositionPoint.elements;
			if (rand){
				rand.seed=randomSeeds[16];
				if (this.emitFromEdge)
					ShapeUtils._randomPointUnitArcCircle(this.arc,CircleShape._tempPositionPoint,rand);
				else
				ShapeUtils._randomPointInsideUnitArcCircle(this.arc,CircleShape._tempPositionPoint,rand);
				randomSeeds[16]=rand.seed;
				}else {
				if (this.emitFromEdge)
					ShapeUtils._randomPointUnitArcCircle(this.arc,CircleShape._tempPositionPoint);
				else
				ShapeUtils._randomPointInsideUnitArcCircle(this.arc,CircleShape._tempPositionPoint);
			}
			rpE[0]=positionPointE[0];
			rpE[1]=positionPointE[1];
			rpE[2]=0;
			Vector3.scale(position,this.radius,position);
			if (this.randomDirection){
				if (rand){
					rand.seed=randomSeeds[17];
					ShapeUtils._randomPointUnitSphere(direction,rand);
					randomSeeds[17]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitSphere(direction);
				}
				}else {
				position.cloneTo(direction);
			}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.radius=this.radius;
			destShape.arc=this.arc;
			destShape.emitFromEdge=this.emitFromEdge;
			destShape.randomDirection=this.randomDirection;
		}

		__static(CircleShape,
		['_tempPositionPoint',function(){return this._tempPositionPoint=new Vector2();}
		]);
		return CircleShape;
	})(BaseShape)


	/**
	*<code>ConeShape</code> 类用于创建锥形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.ConeShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var ConeShape=(function(_super){
		function ConeShape(){
			this.angle=NaN;
			this.radius=NaN;
			this.length=NaN;
			this.emitType=0;
			ConeShape.__super.call(this);
			this.angle=25.0 / 180.0 *Math.PI;
			this.radius=1.0;
			this.length=5.0;
			this.emitType=0;
			this.randomDirection=false;
		}

		__class(ConeShape,'laya.d3.core.particleShuriKen.module.shape.ConeShape',_super);
		var __proto=ConeShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var coneRadius2=this.radius+this.length *Math.sin(this.angle);
			var coneLength=this.length *Math.cos(this.angle);
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=-coneRadius2;
			minE[2]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=coneRadius2;
			maxE[2]=coneLength;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var sinA=Math.sin(this.angle);
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=-sinA;
			minE[2]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=minE[1]=sinA;
			maxE[2]=1;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			var rpE=position.elements;
			var rdE=direction.elements;
			var positionPointE=ConeShape._tempPositionPoint.elements;
			var positionX=NaN;
			var positionY=NaN;
			var directionPointE;
			var dirCosA=Math.cos(this.angle);
			var dirSinA=Math.sin(this.angle);
			switch (this.emitType){
				case 0:
					if (rand){
						rand.seed=randomSeeds[16];
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint,rand);
						randomSeeds[16]=rand.seed;
						}else {
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
					}
					positionX=positionPointE[0];
					positionY=positionPointE[1];
					rpE[0]=positionX *this.radius;
					rpE[1]=positionY *this.radius;
					rpE[2]=0;
					if (this.randomDirection){
						if (rand){
							rand.seed=randomSeeds[17];
							ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,rand);
							randomSeeds[17]=rand.seed;
							}else {
							ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
						}
						directionPointE=ConeShape._tempDirectionPoint.elements;
						rdE[0]=directionPointE[0] *dirSinA;
						rdE[1]=directionPointE[1] *dirSinA;
						}else {
						rdE[0]=positionX *dirSinA;
						rdE[1]=positionY *dirSinA;
					}
					rdE[2]=dirCosA;
					break ;
				case 1:
					if (rand){
						rand.seed=randomSeeds[16];
						ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint,rand);
						randomSeeds[16]=rand.seed;
						}else {
						ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
					}
					positionX=positionPointE[0];
					positionY=positionPointE[1];
					rpE[0]=positionX *this.radius;
					rpE[1]=positionY *this.radius;
					rpE[2]=0;
					if (this.randomDirection){
						if (rand){
							rand.seed=randomSeeds[17];
							ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,rand);
							randomSeeds[17]=rand.seed;
							}else {
							ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint);
						}
						directionPointE=ConeShape._tempDirectionPoint.elements;
						rdE[0]=directionPointE[0] *dirSinA;
						rdE[1]=directionPointE[1] *dirSinA;
						}else {
						rdE[0]=positionX *dirSinA;
						rdE[1]=positionY *dirSinA;
					}
					rdE[2]=dirCosA;
					break ;
				case 2:
					if (rand){
						rand.seed=randomSeeds[16];
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint,rand);
						}else {
						ShapeUtils._randomPointInsideUnitCircle(ConeShape._tempPositionPoint);
					}
					positionX=positionPointE[0];
					positionY=positionPointE[1];
					rpE[0]=positionX *this.radius;
					rpE[1]=positionY *this.radius;
					rpE[2]=0;
					rdE[0]=positionX *dirSinA;
					rdE[1]=positionY *dirSinA;
					rdE[2]=dirCosA;
					Vector3.normalize(direction,direction);
					if (rand){
						Vector3.scale(direction,this.length *rand.getFloat(),direction);
						randomSeeds[16]=rand.seed;
						}else {
						Vector3.scale(direction,this.length *Math.random(),direction);
					}
					Vector3.add(position,direction,position);
					if (this.randomDirection){
						if (rand){
							rand.seed=randomSeeds[17];
							ShapeUtils._randomPointUnitSphere(direction,rand);
							randomSeeds[17]=rand.seed;
							}else {
							ShapeUtils._randomPointUnitSphere(direction);
						}
					}
					break ;
				case 3:
					if (rand){
						rand.seed=randomSeeds[16];
						ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint,rand);
						}else {
						ShapeUtils._randomPointUnitCircle(ConeShape._tempPositionPoint);
					}
					positionX=positionPointE[0];
					positionY=positionPointE[1];
					rpE[0]=positionX *this.radius;
					rpE[1]=positionY *this.radius;
					rpE[2]=0;
					rdE[0]=positionX *dirSinA;
					rdE[1]=positionY *dirSinA;
					rdE[2]=dirCosA;
					Vector3.normalize(direction,direction);
					if (rand){
						Vector3.scale(direction,this.length *rand.getFloat(),direction);
						randomSeeds[16]=rand.seed;
						}else {
						Vector3.scale(direction,this.length *Math.random(),direction);
					}
					Vector3.add(position,direction,position);
					if (this.randomDirection){
						if (rand){
							rand.seed=randomSeeds[17];
							ShapeUtils._randomPointUnitSphere(direction,rand);
							randomSeeds[17]=rand.seed;
							}else {
							ShapeUtils._randomPointUnitSphere(direction);
						}
					}
					break ;
				default :
					throw new Error("ConeShape:emitType is invalid.");
				}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.angle=this.angle;
			destShape.radius=this.radius;
			destShape.length=this.length;
			destShape.emitType=this.emitType;
			destShape.randomDirection=this.randomDirection;
		}

		__static(ConeShape,
		['_tempPositionPoint',function(){return this._tempPositionPoint=new Vector2();},'_tempDirectionPoint',function(){return this._tempDirectionPoint=new Vector2();}
		]);
		return ConeShape;
	})(BaseShape)


	/**
	*<code>HemisphereShape</code> 类用于创建半球形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.HemisphereShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var HemisphereShape=(function(_super){
		function HemisphereShape(){
			this.radius=NaN;
			this.emitFromShell=false;
			HemisphereShape.__super.call(this);
			this.radius=1.0;
			this.emitFromShell=false;
			this.randomDirection=false;
		}

		__class(HemisphereShape,'laya.d3.core.particleShuriKen.module.shape.HemisphereShape',_super);
		var __proto=HemisphereShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=minE[2]=-this.radius;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=this.radius;
			maxE[2]=0;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=-1;
			minE[2]=0;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=maxE[2]=1;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			var rpE=position.elements;
			if (rand){
				rand.seed=randomSeeds[16];
				if (this.emitFromShell)
					ShapeUtils._randomPointUnitSphere(position,rand);
				else
				ShapeUtils._randomPointInsideUnitSphere(position,rand);
				randomSeeds[16]=rand.seed;
				}else {
				if (this.emitFromShell)
					ShapeUtils._randomPointUnitSphere(position);
				else
				ShapeUtils._randomPointInsideUnitSphere(position);
			}
			Vector3.scale(position,this.radius,position);
			var z=rpE[2];
			(z > 0.0)&& (rpE[2]=z *-1.0);
			if (this.randomDirection){
				if (rand){
					rand.seed=randomSeeds[17];
					ShapeUtils._randomPointUnitSphere(direction,rand);
					randomSeeds[17]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitSphere(direction);
				}
				}else {
				position.cloneTo(direction);
			}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.radius=this.radius;
			destShape.emitFromShell=this.emitFromShell;
			destShape.randomDirection=this.randomDirection;
		}

		return HemisphereShape;
	})(BaseShape)


	/**
	*<code>SphereShape</code> 类用于创建球形粒子形状。
	*/
	//class laya.d3.core.particleShuriKen.module.shape.SphereShape extends laya.d3.core.particleShuriKen.module.shape.BaseShape
	var SphereShape=(function(_super){
		function SphereShape(){
			this.radius=NaN;
			this.emitFromShell=false;
			SphereShape.__super.call(this);
			this.radius=1.0;
			this.emitFromShell=false;
			this.randomDirection=false;
		}

		__class(SphereShape,'laya.d3.core.particleShuriKen.module.shape.SphereShape',_super);
		var __proto=SphereShape.prototype;
		/**
		*@inheritDoc
		*/
		__proto._getShapeBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=minE[2]=-this.radius;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=maxE[2]=this.radius;
		}

		/**
		*@inheritDoc
		*/
		__proto._getSpeedBoundBox=function(boundBox){
			var minE=boundBox.min.elements;
			minE[0]=minE[1]=minE[2]=-1;
			var maxE=boundBox.max.elements;
			maxE[0]=maxE[1]=maxE[2]=1;
		}

		/**
		*用于生成粒子初始位置和方向。
		*@param position 粒子位置。
		*@param direction 粒子方向。
		*/
		__proto.generatePositionAndDirection=function(position,direction,rand,randomSeeds){
			if (rand){
				rand.seed=randomSeeds[16];
				if (this.emitFromShell)
					ShapeUtils._randomPointUnitSphere(position,rand);
				else
				ShapeUtils._randomPointInsideUnitSphere(position,rand);
				randomSeeds[16]=rand.seed;
				}else {
				if (this.emitFromShell)
					ShapeUtils._randomPointUnitSphere(position);
				else
				ShapeUtils._randomPointInsideUnitSphere(position);
			}
			Vector3.scale(position,this.radius,position);
			if (this.randomDirection){
				if (rand){
					rand.seed=randomSeeds[17];
					ShapeUtils._randomPointUnitSphere(direction,rand);
					randomSeeds[17]=rand.seed;
					}else {
					ShapeUtils._randomPointUnitSphere(direction);
				}
				}else {
				position.cloneTo(direction);
			}
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var destShape=destObject;
			destShape.radius=this.radius;
			destShape.emitFromShell=this.emitFromShell;
			destShape.randomDirection=this.randomDirection;
		}

		return SphereShape;
	})(BaseShape)


	/**
	*<code>Sprite3D</code> 类用于实现3D精灵。
	*/
	//class laya.d3.core.Sprite3D extends laya.display.Node
	var Sprite3D=(function(_super){
		function Sprite3D(name){
			this._projectionViewWorldMatrix=null;
			this._projectionViewWorldUpdateLoopCount=0;
			this._projectionViewWorldUpdateCamera=null;
			this._id=0;
			this._componentsMap=null;
			this._typeComponentsIndices=null;
			this._components=null;
			this._url=null;
			this._belongScene=false;
			this._active=false;
			this._activeInHierarchy=false;
			this._layer=null;
			this._shaderDefineValue=0;
			this._shaderValues=null;
			this._colliders=null;
			this.transform=null;
			this.isStatic=false;
			Sprite3D.__super.call(this);
			this._projectionViewWorldUpdateLoopCount=-1;
			this._projectionViewWorldMatrix=new Matrix4x4();
			this._shaderValues=new ValusArray();
			this._colliders=[];
			this._componentsMap=[];
			this._typeComponentsIndices=[];
			this._components=[];
			this._belongScene=false;
			(name)? (this.name=name):(this.name="Sprite3D-"+Sprite3D._nameNumberCounter++);
			this._activeInHierarchy=false;
			this._id=++Sprite3D._uniqueIDCounter;
			this.layer=Layer.currentCreationLayer;
			this.transform=new Transform3D(this);
			this.active=true;
		}

		__class(Sprite3D,'laya.d3.core.Sprite3D',_super);
		var __proto=Sprite3D.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IUpdate":true,"laya.resource.ICreateResource":true,"laya.d3.core.IClone":true})
		/**
		*@private
		*/
		__proto._setBelongScene=function(){
			this._belongScene=true;
			for (var i=0,n=this._childs.length;i < n;i++)
			(this._childs [i])._setBelongScene();
		}

		/**
		*@private
		*/
		__proto._setUnBelongScene=function(){
			this._belongScene=false;
			for (var i=0,n=this._childs.length;i < n;i++)
			(this._childs [i])._setUnBelongScene();
		}

		/**
		*@private
		*/
		__proto._inActiveHierarchy=function(){
			this._activeInHierarchy=false;
			this._clearSelfRenderObjects();
			this.event(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",false);
			for (var i=0,n=this._childs.length;i < n;i++){
				var child=this._childs [i];
				(child._active)&& (child._inActiveHierarchy());
			}
		}

		/**
		*@private
		*/
		__proto._activeHierarchy=function(){
			this._activeInHierarchy=true;
			this._addSelfRenderObjects();
			this.event(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",true);
			for (var i=0,n=this._childs.length;i < n;i++){
				var child=this._childs [i];
				(child._active)&& (child._activeHierarchy());
			}
		}

		/**
		*@private
		*/
		__proto._removeComponent=function(mapIndex,index){
			var componentIndices=this._typeComponentsIndices[mapIndex];
			var componentIndex=componentIndices[index];
			var component=this._components[componentIndex];
			if ((component instanceof laya.d3.component.physics.Collider )){
				var colliderComponent=component;
				var colliders=this._layer._colliders;
				colliders.splice(colliders.indexOf(colliderComponent),1);
				this._colliders.splice(this._colliders.indexOf(colliderComponent),1);
			}
			this._components.splice(componentIndex,1);
			componentIndices.splice(index,1);
			(componentIndices.length===0)&& (this._typeComponentsIndices.splice(mapIndex,1),this._componentsMap.splice(mapIndex,1));
			for (var i=0,n=this._componentsMap.length;i < n;i++){
				componentIndices=this._typeComponentsIndices[i];
				for (var j=componentIndices.length-1;j >=0;j--){
					var oldComponentIndex=componentIndices[j];
					if (oldComponentIndex > componentIndex)
						componentIndices[j]=--oldComponentIndex;
					else
					break ;
				}
			}
			component._destroy();
			this.event(/*laya.events.Event.COMPONENT_REMOVED*/"componentremoved",component);
		}

		/**
		*@private
		*/
		__proto.createConchModel=function(){
			return /*__JS__ */null;
		}

		/**
		*增加Shader宏定义。
		*@param value 宏定义。
		*/
		__proto._addShaderDefine=function(value){
			this._shaderDefineValue |=value;
		}

		/**
		*移除Shader宏定义。
		*@param value 宏定义。
		*/
		__proto._removeShaderDefine=function(value){
			this._shaderDefineValue &=~value;
		}

		/**
		*清理自身渲染物体，请重载此函数。
		*/
		__proto._clearSelfRenderObjects=function(){}
		/**
		*添加自身渲染物体，请重载此函数。
		*/
		__proto._addSelfRenderObjects=function(){}
		/**
		*更新组件update函数。
		*@param state 渲染相关状态。
		*/
		__proto._updateComponents=function(state){
			for (var i=0,n=this._components.length;i < n;i++){
				var component=this._components[i];
				(!component.started)&& (component._start(state),component.started=true);
				(component.enable)&& (component._update(state));
			}
		}

		/**
		*更新组件lateUpdate函数。
		*@param state 渲染相关状态。
		*/
		__proto._lateUpdateComponents=function(state){
			for (var i=0;i < this._components.length;i++){
				var component=this._components[i];
				(!component.started)&& (component._start(state),component.started=true);
				(component.enable)&& (component._lateUpdate(state));
			}
		}

		/**
		*更新子节点。
		*@param state 渲染相关状态。
		*/
		__proto._updateChilds=function(state){
			var n=this._childs.length;
			if (n===0)return;
			for (var i=0;i < n;++i)
			this._childs[i]._update((state));
		}

		/**
		*更新子节点。
		*@param state 渲染相关状态。
		*/
		__proto._updateChildsConch=function(state){
			var n=this._childs.length;
			if (n===0)return;
			for (var i=0;i < n;++i)
			this._childs[i]._update((state));
		}

		/**
		*排序函数。
		*@param state 渲染相关状态。
		*/
		__proto._getSortID=function(renderElement,material){
			return renderElement._getVertexBuffer().vertexDeclaration.id+material.id */*laya.d3.graphics.VertexDeclaration._maxVertexDeclarationBit*/1000;
		}

		/**
		*@private
		*/
		__proto._renderUpdate=function(projectionView){
			this._setShaderValueMatrix4x4(/*CLASS CONST:laya.d3.core.Sprite3D.WORLDMATRIX*/0,this.transform.worldMatrix);
			var projViewWorld=this.getProjectionViewWorldMatrix(projectionView);
			this._setShaderValueMatrix4x4(/*CLASS CONST:laya.d3.core.Sprite3D.MVPMATRIX*/1,projViewWorld);
		}

		/**
		*更新
		*@param state 渲染相关状态
		*/
		__proto._update=function(state){
			state.owner=this;
			if (this._activeInHierarchy){
				this._updateComponents(state);
				this._lateUpdateComponents(state);
				Stat.spriteCount++;
				this._childs.length && this._updateChilds(state);
			}
		}

		/**
		*更新
		*@param state 渲染相关状态
		*/
		__proto._updateConch=function(state){
			state.owner=this;
			if (this._activeInHierarchy){
				this._updateComponents(state);
				this._lateUpdateComponents(state);
				Stat.spriteCount++;
				this._childs.length && this._updateChilds(state);
			}
		}

		/**
		*@private
		*/
		__proto._setShaderValueMatrix4x4=function(shaderName,matrix4x4){
			this._shaderValues.setValue(shaderName,matrix4x4 ? matrix4x4.elements :null);
		}

		/**
		*设置颜色。
		*@param shaderIndex shader索引。
		*@param color 颜色向量。
		*/
		__proto._setShaderValueColor=function(shaderIndex,color){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,color ? color.elements :null);
		}

		/**
		*设置Buffer。
		*@param shaderIndex shader索引。
		*@param buffer buffer数据。
		*/
		__proto._setShaderValueBuffer=function(shaderIndex,buffer){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,buffer);
		}

		/**
		*设置整型。
		*@param shaderIndex shader索引。
		*@param i 整形。
		*/
		__proto._setShaderValueInt=function(shaderIndex,i){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,i);
		}

		/**
		*设置布尔。
		*@param shaderIndex shader索引。
		*@param b 布尔。
		*/
		__proto._setShaderValueBool=function(shaderIndex,b){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,b);
		}

		/**
		*设置浮点。
		*@param shaderIndex shader索引。
		*@param i 浮点。
		*/
		__proto._setShaderValueNumber=function(shaderIndex,number){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,number);
		}

		/**
		*设置二维向量。
		*@param shaderIndex shader索引。
		*@param vector2 二维向量。
		*/
		__proto._setShaderValueVector2=function(shaderIndex,vector2){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,vector2 ? vector2.elements :null);
		}

		/**
		*获取投影视图世界矩阵。
		*@param projectionViewMatrix 投影视图矩阵。
		*@return 投影视图世界矩阵。
		*/
		__proto.getProjectionViewWorldMatrix=function(projectionViewMatrix){
			var curLoopCount=Stat.loopCount;
			Matrix4x4.multiply(projectionViewMatrix,this.transform.worldMatrix,this._projectionViewWorldMatrix);
			return this._projectionViewWorldMatrix;
		}

		/**
		*加载层级文件，并作为该节点的子节点。
		*@param url
		*/
		__proto.loadHierarchy=function(url){
			this.addChild(laya.d3.core.Sprite3D.load(url));
		}

		/**
		*@inheritDoc
		*/
		__proto.addChildAt=function(node,index){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			var returnNode=_super.prototype.addChildAt.call(this,node,index);
			var sprite3D=node;
			sprite3D.transform.parent=this.transform;
			if (this._belongScene){
				sprite3D._setBelongScene();
				(this._activeInHierarchy && sprite3D._active)&& (sprite3D._activeHierarchy());
			}
			return returnNode;
		}

		/**
		*@inheritDoc
		*/
		__proto.addChild=function(node){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			var returnNode=_super.prototype.addChild.call(this,node);
			var sprite3D=node;
			sprite3D.transform.parent=this.transform;
			if (this._belongScene){
				sprite3D._setBelongScene();
				(this._activeInHierarchy && sprite3D._active)&& (sprite3D._activeHierarchy());
			}
			return returnNode;
		}

		/**
		*@inheritDoc
		*/
		__proto.removeChildAt=function(index){
			var node=this.getChildAt(index);
			if (node){
				var sprite3D=node;
				sprite3D.transform.parent=null;
				if (this._belongScene){
					sprite3D._setUnBelongScene();
					(this._activeInHierarchy && sprite3D._active)&& (sprite3D._inActiveHierarchy());
				}
				this._childs.splice(index,1);
				this.conchModel && this.conchModel.removeChild(node.conchModel);
				node.parent=null;
			}
			return node;
		}

		/**
		*@inheritDoc
		*/
		__proto.removeChildren=function(beginIndex,endIndex){
			(beginIndex===void 0)&& (beginIndex=0);
			(endIndex===void 0)&& (endIndex=0x7fffffff);
			if (this._childs && this._childs.length > 0){
				var childs=this._childs;
				if (beginIndex===0 && endIndex >=n){
					var arr=childs;
					this._childs=Node.ARRAY_EMPTY;
					}else {
					arr=childs.splice(beginIndex,endIndex-beginIndex);
				}
				for (var i=0,n=arr.length;i < n;i++){
					arr[i].parent=null;
					var sprite3D=arr [i];
					sprite3D.transform.parent=null;
					if (this._belongScene){
						sprite3D._setUnBelongScene();
						(this._activeInHierarchy && sprite3D._active)&& (sprite3D._inActiveHierarchy());
					}
					this.conchModel && this.conchModel.removeChild(arr[i].conchModel);
				}
			}
			return this;
		}

		/**
		*添加指定类型组件。
		*@param type 组件类型。
		*@return 组件。
		*/
		__proto.addComponent=function(type){
			var typeComponentIndex;
			var index=this._componentsMap.indexOf(type);
			if (index===-1){
				typeComponentIndex=[];
				this._componentsMap.push(type);
				this._typeComponentsIndices.push(typeComponentIndex);
				}else {
				typeComponentIndex=this._typeComponentsIndices[index];
				if (this._components[typeComponentIndex[0]].isSingleton)
					throw new Error("无法单实例创建"+type+"组件"+"，"+type+"组件已存在！");
			};
			var component=ClassUtils.getInstance(type);
			typeComponentIndex.push(this._components.length);
			this._components.push(component);
			if ((component instanceof laya.d3.component.physics.Collider )){
				this._layer._colliders.push(component);
				this._colliders.push(component);
			}
			component._initialize(this);
			this.event(/*laya.events.Event.COMPONENT_ADDED*/"componentadded",component);
			return component;
		}

		/**
		*通过指定类型和类型索引获得组件。
		*@param type 组件类型。
		*@param typeIndex 类型索引。
		*@return 组件。
		*/
		__proto.getComponentByType=function(type,typeIndex){
			(typeIndex===void 0)&& (typeIndex=0);
			var mapIndex=this._componentsMap.indexOf(type);
			if (mapIndex===-1)
				return null;
			return this._components[this._typeComponentsIndices[mapIndex][typeIndex]];
		}

		/**
		*通过指定类型获得所有组件。
		*@param type 组件类型。
		*@param components 组件输出队列。
		*/
		__proto.getComponentsByType=function(type,components){
			var index=this._componentsMap.indexOf(type);
			if (index===-1)
				components.length=0;
			var typeComponents=this._typeComponentsIndices[index];
			var count=typeComponents.length;
			components.length=count;
			for (var i=0;i < count;i++)
			components[i]=this._components[typeComponents[i]];
		}

		/**
		*通过指定索引获得组件。
		*@param index 索引。
		*@return 组件。
		*/
		__proto.getComponentByIndex=function(index){
			return this._components[index];
		}

		/**
		*通过指定类型和类型索引移除组件。
		*@param type 组件类型。
		*@param typeIndex 类型索引。
		*/
		__proto.removeComponentByType=function(type,typeIndex){
			(typeIndex===void 0)&& (typeIndex=0);
			var mapIndex=this._componentsMap.indexOf(type);
			if (mapIndex===-1)
				return;
			this._removeComponent(mapIndex,typeIndex);
		}

		/**
		*通过指定类型移除所有组件。
		*@param type 组件类型。
		*/
		__proto.removeComponentsByType=function(type){
			var mapIndex=this._componentsMap.indexOf(type);
			if (mapIndex===-1)
				return;
			var componentIndices=this._typeComponentsIndices[mapIndex];
			for (var i=0,n=componentIndices.length;i < n;componentIndices.length < n ? n--:i++)
			this._removeComponent(mapIndex,i);
		}

		/**
		*移除全部组件。
		*/
		__proto.removeAllComponent=function(){
			for (var i=0,n=this._componentsMap.length;i < n;this._componentsMap.length < n ? n--:i++)
			this.removeComponentsByType(this._componentsMap[i]);
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(url,data,params){
			if (this.destroyed)
				return;
			var oriData=data[0];
			var innerResouMap=data[1];
			ClassUtils.createByJson(oriData,this,this,Handler.create(null,Utils3D._parseHierarchyProp,[innerResouMap],false),Handler.create(null,Utils3D._parseHierarchyNode,null,false));
			this.event(/*laya.events.Event.HIERARCHY_LOADED*/"hierarchyloaded",[this]);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destSprite3D=destObject;
			destSprite3D.name=this.name;
			destSprite3D.destroyed=this.destroyed;
			destSprite3D.timer=this.timer;
			destSprite3D._$P=this._$P;
			destSprite3D.active=this._active;
			var destLocalPosition=destSprite3D.transform.localPosition;
			this.transform.localPosition.cloneTo(destLocalPosition);
			destSprite3D.transform.localPosition=destLocalPosition;
			var destLocalRotation=destSprite3D.transform.localRotation;
			this.transform.localRotation.cloneTo(destLocalRotation);
			destSprite3D.transform.localRotation=destLocalRotation;
			var destLocalScale=destSprite3D.transform.localScale;
			this.transform.localScale.cloneTo(destLocalScale);
			destSprite3D.transform.localScale=destLocalScale;
			destSprite3D.isStatic=this.isStatic;
			var i=0,n=0;
			for (i=0,n=this._componentsMap.length;i < n;i++)
			destSprite3D.addComponent(this._componentsMap[i]);
			for (i=0,n=this._childs.length;i < n;i++)
			destSprite3D.addChild(this._childs[i].clone());
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destSprite3D=/*__JS__ */new this.constructor();
			this.cloneTo(destSprite3D);
			return destSprite3D;
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			var i=0,n=0;
			for (i=0,n=this._components.length;i < n;i++)
			this._components[i]._destroy();
			this._components=null;
			this._componentsMap=null;
			this._typeComponentsIndices=null;
			this.transform=null;
			var colliders=this._layer._colliders;
			for (i=0,n=this._colliders.length;i < n;i++)
			colliders.splice(colliders.indexOf(this._colliders[i]),1);
			this._colliders=null;
			Loader.clearRes(this.url);
		}

		/**
		*获得组件的数量。
		*@return 组件数量。
		*/
		__getset(0,__proto,'componentsCount',function(){
			return this._typeComponentsIndices.length;
		});

		/**
		*获取唯一标识ID。
		*@return 唯一标识ID。
		*/
		__getset(0,__proto,'id',function(){
			return this._id;
		});

		/**
		*获取在层级中是否激活。
		*@return 在层级中是否激活。
		*/
		__getset(0,__proto,'activeInHierarchy',function(){
			return this._activeInHierarchy;
		});

		/**
		*设置是否激活。
		*@param value 是否激活。
		*/
		/**
		*获取自身是否激活。
		*@return 自身是否激活。
		*/
		__getset(0,__proto,'active',function(){
			return this._active;
			},function(value){
			if (this._active!==value){
				this._active=value;
				if (this._belongScene){
					if (value)
						this._activeHierarchy();
					else
					this._inActiveHierarchy();
				}
			}
		});

		/**
		*获取是否属于场景。
		*@return 是否属于场景。
		*/
		__getset(0,__proto,'belongScene',function(){
			return this._belongScene;
		});

		/**
		*色湖之资源的URL地址。
		*@param value URL地址。
		*/
		/**
		*获取资源的URL地址。
		*@return URL地址。
		*/
		__getset(0,__proto,'url',function(){
			return this._url;
			},function(value){
			this._url=value;
		});

		/**
		*设置蒙版。
		*@param value 蒙版。
		*/
		/**
		*获取蒙版。
		*@return 蒙版。
		*/
		__getset(0,__proto,'layer',function(){
			return this._layer;
			},function(value){
			if (value){
				var i=0,n=this._colliders.length;
				if (this._layer){
					var oldColliders=this._layer._colliders;
					for (i=0;i < n;i++)
					oldColliders.splice(oldColliders.indexOf(this._colliders[i]),1);
				};
				var colliders=value._colliders;
				for (i=0;i < n;i++)
				colliders.push(this._colliders[i]);
				this._layer=value;
				this.event(/*laya.events.Event.LAYER_CHANGED*/"layerchanged",value);
				}else {
				throw new Error("Layer value can be null.");
			}
		});

		/**
		*获得所属场景。
		*@return 场景。
		*/
		__getset(0,__proto,'scene',function(){
			return this.parent ? (this.parent).scene :null;
		});

		Sprite3D.instantiate=function(original,position,rotation,parent,worldPositionStays){
			(worldPositionStays===void 0)&& (worldPositionStays=true);
			var destSprite3D=original.clone();
			var transform;
			if (position || rotation){
				(parent)&& (parent.addChild(destSprite3D));
				transform=destSprite3D.transform;
				(position)&& (transform.position=position);
				(rotation)&& (transform.rotation=rotation);
				}else {
				if (worldPositionStays){
					transform=destSprite3D.transform;
					if (parent){
						var oriPosition=transform.position;
						var oriRotation=transform.rotation;
						parent.addChild(destSprite3D);
						transform.position=oriPosition;
						transform.rotation=oriRotation;
					}
					}else {
					if (parent){
						parent.addChild(destSprite3D);
					}
				}
			}
			return destSprite3D;
		}

		Sprite3D.load=function(url){
			return Laya.loader.create(url,null,null,Sprite3D,null,1,false);
		}

		Sprite3D.WORLDMATRIX=0;
		Sprite3D.MVPMATRIX=1;
		Sprite3D._uniqueIDCounter=0;
		Sprite3D._nameNumberCounter=0;
		return Sprite3D;
	})(Node)


	/**
	*<code>BaseMaterial</code> 类用于创建材质,抽象类,不允许实例。
	*/
	//class laya.d3.core.material.BaseMaterial extends laya.resource.Resource
	var BaseMaterial=(function(_super){
		function BaseMaterial(){
			this._sharderNameID=0;
			this._shaderDefineValue=0;
			this._disablePublicShaderDefine=0;
			this._shaderValues=null;
			this._values=null;
			this._textureSharderIndices=null;
			this._shader=null;
			this._alphaTest=false;
			this._renderQueue=0;
			this._shaderCompile=null;
			this._isInstance=false;
			this.cull=0;
			this.blend=0;
			this.srcBlend=0;
			this.dstBlend=0;
			this.srcBlendRGB=0;
			this.dstBlendRGB=0;
			this.srcBlendAlpha=0;
			this.dstBlendAlpha=0;
			this.blendConstColor=null;
			this.blendEquation=0;
			this.blendEquationRGB=0;
			this.blendEquationAlpha=0;
			this.depthTest=false;
			this.depthFunc=0;
			this.depthWrite=false;
			this._conchMaterial=null;
			BaseMaterial.__super.call(this);
			this._loaded=true;
			this._isInstance=false;
			this._shaderDefineValue=0;
			this._disablePublicShaderDefine=0;
			this._shaderValues=new ValusArray();
			this._values=[];
			this._textureSharderIndices=[];
			this.cull=2;
			this.blend=0;
			this.srcBlend=1;
			this.dstBlend=0;
			this.srcBlendRGB=1;
			this.dstBlendRGB=0;
			this.srcBlendAlpha=1;
			this.dstBlendAlpha=0;
			this.blendConstColor=new Vector4(1,1,1,1);
			this.blendEquation=0;
			this.blendEquationRGB=0;
			this.blendEquationAlpha=0;
			this.depthTest=true;
			this.depthFunc=0x0201;
			this.depthWrite=true;
			if (Render.isConchNode){
				this._conchMaterial=/*__JS__ */new ConchMaterial();
			}
		}

		__class(BaseMaterial,'laya.d3.core.material.BaseMaterial',_super);
		var __proto=BaseMaterial.prototype;
		Laya.imps(__proto,{"laya.d3.core.IClone":true})
		/**
		*@private
		*/
		__proto._uploadTextures=function(){
			for (var i=0,n=this._textureSharderIndices.length;i < n;i++){
				var shaderIndex=this._textureSharderIndices[i];
				var texture=this._values[shaderIndex];
				if (texture)
					this._uploadTexture(shaderIndex,texture.source || texture.defaulteTexture.source);
			}
		}

		/**
		*@private
		*/
		__proto._getShader=function(sceneDefineValue,vertexDefineValue,spriteDefineValue){
			var publicDefineValue=(sceneDefineValue | vertexDefineValue)& (~this._disablePublicShaderDefine);
			this._shader=this._shaderCompile.withCompile(this._sharderNameID,publicDefineValue,spriteDefineValue,this._shaderDefineValue);
			return this._shader;
		}

		/**
		*@private
		*/
		__proto._uploadTexture=function(shaderIndex,textureSource){
			this._shaderValues.data[shaderIndex]=textureSource;
		}

		/**
		*增加Shader宏定义。
		*@param value 宏定义。
		*/
		__proto._addShaderDefine=function(value){
			this._shaderDefineValue |=value;
			if (this._conchMaterial){
				this._conchMaterial.addShaderDefine(value);
			}
		}

		/**
		*移除Shader宏定义。
		*@param value 宏定义。
		*/
		__proto._removeShaderDefine=function(value){
			this._shaderDefineValue &=~value;
			if (this._conchMaterial){
				this._conchMaterial.removeShaderDefine(value);
			}
		}

		/**
		*增加禁用宏定义。
		*@param value 宏定义。
		*/
		__proto._addDisablePublicShaderDefine=function(value){
			this._disablePublicShaderDefine |=value;
		}

		/**
		*移除禁用宏定义。
		*@param value 宏定义。
		*/
		__proto._removeDisablePublicShaderDefine=function(value){
			this._disablePublicShaderDefine &=~value;
		}

		/**
		*设置Buffer。
		*@param shaderIndex shader索引。
		*@param buffer buffer数据。
		*/
		__proto._setBuffer=function(shaderIndex,buffer){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,buffer);
			this._values[shaderIndex]=buffer;
			if (this._conchMaterial){
				this._conchMaterial.setShaderValue(shaderIndex,buffer,0);
			}
		}

		/**
		*获取Buffer。
		*@param shaderIndex shader索引。
		*@return
		*/
		__proto._getBuffer=function(shaderIndex){
			return this._values[shaderIndex];
		}

		/**
		*设置矩阵。
		*@param shaderIndex shader索引。
		*@param matrix4x4 矩阵。
		*/
		__proto._setMatrix4x4=function(shaderIndex,matrix4x4){
			this._shaderValues.setValue(shaderIndex,matrix4x4 ? matrix4x4.elements :null);
			this._values[shaderIndex]=matrix4x4;
			if (this._conchMaterial){
				this._conchMaterial.setShaderValue(shaderIndex,matrix4x4.elements,0);
			}
		}

		/**
		*获取矩阵。
		*@param shaderIndex shader索引。
		*@return 矩阵。
		*/
		__proto._getMatrix4x4=function(shaderIndex){
			return this._values[shaderIndex];
		}

		/**
		*设置整型。
		*@param shaderIndex shader索引。
		*@param i 整形。
		*/
		__proto._setInt=function(shaderIndex,i){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,i);
			this._values[shaderIndex]=i;
			if (this._conchMaterial){
				this._conchMaterial.setShaderValue(shaderIndex,i,1);
			}
		}

		/**
		*获取整形。
		*@param shaderIndex shader索引。
		*@return 整形。
		*/
		__proto._getInt=function(shaderIndex){
			return this._values[shaderIndex];
		}

		/**
		*设置浮点。
		*@param shaderIndex shader索引。
		*@param i 浮点。
		*/
		__proto._setNumber=function(shaderIndex,number){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,number);
			this._values[shaderIndex]=number;
			if (this._conchMaterial){
				this._conchMaterial.setShaderValue(shaderIndex,number,2);
			}
		}

		/**
		*获取浮点。
		*@param shaderIndex shader索引。
		*@return 浮点。
		*/
		__proto._getNumber=function(shaderIndex){
			return this._values[shaderIndex];
		}

		/**
		*设置布尔。
		*@param shaderIndex shader索引。
		*@param b 布尔。
		*/
		__proto._setBool=function(shaderIndex,b){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,b);
			this._values[shaderIndex]=b;
			if (this._conchMaterial){
				this._conchMaterial.setShaderValue(shaderIndex,b,1);
			}
		}

		/**
		*获取布尔。
		*@param shaderIndex shader索引。
		*@return 布尔。
		*/
		__proto._getBool=function(shaderIndex){
			return this._values[shaderIndex];
		}

		/**
		*设置二维向量。
		*@param shaderIndex shader索引。
		*@param vector2 二维向量。
		*/
		__proto._setVector2=function(shaderIndex,vector2){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,vector2 ? vector2.elements :null);
			this._values[shaderIndex]=vector2;
			if (this._conchMaterial){
				this._conchMaterial.setShaderValue(shaderIndex,vector2.elements,0);
			}
		}

		/**
		*获取二维向量。
		*@param shaderIndex shader索引。
		*@return 二维向量。
		*/
		__proto._getVector2=function(shaderIndex){
			return this._values[shaderIndex];
		}

		/**
		*设置颜色。
		*@param shaderIndex shader索引。
		*@param color 颜色向量。
		*/
		__proto._setColor=function(shaderIndex,color){
			var shaderValue=this._shaderValues;
			shaderValue.setValue(shaderIndex,color ? color.elements :null);
			this._values[shaderIndex]=color;
			if (this._conchMaterial && color){
				this._conchMaterial.setShaderValue(shaderIndex,color.elements,0);
			}
		}

		/**
		*获取颜色。
		*@param shaderIndex shader索引。
		*@return 颜色向量。
		*/
		__proto._getColor=function(shaderIndex){
			return this._values[shaderIndex];
		}

		/**
		*设置纹理。
		*@param shaderIndex shader索引。
		*@param texture 纹理。
		*/
		__proto._setTexture=function(shaderIndex,texture){
			var shaderValue=this._shaderValues;
			var value=this._values[shaderIndex];
			if (!value && texture)
				this._textureSharderIndices.push(shaderIndex);
			else if (value && !texture)
			this._textureSharderIndices.splice(this._textureSharderIndices.indexOf(shaderIndex),1);
			this._values[shaderIndex]=texture;
			if (this._conchMaterial){
				this._conchMaterial.setTexture(texture._conchTexture,this._textureSharderIndices.indexOf(shaderIndex),shaderIndex);
			}
		}

		/**
		*获取纹理。
		*@param shaderIndex shader索引。
		*@return 纹理。
		*/
		__proto._getTexture=function(shaderIndex){
			return this._values[shaderIndex];
		}

		/**
		*上传材质。
		*@param state 相关渲染状态。
		*@param bufferUsageShader Buffer相关绑定。
		*@param shader 着色器。
		*@return 是否成功。
		*/
		__proto._upload=function(){
			this._uploadTextures();
			this._shader.uploadMaterialUniforms(this._shaderValues.data);
		}

		__proto._setMaterialShaderParams=function(state){}
		/**
		*设置渲染相关状态。
		*/
		__proto._setRenderStateBlendDepth=function(){
			var gl=WebGL.mainContext;
			WebGLContext.setDepthTest(gl,this.depthTest);
			WebGLContext.setDepthMask(gl,this.depthWrite);
			WebGLContext.setDepthFunc(gl,this.depthFunc);
			switch (this.blend){
				case 0:
					WebGLContext.setBlend(gl,false);
					break ;
				case 1:
					WebGLContext.setBlend(gl,true);
					WebGLContext.setBlendFunc(gl,this.srcBlend,this.dstBlend);
					break ;
				case 2:
					WebGLContext.setBlend(gl,true);
					break ;
				}
		}

		/**
		*设置渲染相关状态。
		*/
		__proto._setRenderStateFrontFace=function(isTarget,transform){
			var gl=WebGL.mainContext;
			var forntFace=0;
			switch (this.cull){
				case 0:
					WebGLContext.setCullFace(gl,false);
					break ;
				case 1:
					WebGLContext.setCullFace(gl,true);
					if (isTarget){
						if (transform._isFrontFaceInvert)
							forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
						else
						forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
						}else {
						if (transform._isFrontFaceInvert)
							forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
						else
						forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
					}
					WebGLContext.setFrontFace(gl,forntFace);
					break ;
				case 2:
					WebGLContext.setCullFace(gl,true);
					if (isTarget){
						if (transform._isFrontFaceInvert)
							forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
						else
						forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
						}else {
						if (transform._isFrontFaceInvert)
							forntFace=/*laya.webgl.WebGLContext.CCW*/0x0901;
						else
						forntFace=/*laya.webgl.WebGLContext.CW*/0x0900;
					}
					WebGLContext.setFrontFace(gl,forntFace);
					break ;
				}
		}

		/**
		*设置使用Shader名字。
		*@param name 名称。
		*/
		__proto.setShaderName=function(name){
			this._sharderNameID=Shader3D.nameKey.getID(name);
			this._shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
			if (this._conchMaterial){
				this._conchMaterial.setShader(this._shaderCompile._conchShader);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(url,data,params){
			var jsonData=data[0];
			var textureMap=data[1];
			switch (jsonData.version){
				case "LAYAMATERIAL:01":;
					var props=jsonData.props;
					var i=0,n=0;
					for (var prop in props){
					switch (prop){
						case "colors":;
							var colors=props[prop];
							for (i=0,n=colors.length;i < n;i++){
								var color=colors[i];
								var colorValue=color.value;
							switch (colorValue.length){
								case 2:
									this[color.name]=new Vector2(colorValue[0],colorValue[1]);
									break ;
								case 3:
									this[color.name]=new Vector3(colorValue[0],colorValue[1],colorValue[2]);
									break ;
								case 4:
									this[color.name]=new Vector4(colorValue[0],colorValue[1],colorValue[2],colorValue[3]);
									break ;
								default :
									throw new Error("BaseMaterial:unkonwn color length.");
								}
						}
						break ;
						case "textures":;
						var textures=props[prop];
						for (i=0,n=textures.length;i < n;i++){
							var texture=textures[i];
							var path=texture.path;
							(path)&& (this[texture.name]=Loader.getRes(textureMap[path]));
						}
						break ;
						default :
						this[prop]=props[prop];
					}
				}
				break ;
				default :
				throw new Error("BaseMaterial:unkonwn version.");
			}
			this.event(/*laya.events.Event.LOADED*/"loaded",this);
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var destBaseMaterial=destObject;
			destBaseMaterial.name=this.name;
			destBaseMaterial.cull=this.cull;
			destBaseMaterial.blend=this.blend;
			destBaseMaterial.srcBlend=this.srcBlend;
			destBaseMaterial.dstBlend=this.dstBlend;
			destBaseMaterial.srcBlendRGB=this.srcBlendRGB;
			destBaseMaterial.dstBlendRGB=this.dstBlendRGB;
			destBaseMaterial.srcBlendAlpha=this.srcBlendAlpha;
			destBaseMaterial.dstBlendAlpha=this.dstBlendAlpha;
			this.blendConstColor.cloneTo(destBaseMaterial.blendConstColor);
			destBaseMaterial.blendEquation=this.blendEquation;
			destBaseMaterial.blendEquationRGB=this.blendEquationRGB;
			destBaseMaterial.blendEquationAlpha=this.blendEquationAlpha;
			destBaseMaterial.depthTest=this.depthTest;
			destBaseMaterial.depthFunc=this.depthFunc;
			destBaseMaterial.depthWrite=this.depthWrite;
			destBaseMaterial._loaded=this._loaded;
			destBaseMaterial._renderQueue=this._renderQueue;
			destBaseMaterial._shader=this._shader;
			destBaseMaterial._sharderNameID=this._sharderNameID;
			destBaseMaterial._disablePublicShaderDefine=this._disablePublicShaderDefine;
			destBaseMaterial._shaderDefineValue=this._shaderDefineValue;
			var i=0,n=0;
			var destShaderValues=destBaseMaterial._shaderValues;
			destBaseMaterial._shaderValues.data.length=this._shaderValues.data.length;
			var valueCount=this._values.length;
			var destValues=destBaseMaterial._values;
			destValues.length=valueCount;
			for (i=0,n=valueCount;i < n;i++){
				var value=this._values[i];
				if (value){
					if ((typeof value=='number')){
						destValues[i]=value;
						destShaderValues.data[i]=value;
						}else if (((typeof value=='number')&& Math.floor(value)==value)){
						destValues[i]=value;
						destShaderValues.data[i]=value;
						}else if ((typeof value=='boolean')){
						destValues[i]=value;
						destShaderValues.data[i]=value;
						}else if ((value instanceof laya.d3.math.Vector2 )){
						var v2=(destValues[i])|| (destValues[i]=new Vector2());
						(value).cloneTo(v2);
						destShaderValues.data[i]=v2.elements;
						}else if ((value instanceof laya.d3.math.Vector3 )){
						var v3=(destValues[i])|| (destValues[i]=new Vector3());
						(value).cloneTo(v3);
						destShaderValues.data[i]=v3.elements;
						}else if ((value instanceof laya.d3.math.Vector4 )){
						var v4=(destValues[i])|| (destValues[i]=new Vector4());
						(value).cloneTo(v4);
						destShaderValues.data[i]=v4.elements;
						}else if ((value instanceof laya.d3.math.Matrix4x4 )){
						var mat=(destValues[i])|| (destValues[i]=new Matrix4x4());
						(value).cloneTo(mat);
						destShaderValues.data[i]=mat.elements;
						}else if ((value instanceof laya.d3.resource.BaseTexture )){
						destValues[i]=value;
					}
				}
			}
			destBaseMaterial._textureSharderIndices=this._textureSharderIndices.slice();
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var destBaseMaterial=/*__JS__ */new this.constructor();
			this.cloneTo(destBaseMaterial);
			return destBaseMaterial;
		}

		/**
		*@inheritDoc
		*/
		__proto.dispose=function(){
			this.resourceManager.removeResource(this);
			_super.prototype.dispose.call(this);
		}

		/**
		*获取所属渲染队列。
		*@return 渲染队列。
		*/
		__getset(0,__proto,'renderQueue',function(){
			return this._renderQueue;
		});

		/**
		*设置透明测试模式裁剪值。
		*@param value 透明测试模式裁剪值。
		*/
		/**
		*获取透明测试模式裁剪值。
		*@return 透明测试模式裁剪值。
		*/
		__getset(0,__proto,'alphaTestValue',function(){
			return this._getNumber(0);
			},function(value){
			this._setNumber(0,value);
		});

		/**
		*设置是否透明裁剪。
		*@param value 是否透明裁剪。
		*/
		/**
		*获取是否透明裁剪。
		*@return 是否透明裁剪。
		*/
		__getset(0,__proto,'alphaTest',function(){
			return this._alphaTest;
			},function(value){
			this._alphaTest=value;
			if (value)
				this._addShaderDefine(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
			else
			this._removeShaderDefine(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
		});

		BaseMaterial.CULL_NONE=0;
		BaseMaterial.CULL_FRONT=1;
		BaseMaterial.CULL_BACK=2;
		BaseMaterial.BLEND_DISABLE=0;
		BaseMaterial.BLEND_ENABLE_ALL=1;
		BaseMaterial.BLEND_ENABLE_SEPERATE=2;
		BaseMaterial.BLENDPARAM_ZERO=0;
		BaseMaterial.BLENDPARAM_ONE=1;
		BaseMaterial.BLENDPARAM_SRC_COLOR=0x0300;
		BaseMaterial.BLENDPARAM_ONE_MINUS_SRC_COLOR=0x0301;
		BaseMaterial.BLENDPARAM_DST_COLOR=0x0306;
		BaseMaterial.BLENDPARAM_ONE_MINUS_DST_COLOR=0x0307;
		BaseMaterial.BLENDPARAM_SRC_ALPHA=0x0302;
		BaseMaterial.BLENDPARAM_ONE_MINUS_SRC_ALPHA=0x0303;
		BaseMaterial.BLENDPARAM_DST_ALPHA=0x0304;
		BaseMaterial.BLENDPARAM_ONE_MINUS_DST_ALPHA=0x0305;
		BaseMaterial.BLENDPARAM_CONSTANT_COLOR=0x8001;
		BaseMaterial.BLENDPARAM_ONE_MINUS_CONSTANT_COLOR=0x8002;
		BaseMaterial.BLENDPARAM_CONSTANT_ALPHA=0x8003;
		BaseMaterial.BLENDPARAM_ONE_MINUS_CONSTANT_ALPHA=0x8004;
		BaseMaterial.BLENDPARAM_SRC_ALPHA_SATURATE=0x0308;
		BaseMaterial.BLENDEQUATION_ADD=0;
		BaseMaterial.BLENDEQUATION_SUBTRACT=1;
		BaseMaterial.BLENDEQUATION_REVERSE_SUBTRACT=2;
		BaseMaterial.DEPTHFUNC_NEVER=0x0200;
		BaseMaterial.DEPTHFUNC_LESS=0x0201;
		BaseMaterial.DEPTHFUNC_EQUAL=0x0202;
		BaseMaterial.DEPTHFUNC_LEQUAL=0x0203;
		BaseMaterial.DEPTHFUNC_GREATER=0x0204;
		BaseMaterial.DEPTHFUNC_NOTEQUAL=0x0205;
		BaseMaterial.DEPTHFUNC_GEQUAL=0x0206;
		BaseMaterial.DEPTHFUNC_ALWAYS=0x0207;
		BaseMaterial.SHADERDEFINE_ALPHATEST=0x1;
		BaseMaterial.ALPHATESTVALUE=0;
		return BaseMaterial;
	})(Resource)


	/**
	*<code>BaseTexture</code> 纹理的父类，抽象类，不允许实例。
	*/
	//class laya.d3.resource.BaseTexture extends laya.resource.Resource
	var BaseTexture=(function(_super){
		function BaseTexture(){
			this._width=0;
			this._height=0;
			this._size=null;
			this._repeat=false;
			this._mipmap=false;
			this._minFifter=0;
			this._magFifter=0;
			this._source=null;
			BaseTexture.__super.call(this);
			this._conchTexture
			if (Render.isConchNode){
				this._conchTexture=/*__JS__ */new ConchTexture();
			}
			this._repeat=true;
			this.mipmap=true;
			this.minFifter=-1;
			this.magFifter=-1;
		}

		__class(BaseTexture,'laya.d3.resource.BaseTexture',_super);
		var __proto=BaseTexture.prototype;
		__proto.dispose=function(){
			this.resourceManager.removeResource(this);
			_super.prototype.dispose.call(this);
		}

		/**
		*获取宽度。
		*/
		__getset(0,__proto,'width',function(){
			return this._width;
		});

		/**
		*是否使用重复模式纹理寻址
		*/
		/**
		*是否使用重复模式纹理寻址
		*/
		__getset(0,__proto,'repeat',function(){
			return this._repeat;
			},function(value){
			this._repeat=value;
		});

		/**
		*获取高度。
		*/
		__getset(0,__proto,'height',function(){
			return this._height;
		});

		/**
		*放大过滤器
		*/
		/**
		*放大过滤器
		*/
		__getset(0,__proto,'magFifter',function(){
			return this._magFifter;
			},function(value){
			this._magFifter=value;
			if (value !=this._magFifter){
				this._conchTexture && this._conchTexture.setMaxFifter(value);
			}
		});

		/**
		*获取尺寸。
		*/
		__getset(0,__proto,'size',function(){
			return this._size;
		});

		/**
		*是否使用mipLevel
		*/
		/**
		*是否使用mipLevel
		*/
		__getset(0,__proto,'mipmap',function(){
			return this._mipmap;
			},function(value){
			this._mipmap=value;
			if (this._mipmap !=value){
				this._conchTexture && this._conchTexture.setMipMap(value);
			}
		});

		/**
		*缩小过滤器
		*/
		/**
		*缩小过滤器
		*/
		__getset(0,__proto,'minFifter',function(){
			return this._minFifter;
			},function(value){
			this._minFifter=value;
			if (this._minFifter !=value){
				this._conchTexture && this._conchTexture.setMinFifter(value);
			}
		});

		/**
		*获取纹理资源。
		*/
		__getset(0,__proto,'defaulteTexture',function(){
			return BaseTexture.grayTexture;
		});

		/**
		*获取纹理资源。
		*/
		__getset(0,__proto,'source',function(){
			this.activeResource();
			return this._source;
		});

		__static(BaseTexture,
		['grayTexture',function(){return this.grayTexture=new SolidColorTexture2D(new Vector4(0.5,0.5,0.5,1.0));}
		]);
		return BaseTexture;
	})(Resource)


	/**
	*<code>BaseMesh</code> 类用于创建网格,抽象类,不允许实例。
	*/
	//class laya.d3.resource.models.BaseMesh extends laya.resource.Resource
	var BaseMesh=(function(_super){
		function BaseMesh(){
			this._subMeshCount=0;
			this._boundingBox=null;
			this._boundingSphere=null;
			this._boundingBoxCorners=null;
			BaseMesh.__super.call(this);
			this._loaded=false;
			this._boundingBoxCorners=__newvec(8,null);
		}

		__class(BaseMesh,'laya.d3.resource.models.BaseMesh',_super);
		var __proto=BaseMesh.prototype;
		/**
		*@private
		*/
		__proto._generateBoundingObject=function(){
			var pos=this.positions;
			this._boundingSphere=new BoundSphere(new Vector3(),0);
			BoundSphere.createfromPoints(pos,this._boundingSphere);
			this._boundingBox=new BoundBox(new Vector3(),new Vector3());
			BoundBox.createfromPoints(pos,this._boundingBox);
			this._boundingBox.getCorners(this._boundingBoxCorners);
		}

		/**
		*获取渲染单元数量,请重载此方法。
		*@return 渲染单元数量。
		*/
		__proto.getRenderElementsCount=function(){
			throw new Error("未Override,请重载该属性！");
		}

		/**
		*获取渲染单元,请重载此方法。
		*@param index 索引。
		*@return 渲染单元。
		*/
		__proto.getRenderElement=function(index){
			throw new Error("未Override,请重载该属性！");
		}

		/**
		*获取网格顶点,请重载此方法。
		*@return 网格顶点。
		*/
		__getset(0,__proto,'positions',function(){
			throw new Error("未Override,请重载该属性！");
		});

		/**
		*获取SubMesh的个数。
		*@return SubMesh的个数。
		*/
		__getset(0,__proto,'subMeshCount',function(){
			return this._subMeshCount;
		});

		/**
		*获取AABB包围盒,禁止修改其数据。
		*@return AABB包围盒。
		*/
		__getset(0,__proto,'boundingBox',function(){
			return this._boundingBox;
		});

		/**
		*获取包围球顶点,禁止修改其数据。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundingBoxCorners',function(){
			return this._boundingBoxCorners;
		});

		/**
		*获取包围球,禁止修改其数据。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundingSphere',function(){
			return this._boundingSphere;
		});

		return BaseMesh;
	})(Resource)


	/**
	*<code>Sky</code> 类用于创建天空的父类，抽象类不允许实例。
	*/
	//class laya.d3.resource.models.Sky extends laya.resource.Resource
	var Sky=(function(_super){
		function Sky(){
			this.__ownerCamera=null;
			this._alphaBlending=1.0;
			this._colorIntensity=1.0;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._sharderNameID=0;
			this._shader=null;
			this._shaderValue=null;
			this._shaderCompile=null;
			this._environmentDiffuse=null;
			this._environmentSpecular=null;
			this._conchSky=null;
			Sky.__super.call(this);
			this._shaderValue=new ValusArray();
			if (Render.isConchNode){
				this._conchSky=/*__JS__ */new ConchSkyMesh();
			}
		}

		__class(Sky,'laya.d3.resource.models.Sky',_super);
		var __proto=Sky.prototype;
		/**
		*@private
		*/
		__proto._setEnvironmentDiffuse=function(){
			if (this._environmentDiffuse.loaded){
				this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.ENVIRONMENTDIFFUSE*/7,this._environmentDiffuse.source);
				}else {
				this._environmentDiffuse.on(/*laya.events.Event.LOADED*/"loaded",this,this._environmentDiffuseLoaded);
			}
		}

		/**
		*@private
		*/
		__proto._setEnvironmentSpecular=function(){
			if (this._environmentSpecular.loaded){
				var si=this._environmentSpecular['simLodInfo'];
				if (si && (si instanceof Float32Array))
					this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.SIMLODINFO*/9,si);
				this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.ENVIRONMENTSPECULAR*/8,this._environmentSpecular.source);
				}else {
				this._environmentSpecular.on(/*laya.events.Event.LOADED*/"loaded",this,this._environmentSpecularLoaded);
			}
		}

		/**
		*@private
		*/
		__proto._environmentDiffuseLoaded=function(){
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.ENVIRONMENTDIFFUSE*/7,this._environmentDiffuse.source);
		}

		/**
		*@private
		*/
		__proto._environmentSpecularLoaded=function(){
			var si=this._environmentSpecular['simLodInfo'];
			if (si && (si instanceof Float32Array))
				this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.SIMLODINFO*/9,si);
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.ENVIRONMENTSPECULAR*/8,this._environmentSpecular.source);
		}

		/**
		*@private
		*/
		__proto._render=function(state){}
		/**
		*@private
		*/
		__getset(0,__proto,'_ownerCamera',null,function(value){
			this.__ownerCamera=value;
			(this._environmentDiffuse)&& (this._setEnvironmentDiffuse());
			(this._environmentSpecular)&& (this._setEnvironmentSpecular());
		});

		/**
		*设置透明混合度。
		*@param value 透明混合度。
		*/
		/**
		*获取透明混合度。
		*@return 透明混合度。
		*/
		__getset(0,__proto,'alphaBlending',function(){
			return this._alphaBlending;
			},function(value){
			this._alphaBlending=value;
			if (this._alphaBlending < 0)
				this._alphaBlending=0;
			if (this._alphaBlending > 1)
				this._alphaBlending=1;
			if (this._conchSky){
				this._conchSky.setShaderValue(/*CLASS CONST:laya.d3.resource.models.Sky.ALPHABLENDING*/2,this._alphaBlending,2);
			}
		});

		__getset(0,__proto,'envDiffuseSHBlue',null,function(value){
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.DIFFUSEIRRADMATB*/12,value);
		});

		/**
		*设置颜色强度。
		*@param value 颜色强度。
		*/
		/**
		*获取颜色强度。
		*@return 颜色强度。
		*/
		__getset(0,__proto,'colorIntensity',function(){
			return this._colorIntensity;
			},function(value){
			this._colorIntensity=value;
			if (this._colorIntensity < 0)
				this._colorIntensity=0;
			if (this._conchSky){
				this._conchSky.setShaderValue(/*CLASS CONST:laya.d3.resource.models.Sky.INTENSITY*/1,this._colorIntensity,2);
			}
		});

		__getset(0,__proto,'envDiffuseSHGreen',null,function(value){
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.DIFFUSEIRRADMATG*/11,value);
		});

		__getset(0,__proto,'envDiffuseSHRed',null,function(value){
			this.__ownerCamera._shaderValues.setValue(/*laya.d3.core.BaseCamera.DIFFUSEIRRADMATR*/10,value);
		});

		/**
		*设置环境漫反射贴图。
		*@param value 环境漫反射贴图。
		*/
		/**
		*获取环境漫反射贴图。
		*@return 环境漫反射贴图。
		*/
		__getset(0,__proto,'environmentDiffuse',function(){
			return this._environmentDiffuse;
			},function(value){
			value.minFifter=/*laya.webgl.WebGLContext.NEAREST*/0x2600;
			this._environmentDiffuse=value;
			(this.__ownerCamera)&& (this._setEnvironmentDiffuse());
		});

		/**
		*设置环境高光贴图。
		*@param value 环境高光贴图。
		*/
		/**
		*获取环境高光贴图。
		*@return 环境高光贴图。
		*/
		__getset(0,__proto,'environmentSpecular',function(){
			return this._environmentSpecular;
			},function(value){
			this._environmentSpecular=value;
			(this.__ownerCamera)&& (this._setEnvironmentSpecular());
		});

		Sky.MVPMATRIX=0;
		Sky.INTENSITY=1;
		Sky.ALPHABLENDING=2;
		Sky.DIFFUSETEXTURE=3;
		return Sky;
	})(Resource)


	/**
	*<code>TerrainHeightData</code> 类用于描述地形高度信息。
	*/
	//class laya.d3.terrain.TerrainHeightData extends laya.resource.Resource
	var TerrainHeightData=(function(_super){
		function TerrainHeightData(){
			this._terrainHeightData=null;
			this._width=0;
			this._height=0;
			this._bitType=0;
			this._value=NaN;
			TerrainHeightData.__super.call(this);
		}

		__class(TerrainHeightData,'laya.d3.terrain.TerrainHeightData',_super);
		var __proto=TerrainHeightData.prototype;
		/**
		*异步回调
		*/
		__proto.onAsynLoaded=function(url,data,params){
			this._width=params[0];
			this._height=params[1];
			this._bitType=params[2];
			this._value=params[3];
			var buffer;
			var ratio=NaN;
			if (this._bitType==8){
				buffer=new Uint8Array(data);
				ratio=1.0 / 255.0;
			}
			else if (this._bitType==16){
				buffer=new Int16Array(data);
				ratio=1.0 / 32766.0;
			}
			this._terrainHeightData=new Float32Array(this._height *this._width);
			for (var i=0,n=this._height *this._width;i < n;i++){
				this._terrainHeightData[i]=(buffer[i] *ratio *this._value)/2;
			}
			this._loaded=true;
			this.event(/*laya.events.Event.LOADED*/"loaded",this);
		}

		TerrainHeightData.load=function(url,widht,height,bitType,value){
			return Laya.loader.create(url,null,null,TerrainHeightData,[widht,height,bitType,value],1,false);
		}

		return TerrainHeightData;
	})(Resource)


	/**
	*<code>TerrainRes</code> 类用于描述地形信息。
	*/
	//class laya.d3.terrain.TerrainRes extends laya.resource.Resource
	var TerrainRes=(function(_super){
		function TerrainRes(){
			this._version=NaN;
			this._gridSize=NaN;
			this._chunkNumX=0;
			this._chunkNumZ=0;
			this._heightDataX=0;
			this._heightDataZ=0;
			this._heightDataBitType=0;
			this._heightDataValue=NaN;
			this._heightDataUrl=null;
			this._detailTextureInfos=null;
			this._chunkInfos=null;
			this._heightData=null;
			TerrainRes.__super.call(this);
		}

		__class(TerrainRes,'laya.d3.terrain.TerrainRes',_super);
		var __proto=TerrainRes.prototype;
		__proto.parseData=function(data,path){
			var json=data;
			this._version=json.version;
			if (this._version==1.0){
				this._gridSize=json.gridSize;
				this._chunkNumX=json.chunkNumX;
				this._chunkNumZ=json.chunkNumZ;
				var heightData=json.heightData;
				this._heightDataX=heightData.numX;
				this._heightDataZ=heightData.numZ;
				this._heightDataBitType=heightData.bitType;
				this._heightDataValue=heightData.value;
				this._heightDataUrl=path+heightData.url;
				var detailTextures=json.detailTexture;
				this._detailTextureInfos=__newvec(detailTextures.length);
				for (var i=0;i < detailTextures.length;i++){
					var detail=detailTextures[i];
					var info=new DetailTextureInfo();
					info.diffuseTexture=path+detail.diffuse;
					info.normalTexture=detail.normal ? path+detail.normal :null;
					if (detail.scale){
						info.scale=new Vector2(detail.scale[0],detail.scale[1]);
					}
					else{
						info.scale=new Vector2(1,1);
					}
					if (detail.offset){
						info.offset=new Vector2(detail.offset[0],detail.offset[1]);
					}
					else{
						info.offset=new Vector2(0,0);
					}
					this._detailTextureInfos[i]=info;
				};
				var jchunks=json.chunkInfo;
				if (this._chunkNumX *this._chunkNumZ !=jchunks.length){
					alert("terrain data error");
					return false;
				}
				this._chunkInfos=__newvec(jchunks.length);
				for (i=0;i < jchunks.length;i++){
					var jchunk=jchunks[i];
					var chunkinfo=new ChunkInfo();
					var nAlphaMapNum=jchunk.alphaMap.length;
					var nDetailIDNum=jchunk.detailID.length;
					if (nAlphaMapNum !=nDetailIDNum){
						alert("terrain chunk data error");
						return false;
					}
					chunkinfo.alphaMap=__newvec(nAlphaMapNum);
					chunkinfo.detailID=__newvec(nDetailIDNum);
					chunkinfo.normalMap=path+jchunk.normalMap;
					for (var j=0;j < nAlphaMapNum;j++){
						chunkinfo.alphaMap[j]=path+jchunk.alphaMap[j];
						var jid=jchunk.detailID[j];
						var nIDNum=jid.length;
						chunkinfo.detailID[j]=new Uint8Array(nIDNum);
						for (var k=0;k < nIDNum;k++){
							chunkinfo.detailID[j][k]=jid[k];
						}
					}
					this._chunkInfos[i]=chunkinfo;
				}
				this._heightData=TerrainHeightData.load(this._heightDataUrl,this._heightDataX,this._heightDataZ,this._heightDataBitType,this._heightDataValue);
				if (this._heightData.loaded)
					this.onLoadTerrainComplete(this._heightData);
				else
				this._heightData.once(/*laya.events.Event.LOADED*/"loaded",this,this.onLoadTerrainComplete);
			}
			return true;
		}

		__proto.onLoadTerrainComplete=function(heightData){
			this._loaded=true;
			this.event(/*laya.events.Event.LOADED*/"loaded",this);
		}

		/**
		*异步回调
		*/
		__proto.onAsynLoaded=function(url,data,params){
			var sBuffer=url.split('/');
			var sPath="";
			for (var i=0,n=sBuffer.length-1;i < n;i++){
				sPath+=sBuffer[i];
				sPath+="/";
			}
			this.parseData(data,sPath);
		}

		TerrainRes.load=function(url){
			return Laya.loader.create(url,null,null,TerrainRes,null,1,false);
		}

		return TerrainRes;
	})(Resource)


	/**
	*<code>KeyframeAnimation</code> 类用于帧动画组件的父类。
	*/
	//class laya.d3.component.animation.KeyframeAnimations extends laya.d3.component.Component3D
	var KeyframeAnimations=(function(_super){
		function KeyframeAnimations(){
			this._player=null;
			this._templet=null;
			KeyframeAnimations.__super.call(this);
			this._player=new AnimationPlayer();
		}

		__class(KeyframeAnimations,'laya.d3.component.animation.KeyframeAnimations',_super);
		var __proto=KeyframeAnimations.prototype;
		/**
		*@private
		*/
		__proto._updateAnimtionPlayer=function(){
			this._player._update(Laya.timer.delta);
		}

		/**
		*@private
		*/
		__proto._addUpdatePlayerToTimer=function(){
			Laya.timer.frameLoop(1,this,this._updateAnimtionPlayer);
		}

		/**
		*@private
		*/
		__proto._removeUpdatePlayerToTimer=function(){
			Laya.timer.clear(this,this._updateAnimtionPlayer);
		}

		/**
		*@private
		*/
		__proto._onOwnerActiveHierarchyChanged=function(active){
			if (this._owner.displayedInStage){
				if (active)
					this._addUpdatePlayerToTimer();
				else
				this._removeUpdatePlayerToTimer();
			}
		}

		/**
		*@private
		*/
		__proto._onDisplayInStage=function(){
			(this._owner.activeInHierarchy)&& (this._addUpdatePlayerToTimer());
		}

		/**
		*@private
		*/
		__proto._onUnDisplayInStage=function(){
			(this._owner.activeInHierarchy)&& (this._removeUpdatePlayerToTimer());
		}

		/**
		*@private
		*载入组件时执行
		*/
		__proto._load=function(owner){
			(this._owner.displayedInStage && this._owner.activeInHierarchy)&& (this._addUpdatePlayerToTimer());
			this._owner.on(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onOwnerActiveHierarchyChanged);
			this._owner.on(/*laya.events.Event.DISPLAY*/"display",this,this._onDisplayInStage);
			this._owner.on(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._onUnDisplayInStage);
		}

		/**
		*@private
		*卸载组件时执行
		*/
		__proto._unload=function(owner){
			_super.prototype._unload.call(this,owner);
			(this._owner.displayedInStage && this._owner.activeInHierarchy)&& (this._removeUpdatePlayerToTimer());
			this._owner.off(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onOwnerActiveHierarchyChanged);
			this._owner.off(/*laya.events.Event.DISPLAY*/"display",this,this._onDisplayInStage);
			this._owner.off(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._onUnDisplayInStage);
			this._player._destroy();
			this._player=null;
			this._templet=null;
		}

		/**
		*设置url地址。
		*@param value 地址。
		*/
		__getset(0,__proto,'url',null,function(value){
			console.log("Warning: discard property,please use templet property instead.");
			var templet=Laya.loader.create(value,null,null,AnimationTemplet);
			if (this._templet!==templet){
				if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
					this._player.stop(true);
				this._templet=templet;
				this._player.templet=templet;
				this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
			}
		});

		/**
		*获取动画播放器。
		*@return 动画播放器。
		*/
		__getset(0,__proto,'player',function(){
			return this._player;
		});

		/**
		*设置动画模板。
		*@param value 设置动画模板。
		*/
		/**
		*获取动画模板。
		*@return value 动画模板。
		*/
		__getset(0,__proto,'templet',function(){
			return this._templet;
			},function(value){
			if (this._templet!==value){
				if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
					this._player.stop(true);
				this._templet=value;
				this._player.templet=value;
				this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
			}
		});

		/**
		*获取播放器帧数。
		*@return 播放器帧数。
		*/
		__getset(0,__proto,'currentFrameIndex',function(){
			return this._player.currentKeyframeIndex;
		});

		/**
		*获取播放器的动画索引。
		*@return 动画索引。
		*/
		__getset(0,__proto,'currentAnimationClipIndex',function(){
			return this._player.currentAnimationClipIndex;
		});

		/**
		*获取播放器当前动画的节点数量。
		*@return 节点数量。
		*/
		__getset(0,__proto,'nodeCount',function(){
			return this._templet.getNodeCount(this._player.currentAnimationClipIndex);
		});

		return KeyframeAnimations;
	})(Component3D)


	/**
	*<code>AttachPoint</code> 类用于创建挂点组件。
	*/
	//class laya.d3.component.AttachPoint extends laya.d3.component.Component3D
	var AttachPoint=(function(_super){
		function AttachPoint(){
			this._attachSkeleton=null;
			this._extenData=null;
			this.attachBones=null;
			this.matrixs=null;
			AttachPoint.__super.call(this);
			this.attachBones=[];
			this.matrixs=[];
		}

		__class(AttachPoint,'laya.d3.component.AttachPoint',_super);
		var __proto=AttachPoint.prototype;
		/**
		*@private
		*初始化载入挂点组件。
		*@param owner 所属精灵对象。
		*/
		__proto._load=function(owner){
			_super.prototype._load.call(this,owner);
			this._attachSkeleton=owner.getComponentByType(SkinAnimations);
		}

		/**
		*@private
		*更新挂点组件。
		*@param state 渲染状态。
		*/
		__proto._update=function(state){
			if (!this._attachSkeleton||this._attachSkeleton.destroyed || this._attachSkeleton.player.state!==/*laya.ani.AnimationState.playing*/2 || !this._attachSkeleton.curBonesDatas)
				return;
			var player=this._attachSkeleton.player;
			var templet=this._attachSkeleton.templet;
			this.matrixs.length=this.attachBones.length;
			var boneDatas=this._attachSkeleton.curBonesDatas;
			var worldMatrix=this.owner.transform.worldMatrix;
			for (var i=0,n=this.attachBones.length;i < n;i++){
				var startIndex=templet.getNodeIndexWithName(player.currentAnimationClipIndex,this.attachBones[i])*16;
				var matrix=this.matrixs[i];
				matrix || (matrix=this.matrixs[i]=new Matrix4x4());
				var matrixE=matrix.elements;
				for (var j=0;j < 16;j++)
				matrixE[j]=boneDatas[startIndex+j];
				Matrix4x4.multiply(worldMatrix,matrix,matrix);
			}
			this.event(/*laya.events.Event.COMPLETE*/"complete");
		}

		return AttachPoint;
	})(Component3D)


	/**
	*<code>Collider</code> 类用于创建碰撞器的父类，抽象类，不允许实例。
	*/
	//class laya.d3.component.physics.Collider extends laya.d3.component.Component3D
	var Collider=(function(_super){
		function Collider(){
			this._needUpdate=false;
			Collider.__super.call(this);
		}

		__class(Collider,'laya.d3.component.physics.Collider',_super);
		var __proto=Collider.prototype;
		__proto.raycast=function(ray,hitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=Number.MAX_VALUE);
			throw new Error("Must override it.");
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'isSingleton',function(){
			return Collider._isSingleton;
		});

		Collider._isSingleton=false;
		return Collider;
	})(Component3D)


	/**
	*<code>Script</code> 类用于创建脚本的父类。
	*/
	//class laya.d3.component.Script extends laya.d3.component.Component3D
	var Script=(function(_super){
		/**
		*创建一个新的 <code>Script</code> 实例。
		*/
		function Script(){
			Script.__super.call(this);
		}

		__class(Script,'laya.d3.component.Script',_super);
		var __proto=Script.prototype;
		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'isSingleton',function(){
			return Script._isSingleton;
		});

		Script._isSingleton=false;
		return Script;
	})(Component3D)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.GlitterRender extends laya.d3.core.render.BaseRender
	var GlitterRender=(function(_super){
		function GlitterRender(owner){
			GlitterRender.__super.call(this,owner);
		}

		__class(GlitterRender,'laya.d3.core.GlitterRender',_super);
		var __proto=GlitterRender.prototype;
		__proto._calculateBoundingBox=function(){
			var minE=this._boundingBox.min.elements;
			minE[0]=-Number.MAX_VALUE;
			minE[1]=-Number.MAX_VALUE;
			minE[2]=-Number.MAX_VALUE;
			var maxE=this._boundingBox.min.elements;
			maxE[0]=Number.MAX_VALUE;
			maxE[1]=Number.MAX_VALUE;
			maxE[2]=Number.MAX_VALUE;
		}

		__proto._calculateBoundingSphere=function(){
			var centerE=this._boundingSphere.center.elements;
			centerE[0]=0;
			centerE[1]=0;
			centerE[2]=0;
			this._boundingSphere.radius=Number.MAX_VALUE;
		}

		return GlitterRender;
	})(BaseRender)


	/**
	*<code>MeshFilter</code> 类用于创建网格过滤器。
	*/
	//class laya.d3.core.MeshFilter extends laya.d3.core.GeometryFilter
	var MeshFilter=(function(_super){
		function MeshFilter(owner){
			this._owner=null;
			this._sharedMesh=null;
			MeshFilter.__super.call(this);
			this._owner=owner;
		}

		__class(MeshFilter,'laya.d3.core.MeshFilter',_super);
		var __proto=MeshFilter.prototype;
		/**
		*@private
		*/
		__proto._sharedMeshLoaded=function(){
			this.event(/*laya.events.Event.LOADED*/"loaded");
		}

		/**
		*@inheritDoc
		*/
		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
			this._owner=null;
			this._sharedMesh=null;
		}

		/**
		*设置共享网格。
		*@return value 共享网格。
		*/
		/**
		*获取共享网格。
		*@return 共享网格。
		*/
		__getset(0,__proto,'sharedMesh',function(){
			return this._sharedMesh;
			},function(value){
			var oldMesh=this._sharedMesh;
			this._sharedMesh=value;
			this.event(/*laya.events.Event.MESH_CHANGED*/"meshchanged",[this,oldMesh,value]);
			if (!value.loaded){
				this._sharedMesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._sharedMeshLoaded);
			}
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_isAsyncLoaded',function(){
			return this._sharedMesh.loaded;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingBoxCorners',function(){
			return this._sharedMesh.boundingBoxCorners;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingSphere',function(){
			return this._sharedMesh.boundingSphere;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingBox',function(){
			return this._sharedMesh.boundingBox;
		});

		return MeshFilter;
	})(GeometryFilter)


	/**
	*<code>MeshRender</code> 类用于网格渲染器。
	*/
	//class laya.d3.core.MeshRender extends laya.d3.core.render.BaseRender
	var MeshRender=(function(_super){
		function MeshRender(owner){
			this._meshSprite3DOwner=null;
			this._lightmapScaleOffset=null;
			this.lightmapIndex=0;
			MeshRender.__super.call(this,owner);
			this._meshSprite3DOwner=owner;
			this.lightmapIndex=-1;
			this.castShadow=false;
			this.receiveShadow=false;
			this._meshSprite3DOwner.meshFilter.on(/*laya.events.Event.MESH_CHANGED*/"meshchanged",this,this._onMeshChanged);
		}

		__class(MeshRender,'laya.d3.core.MeshRender',_super);
		var __proto=MeshRender.prototype;
		/**
		*@private
		*/
		__proto._onMeshChanged=function(sender,oldMesh,mesh){
			if (mesh.loaded){
				this._boundingSphereNeedChange=this._boundingBoxNeedChange=this._boundingBoxCenterNeedChange=this._octreeNodeNeedChange=true;
				}else {
				mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._onMeshLoaed);
			}
		}

		/**
		*@private
		*/
		__proto._onMeshLoaed=function(sender,enable){
			this._boundingSphereNeedChange=this._boundingBoxNeedChange=this._boundingBoxCenterNeedChange=this._octreeNodeNeedChange=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingSphere=function(){
			var sharedMesh=this._meshSprite3DOwner.meshFilter.sharedMesh;
			if (sharedMesh==null || sharedMesh.boundingSphere==null){
				this._boundingSphere.toDefault();
				}else {
				var meshBoundingSphere=sharedMesh.boundingSphere;
				var maxScale=NaN;
				var transform=this._meshSprite3DOwner.transform;
				var scale=transform.scale;
				if (scale.x >=scale.y && scale.x >=scale.z)
					maxScale=scale.x;
				else
				maxScale=scale.y >=scale.z ? scale.y :scale.z;
				Vector3.transformCoordinate(meshBoundingSphere.center,transform.worldMatrix,this._boundingSphere.center);
				this._boundingSphere.radius=meshBoundingSphere.radius *maxScale;
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingBox=function(){
			var sharedMesh=this._meshSprite3DOwner.meshFilter.sharedMesh;
			if (sharedMesh==null || sharedMesh.boundingBox==null){
				this._boundingBox.toDefault();
				}else {
				var worldMat=this._meshSprite3DOwner.transform.worldMatrix;
				var corners=sharedMesh.boundingBoxCorners;
				for (var i=0;i < 8;i++)
				Vector3.transformCoordinate(corners[i],worldMat,BaseRender._tempBoudingBoxCorners[i]);
				BoundBox.createfromPoints(BaseRender._tempBoudingBoxCorners,this._boundingBox);
			}
		}

		/**
		*@private
		*/
		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
			this._lightmapScaleOffset=null;
			this._meshSprite3DOwner=null;
		}

		/**
		*设置光照贴图的缩放和偏移。
		*@param 光照贴图的缩放和偏移。
		*/
		/**
		*获取光照贴图的缩放和偏移。
		*@return 光照贴图的缩放和偏移。
		*/
		__getset(0,__proto,'lightmapScaleOffset',function(){
			return this._lightmapScaleOffset;
			},function(value){
			this._lightmapScaleOffset=value;
			this._owner._setShaderValueColor(/*laya.d3.core.MeshSprite3D.LIGHTMAPSCALEOFFSET*/2,value);
			this._owner._addShaderDefine(/*laya.d3.core.RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV*/0x2);
		});

		return MeshRender;
	})(BaseRender)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.ParticleRender extends laya.d3.core.render.BaseRender
	var ParticleRender=(function(_super){
		function ParticleRender(owner){
			ParticleRender.__super.call(this,owner);
		}

		__class(ParticleRender,'laya.d3.core.ParticleRender',_super);
		var __proto=ParticleRender.prototype;
		__proto._calculateBoundingBox=function(){
			var minE=this._boundingBox.min.elements;
			minE[0]=-Number.MAX_VALUE;
			minE[1]=-Number.MAX_VALUE;
			minE[2]=-Number.MAX_VALUE;
			var maxE=this._boundingBox.min.elements;
			maxE[0]=Number.MAX_VALUE;
			maxE[1]=Number.MAX_VALUE;
			maxE[2]=Number.MAX_VALUE;
		}

		__proto._calculateBoundingSphere=function(){
			var centerE=this._boundingSphere.center.elements;
			centerE[0]=0;
			centerE[1]=0;
			centerE[2]=0;
			this._boundingSphere.radius=Number.MAX_VALUE;
		}

		return ParticleRender;
	})(BaseRender)


	/**
	*<code>ShurikenParticleSystem</code> 类用于创建3D粒子数据模板。
	*/
	//class laya.d3.core.particleShuriKen.ShurikenParticleSystem extends laya.d3.core.GeometryFilter
	var ShurikenParticleSystem=(function(_super){
		function ShurikenParticleSystem(owner){
			this.halfKSqrtOf2=1.42 *0.5;
			this._boundingBoxCorners=null;
			this._owner=null;
			this._vertices=null;
			this._floatCountPerVertex=0;
			this._firstActiveElement=0;
			this._firstNewElement=0;
			this._firstFreeElement=0;
			this._firstRetiredElement=0;
			this._drawCounter=0;
			this._currentTime=NaN;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._bufferMaxParticles=0;
			this._emission=null;
			this._shape=null;
			this._isPlaying=false;
			this._isPaused=false;
			this._playStartDelay=NaN;
			this._frameTime=NaN;
			this._emissionTime=NaN;
			this._playbackTime=NaN;
			this._burstsIndex=0;
			this._velocityOverLifetime=null;
			this._colorOverLifetime=null;
			this._sizeOverLifetime=null;
			this._rotationOverLifetime=null;
			this._textureSheetAnimation=null;
			this._startUpdateLoopCount=0;
			this._rand=null;
			this._randomSeeds=null;
			this.duration=NaN;
			this.looping=false;
			this.prewarm=false;
			this.startDelayType=0;
			this.startDelay=NaN;
			this.startDelayMin=NaN;
			this.startDelayMax=NaN;
			this.startLifetimeType=0;
			this.startLifetimeConstant=NaN;
			this.startLifeTimeGradient=null;
			this.startLifetimeConstantMin=NaN;
			this.startLifetimeConstantMax=NaN;
			this.startLifeTimeGradientMin=null;
			this.startLifeTimeGradientMax=null;
			this.startSpeedType=0;
			this.startSpeedConstant=NaN;
			this.startSpeedConstantMin=NaN;
			this.startSpeedConstantMax=NaN;
			this.threeDStartSize=false;
			this.startSizeType=0;
			this.startSizeConstant=NaN;
			this.startSizeConstantSeparate=null;
			this.startSizeConstantMin=NaN;
			this.startSizeConstantMax=NaN;
			this.startSizeConstantMinSeparate=null;
			this.startSizeConstantMaxSeparate=null;
			this.threeDStartRotation=false;
			this.startRotationType=0;
			this.startRotationConstant=NaN;
			this.startRotationConstantSeparate=null;
			this.startRotationConstantMin=NaN;
			this.startRotationConstantMax=NaN;
			this.startRotationConstantMinSeparate=null;
			this.startRotationConstantMaxSeparate=null;
			this.randomizeRotationDirection=NaN;
			this.startColorType=0;
			this.startColorConstant=null;
			this.startColorConstantMin=null;
			this.startColorConstantMax=null;
			this.gravity=null;
			this.gravityModifier=NaN;
			this.simulationSpace=0;
			this.scaleMode=0;
			this.playOnAwake=false;
			this.randomSeed=null;
			this.autoRandomSeed=false;
			this.isPerformanceMode=false;
			ShurikenParticleSystem.__super.call(this);
			this._tempRotationMatrix=new Matrix4x4();
			this._boundingSphere=new BoundSphere(new Vector3(),0);
			this._boundingBox=new BoundBox(new Vector3(),new Vector3());
			this._uvLength=new Vector2();
			this._owner=owner;
			this._boundingBoxCorners=__newvec(8,null);
			this._currentTime=0;
			this._floatCountPerVertex=40;
			this._isPlaying=false;
			this._isPaused=false;
			this._burstsIndex=0;
			this._frameTime=0;
			this._emissionTime=0;
			this._playbackTime=0;
			this._bufferMaxParticles=1000;
			this.duration=5.0;
			this.looping=true;
			this.prewarm=false;
			this.startDelayType=0;
			this.startDelay=0.0;
			this.startDelayMin=0.0;
			this.startDelayMax=0.0;
			this.startLifetimeType=0;
			this.startLifetimeConstant=5.0;
			this.startLifeTimeGradient=new GradientDataNumber();
			this.startLifetimeConstantMin=0.0;
			this.startLifetimeConstantMax=5.0;
			this.startLifeTimeGradientMin=new GradientDataNumber();
			this.startLifeTimeGradientMax=new GradientDataNumber();
			this.startSpeedType=0;
			this.startSpeedConstant=5.0;
			this.startSpeedConstantMin=0.0;
			this.startSpeedConstantMax=5.0;
			this.threeDStartSize=false;
			this.startSizeType=0;
			this.startSizeConstant=1;
			this.startSizeConstantSeparate=new Vector3(1,1,1);
			this.startSizeConstantMin=0;
			this.startSizeConstantMax=1;
			this.startSizeConstantMinSeparate=new Vector3(0,0,0);
			this.startSizeConstantMaxSeparate=new Vector3(1,1,1);
			this.threeDStartRotation=false;
			this.startRotationType=0;
			this.startRotationConstant=0;
			this.startRotationConstantSeparate=new Vector3(0,0,0);
			this.startRotationConstantMin=0.0;
			this.startRotationConstantMax=0.0;
			this.startRotationConstantMinSeparate=new Vector3(0,0,0);
			this.startRotationConstantMaxSeparate=new Vector3(0,0,0);
			this.randomizeRotationDirection=0.0;
			this.startColorType=0;
			this.startColorConstant=new Vector4(1,1,1,1);
			this.startColorConstantMin=new Vector4(1,1,1,1);
			this.startColorConstantMax=new Vector4(1,1,1,1);
			this.gravity=new Vector3(0,-9.81,0);
			this.gravityModifier=0.0;
			this.simulationSpace=1;
			this.scaleMode=0;
			this.playOnAwake=true;
			this._rand=new Rand(0);
			this.autoRandomSeed=true;
			this.randomSeed=new Uint32Array(1);
			this._randomSeeds=new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length);
			this.isPerformanceMode=true;
			this._owner.on(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onOwnerActiveHierarchyChanged);
			this._owner.on(/*laya.events.Event.DISPLAY*/"display",this,this._onDisplayInStage);
			this._owner.on(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._onUnDisplayInStage);
		}

		__class(ShurikenParticleSystem,'laya.d3.core.particleShuriKen.ShurikenParticleSystem',_super);
		var __proto=ShurikenParticleSystem.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true,"laya.d3.core.IClone":true})
		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer;
			else
			return null;
		}

		__proto._getIndexBuffer=function(){
			return this._indexBuffer;
		}

		/**
		*@private
		*/
		__proto._generateBoundingSphere=function(){
			var centerE=this._boundingSphere.center.elements;
			centerE[0]=0;
			centerE[1]=0;
			centerE[2]=0;
			this._boundingSphere.radius=Number.MAX_VALUE;
		}

		/**
		*@private
		*/
		__proto._generateBoundingBox=function(){
			var particle=this._owner;
			var particleRender=particle.particleRender;
			var boundMin=this._boundingBox.min;
			var boundMax=this._boundingBox.max;
			var i=0,n=0;
			var maxStartLifeTime=NaN;
			switch (this.startLifetimeType){
				case 0:
					maxStartLifeTime=this.startLifetimeConstant;
					break ;
				case 1:
					maxStartLifeTime=-Number.MAX_VALUE;
					var startLifeTimeGradient=startLifeTimeGradient;
					for (i=0,n=startLifeTimeGradient.gradientCount;i < n;i++)
					maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradient.getValueByIndex(i));
					break ;
				case 2:
					maxStartLifeTime=Math.max(this.startLifetimeConstantMin,this.startLifetimeConstantMax);
					break ;
				case 3:
					maxStartLifeTime=-Number.MAX_VALUE;
					var startLifeTimeGradientMin=startLifeTimeGradientMin;
					for (i=0,n=startLifeTimeGradientMin.gradientCount;i < n;i++)
					maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradientMin.getValueByIndex(i));
					var startLifeTimeGradientMax=startLifeTimeGradientMax;
					for (i=0,n=startLifeTimeGradientMax.gradientCount;i < n;i++)
					maxStartLifeTime=Math.max(maxStartLifeTime,startLifeTimeGradientMax.getValueByIndex(i));
					break ;
				};
			var minStartSpeed=NaN,maxStartSpeed=NaN;
			switch (this.startSpeedType){
				case 0:
					minStartSpeed=maxStartSpeed=this.startSpeedConstant;
					break ;
				case 1:
					break ;
				case 2:
					minStartSpeed=this.startLifetimeConstantMin;
					maxStartSpeed=this.startLifetimeConstantMax;
					break ;
				case 3:
					break ;
				};
			var minPosition,maxPosition,minDirection,maxDirection;
			if (this._shape && this._shape.enable){
				}else {
				minPosition=maxPosition=Vector3.ZERO;
				minDirection=Vector3.ZERO;
				maxDirection=Vector3.UnitZ;
			};
			var startMinVelocity=new Vector3(minDirection.x *minStartSpeed,minDirection.y *minStartSpeed,minDirection.z *minStartSpeed);
			var startMaxVelocity=new Vector3(maxDirection.x *maxStartSpeed,maxDirection.y *maxStartSpeed,maxDirection.z *maxStartSpeed);
			if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
				var lifeMinVelocity;
				var lifeMaxVelocity;
				var velocity=this._velocityOverLifetime.velocity;
				switch (velocity.type){
					case 0:
						lifeMinVelocity=lifeMaxVelocity=velocity.constant;
						break ;
					case 1:
						lifeMinVelocity=lifeMaxVelocity=new Vector3(velocity.gradientX.getAverageValue(),velocity.gradientY.getAverageValue(),velocity.gradientZ.getAverageValue());
						break ;
					case 2:
						lifeMinVelocity=velocity.constantMin;
						lifeMaxVelocity=velocity.constantMax;
						break ;
					case 3:
						lifeMinVelocity=new Vector3(velocity.gradientXMin.getAverageValue(),velocity.gradientYMin.getAverageValue(),velocity.gradientZMin.getAverageValue());
						lifeMaxVelocity=new Vector3(velocity.gradientXMax.getAverageValue(),velocity.gradientYMax.getAverageValue(),velocity.gradientZMax.getAverageValue());
						break ;
					}
			};
			var positionScale,velocityScale;
			var transform=this._owner.transform;
			var worldPosition=transform.position;
			var sizeScale=ShurikenParticleSystem._tempVector39;
			var sizeScaleE=sizeScale.elements;
			var renderMode=particleRender.renderMode;
			switch (this.scaleMode){
				case 0:;
					var scale=transform.scale;
					positionScale=scale;
					sizeScaleE[0]=scale.x;
					sizeScaleE[1]=scale.z;
					sizeScaleE[2]=scale.y;
					(renderMode===1)&& (velocityScale=scale);
					break ;
				case 1:;
					var localScale=transform.localScale;
					positionScale=localScale;
					sizeScaleE[0]=localScale.x;
					sizeScaleE[1]=localScale.z;
					sizeScaleE[2]=localScale.y;
					(renderMode===1)&& (velocityScale=localScale);
					break ;
				case 2:
					positionScale=transform.scale;
					sizeScaleE[0]=sizeScaleE[1]=sizeScaleE[2]=1;
					(renderMode===1)&& (velocityScale=Vector3.ONE);
					break ;
				};
			var minStratPosition,maxStratPosition;
			if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
				}else {
				minStratPosition=new Vector3(startMinVelocity.x *maxStartLifeTime,startMinVelocity.y *maxStartLifeTime,startMinVelocity.z *maxStartLifeTime);
				maxStratPosition=new Vector3(startMaxVelocity.x *maxStartLifeTime,startMaxVelocity.y *maxStartLifeTime,startMaxVelocity.z *maxStartLifeTime);
				if (this.scaleMode !=2){
					Vector3.add(minPosition,minStratPosition,boundMin);
					Vector3.multiply(positionScale,boundMin,boundMin);
					Vector3.add(maxPosition,maxStratPosition,boundMax);
					Vector3.multiply(positionScale,boundMax,boundMax);
					}else {
					Vector3.multiply(positionScale,minPosition,boundMin);
					Vector3.add(boundMin,minStratPosition,boundMin);
					Vector3.multiply(positionScale,maxPosition,boundMax);
					Vector3.add(boundMax,maxStratPosition,boundMax);
				}
			}
			switch (this.simulationSpace){
				case 0:
					break ;
				case 1:
					Vector3.add(boundMin,worldPosition,boundMin);
					Vector3.add(boundMax,worldPosition,boundMax);
					break ;
				};
			var maxSize=NaN,maxSizeY=NaN;
			switch (this.startSizeType){
				case 0:
					if (this.threeDStartSize){
						var startSizeConstantSeparate=startSizeConstantSeparate;
						maxSize=Math.max(startSizeConstantSeparate.x,startSizeConstantSeparate.y);
						if (renderMode===1)
							maxSizeY=startSizeConstantSeparate.y;
						}else {
						maxSize=this.startSizeConstant;
						if (renderMode===1)
							maxSizeY=this.startSizeConstant;
					}
					break ;
				case 1:
					break ;
				case 2:
					if (this.threeDStartSize){
						var startSizeConstantMaxSeparate=startSizeConstantMaxSeparate;
						maxSize=Math.max(startSizeConstantMaxSeparate.x,startSizeConstantMaxSeparate.y);
						if (renderMode===1)
							maxSizeY=startSizeConstantMaxSeparate.y;
						}else {
						maxSize=this.startSizeConstantMax;
						if (renderMode===1)
							maxSizeY=this.startSizeConstantMax;
					}
					break ;
				case 3:
					break ;
				}
			if (this._sizeOverLifetime && this._sizeOverLifetime.enbale){
				var size=this._sizeOverLifetime.size;
				maxSize *=this._sizeOverLifetime.size.getMaxSizeInGradient();
			};
			var threeDMaxSize=ShurikenParticleSystem._tempVector30;
			var threeDMaxSizeE=threeDMaxSize.elements;
			var rotSize=NaN,nonRotSize=NaN;
			switch (renderMode){
				case 0:
					rotSize=maxSize *this.halfKSqrtOf2;
					Vector3.scale(sizeScale,maxSize,threeDMaxSize);
					Vector3.subtract(boundMin,threeDMaxSize,boundMin);
					Vector3.add(boundMax,threeDMaxSize,boundMax);
					break ;
				case 1:;
					var maxStretchPosition=ShurikenParticleSystem._tempVector31;
					var maxStretchVelocity=ShurikenParticleSystem._tempVector32;
					var minStretchVelocity=ShurikenParticleSystem._tempVector33;
					var minStretchPosition=ShurikenParticleSystem._tempVector34;
					if (this._velocityOverLifetime && this._velocityOverLifetime.enbale){
						}else {
						Vector3.multiply(velocityScale,startMaxVelocity,maxStretchVelocity);
						Vector3.multiply(velocityScale,startMinVelocity,minStretchVelocity);
					};
					var sizeStretch=maxSizeY *particleRender.stretchedBillboardLengthScale;
					var maxStretchLength=Vector3.scalarLength(maxStretchVelocity)*particleRender.stretchedBillboardSpeedScale+sizeStretch;
					var minStretchLength=Vector3.scalarLength(minStretchVelocity)*particleRender.stretchedBillboardSpeedScale+sizeStretch;
					var norMaxStretchVelocity=ShurikenParticleSystem._tempVector35;
					var norMinStretchVelocity=ShurikenParticleSystem._tempVector36;
					Vector3.normalize(maxStretchVelocity,norMaxStretchVelocity);
					Vector3.scale(norMaxStretchVelocity,maxStretchLength,minStretchPosition);
					Vector3.subtract(maxStratPosition,minStretchPosition,minStretchPosition);
					Vector3.normalize(minStretchVelocity,norMinStretchVelocity);
					Vector3.scale(norMinStretchVelocity,minStretchLength,maxStretchPosition);
					Vector3.add(minStratPosition,maxStretchPosition,maxStretchPosition);
					debugger;
					rotSize=maxSize *this.halfKSqrtOf2;
					Vector3.scale(sizeScale,rotSize,threeDMaxSize);
					var halfNorMaxStretchVelocity=ShurikenParticleSystem._tempVector37;
					var halfNorMinStretchVelocity=ShurikenParticleSystem._tempVector38;
					Vector3.scale(norMaxStretchVelocity,0.5,halfNorMaxStretchVelocity);
					Vector3.scale(norMinStretchVelocity,0.5,halfNorMinStretchVelocity);
					Vector3.multiply(halfNorMaxStretchVelocity,sizeScale,halfNorMaxStretchVelocity);
					Vector3.multiply(halfNorMinStretchVelocity,sizeScale,halfNorMinStretchVelocity);
					Vector3.add(boundMin,halfNorMinStretchVelocity,boundMin);
					Vector3.min(boundMin,minStretchPosition,boundMin);
					Vector3.subtract(boundMin,threeDMaxSize,boundMin);
					Vector3.subtract(boundMax,halfNorMaxStretchVelocity,boundMax);
					Vector3.max(boundMax,maxStretchPosition,boundMax);
					Vector3.add(boundMax,threeDMaxSize,boundMax);
					break ;
				case 2:
					maxSize *=Math.cos(0.78539816339744830961566084581988);
					nonRotSize=maxSize *0.5;
					threeDMaxSizeE[0]=sizeScale.x *nonRotSize;
					threeDMaxSizeE[1]=sizeScale.z *nonRotSize;
					Vector3.subtract(boundMin,threeDMaxSize,boundMin);
					Vector3.add(boundMax,threeDMaxSize,boundMax);
					break ;
				case 3:
					maxSize *=Math.cos(0.78539816339744830961566084581988);
					nonRotSize=maxSize *0.5;
					Vector3.scale(sizeScale,nonRotSize,threeDMaxSize);
					Vector3.subtract(boundMin,threeDMaxSize,boundMin);
					Vector3.add(boundMax,threeDMaxSize,boundMax);
					break ;
				}
			this._boundingBox.getCorners(this._boundingBoxCorners);
		}

		/**
		*@private
		*/
		__proto._updateEmission=function(){
			if (!Laya.stage.isVisibility)
				return;
			var elapsedTime=0;
			(this._startUpdateLoopCount!==Stat.loopCount)&& (elapsedTime=Laya.timer.delta / 1000.0,this._currentTime+=elapsedTime);
			this._retireActiveParticles();
			this._freeRetiredParticles();
			(this._emission.enbale)&& (this._advanceTime(elapsedTime));
			if (this._firstActiveElement===this._firstFreeElement)
				this._currentTime=0;
			if (this._firstRetiredElement===this._firstActiveElement)
				this._drawCounter=0;
		}

		/**
		*@private
		*/
		__proto._addUpdateEmissionToTimer=function(){
			Laya.timer.frameLoop(1,this,this._updateEmission);
		}

		/**
		*@private
		*/
		__proto._removeUpdateEmissionToTimer=function(){
			Laya.timer.clear(this,this._updateEmission);
		}

		/**
		*@private
		*/
		__proto._onOwnerActiveHierarchyChanged=function(active){
			if (this._owner.displayedInStage){
				if (active)
					this._addUpdateEmissionToTimer();
				else
				this._removeUpdateEmissionToTimer();
			}
		}

		/**
		*@private
		*/
		__proto._onDisplayInStage=function(){
			(this._owner.activeInHierarchy)&& (this._addUpdateEmissionToTimer());
		}

		/**
		*@private
		*/
		__proto._onUnDisplayInStage=function(){
			(this._owner.activeInHierarchy)&& (this._removeUpdateEmissionToTimer());
		}

		/**
		*@private
		*/
		__proto._retireActiveParticles=function(){
			var epsilon=0.0001;
			while (this._firstActiveElement !=this._firstNewElement){
				var index=this._firstActiveElement *this._floatCountPerVertex *4;
				var timeIndex=index+11;
				var particleAge=this._currentTime-this._vertices[timeIndex];
				if (particleAge+epsilon < this._vertices[index+7])
					break ;
				this._vertices[timeIndex]=this._drawCounter;
				this._firstActiveElement++;
				if (this._firstActiveElement >=this._bufferMaxParticles)
					this._firstActiveElement=0;
			}
		}

		/**
		*@private
		*/
		__proto._freeRetiredParticles=function(){
			while (this._firstRetiredElement !=this._firstActiveElement){
				var age=this._drawCounter-this._vertices[this._firstRetiredElement *this._floatCountPerVertex *4+11];
				if (this.isPerformanceMode)
					if (age < 3)
				break ;
				this._firstRetiredElement++;
				if (this._firstRetiredElement >=this._bufferMaxParticles)
					this._firstRetiredElement=0;
			}
		}

		/**
		*@private
		*/
		__proto._setPartVertexDatas=function(){
			for (var i=0;i < this._bufferMaxParticles;i++){
				var particleOffset=i *this._floatCountPerVertex *4;
				this._vertices[particleOffset+this._floatCountPerVertex *0+0]=-0.5;
				this._vertices[particleOffset+this._floatCountPerVertex *0+1]=-0.5;
				this._vertices[particleOffset+this._floatCountPerVertex *1+0]=0.5;
				this._vertices[particleOffset+this._floatCountPerVertex *1+1]=-0.5;
				this._vertices[particleOffset+this._floatCountPerVertex *2+0]=0.5;
				this._vertices[particleOffset+this._floatCountPerVertex *2+1]=0.5;
				this._vertices[particleOffset+this._floatCountPerVertex *3+0]=-0.5;
				this._vertices[particleOffset+this._floatCountPerVertex *3+1]=0.5;
			}
		}

		/**
		*@private
		*/
		__proto._initPartVertexDatas=function(){
			this._vertexBuffer=VertexBuffer3D.create(VertexParticleShuriken.vertexDeclaration,this._bufferMaxParticles *4,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this._vertices=new Float32Array(this._bufferMaxParticles *this._floatCountPerVertex *4);
			this._setPartVertexDatas();
		}

		/**
		*@private
		*/
		__proto._initIndexDatas=function(){
			this._indexBuffer=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._bufferMaxParticles *6,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			var indexes=new Uint16Array(this._bufferMaxParticles *6);
			for (var i=0;i < this._bufferMaxParticles;i++){
				var indexOffset=i *6;
				var vertexOffset=i *4;
				indexes[indexOffset+0]=(vertexOffset+0);
				indexes[indexOffset+1]=(vertexOffset+2);
				indexes[indexOffset+2]=(vertexOffset+1);
				indexes[indexOffset+3]=(vertexOffset+0);
				indexes[indexOffset+4]=(vertexOffset+3);
				indexes[indexOffset+5]=(vertexOffset+2);
			}
			this._indexBuffer.setData(indexes);
		}

		/**
		*@private
		*/
		__proto._burst=function(fromTime,toTime){
			var totalEmitCount=0;
			var bursts=this._emission._bursts;
			for (var n=bursts.length;this._burstsIndex < n;this._burstsIndex++){
				var burst=bursts[this._burstsIndex];
				var burstTime=burst.time;
				if (burstTime >=fromTime && burstTime <=toTime){
					var emitCount=0;
					if (this.autoRandomSeed){
						emitCount=MathUtil.lerp(burst.minCount,burst.maxCount,Math.random());
						}else {
						this._rand.seed=this._randomSeeds[0];
						emitCount=MathUtil.lerp(burst.minCount,burst.maxCount,this._rand.getFloat());
						this._randomSeeds[0]=this._rand.seed;
					}
					totalEmitCount+=emitCount;
					}else {
					break ;
				}
			}
			return totalEmitCount;
		}

		/**
		*@private
		*/
		__proto._advanceTime=function(elapsedTime){
			elapsedTime=Math.min(ShurikenParticleSystem._maxElapsedTime,elapsedTime);
			if (!this._isPlaying || this._isPaused)
				return;
			this._playbackTime+=elapsedTime;
			if (this._playbackTime < this._playStartDelay)
				return;
			var i=0;
			var lastEmissionTime=this._emissionTime;
			this._emissionTime+=elapsedTime;
			var totalEmitCount=0;
			if (this._emissionTime > this.duration){
				totalEmitCount+=this._burst(lastEmissionTime,this.duration);
				if (this.looping){
					this._emissionTime-=this.duration;
					this.event(/*laya.events.Event.COMPLETE*/"complete");
					this._burstsIndex=0;
					totalEmitCount+=this._burst(0,this._emissionTime);
					}else {
					this._isPlaying=false;
					totalEmitCount=Math.min(this.maxParticles-this.aliveParticleCount,totalEmitCount);
					for (i=0;i < totalEmitCount;i++)
					this.emit();
					this.event(/*laya.events.Event.STOPPED*/"stopped");
					return;
				}
				}else {
				totalEmitCount+=this._burst(lastEmissionTime,this._emissionTime);
			}
			totalEmitCount=Math.min(this.maxParticles-this.aliveParticleCount,totalEmitCount);
			for (i=0;i < totalEmitCount;i++)
			this.emit();
			this._frameTime+=elapsedTime;
			var minEmissionTime=this.emission._minEmissionTime;
			if (this._frameTime < minEmissionTime)
				return;
			while (this._frameTime > minEmissionTime){
				if (this.emit())
					this._frameTime-=minEmissionTime;
				else
				break ;
			}
		}

		/**
		*@private
		*/
		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
			(this._owner.displayedInStage && this._owner.activeInHierarchy)&& (this._removeUpdateEmissionToTimer());
			this._vertexBuffer.dispose();
			this._indexBuffer.dispose();
			this._emission._destroy();
			this._owner=null;
			this._vertices=null;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._emission=null;
			this._shape=null;
			this.startLifeTimeGradient=null;
			this.startLifeTimeGradientMin=null;
			this.startLifeTimeGradientMax=null;
			this.startSizeConstantSeparate=null;
			this.startSizeConstantMinSeparate=null;
			this.startSizeConstantMaxSeparate=null;
			this.startRotationConstantSeparate=null;
			this.startRotationConstantMinSeparate=null;
			this.startRotationConstantMaxSeparate=null;
			this.startColorConstant=null;
			this.startColorConstantMin=null;
			this.startColorConstantMax=null;
			this.gravity=null;
			this._velocityOverLifetime=null;
			this._colorOverLifetime=null;
			this._sizeOverLifetime=null;
			this._rotationOverLifetime=null;
			this._textureSheetAnimation=null;
		}

		/**
		*发射一个粒子。
		*/
		__proto.emit=function(){
			var position=ShurikenParticleSystem._tempPosition;
			var direction=ShurikenParticleSystem._tempDirection;
			if (this._shape.enable){
				if (this.autoRandomSeed)
					this._shape.generatePositionAndDirection(position,direction);
				else
				this._shape.generatePositionAndDirection(position,direction,this._rand,this._randomSeeds);
				}else {
				var positionE=position.elements;
				var directionE=direction.elements;
				positionE[0]=positionE[1]=positionE[2]=0;
				directionE[0]=directionE[1]=0;
				directionE[2]=1;
			}
			return this.addParticle(position,direction);
		}

		//TODO:提前判断优化
		__proto.addParticle=function(position,direction){
			Vector3.normalize(direction,direction);
			var positionE=position.elements;
			var directionE=direction.elements;
			var nextFreeParticle=this._firstFreeElement+1;
			if (nextFreeParticle >=this._bufferMaxParticles)
				nextFreeParticle=0;
			if (nextFreeParticle===this._firstRetiredElement)
				return false;
			var particleData=ShurikenParticleData.create(this,this._owner.particleRender,positionE,directionE,this._currentTime,this._owner.transform);
			var startIndex=this._firstFreeElement *this._floatCountPerVertex *4;
			var subU=particleData.startUVInfo[0];
			var subV=particleData.startUVInfo[1];
			var startU=particleData.startUVInfo[2];
			var startV=particleData.startUVInfo[3];
			this._vertices[startIndex+2]=startU;
			this._vertices[startIndex+3]=startV+subV;
			this._vertices[startIndex+this._floatCountPerVertex+2]=startU+subU;
			this._vertices[startIndex+this._floatCountPerVertex+3]=startV+subV;
			this._vertices[startIndex+this._floatCountPerVertex *2+2]=startU+subU;
			this._vertices[startIndex+this._floatCountPerVertex *2+3]=startV;
			this._vertices[startIndex+this._floatCountPerVertex *3+2]=startU;
			this._vertices[startIndex+this._floatCountPerVertex *3+3]=startV;
			var randomVelocityX=NaN,randomVelocityY=NaN,randomVelocityZ=NaN,randomColor=NaN,randomSize=NaN,randomRotation=NaN,randomTextureAnimation=NaN;
			var needRandomVelocity=this._velocityOverLifetime && this._velocityOverLifetime.enbale;
			if (needRandomVelocity){
				var velocityType=this._velocityOverLifetime.velocity.type;
				if (velocityType===2 || velocityType===3){
					if (this.autoRandomSeed){
						randomVelocityX=Math.random();
						randomVelocityY=Math.random();
						randomVelocityZ=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[9];
						randomVelocityX=this._rand.getFloat();
						randomVelocityY=this._rand.getFloat();
						randomVelocityZ=this._rand.getFloat();
						this._randomSeeds[9]=this._rand.seed;
					}
					}else {
					needRandomVelocity=false;
				}
				}else {
				needRandomVelocity=false;
			};
			var needRandomColor=this._colorOverLifetime && this._colorOverLifetime.enbale;
			if (needRandomColor){
				var colorType=this._colorOverLifetime.color.type;
				if (colorType===3){
					if (this.autoRandomSeed){
						randomColor=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[10];
						randomColor=this._rand.getFloat();
						this._randomSeeds[10]=this._rand.seed;
					}
					}else {
					needRandomColor=false;
				}
				}else {
				needRandomColor=false;
			};
			var needRandomSize=this._sizeOverLifetime && this._sizeOverLifetime.enbale;
			if (needRandomSize){
				var sizeType=this._sizeOverLifetime.size.type;
				if (sizeType===3){
					if (this.autoRandomSeed){
						randomSize=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[11];
						randomSize=this._rand.getFloat();
						this._randomSeeds[11]=this._rand.seed;
					}
					}else {
					needRandomSize=false;
				}
				}else {
				needRandomSize=false;
			};
			var needRandomRotation=this._rotationOverLifetime && this._rotationOverLifetime.enbale;
			if (needRandomRotation){
				var rotationType=this._rotationOverLifetime.angularVelocity.type;
				if (rotationType===2 || rotationType===3){
					if (this.autoRandomSeed){
						randomRotation=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[12];
						randomRotation=this._rand.getFloat();
						this._randomSeeds[12]=this._rand.seed;
					}
					}else {
					needRandomRotation=false;
				}
				}else {
				needRandomRotation=false;
			};
			var needRandomTextureAnimation=this._textureSheetAnimation && this._textureSheetAnimation.enbale;
			if (needRandomTextureAnimation){
				var textureAnimationType=this._textureSheetAnimation.frame.type;
				if (textureAnimationType===3){
					if (this.autoRandomSeed){
						randomTextureAnimation=Math.random();
						}else {
						this._rand.seed=this._randomSeeds[15];
						randomTextureAnimation=this._rand.getFloat();
						this._randomSeeds[15]=this._rand.seed;
					}
					}else {
					needRandomTextureAnimation=false;
				}
				}else {
				needRandomTextureAnimation=false;
			}
			for (var i=0;i < 4;i++){
				var vertexStart=startIndex+i *this._floatCountPerVertex;
				var j=0,offset=0;
				for (j=0,offset=4;j < 3;j++)
				this._vertices[vertexStart+offset+j]=particleData.position[j];
				this._vertices[vertexStart+7]=particleData.startLifeTime;
				for (j=0,offset=8;j < 3;j++)
				this._vertices[vertexStart+offset+j]=particleData.direction[j];
				this._vertices[vertexStart+11]=particleData.time;
				for (j=0,offset=12;j < 4;j++)
				this._vertices[vertexStart+offset+j]=particleData.startColor[j];
				for (j=0,offset=16;j < 3;j++)
				this._vertices[vertexStart+offset+j]=particleData.startSize[j];
				for (j=0,offset=19;j < 3;j++)
				this._vertices[vertexStart+offset+j]=particleData.startRotation0[j];
				for (j=0,offset=22;j < 3;j++)
				this._vertices[vertexStart+offset+j]=particleData.startRotation1[j];
				for (j=0,offset=25;j < 3;j++)
				this._vertices[vertexStart+offset+j]=particleData.startRotation2[j];
				this._vertices[vertexStart+28]=particleData.startSpeed;
				needRandomColor && (this._vertices[vertexStart+30]=randomColor);
				needRandomSize && (this._vertices[vertexStart+31]=randomSize);
				needRandomRotation && (this._vertices[vertexStart+32]=randomRotation);
				needRandomTextureAnimation && (this._vertices[vertexStart+33]=randomTextureAnimation);
				if (needRandomVelocity){
					this._vertices[vertexStart+34]=randomVelocityX;
					this._vertices[vertexStart+35]=randomVelocityY;
					this._vertices[vertexStart+36]=randomVelocityZ;
				}
				for (j=0,offset=37;j < 3;j++)
				this._vertices[vertexStart+offset+j]=particleData.simulationWorldPostion[j];
			}
			this._firstFreeElement=nextFreeParticle;
			return true;
		}

		__proto.addNewParticlesToVertexBuffer=function(){
			var start=0;
			if (this._firstNewElement < this._firstFreeElement){
				start=this._firstNewElement *4 *this._floatCountPerVertex;
				this._vertexBuffer.setData(this._vertices,start,start,(this._firstFreeElement-this._firstNewElement)*4 *this._floatCountPerVertex);
				}else {
				start=this._firstNewElement *4 *this._floatCountPerVertex;
				this._vertexBuffer.setData(this._vertices,start,start,(this._bufferMaxParticles-this._firstNewElement)*4 *this._floatCountPerVertex);
				if (this._firstFreeElement > 0){
					this._vertexBuffer.setData(this._vertices,0,0,this._firstFreeElement *4 *this._floatCountPerVertex);
				}
			}
			this._firstNewElement=this._firstFreeElement;
		}

		__proto._beforeRender=function(state){
			if (this._firstNewElement !=this._firstFreeElement){
				this.addNewParticlesToVertexBuffer();
			}
			this._drawCounter++;
			if (this._firstActiveElement !=this._firstFreeElement){
				this._vertexBuffer._bind();
				this._indexBuffer._bind();
				return true;
			}
			return false;
		}

		__proto._render=function(state){
			var drawVertexCount=0;
			var glContext=WebGL.mainContext;
			if (this._firstActiveElement < this._firstFreeElement){
				drawVertexCount=(this._firstFreeElement-this._firstActiveElement)*6;
				glContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,drawVertexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._firstActiveElement *6 *2);
				Stat.trianglesFaces+=drawVertexCount / 3;
				Stat.drawCall++;
				}else {
				drawVertexCount=(this._bufferMaxParticles-this._firstActiveElement)*6;
				glContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,drawVertexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._firstActiveElement *6 *2);
				Stat.trianglesFaces+=drawVertexCount / 3;
				Stat.drawCall++;
				if (this._firstFreeElement > 0){
					drawVertexCount=this._firstFreeElement *6;
					glContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,drawVertexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
					Stat.trianglesFaces+=drawVertexCount / 3;
					Stat.drawCall++;
				}
			}
		}

		/**
		*开始发射粒子。
		*/
		__proto.play=function(){
			this._burstsIndex=0;
			this._isPlaying=true;
			this._isPaused=false;
			this._frameTime=0;
			this._emissionTime=0;
			this._playbackTime=0;
			if (!this.autoRandomSeed){
				for (var i=0,n=this._randomSeeds.length;i < n;i++)
				this._randomSeeds[i]=this.randomSeed[0]+ShurikenParticleSystem._RANDOMOFFSET[i];
			}
			switch (this.startDelayType){
				case 0:
					this._playStartDelay=this.startDelay;
					break ;
				case 1:
					if (this.autoRandomSeed){
						this._playStartDelay=MathUtil.lerp(this.startDelayMin,this.startDelayMax,Math.random());
						}else {
						this._rand.seed=this._randomSeeds[2];
						this._playStartDelay=MathUtil.lerp(this.startDelayMin,this.startDelayMax,this._rand.getFloat());
						this._randomSeeds[2]=this._rand.seed;
					}
					break ;
				default :
					throw new Error("Utils3D: startDelayType is invalid.");
				}
			this._startUpdateLoopCount=Stat.loopCount;
			this.event(/*laya.events.Event.PLAYED*/"played");
		}

		/**
		*暂停发射粒子。
		*/
		__proto.pause=function(){
			this._isPaused=true;
			this.event(/*laya.events.Event.PAUSED*/"paused");
		}

		/**
		*停止发射粒子。
		*/
		__proto.stop=function(){
			this._burstsIndex=0;
			this._frameTime=0;
			this._isPlaying=false;
			this._isPaused=false;
			this._emissionTime=0;
			this._playbackTime=0;
			this.event(/*laya.events.Event.STOPPED*/"stopped");
		}

		/**
		*克隆。
		*@param destObject 克隆源。
		*/
		__proto.cloneTo=function(destObject){
			var dest=destObject;
			dest.duration=this.duration;
			dest.looping=this.looping;
			dest.prewarm=this.prewarm;
			dest.startDelayType=this.startDelayType;
			dest.startDelay=this.startDelay;
			dest.startDelayMin=this.startDelayMin;
			dest.startDelayMax=this.startDelayMax;
			dest.startLifetimeType=this.startLifetimeType;
			dest.startLifetimeConstant=this.startLifetimeConstant;
			this.startLifeTimeGradient.cloneTo(dest.startLifeTimeGradient);
			dest.startLifetimeConstantMin=this.startLifetimeConstantMin;
			dest.startLifetimeConstantMax=this.startLifetimeConstantMax;
			this.startLifeTimeGradientMin.cloneTo(dest.startLifeTimeGradientMin);
			this.startLifeTimeGradientMax.cloneTo(dest.startLifeTimeGradientMax);
			dest.startSpeedType=this.startSpeedType;
			dest.startSpeedConstant=this.startSpeedConstant;
			dest.startSpeedConstantMin=this.startSpeedConstantMin;
			dest.startSpeedConstantMax=this.startSpeedConstantMax;
			dest.threeDStartSize=this.threeDStartSize;
			dest.startSizeType=this.startSizeType;
			dest.startSizeConstant=this.startSizeConstant;
			this.startSizeConstantSeparate.cloneTo(dest.startSizeConstantSeparate);
			dest.startSizeConstantMin=this.startSizeConstantMin;
			dest.startSizeConstantMax=this.startSizeConstantMax;
			this.startSizeConstantMinSeparate.cloneTo(dest.startSizeConstantMinSeparate);
			this.startSizeConstantMaxSeparate.cloneTo(dest.startSizeConstantMaxSeparate);
			dest.threeDStartRotation=this.threeDStartRotation;
			dest.startRotationType=this.startRotationType;
			dest.startRotationConstant=this.startRotationConstant;
			this.startRotationConstantSeparate.cloneTo(dest.startRotationConstantSeparate);
			dest.startRotationConstantMin=this.startRotationConstantMin;
			dest.startRotationConstantMax=this.startRotationConstantMax;
			this.startRotationConstantMinSeparate.cloneTo(dest.startRotationConstantMinSeparate);
			this.startRotationConstantMaxSeparate.cloneTo(dest.startRotationConstantMaxSeparate);
			dest.randomizeRotationDirection=this.randomizeRotationDirection;
			dest.startColorType=this.startColorType;
			this.startColorConstant.cloneTo(dest.startColorConstant);
			this.startColorConstantMin.cloneTo(dest.startColorConstantMin);
			this.startColorConstantMax.cloneTo(dest.startColorConstantMax);
			this.gravity.cloneTo(dest.gravity);
			dest.gravityModifier=this.gravityModifier;
			dest.simulationSpace=this.simulationSpace;
			dest.scaleMode=this.scaleMode;
			dest.playOnAwake=this.playOnAwake;
			dest.maxParticles=this.maxParticles;
			(this.emission)&& (dest.emission=this.emission.clone());
			(this.shape)&& (dest.shape=this.shape.clone());
			(this.velocityOverLifetime)&& (dest.velocityOverLifetime=this.velocityOverLifetime.clone());
			(this.colorOverLifetime)&& (dest.colorOverLifetime=this.colorOverLifetime.clone());
			(this.sizeOverLifetime)&& (dest.sizeOverLifetime=this.sizeOverLifetime.clone());
			(this.rotationOverLifetime)&& (dest.rotationOverLifetime=this.rotationOverLifetime.clone());
			(this.textureSheetAnimation)&& (dest.textureSheetAnimation=this.textureSheetAnimation.clone());
			dest.isPerformanceMode=this.isPerformanceMode;
			dest._isPlaying=this._isPlaying;
			dest._isPaused=this._isPaused;
			dest._playStartDelay=this._playStartDelay;
			dest._frameTime=this._frameTime;
			dest._emissionTime=this._emissionTime;
			dest._playbackTime=this._playbackTime;
			dest._burstsIndex=this._burstsIndex;
		}

		/**
		*克隆。
		*@return 克隆副本。
		*/
		__proto.clone=function(){
			var dest=/*__JS__ */new this.constructor();
			this.cloneTo(dest);
			return dest;
		}

		__proto._renderRuntime=function(conchGraphics3D,renderElement,state){}
		/**是否已暂停。*/
		__getset(0,__proto,'isPaused',function(){
			return this._isPaused;
		});

		/**当前粒子时间。*/
		__getset(0,__proto,'currentTime',function(){
			return this._currentTime;
		});

		/**设置最大粒子数,注意:谨慎修改此属性，有性能损耗。*/
		/**获取最大粒子数。*/
		__getset(0,__proto,'maxParticles',function(){
			return this._bufferMaxParticles-1;
			},function(value){
			var newMaxParticles=value+1;
			if (newMaxParticles!==this._bufferMaxParticles){
				this._bufferMaxParticles=newMaxParticles;
				if (this._vertexBuffer){
					this._vertexBuffer.dispose();
					this._indexBuffer.dispose();
				}
				this._initPartVertexDatas();
				this._initIndexDatas();
			}
		});

		/**
		*是否存活。
		*/
		__getset(0,__proto,'isAlive',function(){
			if (this._isPlaying || this.aliveParticleCount > 0)
				return true;
			return false;
		});

		/**
		*设置形状。
		*/
		/**
		*获取形状。
		*/
		__getset(0,__proto,'shape',function(){
			return this._shape;
			},function(value){
			this._shape=value;
			this._emission._shape=value;
		});

		/**
		*设置生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期旋转。
		*/
		/**
		*获取生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期旋转。
		*/
		__getset(0,__proto,'rotationOverLifetime',function(){
			return this._rotationOverLifetime;
			},function(value){
			if (value){
				var rotation=value.angularVelocity;
				var rotationSeparate=rotation.separateAxes;
				var rotationType=rotation.type;
				if (value.enbale){
					if (rotationSeparate)
						this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
					else
					this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
					switch (rotationType){
						case 0:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
							break ;
						case 1:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
							break ;
						case 2:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
							break ;
						case 3:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
							break ;
						}
					}else {
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
				}
				switch (rotationType){
					case 0:
						if (rotationSeparate){
							this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE*/28,rotation.constantSeparate);
							}else {
							this._owner._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONST*/27,rotation.constant);
						}
						break ;
					case 1:
						if (rotationSeparate){
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX*/30,rotation.gradientX._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY*/31,rotation.gradientY._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ*/32,rotation.gradientZ._elements);
							}else {
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT*/29,rotation.gradient._elements);
						}
						break ;
					case 2:
						if (rotationSeparate){
							this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE*/28,rotation.constantMinSeparate);
							this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE*/34,rotation.constantMaxSeparate);
							}else {
							this._owner._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONST*/27,rotation.constantMin);
							this._owner._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX*/33,rotation.constantMax);
						}
						break ;
					case 3:
						if (rotationSeparate){
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX*/30,rotation.gradientXMin._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX*/36,rotation.gradientXMax._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY*/31,rotation.gradientYMin._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX*/37,rotation.gradientYMax._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ*/32,rotation.gradientZMin._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX*/38,rotation.gradientZMax._elements);
							}else {
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT*/29,rotation.gradientMin._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX*/35,rotation.gradientMax._elements);
						}
						break ;
					}
				}else {
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
				this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE*/28,null);
				this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE*/34,null);
				this._owner._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONST*/27,undefined);
				this._owner._setShaderValueNumber(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX*/33,undefined);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX*/30,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX*/36,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY*/31,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX*/37,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ*/32,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX*/38,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT*/29,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX*/35,null);
			}
			this._rotationOverLifetime=value;
		});

		/**
		*设置发射器。
		*/
		/**
		*获取发射器。
		*/
		__getset(0,__proto,'emission',function(){
			return this._emission;
			},function(value){
			this._emission=value;
			value._particleSystem=this;
			value._shape=this._shape;
		});

		/**
		*获取一次循环内的累计时间。
		*@return 一次循环内的累计时间。
		*/
		__getset(0,__proto,'emissionTime',function(){
			return this._emissionTime > this.duration ? this.duration :this._emissionTime;
		});

		/**
		*粒子存活个数。
		*/
		__getset(0,__proto,'aliveParticleCount',function(){
			if (this._firstNewElement >=this._firstRetiredElement)
				return this._firstNewElement-this._firstRetiredElement;
			else
			return this._bufferMaxParticles-this._firstRetiredElement+this._firstNewElement;
		});

		/**是否正在播放。*/
		__getset(0,__proto,'isPlaying',function(){
			return this._isPlaying;
		});

		/**
		*获取播放的累计时间。
		*@return 播放的累计时间。
		*/
		__getset(0,__proto,'playbackTime',function(){
			return this._playbackTime;
		});

		/**
		*设置生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期速度.
		*/
		/**
		*获取生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期速度.
		*/
		__getset(0,__proto,'velocityOverLifetime',function(){
			return this._velocityOverLifetime;
			},function(value){
			if (value){
				var velocity=value.velocity;
				var velocityType=velocity.type;
				if (value.enbale){
					switch (velocityType){
						case 0:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
							break ;
						case 1:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
							break ;
						case 2:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
							break ;
						case 3:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
							break ;
						}
					}else {
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
				}
				switch (velocityType){
					case 0:
						this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/6,velocity.constant);
						break ;
					case 1:
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/7,velocity.gradientX._elements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/8,velocity.gradientY._elements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/9,velocity.gradientZ._elements);
						break ;
					case 2:
						this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/6,velocity.constantMin);
						this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONSTMAX*/10,velocity.constantMax);
						break ;
					case 3:
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/7,velocity.gradientXMin._elements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX*/11,velocity.gradientXMax._elements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/8,velocity.gradientYMin._elements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX*/12,velocity.gradientYMax._elements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/9,velocity.gradientZMin._elements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX*/13,velocity.gradientZMax._elements);
						break ;
					}
				this._owner._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLSPACETYPE*/14,value.space);
				}else {
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
				this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/6,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/7,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/8,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/9,null);
				this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONST*/6,null);
				this._owner._setShaderValueColor(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYCONSTMAX*/10,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTX*/7,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX*/11,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTY*/8,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX*/12,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZ*/9,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX*/13,null);
				this._owner._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.VOLSPACETYPE*/14,undefined);
			}
			this._velocityOverLifetime=value;
		});

		/**
		*设置生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期颜色
		*/
		/**
		*获取生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期颜色
		*/
		__getset(0,__proto,'colorOverLifetime',function(){
			return this._colorOverLifetime;
			},function(value){
			if (value){
				var color=value.color;
				if (value.enbale){
					switch (color.type){
						case 1:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
							break ;
						case 3:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
							break ;
						}
					}else {
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
				}
				switch (color.type){
					case 1:;
						var gradientColor=color.gradient;
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/15,gradientColor._alphaElements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/16,gradientColor._rgbElements);
						break ;
					case 3:;
						var minGradientColor=color.gradientMin;
						var maxGradientColor=color.gradientMax;
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/15,minGradientColor._alphaElements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/16,minGradientColor._rgbElements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS*/17,maxGradientColor._alphaElements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS*/18,maxGradientColor._rgbElements);
						break ;
					}
				}else {
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/15,gradientColor._alphaElements);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/16,gradientColor._rgbElements);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS*/15,minGradientColor._alphaElements);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS*/16,minGradientColor._rgbElements);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS*/17,maxGradientColor._alphaElements);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS*/18,maxGradientColor._rgbElements);
			}
			this._colorOverLifetime=value;
		});

		/**
		*设置生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期尺寸
		*/
		/**
		*获取生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期尺寸
		*/
		__getset(0,__proto,'sizeOverLifetime',function(){
			return this._sizeOverLifetime;
			},function(value){
			if (value){
				var size=value.size;
				var sizeSeparate=size.separateAxes;
				var sizeType=size.type;
				if (value.enbale){
					switch (sizeType){
						case 0:
							if (sizeSeparate)
								this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
							else
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
							break ;
						case 2:
							if (sizeSeparate)
								this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
							else
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
							break ;
						}
					}else {
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
				}
				switch (sizeType){
					case 0:
						if (sizeSeparate){
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTX*/20,size.gradientX._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTY*/21,size.gradientY._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZ*/22,size.gradientZ._elements);
							}else {
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENT*/19,size.gradient._elements);
						}
						break ;
					case 2:
						if (sizeSeparate){
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTX*/20,size.gradientXMin._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTXMAX*/24,size.gradientXMax._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTY*/21,size.gradientYMin._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTYMAX*/25,size.gradientYMax._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZ*/22,size.gradientZMin._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZMAX*/26,size.gradientZMax._elements);
							}else {
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENT*/19,size.gradientMin._elements);
							this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientMax*/23,size.gradientMax._elements);
						}
						break ;
					}
				}else {
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTX*/20,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTXMAX*/24,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTY*/21,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENTYMAX*/25,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZ*/22,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientZMAX*/26,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSIZEGRADIENT*/19,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.SOLSizeGradientMax*/23,null);
			}
			this._sizeOverLifetime=value;
		});

		/**
		*设置生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@param value 生命周期纹理动画。
		*/
		/**
		*获取生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
		*@return 生命周期纹理动画。
		*/
		__getset(0,__proto,'textureSheetAnimation',function(){
			return this._textureSheetAnimation;
			},function(value){
			if (value){
				var frameOverTime=value.frame;
				var textureAniType=frameOverTime.type;
				if (value.enbale){
					switch (textureAniType){
						case 1:
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
							break ;
							this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
						case 3:
							break ;
						}
					}else {
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
					this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
				}
				if (textureAniType===1 || textureAniType===3){
					this._owner._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES*/39,value.cycles);
					var title=value.tiles;
					var _uvLengthE=this._uvLength.elements;
					_uvLengthE[0]=1.0 / title.x;
					_uvLengthE[1]=1.0 / title.y;
					this._owner._setShaderValueVector2(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH*/40,this._uvLength);
				}
				switch (textureAniType){
					case 1:
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS*/41,frameOverTime.frameOverTimeData._elements);
						break ;
					case 3:
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS*/41,frameOverTime.frameOverTimeDataMin._elements);
						this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS*/42,frameOverTime.frameOverTimeDataMax._elements);
						break ;
					}
				}else {
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
				this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
				this._owner._setShaderValueInt(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES*/39,undefined);
				this._owner._setShaderValueVector2(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH*/40,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS*/41,null);
				this._owner._setShaderValueBuffer(/*laya.d3.core.particleShuriKen.ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS*/42,null);
			}
			this._textureSheetAnimation=value;
		});

		__getset(0,__proto,'indexOfHost',function(){
			return 0;
		});

		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer.indexCount / 3;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingSphere',function(){
			return this._boundingSphere;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingBox',function(){
			return this._boundingBox;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingBoxCorners',function(){
			return this._boundingBoxCorners;
		});

		__static(ShurikenParticleSystem,
		['_maxElapsedTime',function(){return this._maxElapsedTime=1.0 / 3.0;},'_RANDOMOFFSET',function(){return this._RANDOMOFFSET=new Uint32Array([0x23571a3e,0xc34f56fe,0x13371337,0x12460f3b,0x6aed452e,0xdec4aea1,0x96aa4de3,0x8d2c8431,0xf3857f6f,0xe0fbd834,0x13740583,0x591bc05c,0x40eb95e4,0xbc524e5f,0xaf502044,0xa614b381,0x1034e524,0xfc524e5f]);},'_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempVector31',function(){return this._tempVector31=new Vector3();},'_tempVector32',function(){return this._tempVector32=new Vector3();},'_tempVector33',function(){return this._tempVector33=new Vector3();},'_tempVector34',function(){return this._tempVector34=new Vector3();},'_tempVector35',function(){return this._tempVector35=new Vector3();},'_tempVector36',function(){return this._tempVector36=new Vector3();},'_tempVector37',function(){return this._tempVector37=new Vector3();},'_tempVector38',function(){return this._tempVector38=new Vector3();},'_tempVector39',function(){return this._tempVector39=new Vector3();},'_tempPosition',function(){return this._tempPosition=new Vector3();},'_tempDirection',function(){return this._tempDirection=new Vector3();}
		]);
		return ShurikenParticleSystem;
	})(GeometryFilter)


	/**
	*<code>ShurikenParticleRender</code> 类用于创建3D粒子渲染器。
	*/
	//class laya.d3.core.particleShuriKen.ShurikenParticleRender extends laya.d3.core.render.BaseRender
	var ShurikenParticleRender=(function(_super){
		function ShurikenParticleRender(owner){
			this._defaultBoundBox=null;
			this._renderMode=0;
			this.stretchedBillboardCameraSpeedScale=NaN;
			this.stretchedBillboardSpeedScale=NaN;
			this.stretchedBillboardLengthScale=NaN;
			ShurikenParticleRender.__super.call(this,owner);
			this._defaultBoundBox=new BoundBox(new Vector3(),new Vector3());
			this._renderMode=0;
			owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SPHERHBILLBOARD);
			this.stretchedBillboardCameraSpeedScale=0.0;
			this.stretchedBillboardSpeedScale=0.0;
			this.stretchedBillboardLengthScale=1.0;
		}

		__class(ShurikenParticleRender,'laya.d3.core.particleShuriKen.ShurikenParticleRender',_super);
		var __proto=ShurikenParticleRender.prototype;
		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingBox=function(){
			var minE=this._boundingBox.min.elements;
			minE[0]=-Number.MAX_VALUE;
			minE[1]=-Number.MAX_VALUE;
			minE[2]=-Number.MAX_VALUE;
			var maxE=this._boundingBox.min.elements;
			maxE[0]=Number.MAX_VALUE;
			maxE[1]=Number.MAX_VALUE;
			maxE[2]=Number.MAX_VALUE;
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateBoundingSphere=function(){
			var centerE=this._boundingSphere.center.elements;
			centerE[0]=0;
			centerE[1]=0;
			centerE[2]=0;
			this._boundingSphere.radius=Number.MAX_VALUE;
		}

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'boundingBox',function(){
			if (!(this._owner).particleSystem.isAlive){
				return this._defaultBoundBox;
				}else {
				if (this._boundingBoxNeedChange){
					this._calculateBoundingBox();
					this._boundingBoxNeedChange=false;
				}
				return this._boundingBox;
			}
		});

		/**
		*设置渲染模式。
		*@param value 渲染模式。
		*/
		/**
		*获取渲染模式。
		*@return 渲染模式。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			if (this._renderMode!==value){
				switch (this._renderMode){
					case 0:
						this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SPHERHBILLBOARD);
						break ;
					case 1:
						this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_STRETCHEDBILLBOARD);
						break ;
					case 2:
						this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_HORIZONTALBILLBOARD);
						break ;
					case 3:
						this._owner._removeShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VERTICALBILLBOARD);
						break ;
					}
				this._renderMode=value;
				switch (value){
					case 0:
						this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_SPHERHBILLBOARD);
						break ;
					case 1:
						this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_STRETCHEDBILLBOARD);
						break ;
					case 2:
						this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_HORIZONTALBILLBOARD);
						break ;
					case 3:
						this._owner._addShaderDefine(ShuriKenParticle3D.SHADERDEFINE_VERTICALBILLBOARD);
						break ;
					default :
						throw new Error("ShurikenParticleRender: unknown renderMode Value.");
					}
			}
		});

		return ShurikenParticleRender;
	})(BaseRender)


	/**
	*@private
	*<code>ParticleTemplet3D</code> 类用于创建3D粒子数据模板。
	*/
	//class laya.d3.resource.tempelet.ParticleTemplet3D extends laya.particle.ParticleTemplateWebGL
	var ParticleTemplet3D=(function(_super){
		function ParticleTemplet3D(owner,setting){
			this._owner=null;
			this._vertexBuffer3D=null;
			this._indexBuffer3D=null;
			ParticleTemplet3D.__super.call(this,setting);
			this._owner=owner;
			this.initialize();
			this._vertexBuffer=this._vertexBuffer3D=VertexBuffer3D.create(VertexParticle.vertexDeclaration,setting.maxPartices *4,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this._indexBuffer=this._indexBuffer3D=IndexBuffer3D.create(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",setting.maxPartices *6,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this.loadContent();
		}

		__class(ParticleTemplet3D,'laya.d3.resource.tempelet.ParticleTemplet3D',_super);
		var __proto=ParticleTemplet3D.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer3D;
			else
			return null;
		}

		__proto._getIndexBuffer=function(){
			return this._indexBuffer3D;
		}

		__proto.addParticle=function(position,velocity){
			this.addParticleArray(position.elements,velocity.elements);
		}

		__proto.loadContent=function(){
			var indexes=new Uint16Array(this.settings.maxPartices *6);
			for (var i=0;i < this.settings.maxPartices;i++){
				indexes[i *6+0]=(i *4+0);
				indexes[i *6+1]=(i *4+1);
				indexes[i *6+2]=(i *4+2);
				indexes[i *6+3]=(i *4+0);
				indexes[i *6+4]=(i *4+2);
				indexes[i *6+5]=(i *4+3);
			}
			this._indexBuffer3D.setData(indexes);
		}

		__proto.addNewParticlesToVertexBuffer=function(){
			var start=0;
			if (this._firstNewElement < this._firstFreeElement){
				start=this._firstNewElement *4 *this._floatCountPerVertex;
				this._vertexBuffer3D.setData(this._vertices,start,start,(this._firstFreeElement-this._firstNewElement)*4 *this._floatCountPerVertex);
				}else {
				start=this._firstNewElement *4 *this._floatCountPerVertex;
				this._vertexBuffer3D.setData(this._vertices,start,start,(this.settings.maxPartices-this._firstNewElement)*4 *this._floatCountPerVertex);
				if (this._firstFreeElement > 0){
					this._vertexBuffer3D.setData(this._vertices,0,0,this._firstFreeElement *4 *this._floatCountPerVertex);
				}
			}
			this._firstNewElement=this._firstFreeElement;
		}

		__proto._beforeRender=function(state){
			if (this._firstNewElement !=this._firstFreeElement){
				this.addNewParticlesToVertexBuffer();
			}
			this._drawCounter++;
			if (this._firstActiveElement !=this._firstFreeElement){
				this._vertexBuffer3D._bind();
				this._indexBuffer._bind();
				return true;
			}
			return false;
		}

		__proto._render=function(state){
			var drawVertexCount=0;
			var glContext=WebGL.mainContext;
			if (this._firstActiveElement < this._firstFreeElement){
				drawVertexCount=(this._firstFreeElement-this._firstActiveElement)*6;
				glContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,drawVertexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._firstActiveElement *6 *2);
				Stat.trianglesFaces+=drawVertexCount / 3;
				Stat.drawCall++;
				}else {
				drawVertexCount=(this.settings.maxPartices-this._firstActiveElement)*6;
				glContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,drawVertexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,this._firstActiveElement *6 *2);
				Stat.trianglesFaces+=drawVertexCount / 3;
				Stat.drawCall++;
				if (this._firstFreeElement > 0){
					drawVertexCount=this._firstFreeElement *6;
					glContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,drawVertexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
					Stat.trianglesFaces+=drawVertexCount / 3;
					Stat.drawCall++;
				}
			}
		}

		__proto._renderRuntime=function(conchGraphics3D,renderElement,state){}
		__getset(0,__proto,'indexOfHost',function(){
			return 0;
		});

		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer3D.indexCount / 3;
		});

		return ParticleTemplet3D;
	})(ParticleTemplateWebGL)


	/**
	*@private
	*<code>GlitterTemplet</code> 类用于创建闪光数据模板。
	*/
	//class laya.d3.resource.tempelet.GlitterTemplet extends laya.d3.core.GeometryFilter
	var GlitterTemplet=(function(_super){
		function GlitterTemplet(owner){
			this._floatCountPerVertex=6;
			this._owner=null;
			this._vertices=null;
			this._vertexBuffer=null;
			this._firstActiveElement=0;
			this._firstNewElement=0;
			this._firstFreeElement=0;
			this._firstRetiredElement=0;
			this._currentTime=NaN;
			this._drawCounter=0;
			this.scLeft=null;
			this.scRight=null;
			this._numPositionMode=0;
			this._numPositionVelocityMode=0;
			this._lastTime=NaN;
			this._needPatch=false;
			this._lastPatchAddPos0=null;
			this._lastPatchAddPos1=null;
			this._lastPatchAddTime=NaN;
			this.lifeTime=NaN;
			this.minSegmentDistance=NaN;
			this.minInterpDistance=NaN;
			this.maxSlerpCount=0;
			this.color=null;
			this._maxSegments=0;
			GlitterTemplet.__super.call(this);
			this._tempVector0=new Vector3();
			this._tempVector1=new Vector3();
			this._tempVector2=new Vector3();
			this._tempVector3=new Vector3();
			this._albedo=new Vector4(1.0,1.0,1.0,1.0);
			this._posModeLastPosition0=new Vector3();
			this._posModeLastPosition1=new Vector3();
			this._posModePosition0=new Vector3();
			this._posModePosition1=new Vector3();
			this._posVelModePosition0=new Vector3();
			this._posVelModeVelocity0=new Vector3();
			this._posVelModePosition1=new Vector3();
			this._posVelModeVelocity1=new Vector3();
			this._owner=owner;
			this._lastTime=0
			this._firstActiveElement=0;
			this._firstNewElement=0;
			this._firstFreeElement=0;
			this._firstRetiredElement=0;
			this._currentTime=0;
			this._drawCounter=0;
			this._needPatch=false;
			this._lastPatchAddPos0=new Vector3();
			this._lastPatchAddPos1=new Vector3();
			this.scLeft=new SplineCurvePositionVelocity();
			this.scRight=new SplineCurvePositionVelocity();
			this.lifeTime=0.5;
			this.minSegmentDistance=0.1;
			this.minInterpDistance=0.6;
			this.maxSlerpCount=128;
			this.color=new Vector4(1.0,1.0,1.0,1.0);
			this._maxSegments=200;
			this._owner.on(/*laya.events.Event.ACTIVE_IN_HIERARCHY_CHANGED*/"activeinhierarchychanged",this,this._onActiveHierarchyChanged);
		}

		__class(GlitterTemplet,'laya.d3.resource.tempelet.GlitterTemplet',_super);
		var __proto=GlitterTemplet.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer;
			else
			return null;
		}

		__proto._getIndexBuffer=function(){
			return null;
		}

		/**
		*@private
		*/
		__proto._initialize=function(){
			this._vertexBuffer=VertexBuffer3D.create(VertexGlitter.vertexDeclaration,this.maxSegments *2,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this._vertices=new Float32Array(this.maxSegments *this._floatCountPerVertex *2);
		}

		__proto._onActiveHierarchyChanged=function(active){
			if (!active){
				this._numPositionMode=0;
				this._numPositionVelocityMode=0;
				this._firstActiveElement=0;
				this._firstNewElement=0;
				this._firstFreeElement=0;
				this._firstRetiredElement=0;
				this._currentTime=0;
				this._drawCounter=0;
			}
		}

		/**
		*@private
		*/
		__proto._updateTextureCoordinates=function(){
			if (this._firstActiveElement < this._firstFreeElement){
				this._updateSubTextureCoordinates(this._firstActiveElement,(this._firstFreeElement-this._firstActiveElement)*2);
				}else {
				this._updateSubTextureCoordinates(this._firstActiveElement,(this.maxSegments-this._firstActiveElement)*2);
				if (this._firstFreeElement > 0)
					this._updateSubTextureCoordinates(0,this._firstFreeElement *2);
			}
		}

		/**
		*@private
		*/
		__proto._updateSubTextureCoordinates=function(start,count){
			var startOffset=start *2;
			for (var i=0;i < count;i+=2){
				var vertexOffset=startOffset+i;
				var upVertexOffset=vertexOffset *this._floatCountPerVertex;
				var downVertexOffset=(vertexOffset+1)*this._floatCountPerVertex;
				this._vertices[upVertexOffset+3]=this._vertices[downVertexOffset+3]=(this._vertices[upVertexOffset+5]-this._currentTime)/ this.lifeTime;
			}
		}

		/**
		*@private
		*/
		__proto._retireActiveGlitter=function(){
			var particleDuration=this.lifeTime;
			var _floatCountOneSegement=this._floatCountPerVertex *2;
			while (this._firstActiveElement !=this._firstNewElement){
				var index=this._firstActiveElement *_floatCountOneSegement+5;
				var particleAge=this._currentTime-this._vertices[index];
				if (particleAge < particleDuration)
					break ;
				this._vertices[index]=this._drawCounter;
				this._firstActiveElement++;
				if (this._firstActiveElement >=this.maxSegments)
					this._firstActiveElement=0;
			}
		}

		/**
		*@private
		*/
		__proto._freeRetiredGlitter=function(){
			var _floatCountOneSegement=this._floatCountPerVertex *2;
			while (this._firstRetiredElement !=this._firstActiveElement){
				var age=this._drawCounter-this._vertices[this._firstRetiredElement *_floatCountOneSegement+5];
				if (age < 3)
					break ;
				this._firstRetiredElement++;
				if (this._firstRetiredElement >=this.maxSegments)
					this._firstRetiredElement=0;
			}
		}

		/**
		*@private
		*/
		__proto._calcVelocity=function(left,right,out){
			Vector3.subtract(left,right,out);
			Vector3.scale(out,0.5,out);
		}

		/**
		*@private
		*/
		__proto._addNewGlitterSegementToVertexBuffer=function(){
			var start=0;
			if (this._firstActiveElement < this._firstFreeElement){
				start=this._firstActiveElement *2 *this._floatCountPerVertex;
				this._vertexBuffer.setData(this._vertices,start,start,(this._firstFreeElement-this._firstActiveElement)*2 *this._floatCountPerVertex);
				}else {
				start=this._firstActiveElement *2 *this._floatCountPerVertex;
				this._vertexBuffer.setData(this._vertices,start,start,(this.maxSegments-this._firstActiveElement)*2 *this._floatCountPerVertex);
				if (this._firstFreeElement > 0){
					this._vertexBuffer.setData(this._vertices,0,0,this._firstFreeElement *2 *this._floatCountPerVertex);
				}
			}
			this._firstNewElement=this._firstFreeElement;
		}

		/**
		*@private
		*/
		__proto._addGlitter=function(position0,position1,time){
			if (this._needPatch){
				this._needPatch=false;
				this._addGlitter(this._lastPatchAddPos0,this._lastPatchAddPos1,this._lastPatchAddTime);
			};
			var nextFreeParticle=this._firstFreeElement+1;
			if (nextFreeParticle >=this.maxSegments){
				nextFreeParticle=0;
				position0.cloneTo(this._lastPatchAddPos0);
				position1.cloneTo(this._lastPatchAddPos1);
				this._lastPatchAddTime=time;
				this._needPatch=true;
			}
			if (nextFreeParticle===this._firstRetiredElement)
				throw new Error("GlitterTemplet:current segement count have large than maxSegments,please adjust the  value of maxSegments or add Glitter Vertex Frequency.");
			var position0e=position0.elements;
			var position1e=position1.elements;
			var j=0;
			var positionIndex=this._firstFreeElement *this._floatCountPerVertex *2;
			for (j=0;j < 3;j++)
			this._vertices[positionIndex+j]=position0e[j];
			this._vertices[positionIndex+3]=0.0;
			this._vertices[positionIndex+4]=0.0;
			this._vertices[positionIndex+5]=time;
			var nextPositionIndex=positionIndex+this._floatCountPerVertex;
			for (j=0;j < 3;j++)
			this._vertices[nextPositionIndex+j]=position1e[j];
			this._vertices[nextPositionIndex+3]=0.0;
			this._vertices[nextPositionIndex+4]=1.0;
			this._vertices[nextPositionIndex+5]=time;
			this._firstFreeElement=nextFreeParticle;
		}

		/**
		*@private
		*更新闪光。
		*@param elapsedTime 间隔时间
		*/
		__proto._update=function(elapsedTime){
			this._currentTime+=elapsedTime / 1000;
			this._retireActiveGlitter();
			this._freeRetiredGlitter();
			if (this._firstActiveElement==this._firstFreeElement)
				this._currentTime=0;
			if (this._firstRetiredElement==this._firstActiveElement)
				this._drawCounter=0;
			this._updateTextureCoordinates();
		}

		//实时更新纹理坐标
		__proto._beforeRender=function(state){
			if (this._firstNewElement !=this._firstFreeElement){
				this._addNewGlitterSegementToVertexBuffer();
			}
			this._drawCounter++;
			if (this._firstActiveElement !=this._firstFreeElement){
				this._vertexBuffer.bindWithIndexBuffer(null);
				return true;
			}
			return false;
		}

		/**
		*@private
		*渲染闪光。
		*@param state 相关渲染状态
		*/
		__proto._render=function(state){
			var drawVertexCount=0;
			var glContext=WebGL.mainContext;
			if (this._firstActiveElement < this._firstFreeElement){
				drawVertexCount=(this._firstFreeElement-this._firstActiveElement)*2;
				glContext.drawArrays(/*laya.webgl.WebGLContext.TRIANGLE_STRIP*/0x0005,this._firstActiveElement *2,drawVertexCount);
				Stat.trianglesFaces+=drawVertexCount-2;
				Stat.drawCall++;
				}else {
				drawVertexCount=(this.maxSegments-this._firstActiveElement)*2;
				glContext.drawArrays(/*laya.webgl.WebGLContext.TRIANGLE_STRIP*/0x0005,this._firstActiveElement *2,drawVertexCount);
				Stat.trianglesFaces+=drawVertexCount-2;
				Stat.drawCall++;
				if (this._firstFreeElement > 0){
					drawVertexCount=this._firstFreeElement *2;
					glContext.drawArrays(/*laya.webgl.WebGLContext.TRIANGLE_STRIP*/0x0005,0,drawVertexCount);
					Stat.trianglesFaces+=drawVertexCount-2;
					Stat.drawCall++;
				}
			}
		}

		/**
		*通过位置添加刀光。
		*@param position0 位置0。
		*@param position1 位置1。
		*/
		__proto.addVertexPosition=function(position0,position1){
			if (this._owner.activeInHierarchy){
				if (this._numPositionMode < 2){
					if (this._numPositionMode===0){
						position0.cloneTo(this._posModeLastPosition0);
						position1.cloneTo(this._posModeLastPosition1);
						}else {
						position0.cloneTo(this._posModePosition0);
						position1.cloneTo(this._posModePosition1);
					}
					this._numPositionMode++;
					}else {
					var v0=this._tempVector2;
					this._calcVelocity(position0,this._posModeLastPosition0,v0);
					var v1=this._tempVector3;
					this._calcVelocity(position1,this._posModeLastPosition1,v1);
					this.addVertexPositionVelocity(this._posModePosition0,v0,this._posModePosition1,v1);
					this._posModePosition0.cloneTo(this._posModeLastPosition0);
					this._posModePosition1.cloneTo(this._posModeLastPosition1);
					position0.cloneTo(this._posModePosition0);
					position1.cloneTo(this._posModePosition1);
				}
			}
		}

		/**
		*通过位置和速度添加刀光。
		*@param position0 位置0。
		*@param velocity0 速度0。
		*@param position1 位置1。
		*@param velocity1 速度1。
		*/
		__proto.addVertexPositionVelocity=function(position0,velocity0,position1,velocity1){
			if (this._owner.activeInHierarchy){
				if (this._numPositionVelocityMode===0){
					this._numPositionVelocityMode++;
					}else {
					var d=this._tempVector0;
					Vector3.subtract(position0,this._posVelModePosition0,d);
					var distance0=Vector3.scalarLength(d);
					Vector3.subtract(position1,this._posVelModePosition1,d);
					var distance1=Vector3.scalarLength(d);
					var slerpCount=0;
					var minSegmentDistance=minSegmentDistance;
					if (distance0 < minSegmentDistance && distance1 < minSegmentDistance)
						return;
					slerpCount=1+Math.floor(Math.max(distance0,distance1)/ this.minInterpDistance);
					if (slerpCount===1){
						this._addGlitter(position0,position1,this._currentTime);
						}else {
						slerpCount=Math.min(slerpCount,this.maxSlerpCount);
						this.scLeft.Init(this._posVelModePosition0,this._posVelModeVelocity0,position0,velocity0);
						this.scRight.Init(this._posVelModePosition1,this._posVelModeVelocity1,position1,velocity1);
						var segment=1.0 / slerpCount;
						var addSegment=segment;
						var timeOffset=this._currentTime-this._lastTime;
						for (var i=1;i <=slerpCount;i++){
							var pos0=this._tempVector0;
							this.scLeft.Slerp(addSegment,pos0);
							var pos1=this._tempVector1;
							this.scRight.Slerp(addSegment,pos1);
							var time=this._lastTime+timeOffset *i / slerpCount;
							this._addGlitter(pos0,pos1,time);
							addSegment+=segment;
						}
					}
				}
				this._lastTime=this._currentTime;
				position0.cloneTo(this._posVelModePosition0);
				velocity0.cloneTo(this._posVelModeVelocity0);
				position1.cloneTo(this._posVelModePosition1);
				velocity1.cloneTo(this._posVelModeVelocity1);
			}
		}

		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
			this._tempVector0=null;
			this._tempVector1=null;
			this._tempVector2=null;
			this._tempVector3=null;
			this._owner=null;
			this._albedo=null;
			this._vertices=null;
			this._vertexBuffer.dispose();
			this._vertexBuffer=null;
			this.scLeft=null;
			this.scRight=null;
			this._posModeLastPosition0=null;
			this._posModeLastPosition1=null;
			this._posModePosition0=null;
			this._posModePosition1=null;
			this._posVelModePosition0=null;
			this._posVelModeVelocity0=null;
			this._posVelModePosition1=null;
			this._posVelModeVelocity1=null;
			this._lastPatchAddPos0=null;
			this._lastPatchAddPos1=null;
			this.color=null;
		}

		__proto._renderRuntime=function(conchGraphics3D,renderElement,state){}
		/**设置最大分段数,注意:谨慎修改此属性，有性能损耗。*/
		/**获取最大分段数。*/
		__getset(0,__proto,'maxSegments',function(){
			return this._maxSegments-1;
			},function(value){
			var newMaxSegments=value+1;
			if (newMaxSegments!==this._maxSegments){
				this._maxSegments=newMaxSegments;
				if (this._vertexBuffer){
					this._vertexBuffer.dispose();
				}
				this._initialize();
			}
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingSphere',function(){
			return _super.prototype._$get__originalBoundingSphere.call(this);
		});

		__getset(0,__proto,'indexOfHost',function(){
			return 0;
		});

		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		__getset(0,__proto,'triangleCount',function(){
			var drawVertexCount=0;
			if (this._firstActiveElement < this._firstFreeElement){
				drawVertexCount=(this._firstFreeElement-this._firstActiveElement)*2-2;
				}else {
				drawVertexCount=(this.maxSegments-this._firstActiveElement)*2-2;
				drawVertexCount+=this._firstFreeElement *2-2;
			}
			return drawVertexCount;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingBox',function(){
			return _super.prototype._$get__originalBoundingBox.call(this);
		});

		return GlitterTemplet;
	})(GeometryFilter)


	/**
	*<code>TerrainFilter</code> 类用于创建TerrainFilter过滤器。
	*/
	//class laya.d3.terrain.TerrainFilter extends laya.d3.core.GeometryFilter
	var TerrainFilter=(function(_super){
		function TerrainFilter(owner,chunkOffsetX,chunkOffsetZ,gridSize,terrainHeightData,heightDataWidth,heightDataHeight){
			this._owner=null;
			this._indexOfHost=0;
			this._gridSize=NaN;
			this.memorySize=0;
			this._numberVertices=0;
			this._maxNumberIndices=0;
			this._currentNumberIndices=0;
			this._numberTriangle=0;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._boundingSphere=null;
			this._boundingBox=null;
			this._indexArrayBuffer=null;
			this._boundingBoxCorners=null;
			this._leafs=null;
			this._leafNum=0;
			this._terrainHeightData=null;
			this._terrainHeightDataWidth=0;
			this._terrainHeightDataHeight=0;
			this._chunkOffsetX=0;
			this._chunkOffsetZ=0;
			this._cameraPos=null;
			this._currentLOD=0;
			this._perspectiveFactor=NaN;
			this._LODTolerance=0;
			TerrainFilter.__super.call(this);
			this._owner=owner;
			this._cameraPos=new Vector3();
			this._chunkOffsetX=chunkOffsetX;
			this._chunkOffsetZ=chunkOffsetZ;
			this._gridSize=gridSize;
			this._terrainHeightData=terrainHeightData;
			this._terrainHeightDataWidth=heightDataWidth;
			this._terrainHeightDataHeight=heightDataHeight;
			this._leafNum=(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM)*(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
			this._leafs=__newvec(this._leafNum);
			for (var i=0;i < this._leafNum;i++){
				this._leafs[i]=new TerrainLeaf();
			}
			this.recreateResource();
		}

		__class(TerrainFilter,'laya.d3.terrain.TerrainFilter',_super);
		var __proto=TerrainFilter.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
		/**
		*@inheritDoc
		*/
		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
			this._owner=null;
			if(this._vertexBuffer)this._vertexBuffer.dispose();
			if(this._indexBuffer)this._indexBuffer.dispose();
		}

		__proto.recreateResource=function(){
			this._currentNumberIndices=0;
			this._numberTriangle=0;
			var nLeafVertexCount=TerrainLeaf.LEAF_VERTEXT_COUNT;
			var nLeafIndexCount=TerrainLeaf.LEAF_MAX_INDEX_COUNT;
			this._numberVertices=nLeafVertexCount *this._leafNum;
			this._maxNumberIndices=nLeafIndexCount *this._leafNum;
			this._indexArrayBuffer=new Uint16Array(this._maxNumberIndices);
			var vertexDeclaration=VertexPositionTerrain.vertexDeclaration;
			var vertexFloatStride=vertexDeclaration.vertexStride / 4;
			var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
			var nNum=TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM;
			var i=0,x=0,z=0;
			for (i=0;i < this._leafNum;i++){
				x=i % nNum;
				z=Math.floor(i / nNum);
				this._leafs[i].calcVertextBuffer(this._chunkOffsetX,this._chunkOffsetZ,x *TerrainLeaf.LEAF_GRID_NUM,z *TerrainLeaf.LEAF_GRID_NUM,this._gridSize,vertices,
				i *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT,vertexFloatStride,this._terrainHeightData,this._terrainHeightDataWidth,this._terrainHeightDataHeight);
			}
			for (i=0;i < this._leafNum;i++){
				x=i % nNum;
				z=Math.floor(i / nNum);
				this._leafs[i].calcSkirtVertextBuffer(this._chunkOffsetX,this._chunkOffsetZ,x *TerrainLeaf.LEAF_GRID_NUM,z *TerrainLeaf.LEAF_GRID_NUM,this._gridSize,vertices,
				this._leafNum *TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT+i *TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT,vertexFloatStride,this._terrainHeightData,this._terrainHeightDataWidth,this._terrainHeightDataHeight);
			}
			this.assembleIndexInit();
			this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._maxNumberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,false);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(this._indexArrayBuffer);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.calcOriginalBoudingBoxAndSphere();
		}

		__proto.setLODLevel=function(leafsLODLevel){
			if (leafsLODLevel.length !=4)return true;
			var nLOD=((leafsLODLevel[0]+1)<< 24)+((leafsLODLevel[1]+1)<< 16)+((leafsLODLevel[2]+1)<< 8)+(leafsLODLevel[3]+1);
			if (this._currentLOD==nLOD){
				return false;
			}
			this._currentLOD=nLOD;
			return true;
		}

		__proto.assembleIndexInit=function(){
			this._currentNumberIndices=0;
			this._numberTriangle=0;
			var nOffsetIndex=0;
			for (var i=0;i < this._leafNum;i++){
				var planeLODIndex=TerrainLeaf.getPlaneLODIndex(i,0);
				this._indexArrayBuffer.set(planeLODIndex,nOffsetIndex);
				nOffsetIndex+=planeLODIndex.length;
				var skirtLODIndex=TerrainLeaf.getSkirtLODIndex(i,0);
				this._indexArrayBuffer.set(skirtLODIndex,nOffsetIndex);
				nOffsetIndex+=skirtLODIndex.length;
				this._currentNumberIndices+=(planeLODIndex.length+skirtLODIndex.length);
			}
			this._numberTriangle=this._currentNumberIndices / 3;
		}

		__proto.isNeedAssemble=function(camera,cameraPostion){
			var perspectiveFactor=Math.min(camera.viewport.width,camera.viewport.height)/ (2 *Math.tan(Math.PI *camera.fieldOfView / 180.0));
			if (this._perspectiveFactor !=perspectiveFactor){
				this._perspectiveFactor=perspectiveFactor;
				return 1;
			}
			if (this._LODTolerance !=Terrain.LOD_TOLERANCE_VALUE){
				this._LODTolerance=Terrain.LOD_TOLERANCE_VALUE;
				return 1;
			}
			if (Vector3.equals(cameraPostion,this._cameraPos)==false){
				this._cameraPos.x=cameraPostion.x;this._cameraPos.y=cameraPostion.y;this._cameraPos.z=cameraPostion.z;
				return 2;
			}
			return 0;
		}

		__proto.assembleIndex=function(camera,cameraPostion){
			var nNeedType=this.isNeedAssemble(camera,cameraPostion);
			if (nNeedType > 0){
				for (var i=0;i < this._leafNum;i++){
					TerrainFilter._TEMP_ARRAY_BUFFER[i]=this._leafs[i].determineLod(cameraPostion,this._perspectiveFactor,Terrain.LOD_TOLERANCE_VALUE,nNeedType==1);
				}
				if (this.setLODLevel(TerrainFilter._TEMP_ARRAY_BUFFER)){
					this._currentNumberIndices=0;
					this._numberTriangle=0;
					var nOffsetIndex=0;
					for (i=0;i < this._leafNum;i++){
						var nLODLevel=TerrainFilter._TEMP_ARRAY_BUFFER[i];
						var planeLODIndex=TerrainLeaf.getPlaneLODIndex(i,nLODLevel);
						this._indexArrayBuffer.set(planeLODIndex,nOffsetIndex);
						nOffsetIndex+=planeLODIndex.length;
						var skirtLODIndex=TerrainLeaf.getSkirtLODIndex(i,nLODLevel);
						this._indexArrayBuffer.set(skirtLODIndex,nOffsetIndex);
						nOffsetIndex+=skirtLODIndex.length;
						this._currentNumberIndices+=(planeLODIndex.length+skirtLODIndex.length);
					}
					this._numberTriangle=this._currentNumberIndices / 3;
					return true;
				}
			}
			return false;
		}

		__proto.calcOriginalBoudingBoxAndSphere=function(){
			var sizeOfY=new Vector2(2147483647,-2147483647);
			for (var i=0;i < this._leafNum;i++){
				sizeOfY.x=this._leafs[i]._sizeOfY.x < sizeOfY.x ? this._leafs[i]._sizeOfY.x :sizeOfY.x;
				sizeOfY.y=this._leafs[i]._sizeOfY.y > sizeOfY.y ? this._leafs[i]._sizeOfY.y :sizeOfY.y;
			};
			var min=new Vector3(this._chunkOffsetX *TerrainLeaf.CHUNK_GRID_NUM *this._gridSize,sizeOfY.x,this._chunkOffsetZ *TerrainLeaf.CHUNK_GRID_NUM *this._gridSize);
			var max=new Vector3((this._chunkOffsetX+1)*TerrainLeaf.CHUNK_GRID_NUM *this._gridSize,sizeOfY.y,(this._chunkOffsetZ+1)*TerrainLeaf.CHUNK_GRID_NUM *this._gridSize);
			this._boundingBox=new BoundBox(min,max);
			var size=new Vector3();
			Vector3.subtract(max,min,size);
			Vector3.scale(size,0.5,size);
			var center=new Vector3();
			Vector3.add(min,size,center);
			this._boundingSphere=new BoundSphere(center,Vector3.scalarLength(size));
			this._boundingBoxCorners=__newvec(8,null);
			this._boundingBox.getCorners(this._boundingBoxCorners);
		}

		__proto.calcLeafBoudingBox=function(worldMatrix){
			for (var i=0;i < this._leafNum;i++){
				this._leafs[i].calcLeafBoudingBox(worldMatrix);
			}
		}

		__proto.calcLeafBoudingSphere=function(worldMatrix,maxScale){
			for (var i=0;i < this._leafNum;i++){
				this._leafs[i].calcLeafBoudingSphere(worldMatrix,maxScale);
			}
		}

		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index==0){
				return this._vertexBuffer;
			}
			return null;
		}

		__proto._getIndexBuffer=function(){
			return this._indexBuffer;
		}

		__proto._beforeRender=function(state){
			this._vertexBuffer._bind();
			this._indexBuffer._bind();
			var terrainMaterial=state.renderElement._material;
			if (terrainMaterial.renderMode==/*laya.d3.core.material.TerrainMaterial.RENDERMODE_OPAQUE*/1){
				var camera=state.camera;
				if (this.assembleIndex(camera,camera.position)){
					this._indexBuffer.setData(this._indexArrayBuffer);
				}
			}
			return true;
		}

		__proto._render=function(state){
			WebGL.mainContext.drawElements(Terrain.RENDER_LINE_MODEL ? /*laya.webgl.WebGLContext.LINES*/0x0001 :/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._currentNumberIndices,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
			Stat.trianglesFaces+=this._numberTriangle;
			Stat.drawCall++;
		}

		__proto._renderRuntime=function(conchGraphics3D,renderElement,state){}
		__getset(0,__proto,'indexOfHost',function(){
			return this._indexOfHost;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingSphere',function(){
			return this._boundingSphere;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'_originalBoundingBox',function(){
			return this._boundingBox;
		});

		__getset(0,__proto,'_vertexBufferCount',function(){
			return this._numberVertices;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._numberTriangle;
		});

		__static(TerrainFilter,
		['_TEMP_ARRAY_BUFFER',function(){return this._TEMP_ARRAY_BUFFER=new Uint32Array(TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM *TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);}
		]);
		return TerrainFilter;
	})(GeometryFilter)


	/**
	*<code>MeshRender</code> 类用于网格渲染器。
	*/
	//class laya.d3.terrain.TerrainRender extends laya.d3.core.render.BaseRender
	var TerrainRender=(function(_super){
		function TerrainRender(owner){
			this._terrainSprite3DOwner=null;
			TerrainRender.__super.call(this,owner);
			this._terrainSprite3DOwner=owner;
		}

		__class(TerrainRender,'laya.d3.terrain.TerrainRender',_super);
		var __proto=TerrainRender.prototype;
		__proto._calculateBoundingSphere=function(){
			var terrainFilter=this._terrainSprite3DOwner.terrainFilter;
			if (terrainFilter==null){
				this._boundingSphere.toDefault();
				}else {
				var meshBoundingSphere=terrainFilter._originalBoundingSphere;
				var maxScale=NaN;
				var transform=this._terrainSprite3DOwner.transform;
				var scale=transform.scale;
				if (scale.x >=scale.y && scale.x >=scale.z)
					maxScale=scale.x;
				else
				maxScale=scale.y >=scale.z ? scale.y :scale.z;
				Vector3.transformCoordinate(meshBoundingSphere.center,transform.worldMatrix,this._boundingSphere.center);
				this._boundingSphere.radius=meshBoundingSphere.radius *maxScale;
				terrainFilter.calcLeafBoudingSphere(transform.worldMatrix,maxScale);
			}
		}

		__proto._calculateBoundingBox=function(){
			var terrainFilter=this._terrainSprite3DOwner.terrainFilter;
			if (terrainFilter==null){
				this._boundingBox.toDefault();
				}else {
				var worldMat=this._terrainSprite3DOwner.transform.worldMatrix;
				var corners=terrainFilter._boundingBoxCorners;
				for (var i=0;i < 8;i++)
				Vector3.transformCoordinate(corners[i],worldMat,BaseRender._tempBoudingBoxCorners[i]);
				BoundBox.createfromPoints(BaseRender._tempBoudingBoxCorners,this._boundingBox);
				terrainFilter.calcLeafBoudingBox(worldMat);
			}
		}

		/**
		*@private
		*/
		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
			this._terrainSprite3DOwner=null;
		}

		return TerrainRender;
	})(BaseRender)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.water.WaterRender extends laya.d3.core.render.BaseRender
	var WaterRender=(function(_super){
		function WaterRender(owner){
			WaterRender.__super.call(this,owner);
		}

		__class(WaterRender,'laya.d3.water.WaterRender',_super);
		var __proto=WaterRender.prototype;
		__proto._calculateBoundingSphere=function(){}
		__proto._calculateBoundingBox=function(){}
		__proto._destroy=function(){
			_super.prototype._destroy.call(this);
		}

		return WaterRender;
	})(BaseRender)


	/**
	*<code>BaseScene</code> 类用于实现场景的父类。
	*/
	//class laya.d3.core.scene.BaseScene extends laya.display.Sprite
	var BaseScene=(function(_super){
		function BaseScene(){
			this._invertYProjectionMatrix=null;
			this._invertYProjectionViewMatrix=null;
			this._invertYScaleMatrix=null;
			this._enableLightCount=3;
			this._renderTargetTexture=null;
			this._customRenderQueneIndex=11;
			this._lastCurrentTime=NaN;
			this._enableFog=false;
			this._enableDepthFog=false;
			this._fogStart=NaN;
			this._fogRange=NaN;
			this._fogColor=null;
			this._shaderValues=null;
			this._shaderDefineValue=0;
			this._staticBatchManager=null;
			this._dynamicBatchManager=null;
			this.enableLight=true;
			this.treeRoot=null;
			this.treeSize=null;
			this.treeLevel=0;
			this.parallelSplitShadowMaps=null;
			this.bFirst=false;
			this.debugSpriter=null;
			this.boxCorners=null;
			this.debugSpriter1=null;
			this.boxCorners1=null;
			BaseScene.__super.call(this);
			this._renderState=new RenderState();
			this._lights=new Array;
			this._frustumCullingObjects=[];
			this._quenes=[];
			this._cameraPool=[];
			this._shaderValues=new ValusArray();
			this._invertYProjectionMatrix=new Matrix4x4();
			this._invertYProjectionViewMatrix=new Matrix4x4();
			this._invertYScaleMatrix=new Matrix4x4();
			this.parallelSplitShadowMaps=[];
			Matrix4x4.createScaling(new Vector3(1,-1,1),this._invertYScaleMatrix);
			this._staticBatchManager=new StaticBatchManager();
			this._dynamicBatchManager=new DynamicBatchManager();
			this.enableFog=false;
			this.fogStart=300;
			this.fogRange=1000;
			this.fogColor=new Vector3(0.7,0.7,0.7);
			(WebGL.frameShaderHighPrecision)&& (this.addShaderDefine(ShaderCompile3D.SHADERDEFINE_FSHIGHPRECISION));
			this.on(/*laya.events.Event.DISPLAY*/"display",this,this._$3__onDisplay);
			this.on(/*laya.events.Event.UNDISPLAY*/"undisplay",this,this._onUnDisplay);
		}

		__class(BaseScene,'laya.d3.core.scene.BaseScene',_super);
		var __proto=BaseScene.prototype;
		Laya.imps(__proto,{"laya.webgl.submit.ISubmit":true})
		/**
		*初始化八叉树。
		*@param width 八叉树宽度。
		*@param height 八叉树高度。
		*@param depth 八叉树深度。
		*@param center 八叉树中心点
		*@param level 八叉树层级。
		*/
		__proto.initOctree=function(width,height,depth,center,level){
			(level===void 0)&& (level=6);
			this.treeSize=new Vector3(width,height,depth);
			this.treeLevel=level;
			this.treeRoot=new OctreeNode(this,0);
			this.treeRoot.init(center,this.treeSize);
		}

		/**
		*@private
		*/
		__proto._$3__onDisplay=function(){
			Laya.stage._scenes.push(this);
			Laya.stage._scenes.sort(BaseScene._sortScenes);
		}

		/**
		*@private
		*/
		__proto._onUnDisplay=function(){
			var scenes=Laya.stage._scenes;
			scenes.splice(scenes.indexOf(this),1);
		}

		/**
		*@private
		*场景相关渲染准备设置。
		*@param gl WebGL上下文。
		*@return state 渲染状态。
		*/
		__proto._prepareUpdateToRenderState=function(gl,state){
			state.elapsedTime=this._lastCurrentTime ? this.timer.currTimer-this._lastCurrentTime :0;
			this._lastCurrentTime=this.timer.currTimer;
			state.scene=this;
		}

		/**
		*@private
		*/
		__proto._prepareSceneToRender=function(state){
			var lightCount=this._lights.length;
			if (lightCount > 0){
				var renderLightCount=0;
				for (var i=0;i < lightCount;i++){
					if (!this._lights[i].updateToWorldState(state))
						continue ;
					renderLightCount++;
					if (renderLightCount >=this._enableLightCount)
						break ;
				}
			}
		}

		/**
		*@private
		*/
		__proto._updateChilds=function(state){
			for (var i=0,n=this._childs.length;i < n;++i)
			this._childs[i]._update(state);
		}

		/**
		*@private
		*/
		__proto._updateChildsConch=function(state){
			for (var i=0,n=this._childs.length;i < n;++i)
			this._childs[i]._updateConch(state);
		}

		/**
		*@private
		*/
		__proto._preRenderScene=function(gl,state){
			var view=state._viewMatrix;
			var projection=state._projectionMatrix;
			var projectionView=state._projectionViewMatrix;
			var i=0,iNum=0;
			var camera=state.camera;
			if (camera.useOcclusionCulling){
				if (this.treeRoot)
					FrustumCulling.renderObjectCullingOctree(state._boundFrustum,this,camera,view,projection,projectionView);
				else
				FrustumCulling.renderObjectCulling(state._boundFrustum,this,camera,view,projection,projectionView);
				}else {
				FrustumCulling.renderObjectCullingNoBoundFrustum(this,camera,view,projection,projectionView);
			}
			for (i=0,iNum=this._quenes.length;i < iNum;i++)
			(this._quenes[i])&& (this._quenes[i]._preRender(state));
		}

		/**
		*@private
		*/
		__proto._clear=function(gl,state){
			var viewport=state._viewport;
			var camera=state.camera;
			var vpX=viewport.x;
			var vpY=camera.renderTargetSize.height-viewport.y-viewport.height;
			var vpWidth=viewport.width;
			var vpHeight=viewport.height;
			gl.viewport(vpX,vpY,vpWidth,vpHeight);
			var flag=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
			var renderTarget=camera.renderTarget;
			switch (camera.clearFlag){
				case /*laya.d3.core.BaseCamera.CLEARFLAG_SOLIDCOLOR*/0:;
					var clearColor=camera.clearColor;
					if (clearColor){
						gl.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
						gl.scissor(vpX,vpY,vpWidth,vpHeight);
						var clearColorE=clearColor.elements;
						gl.clearColor(clearColorE[0],clearColorE[1],clearColorE[2],clearColorE[3]);
						flag |=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000;
					}
					if (renderTarget){
						(clearColor)|| (flag=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000);
					switch (renderTarget.depthStencilFormat){
						case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
							flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
							break ;
						case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
							flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
							break ;
						case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
							flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
							flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
							break ;
						}
				}
				gl.clear(flag);
				if (clearColor)
					gl.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
				break ;
				case /*laya.d3.core.BaseCamera.CLEARFLAG_SKY*/1:
				case /*laya.d3.core.BaseCamera.CLEARFLAG_DEPTHONLY*/2:
				if (renderTarget){
					flag=/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000;
					switch (renderTarget.depthStencilFormat){
						case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
							flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
							break ;
						case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
							flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
							break ;
						case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
							flag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
							flag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400
							break ;
						}
				}
				gl.clear(flag);
				break ;
				case /*laya.d3.core.BaseCamera.CLEARFLAG_NONE*/3:
				break ;
				default :
				throw new Error("BaseScene:camera clearFlag invalid.");
			}
		}

		/**
		*@private
		*/
		__proto._renderScene=function(gl,state){
			var camera=state.camera;
			var i=0,n=0;
			var queue;
			for (i=0;i < 2;i++){
				queue=this._quenes[i];
				if (queue){
					camera.renderTarget ? queue._render(state,true):queue._render(state,false);
				}
			}
			if (camera.clearFlag===/*laya.d3.core.BaseCamera.CLEARFLAG_SKY*/1){
				var sky=camera.sky;
				if (sky){
					WebGLContext.setCullFace(gl,false);
					WebGLContext.setDepthFunc(gl,/*laya.webgl.WebGLContext.LEQUAL*/0x0203);
					WebGLContext.setDepthMask(gl,false);
					sky._render(state);
					WebGLContext.setDepthFunc(gl,/*laya.webgl.WebGLContext.LESS*/0x0201);
					WebGLContext.setDepthMask(gl,true);
				}
			}
			for (i=2,n=this._quenes.length;i < n;i++){
				queue=this._quenes[i];
				if (queue){
					queue._sortAlpha(state.camera.transform.position);
					camera.renderTarget ? queue._render(state,true):queue._render(state,false);
				}
			}
		}

		/**
		*@private
		*/
		__proto._set3DRenderConfig=function(gl){
			gl.disable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
			WebGLContext._blend=false;
			gl.blendFunc(/*laya.webgl.WebGLContext.SRC_ALPHA*/0x0302,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
			WebGLContext._sFactor=/*laya.webgl.WebGLContext.SRC_ALPHA*/0x0302;
			WebGLContext._dFactor=/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303;
			gl.disable(/*laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71);
			WebGLContext._depthTest=false;
			gl.enable(/*laya.webgl.WebGLContext.CULL_FACE*/0x0B44);
			WebGLContext._cullFace=true;
			gl.depthMask(1);
			WebGLContext._depthMask=true;
			gl.frontFace(/*laya.webgl.WebGLContext.CW*/0x0900);
			WebGLContext._frontFace=/*laya.webgl.WebGLContext.CW*/0x0900;
		}

		/**
		*@private
		*/
		__proto._set2DRenderConfig=function(gl){
			WebGLContext.setBlend(gl,true);
			WebGLContext.setBlendFunc(gl,/*laya.webgl.WebGLContext.SRC_ALPHA*/0x0302,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
			WebGLContext.setDepthTest(gl,false);
			WebGLContext.setCullFace(gl,false);
			WebGLContext.setDepthMask(gl,true);
			WebGLContext.setFrontFace(gl,/*laya.webgl.WebGLContext.CCW*/0x0901);
			gl.viewport(0,0,RenderState2D.width,RenderState2D.height);
		}

		/**
		*@private
		*/
		__proto._addLight=function(light){
			if (this._lights.indexOf(light)< 0)this._lights.push(light);
		}

		/**
		*@private
		*/
		__proto._removeLight=function(light){
			var index=this._lights.indexOf(light);
			index >=0 && (this._lights.splice(index,1));
		}

		/**
		*@private
		*/
		__proto._updateScene=function(){
			var renderState=this._renderState;
			this._prepareUpdateToRenderState(WebGL.mainContext,renderState);
			this.beforeUpdate(renderState);
			this._updateChilds(renderState);
			this.lateUpdate(renderState);
		}

		/**
		*@private
		*/
		__proto._updateSceneConch=function(){
			var renderState=this._renderState;
			this._prepareUpdateToRenderState(WebGL.mainContext,renderState);
			this.beforeUpdate(renderState);
			this._updateChildsConch(renderState);
			this.lateUpdate(renderState);
			this._prepareSceneToRender(renderState);
			for (var i=0,n=this._cameraPool.length;i < n;i++){
				var camera=this._cameraPool[i];
				renderState.camera=camera;
				camera._prepareCameraToRender();
			}
		}

		/**
		*@private
		*/
		__proto._preRenderShadow=function(state,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum){
			if (this.treeRoot){
				FrustumCulling.renderShadowObjectCullingOctree(this,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum);
				}else {
				FrustumCulling.renderShadowObjectCulling(this,lightFrustum,shdowQueues,lightViewProjectMatrix,nPSSMNum);
			}
			for (var i=0,iNum=shdowQueues.length;i < iNum;i++)
			(shdowQueues[i])&& (shdowQueues[i]._preRender(state));
		}

		/**
		*@private
		*/
		__proto._renderShadowMap=function(gl,state,sceneCamera){
			var parallelSplitShadowMap=this.parallelSplitShadowMaps[0];
			parallelSplitShadowMap._calcAllLightCameraInfo(sceneCamera);
			var pssmNum=parallelSplitShadowMap.PSSMNum;
			this._preRenderShadow(state,parallelSplitShadowMap._lightCulling,parallelSplitShadowMap._shadowQuenes,parallelSplitShadowMap._lightVPMatrix[0],pssmNum);
			this.addShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW);
			var renderTarget,shadowQuene,lightCamera;
			if (pssmNum > 1){
				for (var i=0;i < pssmNum;i++){
					renderTarget=parallelSplitShadowMap.getRenderTarget(i+1);
					parallelSplitShadowMap.beginRenderTarget(i+1);
					gl.clearColor(1,1,1,1);
					gl.clear(/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000 | /*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100);
					gl.viewport(0,0,renderTarget.width,renderTarget.height);
					state.camera=lightCamera=parallelSplitShadowMap.getLightCamera(i);
					lightCamera._prepareCameraToRender();
					lightCamera._prepareCameraViewProject(lightCamera.viewMatrix,lightCamera.projectionMatrix);
					state._projectionViewMatrix=parallelSplitShadowMap._lightVPMatrix[i+1];
					shadowQuene=parallelSplitShadowMap._shadowQuenes[i];
					shadowQuene._preRender(state);
					shadowQuene._renderShadow(state,false);
					parallelSplitShadowMap.endRenderTarget(i+1);
				}
				}else {
				renderTarget=parallelSplitShadowMap.getRenderTarget(1);
				parallelSplitShadowMap.beginRenderTarget(1);
				gl.clearColor(1,1,1,1);
				gl.clear(/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000 | /*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100);
				gl.viewport(0,0,renderTarget.width,renderTarget.height);
				state.camera=lightCamera=parallelSplitShadowMap.getLightCamera(0);
				lightCamera._prepareCameraToRender();
				lightCamera._prepareCameraViewProject(lightCamera.viewMatrix,lightCamera.projectionMatrix);
				state._projectionViewMatrix=parallelSplitShadowMap._lightVPMatrix[0];
				shadowQuene=parallelSplitShadowMap._shadowQuenes[0];
				shadowQuene._preRender(state);
				shadowQuene._renderShadow(state,true);
				parallelSplitShadowMap.endRenderTarget(1);
			}
			this.removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_CAST_SHADOW);
		}

		/**
		*@private
		*/
		__proto.addTreeNode=function(renderObj){
			this.treeRoot.addTreeNode(renderObj);
		}

		/**
		*@private
		*/
		__proto.removeTreeNode=function(renderObj){
			if (!this.treeSize)return;
			if (renderObj._treeNode){
				renderObj._treeNode.removeObject(renderObj);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.addChildAt=function(node,index){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			var returnNode=laya.display.Node.prototype.addChildAt.call(this,node,index);
			var sprite3D=node;
			sprite3D.transform._onWorldTransform();
			sprite3D._setBelongScene();
			(sprite3D.active)&& (sprite3D._activeHierarchy());
			return returnNode;
		}

		/**
		*@inheritDoc
		*/
		__proto.addChild=function(node){
			if (!((node instanceof laya.d3.core.Sprite3D )))
				throw new Error("Sprite3D:Node type must Sprite3D.");
			var returnNode=laya.display.Node.prototype.addChild.call(this,node);
			var sprite3D=node;
			sprite3D.transform._onWorldTransform();
			sprite3D._setBelongScene();
			(sprite3D.active)&& (sprite3D._activeHierarchy());
			return returnNode;
		}

		/**
		*@inheritDoc
		*/
		__proto.removeChildAt=function(index){
			var node=this.getChildAt(index);
			if (node){
				var sprite3D=node;
				sprite3D.transform.parent=null;
				sprite3D._setUnBelongScene();
				(sprite3D.active)&& (sprite3D._inActiveHierarchy());
				this._childs.splice(index,1);
				this.conchModel && this.conchModel.removeChild(node.conchModel);
				node.parent=null;
			}
			return node;
		}

		/**
		*@inheritDoc
		*/
		__proto.removeChildren=function(beginIndex,endIndex){
			(beginIndex===void 0)&& (beginIndex=0);
			(endIndex===void 0)&& (endIndex=0x7fffffff);
			if (this._childs && this._childs.length > 0){
				var childs=this._childs;
				if (beginIndex===0 && endIndex >=n){
					var arr=childs;
					this._childs=Node.ARRAY_EMPTY;
					}else {
					arr=childs.splice(beginIndex,endIndex-beginIndex);
				}
				for (var i=0,n=arr.length;i < n;i++){
					arr[i].parent=null;
					var sprite3D=arr [i];
					sprite3D.transform.parent=null;
					sprite3D._setUnBelongScene();
					(sprite3D.active)&& (sprite3D._inActiveHierarchy());
					this.conchModel && this.conchModel.removeChild(arr[i].conchModel);
				}
			}
			return this;
		}

		/**
		*@inheritDoc
		*/
		__proto.addFrustumCullingObject=function(renderObject){
			if (this.treeRoot)
				this.addTreeNode(renderObject);
			else
			this._frustumCullingObjects.push(renderObject);
		}

		/**
		*@private
		*/
		__proto.removeFrustumCullingObject=function(renderObject){
			if (this.treeRoot){
				this.removeTreeNode(renderObject);
				}else {
				var index=this._frustumCullingObjects.indexOf(renderObject);
				(index!==-1)&& (this._frustumCullingObjects.splice(index,1));
			}
		}

		/**
		*获得某个渲染队列。
		*@param index 渲染队列索引。
		*@return 渲染队列。
		*/
		__proto.getRenderQueue=function(index){
			return (this._quenes[index] || (this._quenes[index]=new RenderQueue(this)));
		}

		/**
		*添加渲染队列。
		*@param renderConfig 渲染队列配置文件。
		*/
		__proto.addRenderQuene=function(){
			this._quenes[this._customRenderQueneIndex++]=new RenderQueue(this);
		}

		/**
		*更新前处理,可重写此函数。
		*@param state 渲染相关状态。
		*/
		__proto.beforeUpdate=function(state){}
		/**
		*更新后处理,可重写此函数。
		*@param state 渲染相关状态。
		*/
		__proto.lateUpdate=function(state){}
		/**
		*渲染前处理,可重写此函数。
		*@param state 渲染相关状态。
		*/
		__proto.beforeRender=function(state){}
		/**
		*渲染后处理,可重写此函数。
		*@param state 渲染相关状态。
		*/
		__proto.lateRender=function(state){}
		/**
		*增加shader宏定义。
		*@param define shader宏定义。
		*/
		__proto.addShaderDefine=function(define){
			this._shaderDefineValue |=define;
		}

		/**
		*移除shader宏定义。
		*@param define shader宏定义。
		*/
		__proto.removeShaderDefine=function(define){
			this._shaderDefineValue &=~define;
		}

		/**
		*@inheritDoc
		*/
		__proto.render=function(context,x,y){
			(Render._context.ctx)._shader2D.glTexture=null;
			this._childs.length > 0 && context.addRenderObject(this);
			this._renderType &=~ /*laya.renders.RenderSprite.CHILDS*/0x800;
			_super.prototype.render.call(this,context,x,y);
		}

		/**
		*@private
		*/
		__proto._renderCamera=function(gl,state,baseCamera){}
		/**
		*@private
		*/
		__proto.renderSubmit=function(){
			var gl=WebGL.mainContext;
			var renderState=this._renderState;
			this._set3DRenderConfig(gl);
			this._prepareSceneToRender(this._renderState);
			var i=0,n=0,camera;
			if (Laya3D.debugMode || OctreeNode.debugMode){
				for (i=0,n=this._cameraPool.length;i < n;i++){
					Laya3D._debugPhasorSprite.begin(/*laya.webgl.WebGLContext.LINES*/0x0001,renderState);
					camera=this._cameraPool[i];
					(camera.activeInHierarchy)&& (this._renderCamera(gl,renderState,camera));
					Laya3D._debugPhasorSprite.end();
				}
				}else {
				for (i=0,n=this._cameraPool.length;i < n;i++){
					camera=this._cameraPool[i];
					(camera.activeInHierarchy)&& (this._renderCamera(gl,renderState,camera));
				}
			}
			this._set2DRenderConfig(gl);
			return 1;
		}

		__proto._renderDebug=function(gl,state){
			var camera=state.camera;
			if (!this.bFirst){
				if (!this.debugSpriter)this.debugSpriter=new PhasorSpriter3D();
				if (!this.debugSpriter1)this.debugSpriter1=new PhasorSpriter3D();
				var i=0;
				this.boxCorners=__newvec(8,null);
				for (i=0;i < 8;i++){
					this.boxCorners[i]=new Vector3();
				}
				this.parallelSplitShadowMaps[0].getSplitFrustumCulling().getCorners(this.boxCorners);
				this.boxCorners1=__newvec(8,null);
				for (i=0;i < 8;i++){
					this.boxCorners1[i]=new Vector3();
				}
				this.parallelSplitShadowMaps[0].getLightFrustumCulling(0).getCorners(this.boxCorners1);
				this.bFirst=true;
			}
			this.debugSpriter.begin(/*laya.webgl.WebGLContext.LINES*/0x0001,state);
			this.debugSpriter.line(this.boxCorners[0].x,this.boxCorners[0].y,this.boxCorners[0].z,1.0,1.0,0.0,1.0,this.boxCorners[1].x,this.boxCorners[1].y,this.boxCorners[1].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[2].x,this.boxCorners[2].y,this.boxCorners[2].z,1.0,1.0,0.0,1.0,this.boxCorners[3].x,this.boxCorners[3].y,this.boxCorners[3].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[4].x,this.boxCorners[4].y,this.boxCorners[4].z,1.0,1.0,0.0,1.0,this.boxCorners[5].x,this.boxCorners[5].y,this.boxCorners[5].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[6].x,this.boxCorners[6].y,this.boxCorners[6].z,1.0,1.0,0.0,1.0,this.boxCorners[7].x,this.boxCorners[7].y,this.boxCorners[7].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[0].x,this.boxCorners[0].y,this.boxCorners[0].z,1.0,1.0,0.0,1.0,this.boxCorners[3].x,this.boxCorners[3].y,this.boxCorners[3].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[1].x,this.boxCorners[1].y,this.boxCorners[1].z,1.0,1.0,0.0,1.0,this.boxCorners[2].x,this.boxCorners[2].y,this.boxCorners[2].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[2].x,this.boxCorners[2].y,this.boxCorners[2].z,1.0,1.0,0.0,1.0,this.boxCorners[6].x,this.boxCorners[6].y,this.boxCorners[6].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[3].x,this.boxCorners[3].y,this.boxCorners[3].z,1.0,1.0,0.0,1.0,this.boxCorners[7].x,this.boxCorners[7].y,this.boxCorners[7].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[0].x,this.boxCorners[0].y,this.boxCorners[0].z,1.0,1.0,0.0,1.0,this.boxCorners[4].x,this.boxCorners[4].y,this.boxCorners[4].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[1].x,this.boxCorners[1].y,this.boxCorners[1].z,1.0,1.0,0.0,1.0,this.boxCorners[5].x,this.boxCorners[5].y,this.boxCorners[5].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[4].x,this.boxCorners[4].y,this.boxCorners[4].z,1.0,1.0,0.0,1.0,this.boxCorners[7].x,this.boxCorners[7].y,this.boxCorners[7].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.line(this.boxCorners[5].x,this.boxCorners[5].y,this.boxCorners[5].z,1.0,1.0,0.0,1.0,this.boxCorners[6].x,this.boxCorners[6].y,this.boxCorners[6].z,1.0,1.0,0.0,1.0);
			this.debugSpriter.end();
			this.debugSpriter1.begin(/*laya.webgl.WebGLContext.LINES*/0x0001,state);
			this.debugSpriter1.line(this.boxCorners1[0].x,this.boxCorners1[0].y,this.boxCorners1[0].z,1.0,0.0,0.0,1.0,this.boxCorners1[1].x,this.boxCorners1[1].y,this.boxCorners1[1].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[2].x,this.boxCorners1[2].y,this.boxCorners1[2].z,1.0,0.0,0.0,1.0,this.boxCorners1[3].x,this.boxCorners1[3].y,this.boxCorners1[3].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[4].x,this.boxCorners1[4].y,this.boxCorners1[4].z,1.0,0.0,0.0,1.0,this.boxCorners1[5].x,this.boxCorners1[5].y,this.boxCorners1[5].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[6].x,this.boxCorners1[6].y,this.boxCorners1[6].z,1.0,0.0,0.0,1.0,this.boxCorners1[7].x,this.boxCorners1[7].y,this.boxCorners1[7].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[0].x,this.boxCorners1[0].y,this.boxCorners1[0].z,1.0,0.0,0.0,1.0,this.boxCorners1[3].x,this.boxCorners1[3].y,this.boxCorners1[3].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[1].x,this.boxCorners1[1].y,this.boxCorners1[1].z,1.0,0.0,0.0,1.0,this.boxCorners1[2].x,this.boxCorners1[2].y,this.boxCorners1[2].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[2].x,this.boxCorners1[2].y,this.boxCorners1[2].z,1.0,0.0,0.0,1.0,this.boxCorners1[6].x,this.boxCorners1[6].y,this.boxCorners1[6].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[3].x,this.boxCorners1[3].y,this.boxCorners1[3].z,1.0,0.0,0.0,1.0,this.boxCorners1[7].x,this.boxCorners1[7].y,this.boxCorners1[7].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[0].x,this.boxCorners1[0].y,this.boxCorners1[0].z,1.0,0.0,0.0,1.0,this.boxCorners1[4].x,this.boxCorners1[4].y,this.boxCorners1[4].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[1].x,this.boxCorners1[1].y,this.boxCorners1[1].z,1.0,0.0,0.0,1.0,this.boxCorners1[5].x,this.boxCorners1[5].y,this.boxCorners1[5].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[4].x,this.boxCorners1[4].y,this.boxCorners1[4].z,1.0,0.0,0.0,1.0,this.boxCorners1[7].x,this.boxCorners1[7].y,this.boxCorners1[7].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.line(this.boxCorners1[5].x,this.boxCorners1[5].y,this.boxCorners1[5].z,1.0,0.0,0.0,1.0,this.boxCorners1[6].x,this.boxCorners1[6].y,this.boxCorners1[6].z,1.0,0.0,0.0,1.0);
			this.debugSpriter1.end();
		}

		/**
		*@private
		*/
		__proto.getRenderType=function(){
			return 0;
		}

		/**
		*@private
		*/
		__proto.releaseRender=function(){}
		/**
		*@private
		*/
		__proto.createConchModel=function(){
			var pScene=/*__JS__ */new ConchScene();
			pScene.init(512,512,512,4);
			return pScene;
		}

		/**
		*设置雾化颜色。
		*@param value 雾化颜色。
		*/
		/**
		*获取雾化颜色。
		*@return 雾化颜色。
		*/
		__getset(0,__proto,'fogColor',function(){
			return this._fogColor;
			},function(value){
			this._fogColor=value;
			this._shaderValues.setValue(/*CLASS CONST:laya.d3.core.scene.BaseScene.FOGCOLOR*/0,value.elements);
		});

		/**
		*设置是否允许雾化。
		*@param value 是否允许雾化。
		*/
		/**
		*获取是否允许雾化。
		*@return 是否允许雾化。
		*/
		__getset(0,__proto,'enableFog',function(){
			return this._enableFog;
			},function(value){
			if (this._enableFog!==value){
				this._enableFog=value;
				if (value){
					this.addShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
					this.removeShaderDefine(ShaderCompile3D.SAHDERDEFINE_DEPTHFOG);
				}
				else
				this.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
			}
		});

		__getset(0,__proto,'enableDepthFog',function(){
			return this._enableDepthFog;
			},function(v){
			if (this._enableDepthFog !=v){
				this._enableDepthFog=v;
				if (v){
					this.addShaderDefine(ShaderCompile3D.SAHDERDEFINE_DEPTHFOG);
					this.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
					}else {
					this.removeShaderDefine(ShaderCompile3D.SAHDERDEFINE_DEPTHFOG);
				}
			}
		});

		/**
		*设置雾化起始位置。
		*@param value 雾化起始位置。
		*/
		/**
		*获取雾化起始位置。
		*@return 雾化起始位置。
		*/
		__getset(0,__proto,'fogStart',function(){
			return this._fogStart;
			},function(value){
			this._fogStart=value;
			this._shaderValues.setValue(/*CLASS CONST:laya.d3.core.scene.BaseScene.FOGSTART*/1,value);
		});

		/**
		*设置雾化范围。
		*@param value 雾化范围。
		*/
		/**
		*获取雾化范围。
		*@return 雾化范围。
		*/
		__getset(0,__proto,'fogRange',function(){
			return this._fogRange;
			},function(value){
			this._fogRange=value;
			this._shaderValues.setValue(/*CLASS CONST:laya.d3.core.scene.BaseScene.FOGRANGE*/2,value);
		});

		/**
		*获取当前场景。
		*@return 当前场景。
		*/
		__getset(0,__proto,'scene',function(){
			return this;
		});

		BaseScene._sortScenes=function(a,b){
			if (a.parent===Laya.stage && b.parent===Laya.stage){
				var stageChildren=Laya.stage._childs;
				return stageChildren.indexOf(a)-stageChildren.indexOf(b);
				}else if (a.parent!==Laya.stage && b.parent!==Laya.stage){
				return BaseScene._sortScenes(a.parent,b.parent);
				}else {
				return (a.parent===Laya.stage)?-1 :1;
			}
		}

		BaseScene.FOGCOLOR=0;
		BaseScene.FOGSTART=1;
		BaseScene.FOGRANGE=2;
		BaseScene.LIGHTDIRECTION=3;
		BaseScene.LIGHTDIRDIFFUSE=4;
		BaseScene.LIGHTDIRAMBIENT=5;
		BaseScene.LIGHTDIRSPECULAR=6;
		BaseScene.POINTLIGHTPOS=7;
		BaseScene.POINTLIGHTRANGE=8;
		BaseScene.POINTLIGHTATTENUATION=9;
		BaseScene.POINTLIGHTDIFFUSE=10;
		BaseScene.POINTLIGHTAMBIENT=11;
		BaseScene.POINTLIGHTSPECULAR=12;
		BaseScene.SPOTLIGHTPOS=13;
		BaseScene.SPOTLIGHTDIRECTION=14;
		BaseScene.SPOTLIGHTSPOT=15;
		BaseScene.SPOTLIGHTRANGE=16;
		BaseScene.SPOTLIGHTATTENUATION=17;
		BaseScene.SPOTLIGHTDIFFUSE=18;
		BaseScene.SPOTLIGHTAMBIENT=19;
		BaseScene.SPOTLIGHTSPECULAR=20;
		BaseScene.SHADOWDISTANCE=21;
		BaseScene.SHADOWLIGHTVIEWPROJECT=22;
		BaseScene.SHADOWMAPPCFOFFSET=23;
		BaseScene.SHADOWMAPTEXTURE1=24;
		BaseScene.SHADOWMAPTEXTURE2=25;
		BaseScene.SHADOWMAPTEXTURE3=26;
		return BaseScene;
	})(Sprite)


	/**
	*<code>BaseCamera</code> 类用于创建摄像机的父类。
	*/
	//class laya.d3.core.BaseCamera extends laya.d3.core.Sprite3D
	var BaseCamera=(function(_super){
		function BaseCamera(nearPlane,farPlane){
			//this._tempVector3=null;
			//this._position=null;
			//this._up=null;
			//this._forward=null;
			//this._right=null;
			//this._renderTarget=null;
			//this._renderingOrder=0;
			//this._renderTargetSize=null;
			//this._nearPlane=NaN;
			//this._farPlane=NaN;
			//this._fieldOfView=NaN;
			//this._orthographic=false;
			//this._orthographicVerticalSize=NaN;
			//this._sky=null;
			//this._useUserProjectionMatrix=false;
			//this._viewportExpressedInClipSpace=false;
			//this.clearFlag=0;
			//this.clearColor=null;
			//this.cullingMask=0;
			//this.useOcclusionCulling=false;
			BaseCamera.__super.call(this);
			(nearPlane===void 0)&& (nearPlane=0.3);
			(farPlane===void 0)&& (farPlane=1000);
			this._tempVector3=new Vector3();
			this._position=new Vector3();
			this._up=new Vector3();
			this._forward=new Vector3();
			this._right=new Vector3();
			this._fieldOfView=60;
			this._useUserProjectionMatrix=false;
			this._orthographic=false;
			this._viewportExpressedInClipSpace=true;
			this._renderTargetSize=Size.fullScreen;
			this._orthographicVerticalSize=10;
			this.renderingOrder=0;
			this._nearPlane=nearPlane;
			this._farPlane=farPlane;
			this.cullingMask=2147483647;
			this.clearFlag=/*CLASS CONST:laya.d3.core.BaseCamera.CLEARFLAG_SOLIDCOLOR*/0;
			this.useOcclusionCulling=true;
			this._calculateProjectionMatrix();
			Laya.stage.on(/*laya.events.Event.RESIZE*/"resize",this,this._onScreenSizeChanged);
		}

		__class(BaseCamera,'laya.d3.core.BaseCamera',_super);
		var __proto=BaseCamera.prototype;
		__proto.createConchModel=function(){
			return /*__JS__ */new ConchCamera();
		}

		/**
		*通过RenderingOrder属性对摄像机机型排序。
		*/
		__proto._sortCamerasByRenderingOrder=function(){
			if (this._displayedInStage){
				var cameraPool=this.scene._cameraPool;
				var n=cameraPool.length-1;
				for (var i=0;i < n;i++){
					if (cameraPool[i].renderingOrder > cameraPool[n].renderingOrder){
						var tempCamera=cameraPool[i];
						cameraPool[i]=cameraPool[n];
						cameraPool[n]=tempCamera;
					}
				}
			}
		}

		/**
		*@private
		*/
		__proto._calculateProjectionMatrix=function(){}
		/**
		*@private
		*/
		__proto._onScreenSizeChanged=function(){
			this._calculateProjectionMatrix();
		}

		/**
		*@private
		*/
		__proto._prepareCameraToRender=function(){
			Layer._currentCameraCullingMask=this.cullingMask;
			var cameraSV=this._shaderValues;
			cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.CAMERAPOS*/0,this.transform.position.elements);
			cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.CAMERADIRECTION*/5,this.forward.elements);
			cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.CAMERAUP*/6,this.up.elements);
		}

		/**
		*@private
		*/
		__proto._prepareCameraViewProject=function(viewMatrix,projectMatrix){
			var cameraSV=this._shaderValues;
			cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.VIEWMATRIX*/1,viewMatrix.elements);
			cameraSV.setValue(/*CLASS CONST:laya.d3.core.BaseCamera.PROJECTMATRIX*/2,projectMatrix.elements);
		}

		/**
		*增加可视图层。
		*@param layer 图层。
		*/
		__proto.addLayer=function(layer){
			if (layer.number===29 || layer.number==30)
				return;
			this.cullingMask=this.cullingMask | layer.mask;
		}

		/**
		*移除可视图层。
		*@param layer 图层。
		*/
		__proto.removeLayer=function(layer){
			if (layer.number===29 || layer.number==30)
				return;
			this.cullingMask=this.cullingMask & ~layer.mask;
		}

		/**
		*增加所有图层。
		*/
		__proto.addAllLayers=function(){
			this.cullingMask=2147483647;
		}

		/**
		*移除所有图层。
		*/
		__proto.removeAllLayers=function(){
			this.cullingMask=0 | Layer.getLayerByNumber(29).mask | Layer.getLayerByNumber(30).mask;
		}

		__proto.ResetProjectionMatrix=function(){
			this._useUserProjectionMatrix=false;
			this._calculateProjectionMatrix();
		}

		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			if (this._sky){
				this._sky._ownerCamera=null;
				this._sky=null;
			}
			this.renderTarget=null;
			Laya.stage.off(/*laya.events.Event.RESIZE*/"resize",this,this._onScreenSizeChanged);
			_super.prototype.destroy.call(this,destroyChild);
		}

		/**
		*向前移动。
		*@param distance 移动距离。
		*/
		__proto.moveForward=function(distance){
			this._tempVector3.elements[0]=this._tempVector3.elements[1]=0;
			this._tempVector3.elements[2]=distance;
			this.transform.translate(this._tempVector3);
		}

		/**
		*向右移动。
		*@param distance 移动距离。
		*/
		__proto.moveRight=function(distance){
			this._tempVector3.elements[1]=this._tempVector3.elements[2]=0;
			this._tempVector3.elements[0]=distance;
			this.transform.translate(this._tempVector3);
		}

		/**
		*向上移动。
		*@param distance 移动距离。
		*/
		__proto.moveVertical=function(distance){
			this._tempVector3.elements[0]=this._tempVector3.elements[2]=0;
			this._tempVector3.elements[1]=distance;
			this.transform.translate(this._tempVector3,false);
		}

		//}// BoundingFrustumWorldSpace
		__proto._addSelfRenderObjects=function(){
			var cameraPool=this.scene._cameraPool;
			var cmaeraCount=cameraPool.length;
			if (cmaeraCount > 0){
				for (var i=cmaeraCount-1;i >=0;i--){
					if (this.renderingOrder <=cameraPool[i].renderingOrder){
						cameraPool.splice(i+1,0,this);
						break ;
					}
				}
				}else {
				cameraPool.push(this);
				if (this.scene.conchModel){
					this.scene.conchModel.setCurrentCamera(this.conchModel);
				}
			}
		}

		__proto._clearSelfRenderObjects=function(){
			var cameraPool=this.scene._cameraPool;
			cameraPool.splice(cameraPool.indexOf(this),1);
		}

		/**设置天空。*/
		/**获取天空。*/
		__getset(0,__proto,'sky',function(){
			return this._sky;
			},function(value){
			this._sky=value;
			value._ownerCamera=this;
			if (this.conchModel){
				this.conchModel.setSkyMesh(this._sky._conchSky);
			}
		});

		/**
		*获取前向量。
		*@return 前向量。
		*/
		__getset(0,__proto,'forward',function(){
			var worldMatrixe=this.transform.worldMatrix.elements;
			var forwarde=this._forward.elements;
			forwarde[0]=-worldMatrixe[8];
			forwarde[1]=-worldMatrixe[9];
			forwarde[2]=-worldMatrixe[10];
			return this._forward;
		});

		/**获取位置。*/
		__getset(0,__proto,'position',function(){
			var worldMatrixe=this.transform.worldMatrix.elements;
			var positione=this._position.elements;
			positione[0]=worldMatrixe[12];
			positione[1]=worldMatrixe[13];
			positione[2]=worldMatrixe[14];
			return this._position;
		});

		/**
		*设置渲染场景的渲染目标。
		*@param value 渲染场景的渲染目标。
		*/
		/**
		*获取渲染场景的渲染目标。
		*@return 渲染场景的渲染目标。
		*/
		__getset(0,__proto,'renderTarget',function(){
			return this._renderTarget;
			},function(value){
			this._renderTarget=value;
			if (value !=null)
				this._renderTargetSize=value.size;
		});

		/**
		*获取上向量。
		*@return 上向量。
		*/
		__getset(0,__proto,'up',function(){
			var worldMatrixe=this.transform.worldMatrix.elements;
			var upe=this._up.elements;
			upe[0]=worldMatrixe[4];
			upe[1]=worldMatrixe[5];
			upe[2]=worldMatrixe[6];
			return this._up;
		});

		/**
		*获取右向量。
		*@return 右向量。
		*/
		__getset(0,__proto,'right',function(){
			var worldMatrixe=this.transform.worldMatrix.elements;
			var righte=this._right.elements;
			righte[0]=worldMatrixe[0];
			righte[1]=worldMatrixe[1];
			righte[2]=worldMatrixe[2];
			return this._right;
		});

		/**
		*设置渲染目标的尺寸
		*@param value 渲染目标的尺寸。
		*/
		/**
		*获取渲染目标的尺寸
		*@return 渲染目标的尺寸。
		*/
		__getset(0,__proto,'renderTargetSize',function(){
			return this._renderTargetSize;
			},function(value){
			if (this.renderTarget !=null && this._renderTargetSize !=value){}
				this._renderTargetSize=value;
			this._calculateProjectionMatrix();
		});

		/**
		*设置视野。
		*@param value 视野。
		*/
		/**
		*获取视野。
		*@return 视野。
		*/
		__getset(0,__proto,'fieldOfView',function(){
			return this._fieldOfView;
			},function(value){
			this._fieldOfView=value;
			this._calculateProjectionMatrix();
		});

		/**
		*设置近裁面。
		*@param value 近裁面。
		*/
		/**
		*获取近裁面。
		*@return 近裁面。
		*/
		__getset(0,__proto,'nearPlane',function(){
			return this._nearPlane;
			},function(value){
			this._nearPlane=value;
			this._calculateProjectionMatrix();
		});

		/**
		*设置远裁面。
		*@param value 远裁面。
		*/
		/**
		*获取远裁面。
		*@return 远裁面。
		*/
		__getset(0,__proto,'farPlane',function(){
			return this._farPlane;
			},function(vaule){
			this._farPlane=vaule;
			this._calculateProjectionMatrix();
		});

		/**
		*设置是否正交投影矩阵。
		*@param 是否正交投影矩阵。
		*/
		/**
		*获取是否正交投影矩阵。
		*@return 是否正交投影矩阵。
		*/
		__getset(0,__proto,'orthographicProjection',function(){
			return this._orthographic;
			},function(vaule){
			this._orthographic=vaule;
			this._calculateProjectionMatrix();
		});

		/**
		*设置正交投影垂直矩阵尺寸。
		*@param 正交投影垂直矩阵尺寸。
		*/
		/**
		*获取正交投影垂直矩阵尺寸。
		*@return 正交投影垂直矩阵尺寸。
		*/
		__getset(0,__proto,'orthographicVerticalSize',function(){
			return this._orthographicVerticalSize;
			},function(vaule){
			this._orthographicVerticalSize=vaule;
			this._calculateProjectionMatrix();
		});

		__getset(0,__proto,'renderingOrder',function(){
			return this._renderingOrder;
			},function(value){
			this._renderingOrder=value;
			this._sortCamerasByRenderingOrder();
		});

		BaseCamera.CAMERAPOS=0;
		BaseCamera.VIEWMATRIX=1;
		BaseCamera.PROJECTMATRIX=2;
		BaseCamera.VPMATRIX=3;
		BaseCamera.VPMATRIX_NO_TRANSLATE=4;
		BaseCamera.CAMERADIRECTION=5;
		BaseCamera.CAMERAUP=6;
		BaseCamera.ENVIRONMENTDIFFUSE=7;
		BaseCamera.ENVIRONMENTSPECULAR=8;
		BaseCamera.SIMLODINFO=9;
		BaseCamera.DIFFUSEIRRADMATR=10;
		BaseCamera.DIFFUSEIRRADMATG=11;
		BaseCamera.DIFFUSEIRRADMATB=12;
		BaseCamera.HDREXPOSURE=13;
		BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING="DEFERREDLIGHTING";
		BaseCamera.RENDERINGTYPE_FORWARDRENDERING="FORWARDRENDERING";
		BaseCamera.CLEARFLAG_SOLIDCOLOR=0;
		BaseCamera.CLEARFLAG_SKY=1;
		BaseCamera.CLEARFLAG_DEPTHONLY=2;
		BaseCamera.CLEARFLAG_NONE=3;
		return BaseCamera;
	})(Sprite3D)


	/**
	*<code>RenderableSprite3D</code> 类用于可渲染3D精灵的父类，抽象类不允许实例。
	*/
	//class laya.d3.core.RenderableSprite3D extends laya.d3.core.Sprite3D
	var RenderableSprite3D=(function(_super){
		function RenderableSprite3D(name){
			this._render=null;
			this._geometryFilter=null;
			RenderableSprite3D.__super.call(this,name)
		}

		__class(RenderableSprite3D,'laya.d3.core.RenderableSprite3D',_super);
		var __proto=RenderableSprite3D.prototype;
		/**
		*@private
		*/
		__proto._renderRenderableBoundBox=function(){
			var linePhasor=Laya3D._debugPhasorSprite;
			var boundBox=this._render.boundingBox;
			var corners=RenderableSprite3D._tempBoundBoxCorners;
			boundBox.getCorners(corners);
			linePhasor.line(corners[0].x,corners[0].y,corners[0].z,0.0,1.0,0.0,1.0,corners[1].x,corners[1].y,corners[1].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[2].x,corners[2].y,corners[2].z,0.0,1.0,0.0,1.0,corners[3].x,corners[3].y,corners[3].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[4].x,corners[4].y,corners[4].z,0.0,1.0,0.0,1.0,corners[5].x,corners[5].y,corners[5].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[6].x,corners[6].y,corners[6].z,0.0,1.0,0.0,1.0,corners[7].x,corners[7].y,corners[7].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[0].x,corners[0].y,corners[0].z,0.0,1.0,0.0,1.0,corners[3].x,corners[3].y,corners[3].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[1].x,corners[1].y,corners[1].z,0.0,1.0,0.0,1.0,corners[2].x,corners[2].y,corners[2].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[2].x,corners[2].y,corners[2].z,0.0,1.0,0.0,1.0,corners[6].x,corners[6].y,corners[6].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[3].x,corners[3].y,corners[3].z,0.0,1.0,0.0,1.0,corners[7].x,corners[7].y,corners[7].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[0].x,corners[0].y,corners[0].z,0.0,1.0,0.0,1.0,corners[4].x,corners[4].y,corners[4].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[1].x,corners[1].y,corners[1].z,0.0,1.0,0.0,1.0,corners[5].x,corners[5].y,corners[5].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[4].x,corners[4].y,corners[4].z,0.0,1.0,0.0,1.0,corners[7].x,corners[7].y,corners[7].z,0.0,1.0,0.0,1.0);
			linePhasor.line(corners[5].x,corners[5].y,corners[5].z,0.0,1.0,0.0,1.0,corners[6].x,corners[6].y,corners[6].z,0.0,1.0,0.0,1.0);
		}

		/**
		*@inheritDoc
		*/
		__proto._update=function(state){
			state.owner=this;
			if (this._activeInHierarchy){
				this._updateComponents(state);
				this._render._updateOctreeNode();
				this._lateUpdateComponents(state);
				Stat.spriteCount++;
				this._childs.length && this._updateChilds(state);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto._updateConch=function(state){
			state.owner=this;
			if (this._activeInHierarchy){
				this._updateComponents(state);
				this._render._updateOctreeNode();
				this._lateUpdateComponents(state);
				Stat.spriteCount++;
				this._childs.length && this._updateChildsConch(state);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._render._destroy();
			this._render=null;
		}

		RenderableSprite3D._tempBoundBoxCorners=[];
		RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV=0x2;
		return RenderableSprite3D;
	})(Sprite3D)


	/**
	*<code>LightSprite</code> 类用于创建灯光的父类。
	*/
	//class laya.d3.core.light.LightSprite extends laya.d3.core.Sprite3D
	var LightSprite=(function(_super){
		function LightSprite(){
			this._diffuseColor=null;
			this._ambientColor=null;
			this._specularColor=null;
			this._reflectColor=null;
			this._shadow=false;
			this._shadowFarPlane=0;
			this._shadowMapSize=0;
			this._shadowMapCount=0;
			this._shadowMapPCFType=0;
			this._parallelSplitShadowMap=null;
			LightSprite.__super.call(this);
			this._diffuseColor=new Vector3(0.8,0.8,0.8);
			this._ambientColor=new Vector3(0.6,0.6,0.6);
			this._specularColor=new Vector3(1.0,1.0,1.0);
			this._reflectColor=new Vector3(1.0,1.0,1.0);
			this._shadow=false;
			this._shadowFarPlane=8;
			this._shadowMapSize=512;
			this._shadowMapCount=1;
			this._shadowMapPCFType=0;
		}

		__class(LightSprite,'laya.d3.core.light.LightSprite',_super);
		var __proto=LightSprite.prototype;
		/**
		*@inheritDoc
		*/
		__proto._addSelfRenderObjects=function(){
			this.scene._addLight(this);
		}

		/**
		*@inheritDoc
		*/
		__proto._clearSelfRenderObjects=function(){
			this.scene._removeLight(this);
		}

		/**
		*更新灯光相关渲染状态参数。
		*@param state 渲染状态参数。
		*/
		__proto.updateToWorldState=function(state){
			return false;
		}

		/**
		*设置灯光的漫反射颜色。
		*@param value 灯光的漫反射颜色。
		*/
		/**
		*获取灯光的漫反射颜色。
		*@return 灯光的漫反射颜色。
		*/
		__getset(0,__proto,'diffuseColor',function(){
			return this._diffuseColor;
			},function(value){
			this._diffuseColor=value;
		});

		/**
		*设置阴影PCF类型。
		*@param value PCF类型。
		*/
		/**
		*获取阴影PCF类型。
		*@return PCF类型。
		*/
		__getset(0,__proto,'shadowPCFType',function(){
			return this._shadowMapPCFType;
			},function(value){
			this._shadowMapPCFType=value;
			(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setPCFType(value));
		});

		/**
		*设置灯光的环境光颜色。
		*@param value 灯光的环境光颜色。
		*/
		/**
		*获取灯光的环境光颜色。
		*@return 灯光的环境光颜色。
		*/
		__getset(0,__proto,'ambientColor',function(){
			return this._ambientColor;
			},function(value){
			this._ambientColor=value;
		});

		/**
		*设置灯光的高光颜色。
		*@param value 灯光的高光颜色。
		*/
		/**
		*获取灯光的高光颜色。
		*@return 灯光的高光颜色。
		*/
		__getset(0,__proto,'specularColor',function(){
			return this._specularColor;
			},function(value){
			this._specularColor=value;
		});

		/**
		*设置灯光的反射颜色。
		*@param value 灯光的反射颜色。
		*/
		/**
		*获取灯光的反射颜色。
		*@return 灯光的反射颜色。
		*/
		__getset(0,__proto,'reflectColor',function(){
			return this._reflectColor;
			},function(value){
			this._reflectColor=value;
		});

		/**
		*设置是否产生阴影。
		*@param value 是否产生阴影。
		*/
		/**
		*获取是否产生阴影。
		*@return 是否产生阴影。
		*/
		__getset(0,__proto,'shadow',function(){
			return this._shadow;
			},function(value){
			throw new Error("LightSprite: must override it.");
		});

		/**
		*设置阴影最远范围。
		*@param value 阴影最远范围。
		*/
		/**
		*获取阴影最远范围。
		*@return 阴影最远范围。
		*/
		__getset(0,__proto,'shadowDistance',function(){
			return this._shadowFarPlane;
			},function(value){
			this._shadowFarPlane=value;
			(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setFarDistance(value));
		});

		/**
		*设置阴影分段数。
		*@param value 阴影分段数。
		*/
		/**
		*获取阴影分段数。
		*@return 阴影分段数。
		*/
		__getset(0,__proto,'shadowPSSMCount',function(){
			return this._shadowMapCount;
			},function(value){
			this._shadowMapCount=value;
			(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.PSSMNum=value);
		});

		/**
		*设置阴影贴图尺寸。
		*@param value 阴影贴图尺寸。
		*/
		/**
		*获取阴影贴图尺寸。
		*@return 阴影贴图尺寸。
		*/
		__getset(0,__proto,'shadowResolution',function(){
			return this._shadowMapSize;
			},function(value){
			this._shadowMapSize=value;
			(this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap.setShadowMapTextureSize(value));
		});

		/**
		*获取灯光的类型。
		*@return 灯光的类型。
		*/
		__getset(0,__proto,'lightType',function(){
			return-1;
		});

		LightSprite.TYPE_DIRECTIONLIGHT=1;
		LightSprite.TYPE_POINTLIGHT=2;
		LightSprite.TYPE_SPOTLIGHT=3;
		return LightSprite;
	})(Sprite3D)


	//class laya.d3.shader.Shader3D extends laya.webgl.shader.BaseShader
	var Shader3D=(function(_super){
		function Shader3D(vs,ps,attributeMap,sceneUniformMap,cameraUniformMap,spriteUniformMap,materialUniformMap,renderElementUniformMap){
			this.customCompile=false;
			//this._attributeMap=null;
			//this._sceneUniformMap=null;
			//this._cameraUniformMap=null;
			//this._spriteUniformMap=null;
			//this._materialUniformMap=null;
			//this._renderElementUniformMap=null;
			//this._vs=null;
			//this._ps=null;
			this._curActTexIndex=0;
			//this._reCompile=false;
			//this._vshader=null;
			//this._pshader=null;
			this._program=null;
			this._attributeParams=null;
			this._uniformParams=null;
			this._attributeParamsMap=[];
			this._sceneUniformParamsMap=[];
			this._cameraUniformParamsMap=[];
			this._spriteUniformParamsMap=[];
			this._materialUniformParamsMap=[];
			this._renderElementUniformParamsMap=[];
			//this._id=0;
			//this._uploadLoopCount=0;
			//this._uploadRenderElement=null;
			//this._uploadMaterial=null;
			//this._uploadSprite3D=null;
			//this._uploadCamera=null;
			//this._uploadScene=null;
			//this._uploadVertexBuffer=null;
			Shader3D.__super.call(this);
			if ((!vs)|| (!ps))throw "Shader Error";
			if (Render.isConchApp || Render.isFlash){
				this.customCompile=true;
			}
			this._id=++Shader3D._count;
			this._vs=vs;
			this._ps=ps;
			this._attributeMap=attributeMap;
			this._sceneUniformMap=sceneUniformMap;
			this._cameraUniformMap=cameraUniformMap;
			this._spriteUniformMap=spriteUniformMap;
			this._materialUniformMap=materialUniformMap;
			this._renderElementUniformMap=renderElementUniformMap;
			this.recreateResource();
		}

		__class(Shader3D,'laya.d3.shader.Shader3D',_super);
		var __proto=Shader3D.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			this._compile();
			this.completeCreate();
			this.memorySize=0;
		}

		//忽略尺寸尺寸
		__proto.detoryResource=function(){
			WebGL.mainContext.deleteShader(this._vshader);
			WebGL.mainContext.deleteShader(this._pshader);
			WebGL.mainContext.deleteProgram(this._program);
			this._vshader=this._pshader=this._program=null;
			this._attributeParams=null;
			this._uniformParams=null;
			this.memorySize=0;
			this._curActTexIndex=0;
		}

		__proto._compile=function(){
			if (!this._vs || !this._ps || this._attributeParams|| this._uniformParams)
				return;
			this._reCompile=true;
			this._attributeParams=[];
			this._uniformParams=[];
			var text=[this._vs,this._ps];
			var result;
			if (this.customCompile)
				result=this._preGetParams(this._vs,this._ps);
			var gl=WebGL.mainContext;
			this._program=gl.createProgram();
			this._vshader=Shader3D._createShader(gl,text[0],/*laya.webgl.WebGLContext.VERTEX_SHADER*/0x8B31);
			this._pshader=Shader3D._createShader(gl,text[1],/*laya.webgl.WebGLContext.FRAGMENT_SHADER*/0x8B30);
			gl.attachShader(this._program,this._vshader);
			gl.attachShader(this._program,this._pshader);
			gl.linkProgram(this._program);
			if (!this.customCompile && !gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.LINK_STATUS*/0x8B82)){
				throw gl.getProgramInfoLog(this._program);
			};
			var one,i=0,j=0,n=0,location;
			var attribNum=this.customCompile ? result.attributes.length :gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_ATTRIBUTES*/0x8B89);
			for (i=0;i < attribNum;i++){
				var attrib=this.customCompile ? result.attributes[i] :gl.getActiveAttrib(this._program,i);
				location=gl.getAttribLocation(this._program,attrib.name);
				one={vartype:"attribute",ivartype:0,attrib:attrib,location:location,name:attrib.name,type:attrib.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
				this._attributeParams.push(one);
			};
			var nUniformNum=this.customCompile ? result.uniforms.length :gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_UNIFORMS*/0x8B86);
			for (i=0;i < nUniformNum;i++){
				var uniform=this.customCompile ? result.uniforms[i] :gl.getActiveUniform(this._program,i);
				location=gl.getUniformLocation(this._program,uniform.name);
				one={vartype:"uniform",ivartype:1,attrib:attrib,location:location,name:uniform.name,type:uniform.type,isArray:false,isSame:false,preValue:null,indexOfParams:0};
				if (one.name.indexOf('[0]')> 0){
					one.name=one.name.substr(0,one.name.length-3);
					one.isArray=true;
					one.location=gl.getUniformLocation(this._program,one.name);
				}
				this._uniformParams.push(one);
			}
			for (i=0,n=this._attributeParams.length;i < n;i++){
				one=this._attributeParams[i];
				one.indexOfParams=i;
				one.index=1;
				one.value=[one.location,null];
				one.codename=one.name;
				one.name=(this._attributeMap[one.codename] !=null)? this._attributeMap[one.codename] :one.codename;
				this._attributeParamsMap.push(one.name);
				this._attributeParamsMap.push(one);
				one._this=this;
				one.uploadedValue=[];
				one.fun=this._attribute;
			}
			for (i=0,n=this._uniformParams.length;i < n;i++){
				one=this._uniformParams[i];
				one.indexOfParams=i;
				one.index=1;
				one.value=[one.location,null];
				one.codename=one.name;
				if (this._sceneUniformMap[one.codename] !=null){
					one.name=this._sceneUniformMap[one.codename];
					this._sceneUniformParamsMap.push(one.name);
					this._sceneUniformParamsMap.push(one);
				}
				else if (this._cameraUniformMap[one.codename] !=null){
					one.name=this._cameraUniformMap[one.codename];
					this._cameraUniformParamsMap.push(one.name);
					this._cameraUniformParamsMap.push(one);
				}
				else if (this._spriteUniformMap[one.codename] !=null){
					one.name=this._spriteUniformMap[one.codename];
					this._spriteUniformParamsMap.push(one.name);
					this._spriteUniformParamsMap.push(one);
				}
				else if (this._materialUniformMap[one.codename] !=null){
					one.name=this._materialUniformMap[one.codename];
					this._materialUniformParamsMap.push(one.name);
					this._materialUniformParamsMap.push(one);
				}
				else if (this._renderElementUniformMap[one.codename] !=null){
					one.name=this._renderElementUniformMap[one.codename];
					this._renderElementUniformParamsMap.push(one.name);
					this._renderElementUniformParamsMap.push(one);
				}
				else{
					console.log("Shader:can't find uinform name:"+one.codename+"in shader file.");
				}
				one._this=this;
				one.uploadedValue=[];
				switch (one.type){
					case /*laya.webgl.WebGLContext.INT*/0x1404:
						one.fun=one.isArray ? this._uniform1iv :this._uniform1i;
						break ;
					case /*laya.webgl.WebGLContext.FLOAT*/0x1406:
						one.fun=one.isArray ? this._uniform1fv :this._uniform1f;
						break ;
					case /*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50:
						one.fun=one.isArray ? this._uniform_vec2v:this._uniform_vec2;
						break ;
					case /*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51:
						one.fun=one.isArray ? this._uniform_vec3v:this._uniform_vec3;
						break ;
					case /*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52:
						one.fun=one.isArray ? this._uniform_vec4v:this._uniform_vec4;
						break ;
					case /*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E:
						one.fun=this._uniform_sampler2D;
						break ;
					case /*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60:
						one.fun=this._uniform_samplerCube;
						break ;
					case /*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C:
						one.fun=this._uniformMatrix4fv;
						break ;
					case /*laya.webgl.WebGLContext.BOOL*/0x8B56:
						one.fun=this._uniform1i;
						break ;
					case /*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A:
						one.fun=this._uinformMatrix2fv;
						break ;
					case /*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B:
						one.fun=this._uinformMatrix3fv;
						break ;
					default :
						throw new Error("compile shader err!");
						break ;
					}
			}
		}

		__proto._attribute=function(one,value){
			var gl=WebGL.mainContext;
			gl.enableVertexAttribArray(one.location);
			gl.vertexAttribPointer(one.location,value[0],value[1],value[2],value[3],value[4]);
			return 2;
		}

		__proto._uniform1f=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value){
				WebGL.mainContext.uniform1f(one.location,uploadedValue[0]=value);
				return 1;
			}
			return 0;
		}

		__proto._uniform1fv=function(one,value){
			if (value.length < 4){
				var uploadedValue=one.uploadedValue;
				if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
					WebGL.mainContext.uniform1fv(one.location,value);
					uploadedValue[0]=value[0];
					uploadedValue[1]=value[1];
					uploadedValue[2]=value[2];
					uploadedValue[3]=value[3];
					return 1;
				}
				return 0;
				}else {
				WebGL.mainContext.uniform1fv(one.location,value);
				return 1;
			}
		}

		__proto._uniform_vec2=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
				WebGL.mainContext.uniform2f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec2v=function(one,value){
			if (value.length < 2){
				var uploadedValue=one.uploadedValue;
				if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
					WebGL.mainContext.uniform2fv(one.location,value);
					uploadedValue[0]=value[0];
					uploadedValue[1]=value[1];
					uploadedValue[2]=value[2];
					uploadedValue[3]=value[3];
					return 1;
				}
				return 0;
				}else {
				WebGL.mainContext.uniform2fv(one.location,value);
				return 1;
			}
		}

		__proto._uniform_vec3=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
				WebGL.mainContext.uniform3f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec3v=function(one,value){
			WebGL.mainContext.uniform3fv(one.location,value);
			return 1;
		}

		__proto._uniform_vec4=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				WebGL.mainContext.uniform4f(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec4v=function(one,value){
			WebGL.mainContext.uniform4fv(one.location,value);
			return 1;
		}

		__proto._uniformMatrix2fv=function(one,value){
			WebGL.mainContext.uniformMatrix2fv(one.location,false,value);
			return 1;
		}

		__proto._uniformMatrix3fv=function(one,value){
			WebGL.mainContext.uniformMatrix3fv(one.location,false,value);
			return 1;
		}

		__proto._uniformMatrix4fv=function(one,value){
			WebGL.mainContext.uniformMatrix4fv(one.location,false,value);
			return 1;
		}

		__proto._uinformMatrix2fv=function(one,value){
			WebGL.mainContext.uniformMatrix2fv(one.location,false,value);
			return 1;
		}

		__proto._uinformMatrix3fv=function(one,value){
			WebGL.mainContext.uniformMatrix3fv(one.location,false,value);
			return 1;
		}

		__proto._uniform1i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value){
				WebGL.mainContext.uniform1i(one.location,uploadedValue[0]=value);
				return 1;
			}
			return 0;
		}

		__proto._uniform1iv=function(one,value){
			WebGL.mainContext.uniform1iv(one.location,value);
			return 1;
		}

		__proto._uniform_ivec2=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1]){
				WebGL.mainContext.uniform2i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_ivec2v=function(one,value){
			WebGL.mainContext.uniform2iv(one.location,value);
			return 1;
		}

		__proto._uniform_vec3i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2]){
				WebGL.mainContext.uniform3i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec3vi=function(one,value){
			WebGL.mainContext.uniform3iv(one.location,value);
			return 1;
		}

		__proto._uniform_vec4i=function(one,value){
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]!==value[0] || uploadedValue[1]!==value[1] || uploadedValue[2]!==value[2] || uploadedValue[3]!==value[3]){
				WebGL.mainContext.uniform4i(one.location,uploadedValue[0]=value[0],uploadedValue[1]=value[1],uploadedValue[2]=value[2],uploadedValue[3]=value[3]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec4vi=function(one,value){
			WebGL.mainContext.uniform4iv(one.location,value);
			return 1;
		}

		__proto._uniform_sampler2D=function(one,value){
			var gl=WebGL.mainContext;
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]==null){
				uploadedValue[0]=this._curActTexIndex;
				gl.uniform1i(one.location,this._curActTexIndex);
				gl.activeTexture(Shader3D._TEXTURES[this._curActTexIndex]);
				if(value)
					WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
				this._curActTexIndex++;
				return 1;
				}else {
				gl.activeTexture(Shader3D._TEXTURES[uploadedValue[0]]);
				if(value)
					WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
				return 0;
			}
		}

		__proto._uniform_samplerCube=function(one,value){
			var gl=WebGL.mainContext;
			var uploadedValue=one.uploadedValue;
			if (uploadedValue[0]==null){
				uploadedValue[0]=this._curActTexIndex;
				gl.uniform1i(one.location,this._curActTexIndex);
				gl.activeTexture(Shader3D._TEXTURES[this._curActTexIndex]);
				if(value)
					WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,value);
				else
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,SolidColorTextureCube.grayTexture.source);
				this._curActTexIndex++;
				return 1;
				}else {
				gl.activeTexture(Shader3D._TEXTURES[uploadedValue[0]]);
				if(value)
					WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,value);
				else
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,SolidColorTextureCube.grayTexture.source);
				return 0;
			}
		}

		__proto._noSetValue=function(one){
			console.log("no....:"+one.name);
		}

		//throw new Error("upload shader err,must set value:"+one.name);
		__proto.uploadTexture2D=function(value){
			Stat.shaderCall++;
			var gl=WebGL.mainContext;
			gl.activeTexture(/*laya.webgl.WebGLContext.TEXTURE0*/0x84C0);
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,value);
		}

		__proto.bind=function(){
			BaseShader.activeShader=this;
			BaseShader.bindShader=this;
			this.activeResource();
			return WebGLContext.UseProgram(this._program);
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,value,...]
		*/
		__proto.uploadAttributes=function(attributeShaderValue,_bufferUsage){
			var value;
			var one,shaderCall=0;
			for (var i=0,n=this._attributeParamsMap.length;i < n;i+=2){
				one=this._attributeParamsMap[i+1];
				value=attributeShaderValue[this._attributeParamsMap[i]];
				if (value !=null){
					_bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
					shaderCall+=one.fun.call(this,one,value);
				}
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,value,...]
		*/
		__proto.uploadSceneUniforms=function(shaderValue){
			var value;
			var one,shaderCall=0;
			for (var i=0,n=this._sceneUniformParamsMap.length;i < n;i+=2){
				one=this._sceneUniformParamsMap[i+1];
				value=shaderValue[this._sceneUniformParamsMap[i]];
				if (value !=null)
					shaderCall+=one.fun.call(this,one,value);
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,value,...]
		*/
		__proto.uploadCameraUniforms=function(shaderValue){
			var value;
			var one,shaderCall=0;
			for (var i=0,n=this._cameraUniformParamsMap.length;i < n;i+=2){
				one=this._cameraUniformParamsMap[i+1];
				value=shaderValue[this._cameraUniformParamsMap[i]];
				if (value !=null)
					shaderCall+=one.fun.call(this,one,value);
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,value,...]
		*/
		__proto.uploadSpriteUniforms=function(shaderValue){
			var value;
			var one,shaderCall=0;
			for (var i=0,n=this._spriteUniformParamsMap.length;i < n;i+=2){
				one=this._spriteUniformParamsMap[i+1];
				value=shaderValue[this._spriteUniformParamsMap[i]];
				if (value !=null)
					shaderCall+=one.fun.call(this,one,value);
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,value,...]
		*/
		__proto.uploadMaterialUniforms=function(shaderValue){
			var value;
			var one,shaderCall=0;
			for (var i=0,n=this._materialUniformParamsMap.length;i < n;i+=2){
				one=this._materialUniformParamsMap[i+1];
				value=shaderValue[this._materialUniformParamsMap[i]];
				if (value !=null)
					shaderCall+=one.fun.call(this,one,value);
			}
			Stat.shaderCall+=shaderCall;
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,value,...]
		*/
		__proto.uploadRenderElementUniforms=function(shaderValue){
			var value;
			var one,shaderCall=0;
			for (var i=0,n=this._renderElementUniformParamsMap.length;i < n;i+=2){
				one=this._renderElementUniformParamsMap[i+1];
				value=shaderValue[this._renderElementUniformParamsMap[i]];
				if (value !=null)
					shaderCall+=one.fun.call(this,one,value);
			}
			Stat.shaderCall+=shaderCall;
		}

		__proto._preGetParams=function(vs,ps){
			var text=[vs,ps];
			var result={};
			var attributes=[];
			var uniforms=[];
			var definesInfo={};
			var definesName=[];
			result.attributes=attributes;
			result.uniforms=uniforms;
			result.defines=definesInfo;
			var removeAnnotation=new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)","g");
			var reg=new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])","g");
			var i=0,n=0,one;
			for (var s=0;s < 2;s++){
				text[s]=text[s].replace(removeAnnotation,"");
				var words=text[s].match(reg);
				var tempelse;
				for (i=0,n=words.length;i < n;i++){
					var word=words[i];
					if (word !="attribute" && word !="uniform"){
						if (word=="#define"){
							word=words[++i];
							definesName[word]=1;
							continue ;
							}else if (word=="#ifdef"){
							tempelse=words[++i];
							var def=definesInfo[tempelse]=definesInfo[tempelse] || [];
							for (i++;i < n;i++){
								word=words[i];
								if (word !="attribute" && word !="uniform"){
									if (word=="#else"){
										for (i++;i < n;i++){
											word=words[i];
											if (word !="attribute" && word !="uniform"){
												if (word=="#endif"){
													break ;
												}
												continue ;
											}
											i=this.parseOne(attributes,uniforms,words,i,word,!definesName[tempelse]);
										}
									}
									continue ;
								}
								i=this.parseOne(attributes,uniforms,words,i,word,definesName[tempelse]);
							}
						}
						continue ;
					}
					i=this.parseOne(attributes,uniforms,words,i,word,true);
				}
			}
			return result;
		}

		__proto.parseOne=function(attributes,uniforms,words,i,word,b){
			var one={type:Shader3D.shaderParamsMap[words[i+1]],name:words[i+2],size:isNaN(parseInt(words[i+3]))? 1 :parseInt(words[i+3])};
			if (b){
				if (word=="attribute"){
					attributes.push(one);
					}else {
					uniforms.push(one);
				}
			}
			if (words[i+3]==':'){
				one.type=words[i+4];
				i+=2;
			}
			i+=2;
			return i;
		}

		__proto.dispose=function(){
			this.resourceManager.removeResource(this);
			laya.resource.Resource.prototype.dispose.call(this);
		}

		Shader3D.create=function(vs,ps,attributeMap,sceneUniformMap,cameraUniformMap,spriteUniformMap,materialUniformMap,renderElementUniformMap){
			return new Shader3D(vs,ps,attributeMap,sceneUniformMap,cameraUniformMap,spriteUniformMap,materialUniformMap,renderElementUniformMap);
		}

		Shader3D.addInclude=function(fileName,txt){
			if (!txt || txt.length===0)
				throw new Error("add shader include file err:"+fileName);
			if (Shader3D._includeFiles[fileName])
				throw new Error("add shader include file err, has add:"+fileName);
			Shader3D._includeFiles[fileName]=txt;
		}

		Shader3D._createShader=function(gl,str,type){
			var shader=gl.createShader(type);
			gl.shaderSource(shader,str);
			gl.compileShader(shader);
			if (!gl.getShaderParameter(shader,/*laya.webgl.WebGLContext.COMPILE_STATUS*/0x8B81)){
				throw gl.getShaderInfoLog(shader);
			}
			return shader;
		}

		Shader3D.PERIOD_RENDERELEMENT=0;
		Shader3D.PERIOD_MATERIAL=1;
		Shader3D.PERIOD_SPRITE=2;
		Shader3D.PERIOD_CAMERA=3;
		Shader3D.PERIOD_SCENE=4;
		Shader3D._TEXTURES=[ /*laya.webgl.WebGLContext.TEXTURE0*/0x84C0,/*laya.webgl.WebGLContext.TEXTURE1*/0x84C1,/*laya.webgl.WebGLContext.TEXTURE2*/0x84C2,/*laya.webgl.WebGLContext.TEXTURE3*/0x84C3,/*laya.webgl.WebGLContext.TEXTURE4*/0x84C4,/*laya.webgl.WebGLContext.TEXTURE5*/0x84C5,/*laya.webgl.WebGLContext.TEXTURE6*/0x84C6,,/*laya.webgl.WebGLContext.TEXTURE7*/0x84C7,/*laya.webgl.WebGLContext.TEXTURE8*/0x84C8];
		Shader3D._includeFiles={};
		Shader3D._count=0;
		__static(Shader3D,
		['shaderParamsMap',function(){return this.shaderParamsMap={"float":/*laya.webgl.WebGLContext.FLOAT*/0x1406,"int":/*laya.webgl.WebGLContext.INT*/0x1404,"bool":/*laya.webgl.WebGLContext.BOOL*/0x8B56,"vec2":/*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50,"vec3":/*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51,"vec4":/*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52,"ivec2":/*laya.webgl.WebGLContext.INT_VEC2*/0x8B53,"ivec3":/*laya.webgl.WebGLContext.INT_VEC3*/0x8B54,"ivec4":/*laya.webgl.WebGLContext.INT_VEC4*/0x8B55,"bvec2":/*laya.webgl.WebGLContext.BOOL_VEC2*/0x8B57,"bvec3":/*laya.webgl.WebGLContext.BOOL_VEC3*/0x8B58,"bvec4":/*laya.webgl.WebGLContext.BOOL_VEC4*/0x8B59,"mat2":/*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A,"mat3":/*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B,"mat4":/*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C,"sampler2D":/*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E,"samplerCube":/*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60};},'nameKey',function(){return this.nameKey=new StringKey();}
		]);
		return Shader3D;
	})(BaseShader)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.material.GlitterMaterial extends laya.d3.core.material.BaseMaterial
	var GlitterMaterial=(function(_super){
		function GlitterMaterial(){
			this._renderMode=0;
			GlitterMaterial.__super.call(this);
			this.setShaderName("GLITTER");
			this.renderMode=1;
		}

		__class(GlitterMaterial,'laya.d3.core.material.GlitterMaterial',_super);
		var __proto=GlitterMaterial.prototype;
		/**
		*@inheritDoc
		*/
		__proto.setShaderName=function(name){
			_super.prototype.setShaderName.call(this,name);
		}

		/**
		*@inheritDoc
		*/
		__proto._setMaterialShaderParams=function(state){
			var glitter=state.owner;
			var templet=glitter.templet;
			this._setColor(4,templet.color);
			this._setNumber(5,templet.lifeTime);
			this._setColor(2,templet._albedo);
			this._setNumber(3,templet._currentTime);
		}

		/**
		*@inheritDoc
		*/
		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var dest=destObject;
			dest._renderMode=this._renderMode;
		}

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		/**
		*获取渲染状态。
		*@return 渲染状态。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			this._renderMode=value;
			switch (value){
				case 1:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 2:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=0;
					this.blend=0;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 13:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 14:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 15:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 16:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 5:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 6:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 7:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 8:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 9:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 10:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 11:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 12:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				default :
					throw new Error("Material:renderMode value error.");
				}
			this._conchMaterial && this._conchMaterial.setRenderMode(value);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._getTexture(1);
			},function(value){
			this._setTexture(1,value);
		});

		GlitterMaterial.load=function(url){
			return Laya.loader.create(url,null,null,GlitterMaterial);
		}

		GlitterMaterial.RENDERMODE_OPAQUE=1;
		GlitterMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		GlitterMaterial.RENDERMODE_TRANSPARENT=13;
		GlitterMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
		GlitterMaterial.RENDERMODE_ADDTIVE=15;
		GlitterMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
		GlitterMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
		GlitterMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
		GlitterMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
		GlitterMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
		GlitterMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
		GlitterMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
		GlitterMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
		GlitterMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
		GlitterMaterial.DIFFUSETEXTURE=1;
		GlitterMaterial.ALBEDO=2;
		GlitterMaterial.CURRENTTIME=3;
		GlitterMaterial.UNICOLOR=4;
		GlitterMaterial.DURATION=5;
		__static(GlitterMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new GlitterMaterial();}
		]);
		return GlitterMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.material.ParticleMaterial extends laya.d3.core.material.BaseMaterial
	var ParticleMaterial=(function(_super){
		function ParticleMaterial(){
			this._renderMode=0;
			ParticleMaterial.__super.call(this);
			this._addShaderDefine(laya.d3.core.material.ParticleMaterial.SHADERDEFINE_PARTICLE3D);
			this.setShaderName("PARTICLE");
			this.renderMode=1;
		}

		__class(ParticleMaterial,'laya.d3.core.material.ParticleMaterial',_super);
		var __proto=ParticleMaterial.prototype;
		__proto._setMaterialShaderParams=function(state){
			var particle=state.owner;
			var templet=particle.templet;
			var setting=templet.settings;
			this._setNumber(3,setting.duration);
			this._setBuffer(4,setting.gravity);
			this._setNumber(5,setting.endVelocity);
			var aspectRadio=state._viewport.width / state._viewport.height;
			var viewportScale=new Vector2(0.5 / aspectRadio,-0.5);
			this._setVector2(1,viewportScale);
			this._setNumber(2,templet._currentTime);
		}

		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var dest=destObject;
			dest._renderMode=this._renderMode;
		}

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		/**
		*获取渲染状态。
		*@return 渲染状态。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			this._renderMode=value;
			switch (value){
				case 1:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 2:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=0;
					this.blend=0;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 13:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 14:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 15:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 16:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 5:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 6:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 7:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 8:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 9:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 10:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 11:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 12:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				default :
					throw new Error("Material:renderMode value error.");
				}
			this._conchMaterial && this._conchMaterial.setRenderMode(value);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._getTexture(6);
			},function(value){
			this._setTexture(6,value);
		});

		ParticleMaterial.load=function(url){
			return Laya.loader.create(url,null,null,ParticleMaterial);
		}

		ParticleMaterial.RENDERMODE_OPAQUE=1;
		ParticleMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		ParticleMaterial.RENDERMODE_TRANSPARENT=13;
		ParticleMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
		ParticleMaterial.RENDERMODE_ADDTIVE=15;
		ParticleMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
		ParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
		ParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
		ParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
		ParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
		ParticleMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
		ParticleMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
		ParticleMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
		ParticleMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
		ParticleMaterial.SHADERDEFINE_PARTICLE3D=0;
		ParticleMaterial.VIEWPORTSCALE=1;
		ParticleMaterial.CURRENTTIME=2;
		ParticleMaterial.DURATION=3;
		ParticleMaterial.GRAVITY=4;
		ParticleMaterial.ENDVELOCITY=5;
		ParticleMaterial.DIFFUSETEXTURE=6;
		__static(ParticleMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new ParticleMaterial();}
		]);
		return ParticleMaterial;
	})(BaseMaterial)


	//class laya.d3.core.material.PBRMaterial extends laya.d3.core.material.BaseMaterial
	var PBRMaterial=(function(_super){
		function PBRMaterial(){
			this._transformUV=null;
			this._renderMode=0;
			PBRMaterial.__super.call(this);
			if (!laya.d3.core.material.PBRMaterial.pbrlutTex){
				var lutdt=Browser.window['__pbrlutdata'];
				if (!lutdt){
					alert('no pbr lutdata, need pbrlut.js');
					throw 'no pbr lutdata, need pbrlut.js';
				};
				var luttex=DataTexture2D.create((new Uint32Array(lutdt)).buffer,256,256,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600,false);
				laya.d3.core.material.PBRMaterial.pbrlutTex=luttex;
			}
			this._setTexture(4,laya.d3.core.material.PBRMaterial.pbrlutTex);
			this.setShaderName("PBR");
			this._setNumber(0,0.5);
		}

		__class(PBRMaterial,'laya.d3.core.material.PBRMaterial',_super);
		var __proto=PBRMaterial.prototype;
		/**
		*禁用灯光。
		*/
		__proto.disableLight=function(){
			this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
		}

		/**
		*禁用雾化。
		*/
		__proto.disableFog=function(){
			this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
		}

		/**
		*@private
		*/
		__proto._setMaterialShaderParams=function(state){
			(this._transformUV)&& (this._transformUV.matrix);
		}

		//触发UV矩阵更新TODO:临时
		__proto.onAsynLoaded=function(url,data,params){
			_super.prototype.onAsynLoaded.call(this,url,data,params);
		}

		/**
		*vdc算法产生的序列。这个比random要均匀一些。
		*/
		__proto.radicalInverse_VdC=function(bits){
			var tmpUint=new Uint32Array(1);
			return (function(bits){
				bits=(bits << 16)| (bits >>> 16);
				bits=((bits & 0x55555555)<< 1)| ((bits & 0xAAAAAAAA)>>> 1);
				bits=((bits & 0x33333333)<< 2)| ((bits & 0xCCCCCCCC)>>> 2);
				bits=((bits & 0x0F0F0F0F)<< 4)| ((bits & 0xF0F0F0F0)>>> 4);
				bits=((bits & 0x00FF00FF)<< 8)| ((bits & 0xFF00FF00)>>> 8);
				tmpUint[0]=bits;
				return tmpUint[0] *2.3283064365386963e-10;
			})(bits);
		}

		/**
		*
		*/
		__proto.createHammersleyTex=function(w,h){
			var ret=new Uint8Array(w*h*4);
			var ri=0;
			var ci=0;
			for(ci=0;ci<w*h;ci++){
				var v=this.radicalInverse_VdC(ci);
				ret[ri++]=v*255;
				ret[ri++]=0;
				ret[ri++]=0;
				ret[ri++]=255;
			}
			return ret;
		}

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._getTexture(2);
			},function(value){
			this._setTexture(2,value);
		});

		__getset(0,__proto,'has_tangent',null,function(v){
			this._addShaderDefine(PBRMaterial.SHADERDEFINE_HAS_TANGENT);
		});

		/**
		*设置粗糙度的值，0为特别光滑，1为特别粗糙。
		*@param value 粗糙度。
		*/
		/**
		*获取粗糙度的值，0为特别光滑，1为特别粗糙。
		*@return 粗糙度的值。
		*/
		__getset(0,__proto,'roughness',function(){
			return this._getNumber(6);
			},function(value){
			this._setNumber(6,value);
			this._addShaderDefine(PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS);
		});

		__getset(0,__proto,'metaless',function(){
			return this._getNumber(7);
			},function(v){
			this._setNumber(7,v);
			this._addShaderDefine(PBRMaterial.SHADERDEFINE_FIX_METALESS);
		});

		/**
		*设置PBRLUT贴图。
		*@param value PBRLUT贴图。
		*/
		/**
		*获取PBRLUT贴图。
		*@return PBRLUT贴图。
		*/
		__getset(0,__proto,'pbrlutTexture',function(){
			return this._getTexture(4);
			},function(value){
			this._setTexture(4,value);
		});

		__getset(0,__proto,'use_groundtruth',null,function(v){
			if (v){
				this._addShaderDefine(PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH);
				if (!laya.d3.core.material.PBRMaterial.HammersleyNoiseTex){
					var texdata=this.createHammersleyTex(32,32);
					laya.d3.core.material.PBRMaterial.HammersleyNoiseTex=DataTexture2D.create(texdata.buffer,32,32,/*laya.webgl.WebGLContext.NEAREST*/0x2600,/*laya.webgl.WebGLContext.NEAREST*/0x2600,false);
				}
				this._setTexture(15,PBRMaterial.HammersleyNoiseTex);
				}else {
				laya.d3.core.material.PBRMaterial.HammersleyNoiseTex=null;
				this._removeShaderDefine(PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH);
			}
		});

		/**
		*设置UV变换。
		*@param value UV变换。
		*/
		/**
		*获取UV变换。
		*@return UV变换。
		*/
		__getset(0,__proto,'transformUV',function(){
			return this._transformUV;
			},function(value){
			this._transformUV=value;
			this._setMatrix4x4(8,value.matrix);
			if (this._conchMaterial){
				this._conchMaterial.setShaderValue(8,value.matrix.elements,0);
			}
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._getTexture(1);
			},function(value){
			this._setTexture(1,value);
		});

		/**
		*获取渲染状态。
		*@return 渲染状态。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			this._renderMode=value;
			switch (value){
				case 1:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 2:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=0;
					this.blend=0;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 3:
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 13:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				default :
					throw new Error("PBRMaterial:renderMode value error.");
				}
		});

		/**
		*设置pbr信息贴图。
		*@param value pbr信息贴图。
		*/
		/**
		*获取pbr信息贴图。
		*@return pbr信息贴图。
		*/
		__getset(0,__proto,'pbrInfoTexture',function(){
			return this._getTexture(3);
			},function(value){
			this._setTexture(3,value);
			this._addShaderDefine(PBRMaterial.SHADERDEFINE_HAS_PBRINFO);
		});

		__getset(0,__proto,'testClipZ',null,function(v){
			this._addShaderDefine(PBRMaterial.SHADERDEFINE_TEST_CLIPZ);
		});

		PBRMaterial.load=function(url){
			return Laya.loader.create(url,null,null,PBRMaterial);
		}

		PBRMaterial.DIFFUSETEXTURE=1;
		PBRMaterial.NORMALTEXTURE=2;
		PBRMaterial.PBRINFOTEXTURE=3;
		PBRMaterial.PBRLUTTEXTURE=4;
		PBRMaterial.UVANIAGE=5;
		PBRMaterial.MATERIALROUGHNESS=6;
		PBRMaterial.MATERIALMETALESS=7;
		PBRMaterial.UVMATRIX=8;
		PBRMaterial.UVAGE=9;
		PBRMaterial.AOOBJPOS=14;
		PBRMaterial.HSNOISETEXTURE=15;
		PBRMaterial.SHADERDEFINE_FIX_ROUGHNESS=0;
		PBRMaterial.SHADERDEFINE_FIX_METALESS=0;
		PBRMaterial.SHADERDEFINE_HAS_TANGENT=0;
		PBRMaterial.SHADERDEFINE_TEST_CLIPZ=0;
		PBRMaterial.SHADERDEFINE_HAS_PBRINFO=0;
		PBRMaterial.SHADERDEFINE_USE_GROUNDTRUTH=0;
		PBRMaterial.RENDERMODE_OPAQUE=1;
		PBRMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		PBRMaterial.RENDERMODE_CUTOUT=3;
		PBRMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
		PBRMaterial.RENDERMODE_TRANSPARENT=13;
		PBRMaterial.pbrlutTex=null
		PBRMaterial.HammersleyNoiseTex=null
		__static(PBRMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new PBRMaterial();}
		]);
		return PBRMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.material.StandardMaterial extends laya.d3.core.material.BaseMaterial
	var StandardMaterial=(function(_super){
		function StandardMaterial(){
			this._renderMode=0;
			this._transformUV=null;
			StandardMaterial.__super.call(this);
			this.setShaderName("SIMPLE");
			this._setColor(9,new Vector3(0.6,0.6,0.6));
			this._setColor(10,new Vector3(1.0,1.0,1.0));
			this._setColor(11,new Vector4(1.0,1.0,1.0,8.0));
			this._setColor(12,new Vector3(1.0,1.0,1.0));
			this._setColor(7,new Vector4(1.0,1.0,1.0,1.0));
			this._setNumber(0,0.5);
			this.renderMode=1;
		}

		__class(StandardMaterial,'laya.d3.core.material.StandardMaterial',_super);
		var __proto=StandardMaterial.prototype;
		/**
		*禁用灯光。
		*/
		__proto.disableLight=function(){
			this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT | ShaderCompile3D.SHADERDEFINE_SPOTLIGHT | ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
		}

		/**
		*禁用雾化。
		*/
		__proto.disableFog=function(){
			this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded=function(url,data,params){
			var jsonData=data[0];
			if (jsonData.version){
				_super.prototype.onAsynLoaded.call(this,url,data,params);
				}else {
				var textureMap=data[1];
				var props=jsonData.props;
				for (var prop in props)
				this[prop]=props[prop];
				StandardMaterial._parseStandardMaterial(textureMap,this,jsonData);
				this.event(/*laya.events.Event.LOADED*/"loaded",this);
			}
		}

		/**
		*@private
		*/
		__proto._setMaterialShaderParams=function(state){
			(this._transformUV)&& (this._transformUV.matrix);
		}

		/**
		*@inheritDoc
		*/
		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var dest=destObject;
			dest._renderMode=this._renderMode;
			(this._transformUV)&& (dest._transformUV=this._transformUV.clone());
		}

		/**
		*设置环境光颜色。
		*@param value 环境光颜色。
		*/
		//NATIVE
		__getset(0,__proto,'ambientColor',function(){
			return this._getColor(9);
			},function(value){
			this._setColor(9,value);
		});

		/**
		*设置环境贴图。
		*@param value 环境贴图。
		*/
		/**
		*获取环境贴图。
		*@return 环境贴图。
		*/
		__getset(0,__proto,'ambientTexture',function(){
			return this._getTexture(5);
			},function(value){
			if (value){
				this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_AMBIENTMAP);
				}else {
				this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_AMBIENTMAP);
			}
			this._setTexture(5,value);
		});

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		/**
		*获取渲染状态。
		*@return 渲染状态。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			this._renderMode=value;
			switch (value){
				case 1:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 2:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=0;
					this.blend=0;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 3:
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.alphaTest=true;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 4:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=0;
					this.blend=0;
					this.alphaTest=true;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 13:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 14:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 15:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 16:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 5:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 6:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 7:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 8:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 9:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 10:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 11:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 12:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				default :
					throw new Error("Material:renderMode value error.");
				}
			this._conchMaterial && this._conchMaterial.setRenderMode(value);
		});

		/**
		*设置反射率。
		*@param value 反射率。
		*/
		__getset(0,__proto,'albedo',function(){
			return this._getColor(7);
			},function(value){
			this._setColor(7,value);
		});

		/**
		*设置漫反射光颜色。
		*@param value 漫反射光颜色。
		*/
		__getset(0,__proto,'diffuseColor',function(){
			return this._getColor(10);
			},function(value){
			this._setColor(10,value);
		});

		/**
		*设置高光颜色。
		*@param value 高光颜色。
		*/
		__getset(0,__proto,'specularColor',function(){
			return this._getColor(11);
			},function(value){
			this._setColor(11,value);
		});

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._getTexture(2);
			},function(value){
			if (value){
				this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_NORMALMAP);
				}else {
				this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_NORMALMAP);
			}
			this._setTexture(2,value);
		});

		/**
		*设置反射颜色。
		*@param value 反射颜色。
		*/
		__getset(0,__proto,'reflectColor',function(){
			return this._getColor(12);
			},function(value){
			this._setColor(12,value);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._getTexture(1);
			},function(value){
			if (value){
				this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_DIFFUSEMAP);
				}else {
				this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_DIFFUSEMAP);
			}
			this._setTexture(1,value);
		});

		/**
		*设置高光贴图。
		*@param value 高光贴图。
		*/
		/**
		*获取高光贴图。
		*@return 高光贴图。
		*/
		__getset(0,__proto,'specularTexture',function(){
			return this._getTexture(3);
			},function(value){
			if (value){
				this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_SPECULARMAP);
				}else {
				this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_SPECULARMAP);
			}
			this._setTexture(3,value);
		});

		/**
		*设置放射贴图。
		*@param value 放射贴图。
		*/
		/**
		*获取放射贴图。
		*@return 放射贴图。
		*/
		__getset(0,__proto,'emissiveTexture',function(){
			return this._getTexture(4);
			},function(value){
			if (value){
				this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_EMISSIVEMAP);
				}else {
				this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_EMISSIVEMAP);
			}
			this._setTexture(4,value);
		});

		/**
		*设置反射贴图。
		*@param value 反射贴图。
		*/
		/**
		*获取反射贴图。
		*@return 反射贴图。
		*/
		__getset(0,__proto,'reflectTexture',function(){
			return this._getTexture(6);
			},function(value){
			if (value){
				this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_REFLECTMAP);
				}else {
				this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_REFLECTMAP);
			}
			this._setTexture(6,value);
		});

		/**
		*设置UV变换。
		*@param value UV变换。
		*/
		/**
		*获取UV变换。
		*@return UV变换。
		*/
		__getset(0,__proto,'transformUV',function(){
			return this._transformUV;
			},function(value){
			this._transformUV=value;
			this._setMatrix4x4(13,value.matrix);
			if (value)
				this._addShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_UVTRANSFORM);
			else
			this._removeShaderDefine(laya.d3.core.material.StandardMaterial.SHADERDEFINE_UVTRANSFORM);
			if (this._conchMaterial){
				this._conchMaterial.setShaderValue(13,value.matrix.elements,0);
			}
		});

		StandardMaterial.load=function(url){
			return Laya.loader.create(url,null,null,StandardMaterial);
		}

		StandardMaterial._parseStandardMaterial=function(textureMap,material,json){
			var customProps=json.customProps;
			var ambientColorValue=customProps.ambientColor;
			material.ambientColor=new Vector3(ambientColorValue[0],ambientColorValue[1],ambientColorValue[2]);
			var diffuseColorValue=customProps.diffuseColor;
			material.diffuseColor=new Vector3(diffuseColorValue[0],diffuseColorValue[1],diffuseColorValue[2]);
			var specularColorValue=customProps.specularColor;
			material.specularColor=new Vector4(specularColorValue[0],specularColorValue[1],specularColorValue[2],specularColorValue[3]);
			var reflectColorValue=customProps.reflectColor;
			material.reflectColor=new Vector3(reflectColorValue[0],reflectColorValue[1],reflectColorValue[2]);
			var diffuseTexture=customProps.diffuseTexture.texture2D;
			(diffuseTexture)&& (material.diffuseTexture=Loader.getRes(textureMap[diffuseTexture]));
			var normalTexture=customProps.normalTexture.texture2D;
			(normalTexture)&& (material.normalTexture=Loader.getRes(textureMap[normalTexture]));
			var specularTexture=customProps.specularTexture.texture2D;
			(specularTexture)&& (material.specularTexture=Loader.getRes(textureMap[specularTexture]));
			var emissiveTexture=customProps.emissiveTexture.texture2D;
			(emissiveTexture)&& (material.emissiveTexture=Loader.getRes(textureMap[emissiveTexture]));
			var ambientTexture=customProps.ambientTexture.texture2D;
			(ambientTexture)&& (material.ambientTexture=Loader.getRes(textureMap[ambientTexture]));
			var reflectTexture=customProps.reflectTexture.texture2D;
			(reflectTexture)&& (material.reflectTexture=Loader.getRes(textureMap[reflectTexture]));
		}

		StandardMaterial.RENDERMODE_OPAQUE=1;
		StandardMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		StandardMaterial.RENDERMODE_CUTOUT=3;
		StandardMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
		StandardMaterial.RENDERMODE_TRANSPARENT=13;
		StandardMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
		StandardMaterial.RENDERMODE_ADDTIVE=15;
		StandardMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
		StandardMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
		StandardMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
		StandardMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
		StandardMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
		StandardMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
		StandardMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
		StandardMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
		StandardMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
		StandardMaterial.SHADERDEFINE_DIFFUSEMAP=0;
		StandardMaterial.SHADERDEFINE_NORMALMAP=0;
		StandardMaterial.SHADERDEFINE_SPECULARMAP=0;
		StandardMaterial.SHADERDEFINE_EMISSIVEMAP=0;
		StandardMaterial.SHADERDEFINE_AMBIENTMAP=0;
		StandardMaterial.SHADERDEFINE_REFLECTMAP=0;
		StandardMaterial.SHADERDEFINE_UVTRANSFORM=0;
		StandardMaterial.DIFFUSETEXTURE=1;
		StandardMaterial.NORMALTEXTURE=2;
		StandardMaterial.SPECULARTEXTURE=3;
		StandardMaterial.EMISSIVETEXTURE=4;
		StandardMaterial.AMBIENTTEXTURE=5;
		StandardMaterial.REFLECTTEXTURE=6;
		StandardMaterial.ALBEDO=7;
		StandardMaterial.UVANIAGE=8;
		StandardMaterial.MATERIALAMBIENT=9;
		StandardMaterial.MATERIALDIFFUSE=10;
		StandardMaterial.MATERIALSPECULAR=11;
		StandardMaterial.MATERIALREFLECT=12;
		StandardMaterial.UVMATRIX=13;
		StandardMaterial.UVAGE=14;
		__static(StandardMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new StandardMaterial();}
		]);
		return StandardMaterial;
	})(BaseMaterial)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.material.TerrainMaterial extends laya.d3.core.material.BaseMaterial
	var TerrainMaterial=(function(_super){
		function TerrainMaterial(){
			this._diffuseScale1=null;
			this._diffuseScale2=null;
			this._diffuseScale3=null;
			this._diffuseScale4=null;
			this._renderMode=0;
			TerrainMaterial.__super.call(this);
			this.setShaderName("Terrain");
			this.renderMode=1;
			this._diffuseScale1=new Vector2();
			this._diffuseScale2=new Vector2();
			this._diffuseScale3=new Vector2();
			this._diffuseScale4=new Vector2();
			this.ambientColor=new Vector3(0.6,0.6,0.6);
			this.diffuseColor=new Vector3(1.0,1.0,1.0);
			this.specularColor=new Vector4(0.2,0.2,0.2,32.0);
		}

		__class(TerrainMaterial,'laya.d3.core.material.TerrainMaterial',_super);
		var __proto=TerrainMaterial.prototype;
		__proto.setDiffuseScale1=function(x,y){
			this._diffuseScale1.x=x;
			this._diffuseScale1.y=y;
			this._setColor(6,this._diffuseScale1);
		}

		__proto.setDiffuseScale2=function(x,y){
			this._diffuseScale2.x=x;
			this._diffuseScale2.y=y;
			this._setColor(7,this._diffuseScale2);
		}

		__proto.setDiffuseScale3=function(x,y){
			this._diffuseScale3.x=x;
			this._diffuseScale3.y=y;
			this._setColor(8,this._diffuseScale3);
		}

		__proto.setDiffuseScale4=function(x,y){
			this._diffuseScale4.x=x;
			this._diffuseScale4.y=y;
			this._setColor(9,this._diffuseScale4);
		}

		__proto.setDetailNum=function(value){
			switch(value){
				case 1:
					this._addShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					break ;
				case 2:
					this._addShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					break ;
				case 3:
					this._addShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					break ;
				case 4:
					this._addShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
					this._removeShaderDefine(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
					break ;
				}
		}

		/**
		*@inheritDoc
		*/
		__proto.setShaderName=function(name){
			_super.prototype.setShaderName.call(this,name);
		}

		/**
		*@inheritDoc
		*/
		__proto._setMaterialShaderParams=function(state){}
		/**
		*@inheritDoc
		*/
		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var dest=destObject;
			dest._renderMode=this._renderMode;
		}

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		/**
		*获取渲染状态。
		*@return 渲染状态。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			this._renderMode=value;
			switch (value){
				case 1:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.depthTest=true;
					this.cull=2;
					this.blend=0;
					this.depthFunc=0x0201;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 2:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=false;
					this.depthTest=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.depthFunc=0x0203;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				default :
					throw new Error("TerrainMaterial:renderMode value error.");
				}
			this._conchMaterial && this._conchMaterial.setRenderMode(value);
		});

		/**
		*设置第二层贴图。
		*@param value 第二层贴图。
		*/
		/**
		*获取第二层贴图。
		*@return 第二层贴图。
		*/
		__getset(0,__proto,'diffuseTexture2',function(){
			return this._getTexture(3);
			},function(value){
			this._setTexture(3,value);
		});

		__getset(0,__proto,'ambientColor',function(){
			return this._getColor(10);
			},function(value){
			this._setColor(10,value);
		});

		/**
		*设置第四层贴图。
		*@param value 第四层贴图。
		*/
		/**
		*获取第四层贴图。
		*@return 第四层贴图。
		*/
		__getset(0,__proto,'diffuseTexture4',function(){
			return this._getTexture(5);
			},function(value){
			this._setTexture(5,value);
		});

		__getset(0,__proto,'diffuseColor',function(){
			return this._getColor(11);
			},function(value){
			this._setColor(11,value);
		});

		/**
		*设置第一层贴图。
		*@param value 第一层贴图。
		*/
		/**
		*获取第一层贴图。
		*@return 第一层贴图。
		*/
		__getset(0,__proto,'diffuseTexture1',function(){
			return this._getTexture(2);
			},function(value){
			this._setTexture(2,value);
		});

		__getset(0,__proto,'specularColor',function(){
			return this._getColor(12);
			},function(value){
			this._setColor(12,value);
		});

		/**
		*设置第三层贴图。
		*@param value 第三层贴图。
		*/
		/**
		*获取第三层贴图。
		*@return 第三层贴图。
		*/
		__getset(0,__proto,'diffuseTexture3',function(){
			return this._getTexture(4);
			},function(value){
			this._setTexture(4,value);
		});

		/**
		*设置splatAlpha贴图。
		*@param value splatAlpha贴图。
		*/
		/**
		*获取splatAlpha贴图。
		*@return splatAlpha贴图。
		*/
		__getset(0,__proto,'splatAlphaTexture',function(){
			return this._getTexture(0);
			},function(value){
			this._setTexture(0,value);
		});

		__getset(0,__proto,'normalTexture',function(){
			return this._getTexture(1);
			},function(value){
			this._setTexture(1,value);
		});

		TerrainMaterial.load=function(url){
			return Laya.loader.create(url,null,null,TerrainMaterial);
		}

		TerrainMaterial.RENDERMODE_OPAQUE=1;
		TerrainMaterial.RENDERMODE_TRANSPARENT=2;
		TerrainMaterial.SPLATALPHATEXTURE=0;
		TerrainMaterial.NORMALTEXTURE=1;
		TerrainMaterial.DIFFUSETEXTURE1=2;
		TerrainMaterial.DIFFUSETEXTURE2=3;
		TerrainMaterial.DIFFUSETEXTURE3=4;
		TerrainMaterial.DIFFUSETEXTURE4=5;
		TerrainMaterial.DIFFUSESCALE1=6;
		TerrainMaterial.DIFFUSESCALE2=7;
		TerrainMaterial.DIFFUSESCALE3=8;
		TerrainMaterial.DIFFUSESCALE4=9;
		TerrainMaterial.MATERIALAMBIENT=10;
		TerrainMaterial.MATERIALDIFFUSE=11;
		TerrainMaterial.MATERIALSPECULAR=12;
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM1=0;
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM2=0;
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM3=0;
		TerrainMaterial.SHADERDEFINE_DETAIL_NUM4=0;
		__static(TerrainMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new TerrainMaterial();}
		]);
		return TerrainMaterial;
	})(BaseMaterial)


	//class laya.d3.core.material.WaterMaterial extends laya.d3.core.material.BaseMaterial
	var WaterMaterial=(function(_super){
		function WaterMaterial(){
			this._renderMode=0;
			this._startTm=0;
			WaterMaterial.__super.call(this);
			this._startTm=Laya.timer.currTimer;
			this.setShaderName("Water");
		}

		__class(WaterMaterial,'laya.d3.core.material.WaterMaterial',_super);
		var __proto=WaterMaterial.prototype;
		/**
		*禁用雾化。
		*/
		__proto.disableFog=function(){
			this._addDisablePublicShaderDefine(ShaderCompile3D.SHADERDEFINE_FOG);
		}

		/**
		*@private
		*/
		__proto._setMaterialShaderParams=function(state){}
		__proto.onAsynLoaded=function(url,data,params){
			_super.prototype.onAsynLoaded.call(this,url,data,params);
		}

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._getTexture(1);
			},function(value){
			this._setTexture(1,value);
		});

		/**
		*设置法线贴图。
		*@param value 法线贴图。
		*/
		/**
		*获取法线贴图。
		*@return 法线贴图。
		*/
		__getset(0,__proto,'normalTexture',function(){
			return this._getTexture(2);
			},function(value){
			this._setTexture(2,value);
		});

		__getset(0,__proto,'underWaterTexture',function(){
			return this._getTexture(3);
			},function(value){
			this._setTexture(3,value);
		});

		__getset(0,__proto,'deepColorTexture',function(){
			return this._getTexture(10);
			},function(v){
			this._setTexture(10,v);
		});

		__getset(0,__proto,'skyTexture',function(){
			return this._getTexture(11);
			},function(v){
			this._setTexture(11,v);
		});

		__getset(0,__proto,'detailTexture',function(){
			return this._getTexture(9);
			},function(value){
			this._setTexture(9,value);
		});

		__getset(0,__proto,'foamTexture',function(){
			return this._getTexture(17);
			},function(v){
			this._setTexture(17,v);
		});

		__getset(0,__proto,'waterInfoTexture',function(){
			return this._getTexture(16);
			},function(v){
			this._setTexture(16,v);
		});

		/**
		*对定点进行变换的纹理。现在不用
		*/
		__getset(0,__proto,'vertexDispTexture',function(){
			return this._getTexture(4);
			},function(value){
			this._setTexture(4,value);
		});

		__getset(0,__proto,'currentTm',function(){
			return this._getNumber(8);
			},function(v){
			this._setNumber(8,v-this._startTm);
		});

		__getset(0,__proto,'waveInfo',function(){
			return this._getBuffer(12);
			},function(v){
			this._setBuffer(12,v);
		});

		__getset(0,__proto,'waveInfoD',function(){
			return this._getBuffer(13);
			},function(v){
			this._setBuffer(13,v);
		});

		__getset(0,__proto,'waveMainDir',function(){
			return this._getNumber(14);
			},function(deg){
			this._setNumber(14,deg*Math.PI/180);
		});

		__getset(0,__proto,'geoWaveUVScale',function(){
			return this._getNumber(18);
			},function(v){
			this._setNumber(18,v);
		});

		__getset(0,__proto,'scrsize',null,function(v){
			this._setBuffer(15,v);
		});

		__getset(0,__proto,'seaColor',function(){
			return this._getBuffer(19);
			},function(v){
			this._setBuffer(19,v);
		});

		/**
		*获取渲染状态。
		*@return 渲染状态。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			this._renderMode=value;
			switch (value){
				case 1:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 2:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=0;
					this.blend=0;
					this.alphaTest=false;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 3:
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 13:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				default :
					throw new Error("PBRMaterial:renderMode value error.");
				}
		});

		WaterMaterial.load=function(url){
			return Laya.loader.create(url,null,null,WaterMaterial);
		}

		WaterMaterial.DIFFUSETEXTURE=1;
		WaterMaterial.NORMALTEXTURE=2;
		WaterMaterial.UNDERWATERTEXTURE=3;
		WaterMaterial.VERTEXDISPTEXTURE=4;
		WaterMaterial.UVANIAGE=5;
		WaterMaterial.UVMATRIX=6;
		WaterMaterial.UVAGE=7;
		WaterMaterial.CURTM=8;
		WaterMaterial.DETAILTEXTURE=9;
		WaterMaterial.DEEPCOLORTEXTURE=10;
		WaterMaterial.SKYTEXTURE=11;
		WaterMaterial.WAVEINFO=12;
		WaterMaterial.WAVEINFOD=13;
		WaterMaterial.WAVEMAINDIR=14;
		WaterMaterial.SCRSIZE=15;
		WaterMaterial.WATERINFO=16;
		WaterMaterial.FOAMTEXTURE=17;
		WaterMaterial.GEOWAVE_UV_SCALE=18;
		WaterMaterial.SEA_COLOR=19;
		WaterMaterial.SHADERDEFINE_SHOW_NORMAL=0;
		WaterMaterial.SHADERDEFINE_CUBE_ENV=0;
		WaterMaterial.SHADERDEFINE_HDR_ENV=0;
		WaterMaterial.RENDERMODE_OPAQUE=1;
		WaterMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		WaterMaterial.RENDERMODE_CUTOUT=3;
		WaterMaterial.RENDERMODE_CUTOUTDOUBLEFACE=4;
		WaterMaterial.RENDERMODE_TRANSPARENT=13;
		__static(WaterMaterial,
		['defaultMaterial',function(){return this.defaultMaterial=new WaterMaterial();}
		]);
		return WaterMaterial;
	})(BaseMaterial)


	/**
	*<code>IndexBuffer3D</code> 类用于创建索引缓冲。
	*/
	//class laya.d3.graphics.IndexBuffer3D extends laya.webgl.utils.Buffer
	var IndexBuffer3D=(function(_super){
		function IndexBuffer3D(indexType,indexCount,bufferUsage,canRead){
			this._indexType=null;
			this._indexTypeByteCount=0;
			this._indexCount=0;
			this._canRead=false;
			(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			(canRead===void 0)&& (canRead=false);
			IndexBuffer3D.__super.call(this);
			this._indexType=indexType;
			this._indexCount=indexCount;
			this._bufferUsage=bufferUsage;
			this._bufferType=/*laya.webgl.WebGLContext.ELEMENT_ARRAY_BUFFER*/0x8893;
			this._canRead=canRead;
			var byteLength=0;
			if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort")
				this._indexTypeByteCount=2;
			else if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte")
			this._indexTypeByteCount=1;
			else
			throw new Error("unidentification index type.");
			byteLength=this._indexTypeByteCount *indexCount;
			this._byteLength=byteLength;
			if (!Render.isConchNode){
				this._bind();
				Buffer._gl.bufferData(this._bufferType,byteLength,this._bufferUsage);
			}
			if (canRead){
				if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort")
					this._buffer=new Uint16Array(indexCount);
				else if (indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte")
				this._buffer=new Uint8Array(indexCount);
				this.memorySize=byteLength *2;
				}else {
				this.memorySize=byteLength;
			}
		}

		__class(IndexBuffer3D,'laya.d3.graphics.IndexBuffer3D',_super);
		var __proto=IndexBuffer3D.prototype;
		/**
		*设置数据。
		*@param data 索引数据。
		*@param bufferOffset 索引缓冲中的偏移。
		*@param dataStartIndex 索引数据的偏移。
		*@param dataCount 索引数据的数量。
		*/
		__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
			(bufferOffset===void 0)&& (bufferOffset=0);
			(dataStartIndex===void 0)&& (dataStartIndex=0);
			(dataCount===void 0)&& (dataCount=4294967295);
			var byteCount=0;
			if (this._indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort"){
				byteCount=2;
				if (dataStartIndex!==0 || dataCount!==4294967295)
					data=new Uint16Array(data.buffer,dataStartIndex *byteCount,dataCount);
				}else if (this._indexType==/*CLASS CONST:laya.d3.graphics.IndexBuffer3D.INDEXTYPE_UBYTE*/"ubyte"){
				byteCount=1;
				if (dataStartIndex!==0 || dataCount!==4294967295)
					data=new Uint8Array(data.buffer,dataStartIndex *byteCount,dataCount);
			}
			if (!Render.isConchNode){
				this._bind();
				Buffer._gl.bufferSubData(this._bufferType,bufferOffset *byteCount,data);
			}
			if (this._canRead){
				if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
					var maxLength=this._buffer.length-bufferOffset;
					if (dataCount > maxLength)
						dataCount=maxLength;
					for (var i=0;i < dataCount;i++)
					this._buffer[bufferOffset+i]=data[i];
					}else {
					this._buffer=data;
				}
			}
		}

		/**
		*获取索引数据。
		*@return 索引数据。
		*/
		__proto.getData=function(){
			if (this._canRead)
				return this._buffer;
			else
			throw new Error("Can't read data from VertexBuffer with only write flag!");
		}

		/**彻底销毁索引缓冲。*/
		__proto.dispose=function(){
			this._buffer=null;
			_super.prototype.dispose.call(this);
			this.memorySize=0;
		}

		/**
		*获取索引类型。
		*@return 索引类型。
		*/
		__getset(0,__proto,'indexType',function(){
			return this._indexType;
		});

		/**
		*获取索引类型字节数量。
		*@return 索引类型字节数量。
		*/
		__getset(0,__proto,'indexTypeByteCount',function(){
			return this._indexTypeByteCount;
		});

		/**
		*获取索引个数。
		*@return 索引个数。
		*/
		__getset(0,__proto,'indexCount',function(){
			return this._indexCount;
		});

		/**
		*获取是否可读。
		*@return 是否可读。
		*/
		__getset(0,__proto,'canRead',function(){
			return this._canRead;
		});

		IndexBuffer3D.INDEXTYPE_UBYTE="ubyte";
		IndexBuffer3D.INDEXTYPE_USHORT="ushort";
		IndexBuffer3D.create=function(indexType,indexCount,bufferUsage,canRead){
			(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			(canRead===void 0)&& (canRead=false);
			return new IndexBuffer3D(indexType,indexCount,bufferUsage,canRead);
		}

		return IndexBuffer3D;
	})(Buffer)


	/**
	*<code>VertexBuffer3D</code> 类用于创建顶点缓冲。
	*/
	//class laya.d3.graphics.VertexBuffer3D extends laya.webgl.utils.Buffer
	var VertexBuffer3D=(function(_super){
		function VertexBuffer3D(vertexDeclaration,vertexCount,bufferUsage,canRead){
			this._vertexDeclaration=null;
			this._vertexCount=0;
			this._canRead=false;
			(canRead===void 0)&& (canRead=false);
			VertexBuffer3D.__super.call(this);
			this._vertexDeclaration=vertexDeclaration;
			this._vertexCount=vertexCount;
			this._bufferUsage=bufferUsage;
			this._bufferType=/*laya.webgl.WebGLContext.ARRAY_BUFFER*/0x8892;
			this._canRead=canRead;
			var byteLength=this._vertexDeclaration.vertexStride *vertexCount;
			this.memorySize=byteLength;
			this._byteLength=byteLength;
			if (!Render.isConchNode){
				this._bind();
				Buffer._gl.bufferData(this._bufferType,byteLength,this._bufferUsage);
			}
			canRead && (this._buffer=new Float32Array(byteLength / 4));
		}

		__class(VertexBuffer3D,'laya.d3.graphics.VertexBuffer3D',_super);
		var __proto=VertexBuffer3D.prototype;
		/**
		*和索引缓冲一起绑定。
		*@param ib 索引缓冲。
		*/
		__proto.bindWithIndexBuffer=function(ib){
			(ib)&& (ib._bind());
			this._bind();
		}

		/**
		*设置数据。
		*@param data 顶点数据。
		*@param bufferOffset 顶点缓冲中的偏移。
		*@param dataStartIndex 顶点数据的偏移。
		*@param dataCount 顶点数据的数量。
		*/
		__proto.setData=function(data,bufferOffset,dataStartIndex,dataCount){
			(bufferOffset===void 0)&& (bufferOffset=0);
			(dataStartIndex===void 0)&& (dataStartIndex=0);
			(dataCount===void 0)&& (dataCount=4294967295);
			if (dataStartIndex!==0 || dataCount!==4294967295)
				data=new Float32Array(data.buffer,dataStartIndex *4,dataCount);
			if (!Render.isConchNode){
				this._bind();
				Buffer._gl.bufferSubData(this._bufferType,bufferOffset *4,data);
			}
			if (this._canRead){
				if (bufferOffset!==0 || dataStartIndex!==0 || dataCount!==4294967295){
					var maxLength=this._buffer.length-bufferOffset;
					if (dataCount > maxLength)
						dataCount=maxLength;
					for (var i=0;i < dataCount;i++)
					this._buffer[bufferOffset+i]=data[i];
					}else {
					this._buffer=data;
				}
			}
		}

		/**
		*获取顶点数据。
		*@return 顶点数据。
		*/
		__proto.getData=function(){
			if (this._canRead)
				return this._buffer;
			else
			throw new Error("Can't read data from VertexBuffer with only write flag!");
		}

		/**销毁顶点缓冲。*/
		__proto.detoryResource=function(){
			var elements=this._vertexDeclaration.getVertexElements();
			for (var i=0;i < elements.length;i++)
			WebGL.mainContext.disableVertexAttribArray(i);
			_super.prototype.detoryResource.call(this);
		}

		/**彻底销毁顶点缓冲。*/
		__proto.dispose=function(){
			_super.prototype.dispose.call(this);
			this._buffer=null;
			this._vertexDeclaration=null;
			this.memorySize=0;
		}

		/**
		*获取顶点结构声明。
		*@return 顶点结构声明。
		*/
		__getset(0,__proto,'vertexDeclaration',function(){
			return this._vertexDeclaration;
		});

		/**
		*获取顶点个数。
		*@return 顶点个数。
		*/
		__getset(0,__proto,'vertexCount',function(){
			return this._vertexCount;
		});

		/**
		*获取是否可读。
		*@return 是否可读。
		*/
		__getset(0,__proto,'canRead',function(){
			return this._canRead;
		});

		VertexBuffer3D.create=function(vertexDeclaration,vertexCount,bufferUsage,canRead){
			(bufferUsage===void 0)&& (bufferUsage=/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			(canRead===void 0)&& (canRead=false);
			return new VertexBuffer3D(vertexDeclaration,vertexCount,bufferUsage,canRead);
		}

		return VertexBuffer3D;
	})(Buffer)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.core.particleShuriKen.ShurikenParticleMaterial extends laya.d3.core.material.BaseMaterial
	var ShurikenParticleMaterial=(function(_super){
		function ShurikenParticleMaterial(){
			this._renderMode=0;
			ShurikenParticleMaterial.__super.call(this);
			this.setShaderName("PARTICLESHURIKEN");
			this._setColor(9,new Vector4(0.5,0.5,0.5,0.5));
			this.renderMode=8;
		}

		__class(ShurikenParticleMaterial,'laya.d3.core.particleShuriKen.ShurikenParticleMaterial',_super);
		var __proto=ShurikenParticleMaterial.prototype;
		/**
		*@inheritDoc
		*/
		__proto._setMaterialShaderParams=function(state){
			var particle=state.owner;
			var particleSystem=particle.particleSystem;
			var particleRender=particle.particleRender;
			var transform=particle.transform;
			var finalGravityE=ShurikenParticleMaterial._tempGravity.elements;
			var gravityE=particleSystem.gravity.elements;
			var gravityModifier=particleSystem.gravityModifier;
			finalGravityE[0]=gravityE[0] *gravityModifier;
			finalGravityE[1]=gravityE[1] *gravityModifier;
			finalGravityE[2]=gravityE[2] *gravityModifier;
			this._setBuffer(4,finalGravityE);
			this._setInt(8,particleSystem.simulationSpace);
			this._setBool(1,particleSystem.threeDStartRotation);
			this._setInt(2,particleSystem.scaleMode);
			this._setInt(6,particleRender.stretchedBillboardLengthScale);
			this._setInt(7,particleRender.stretchedBillboardSpeedScale);
			this._setNumber(3,particleSystem.currentTime);
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(url,data,params){
			var jsonData=data[0];
			if (jsonData.version){
				_super.prototype.onAsynLoaded.call(this,url,data,params);
				}else {
				var textureMap=data[1];
				var props=jsonData.props;
				for (var prop in props)
				this[prop]=props[prop];
				ShurikenParticleMaterial._parseShurikenParticleMaterial(textureMap,this,jsonData);
				this.event(/*laya.events.Event.LOADED*/"loaded",this);
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.cloneTo=function(destObject){
			_super.prototype.cloneTo.call(this,destObject);
			var dest=destObject;
			dest._renderMode=this._renderMode;
		}

		/**
		*设置渲染模式。
		*@return 渲染模式。
		*/
		/**
		*获取渲染状态。
		*@return 渲染状态。
		*/
		__getset(0,__proto,'renderMode',function(){
			return this._renderMode;
			},function(value){
			this._renderMode=value;
			switch (value){
				case 1:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=2;
					this.blend=0;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 2:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.OPAQUE*/1;
					this.depthWrite=true;
					this.cull=0;
					this.blend=0;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
					break ;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 13:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 14:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 15:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 16:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=true;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 5:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 6:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 7:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 8:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthWrite=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 9:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 10:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=0x0303;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 11:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=2;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				case 12:
					this._renderQueue=/*laya.d3.core.render.RenderQueue.TRANSPARENT*/2;
					this.depthTest=false;
					this.cull=0;
					this.blend=1;
					this.srcBlend=0x0302;
					this.dstBlend=1;
					this.event(/*laya.events.Event.RENDERQUEUE_CHANGED*/"renderqueuechanged",this);
					break ;
				default :
					throw new Error("Material:renderMode value error.");
				}
			this._conchMaterial && this._conchMaterial.setRenderMode(value);
		});

		/**
		*设置颜色。
		*@param value 颜色。
		*/
		/**
		*获取颜色。
		*@return 颜色。
		*/
		__getset(0,__proto,'tintColor',function(){
			return this._getColor(9);
			},function(value){
			this._setColor(9,value);
		});

		/**
		*设置漫反射贴图。
		*@param value 漫反射贴图。
		*/
		/**
		*获取漫反射贴图。
		*@return 漫反射贴图。
		*/
		__getset(0,__proto,'diffuseTexture',function(){
			return this._getTexture(0);
			},function(value){
			if (value)
				this._addShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
			else
			this._removeShaderDefine(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP);
			this._setTexture(5,value);
		});

		ShurikenParticleMaterial.load=function(url){
			return Laya.loader.create(url,null,null,ShurikenParticleMaterial);
		}

		ShurikenParticleMaterial._parseShurikenParticleMaterial=function(textureMap,material,json){
			var customProps=json.customProps;
			var diffuseTexture=customProps.diffuseTexture.texture2D;
			(diffuseTexture)&& (material.diffuseTexture=Loader.getRes(textureMap[diffuseTexture]));
			var tintColorValue=customProps.tintColor;
			(tintColorValue)&& (material.tintColor=new Vector4(tintColorValue[0],tintColorValue[1],tintColorValue[2],tintColorValue[3]));
		}

		ShurikenParticleMaterial.RENDERMODE_OPAQUE=1;
		ShurikenParticleMaterial.RENDERMODE_OPAQUEDOUBLEFACE=2;
		ShurikenParticleMaterial.RENDERMODE_TRANSPARENT=13;
		ShurikenParticleMaterial.RENDERMODE_TRANSPARENTDOUBLEFACE=14;
		ShurikenParticleMaterial.RENDERMODE_ADDTIVE=15;
		ShurikenParticleMaterial.RENDERMODE_ADDTIVEDOUBLEFACE=16;
		ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT=5;
		ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENTDOUBLEFACE=6;
		ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVE=7;
		ShurikenParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE=8;
		ShurikenParticleMaterial.RENDERMODE_NONDEPTH_TRANSPARENT=9;
		ShurikenParticleMaterial.RENDERMODE_NONDEPTH_TRANSPARENTDOUBLEFACE=10;
		ShurikenParticleMaterial.RENDERMODE_NONDEPTH_ADDTIVE=11;
		ShurikenParticleMaterial.RENDERMODE_NONDEPTH_ADDTIVEDOUBLEFACE=12;
		ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP=0;
		ShurikenParticleMaterial.THREEDSTARTROTATION=1;
		ShurikenParticleMaterial.SCALINGMODE=2;
		ShurikenParticleMaterial.CURRENTTIME=3;
		ShurikenParticleMaterial.GRAVITY=4;
		ShurikenParticleMaterial.DIFFUSETEXTURE=5;
		ShurikenParticleMaterial.STRETCHEDBILLBOARDLENGTHSCALE=6;
		ShurikenParticleMaterial.STRETCHEDBILLBOARDSPEEDSCALE=7;
		ShurikenParticleMaterial.SIMULATIONSPACE=8;
		ShurikenParticleMaterial.TINTCOLOR=9;
		ShurikenParticleMaterial._diffuseTextureIndex=0;
		__static(ShurikenParticleMaterial,
		['_tempGravity',function(){return this._tempGravity=new Vector3();},'defaultMaterial',function(){return this.defaultMaterial=new ShurikenParticleMaterial();}
		]);
		return ShurikenParticleMaterial;
	})(BaseMaterial)


	/**
	*<code>Terrain</code> 类用于创建地块。
	*/
	//class laya.d3.terrain.Terrain extends laya.d3.core.Sprite3D
	var Terrain=(function(_super){
		function Terrain(terrainRes){
			this._terrainRes=null;
			Terrain.__super.call(this);
			if (terrainRes){
				this._terrainRes=terrainRes;
				if (terrainRes.loaded)
					this.buildTerrain(terrainRes);
				else
				terrainRes.once(/*laya.events.Event.LOADED*/"loaded",this,this.buildTerrain);
			}
		}

		__class(Terrain,'laya.d3.terrain.Terrain',_super);
		var __proto=Terrain.prototype;
		__proto.buildTerrain=function(terrainRes){
			var chunkNumX=terrainRes._chunkNumX;
			var chunkNumZ=terrainRes._chunkNumZ;
			var heightData=terrainRes._heightData;
			var n=0;
			for (var i=0;i < chunkNumZ;i++){
				for (var j=0;j < chunkNumX;j++){
					var terrainChunk=new TerrainChunk(j,i,terrainRes._gridSize,heightData._terrainHeightData,heightData._width,heightData._height);
					var chunkInfo=terrainRes._chunkInfos[n++];
					for (var k=0;k < chunkInfo.alphaMap.length;k++){
						var nNum=chunkInfo.detailID[k].length;
						var sDetialTextureUrl1=(nNum > 0)? terrainRes._detailTextureInfos[ chunkInfo.detailID[k][0]].diffuseTexture :null;
						var sDetialTextureUrl2=(nNum > 1)? terrainRes._detailTextureInfos[ chunkInfo.detailID[k][1]].diffuseTexture :null;
						var sDetialTextureUrl3=(nNum > 2)? terrainRes._detailTextureInfos[ chunkInfo.detailID[k][2]].diffuseTexture :null;
						var sDetialTextureUrl4=(nNum > 3)? terrainRes._detailTextureInfos[ chunkInfo.detailID[k][3]].diffuseTexture :null;
						var detialScale1=(nNum > 0)? terrainRes._detailTextureInfos[ chunkInfo.detailID[k][0]].scale :null;
						var detialScale2=(nNum > 1)? terrainRes._detailTextureInfos[ chunkInfo.detailID[k][1]].scale :null;
						var detialScale3=(nNum > 2)? terrainRes._detailTextureInfos[ chunkInfo.detailID[k][2]].scale :null;
						var detialScale4=(nNum > 3)? terrainRes._detailTextureInfos[ chunkInfo.detailID[k][3]].scale :null;
						terrainChunk.buildRenderElementAndMaterial(nNum,chunkInfo.normalMap,chunkInfo.alphaMap[k],sDetialTextureUrl1,sDetialTextureUrl2,sDetialTextureUrl3,sDetialTextureUrl4,
						detialScale1?detialScale1.x:1,detialScale1?detialScale1.y:1,detialScale2?detialScale2.x:1,detialScale2?detialScale2.y:1,
						detialScale3?detialScale3.x:1,detialScale3?detialScale3.y:1,detialScale4?detialScale4.x:1,detialScale4?detialScale4.y:1);
					}
					terrainChunk.terrainRender.receiveShadow=true;
					this.addChild(terrainChunk);
				}
			}
		}

		/**
		*获取地形X轴长度。
		*@return 地形X轴长度。
		*/
		__proto.width=function(){
			return this._terrainRes._chunkNumX*TerrainLeaf.CHUNK_GRID_NUM *this._terrainRes._gridSize;
		}

		/**
		*获取地形Z轴长度。
		*@return 地形Z轴长度。
		*/
		__proto.depth=function(){
			return this._terrainRes._chunkNumZ *TerrainLeaf.CHUNK_GRID_NUM *this._terrainRes._gridSize;
		}

		/**
		*获取地形高度。
		*@param x X轴坐标。
		*@param z Z轴坐标。
		*/
		__proto.getHeightXZ=function(x,z){
			if (!this._terrainRes || !this._terrainRes.loaded)
				return NaN;
			x-=this.transform.position.x;
			z-=this.transform.position.z;
			if (x < 0 || x > this.width()|| z < 0 || z > this.depth())
				return NaN;
			var gridSize=this._terrainRes._gridSize;
			var nIndexX=parseInt(""+x / gridSize);
			var nIndexZ=parseInt(""+z / gridSize);
			var offsetX=x-nIndexX *gridSize;
			var offsetZ=z-nIndexZ *gridSize;
			var h1=NaN;
			var h2=NaN;
			var h3=NaN;
			var u=NaN;
			var v=NaN;
			var heightData=this._terrainRes._heightData;
			if(offsetX+offsetZ > gridSize){
				h1=heightData._terrainHeightData[(nIndexZ+1-1)*heightData._width+nIndexX+1];
				h2=heightData._terrainHeightData[(nIndexZ+1-1)*heightData._width+nIndexX];
				h3=heightData._terrainHeightData[(nIndexZ-1)*heightData._width+nIndexX+1];
				u=(gridSize-offsetX)/ gridSize;
				v=(gridSize-offsetZ)/ gridSize;
				return h1+(h2-h1)*u+(h3-h1)*v;
			}
			else{
				h1=heightData._terrainHeightData[Math.max(0.0,nIndexZ-1)*heightData._width+nIndexX];
				h2=heightData._terrainHeightData[Math.min(heightData._width *heightData._height-1,(nIndexZ+1-1)*heightData._width+nIndexX)];
				h3=heightData._terrainHeightData[Math.min(heightData._width *heightData._height-1,Math.max(0.0,nIndexZ-1)*heightData._width+nIndexX+1)];
				u=offsetX / gridSize;
				v=offsetZ / gridSize;
				return h1+(h2-h1)*v+(h3-h1)*u;
			}
		}

		Terrain.load=function(url){
			return Laya.loader.create(url,null,null,Terrain,null,1,false);
		}

		Terrain.RENDER_LINE_MODEL=false;
		Terrain.LOD_TOLERANCE_VALUE=4;
		Terrain.LOD_DISTANCE_FACTOR=2.0;
		return Terrain;
	})(Sprite3D)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.water.WaterDetailMaterial extends laya.d3.core.material.BaseMaterial
	var WaterDetailMaterial=(function(_super){
		function WaterDetailMaterial(){
			this._startTm=0;
			WaterDetailMaterial.__super.call(this);
			laya.d3.water.WaterDetailMaterial.init();
			this.setShaderName('WaterDetail');
			this.cull=0;
			this._startTm=Laya.timer.currTimer;
		}

		__class(WaterDetailMaterial,'laya.d3.water.WaterDetailMaterial',_super);
		var __proto=WaterDetailMaterial.prototype;
		__getset(0,__proto,'currentTm',function(){
			return this._getNumber(1);
			},function(v){
			this._setNumber(1,v-this._startTm);
		});

		__getset(0,__proto,'waveInfo',function(){
			return this._getBuffer(12);
			},function(v){
			this._setBuffer(12,v);
		});

		__getset(0,__proto,'waveInfoD',function(){
			return this._getBuffer(13);
			},function(v){
			this._setBuffer(13,v);
		});

		__getset(0,__proto,'texWaveUVScale',function(){
			return this._getNumber(15);
			},function(v){
			this._setNumber(15,v);
		});

		WaterDetailMaterial.init=function(){
			if (laya.d3.water.WaterDetailMaterial._bInited)
				return;
			laya.d3.water.WaterDetailMaterial._bInited=true;
			var attributeMap={
				'a_position':/*laya.d3.graphics.VertexElementUsage.POSITION0*/0,
				'a_normal':/*laya.d3.graphics.VertexElementUsage.NORMAL0*/3,
				'uv':/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2
			};
			var uniformMap={
				'u_curTm':[1,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_WaveInfo':[12,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'u_WaveInfoD':[13,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1],
				'TEXWAVE_UV_SCALE':[15,/*laya.d3.shader.Shader3D.PERIOD_MATERIAL*/1]
			};
			var WaterDetail=Shader3D.nameKey.add("WaterDetail");
			var vs="\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 uv;\n\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec3 vWorldTangent;\nvarying vec3 vWorldBinormal;\n\n\nvoid main() {\n	vec3 pos = a_position;\n	if(pos.z!=0.)pos.y=pos.z;\n	pos.z=0.5;\n	gl_Position = vec4(pos,1.);\n    vUv = uv;\n	//vWorldNorm = normalize((modelMat*vec4(a_normal,0.0)).xyz);\n	//vWorldTangent = normalize((modelMat*vec4(tangent,0.0)).xyz);\n	//vWorldBinormal = normalize((modelMat*vec4(binormal,0.0)).xyz);\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/water/WaterDetailVS.glsl*/;
			var ps="precision highp float;\nprecision lowp int;\n\nconst float PI = 3.14159265358979323846264;\nconst float _2PI = 6.2831853071796;\nvarying vec2 vUv;\nvarying vec3 vWorldNorm;\nvarying vec3 vWorldTangent;\nvarying vec3 vWorldBinormal;\n\nuniform float u_curTm;\n\n#include \"WaveFunction.glsl\"\n\nvoid main() {\n	vec3 wave_N,wave_B,wave_T;\n	calcWave(u_curTm, vUv,wave_B,wave_T,wave_N);\n	gl_FragColor.rgb = normalize(wave_N)*0.5+vec3(0.5);// vec3(0.1,.4,0.1);\n    gl_FragColor.a = 1.0;\n}\n"/*__INCLUDESTR__D:/LayaPublishWork/LayaWorkDir/LayaAir/publish/LayaAirPublish/src/d3/src/laya/d3/water/WaterDetailFS.glsl*/;
			var shaderCompile=ShaderCompile3D.add(WaterDetail,vs,ps,attributeMap,uniformMap);
		}

		WaterDetailMaterial.CURTM=1;
		WaterDetailMaterial.WAVEINFO=12;
		WaterDetailMaterial.WAVEINFOD=13;
		WaterDetailMaterial.WAVEMAINDIR=14;
		WaterDetailMaterial.TEXWAVE_UV_SCALE=15;
		WaterDetailMaterial._bInited=false;
		return WaterDetailMaterial;
	})(BaseMaterial)


	/**
	*<code>CameraAnimations</code> 类用于创建摄像机动画组件。
	*/
	//class laya.d3.component.animation.CameraAnimations extends laya.d3.component.animation.KeyframeAnimations
	var CameraAnimations=(function(_super){
		function CameraAnimations(){
			this._tempCurAnimationData=null;
			this._lastFrameIndex=-1;
			this._currentTransform=null;
			this._originalAnimationTransform=null;
			this._originalFov=0;
			this._camera=null;
			this._cacheAnimationDatas=[];
			this._currentAnimationData=null;
			this.localMode=true;
			this.addMode=true;
			this._tempVector30=new Vector3();
			this._tempVector31=new Vector3();
			this._tempVector32=new Vector3();
			CameraAnimations.__super.call(this);
		}

		__class(CameraAnimations,'laya.d3.component.animation.CameraAnimations',_super);
		var __proto=CameraAnimations.prototype;
		/**
		*@private
		*摄像机动画作用函数。
		*/
		__proto._effect=function(){
			var i=0;
			for (i=0;i < 3;i++){
				this._tempVector30.elements[i]=this._currentAnimationData[i];
				this._tempVector31.elements[i]=this._currentAnimationData[i+3];
				this._tempVector32.elements[i]=this._currentAnimationData[i+6];
			}
			this._currentTransform || (this._currentTransform=new Matrix4x4());
			Matrix4x4.createLookAt(this._tempVector30,this._tempVector31,this._tempVector32,this._currentTransform);
			this._currentTransform.invert(this._currentTransform);
			if (this.addMode){
				Matrix4x4.multiply(this._originalAnimationTransform,this._currentTransform,this._currentTransform);
			}
			if (this.localMode)
				this.owner.transform.localMatrix=this._currentTransform;
			else
			this.owner.transform.worldMatrix=this._currentTransform;
			this._camera.fieldOfView=this._currentAnimationData[9];
		}

		/**
		*@private
		*初始化载入摄像机动画组件。
		*@param owner 所属精灵对象。
		*/
		__proto._load=function(owner){
			var _$this=this;
			if ((owner instanceof laya.d3.core.Camera ))
				this._camera=owner;
			else
			throw new Error("该Sprite3D并非Camera");
			this._player.on(/*laya.events.Event.STOPPED*/"stopped",this,function(){
				if (_$this._player.returnToZeroStopped){
					if (_$this.localMode)
						_$this._originalAnimationTransform && (owner.transform.localMatrix=_$this._originalAnimationTransform);
					else
					_$this._originalAnimationTransform && (owner.transform.worldMatrix=_$this._originalAnimationTransform);
					_$this._camera.fieldOfView=_$this._originalFov;
				}
			});
		}

		/**
		*@private
		*更新摄像机动画组件。
		*@param state 渲染状态。
		*/
		__proto._update=function(state){
			if (!this._templet || !this._templet.loaded || this._player.state!==/*laya.ani.AnimationState.playing*/2)
				return;
			var rate=this._player.playbackRate *Laya.timer.scale;
			var frameIndex=(this._player.isCache && rate >=1.0)? this.currentFrameIndex :-1;
			var animationClipIndex=this.currentAnimationClipIndex;
			if (frameIndex!==-1 && this._lastFrameIndex===frameIndex){
				laya.d3.component.Component3D.prototype._update.call(this,state);
				return;
			}
			if (this._player.isCache && rate >=1.0){
				var cache=this._templet.getAnimationDataWithCache(this._player.cacheFrameRate,this._cacheAnimationDatas,animationClipIndex,frameIndex);
				if (cache){
					this._currentAnimationData=cache;
					this._lastFrameIndex=frameIndex;
					laya.d3.component.Component3D.prototype._update.call(this,state);
					this._effect();
					return;
				}
			};
			var nodes=this._templet.getNodes(animationClipIndex);
			var nodeCount=nodes.length;
			if (this._player.isCache && rate >=1.0){
				this._currentAnimationData=new Float32Array(nodeCount *10);
				}else{
				(this._tempCurAnimationData)|| (this._tempCurAnimationData=new Float32Array(nodeCount *10));
				this._currentAnimationData=this._tempCurAnimationData;
			}
			if (this._player.isCache && rate >=1.0)
				this._templet.getOriginalData(animationClipIndex,this._currentAnimationData,this._player._fullFrames[animationClipIndex],frameIndex,this._player.currentPlayTime);
			else
			this._templet.getOriginalDataUnfixedRate(animationClipIndex,this._currentAnimationData,this._player.currentPlayTime);
			if (this._player.isCache && rate >=1.0){
				this._templet.setAnimationDataWithCache(this._player.cacheFrameRate,this._cacheAnimationDatas,animationClipIndex,frameIndex,this._currentAnimationData);
			}
			this._lastFrameIndex=frameIndex;
			laya.d3.component.Component3D.prototype._update.call(this,state);
			this._effect();
		}

		return CameraAnimations;
	})(KeyframeAnimations)


	/**
	*<code>RigidAnimations</code> 类用于创建变换动画组件。
	*/
	//class laya.d3.component.animation.RigidAnimations extends laya.d3.component.animation.KeyframeAnimations
	var RigidAnimations=(function(_super){
		function RigidAnimations(){
			this._animationSprites=null;
			this._animationSpritesInitLocalMatrix=null;
			this._tempCurAnimationData=null;
			this._curOriginalData=null;
			this._lastFrameIndex=-1;
			this._curAnimationDatas=null;
			RigidAnimations.__super.call(this);
			this._animationSprites=[];
			this._animationSpritesInitLocalMatrix=[];
		}

		__class(RigidAnimations,'laya.d3.component.animation.RigidAnimations',_super);
		var __proto=RigidAnimations.prototype;
		/**
		*@private
		*/
		__proto._init=function(){
			var nodes=this._templet.getNodes(this.currentAnimationClipIndex);
			var curParentSprite=this._owner;
			var nodeLength=nodes.length;
			var pathStart=0;
			var extentDatas=new Uint16Array(this._templet.getPublicExtData());
			for (var i=0;i < nodeLength;i++){
				var hierarchys=extentDatas.slice(pathStart+1,pathStart+1+extentDatas[pathStart]);
				pathStart+=(extentDatas[pathStart]+1);
				for (var j=1;j < hierarchys.length;j++){
					var childIndex=hierarchys[j];
					curParentSprite=curParentSprite._childs[hierarchys[j]];
				};
				var curSprite=curParentSprite.getChildByName(nodes[i].name);
				if (!curSprite)
					break ;
				this._animationSprites[i]=curSprite;
				var localMatrix=this._animationSpritesInitLocalMatrix[i];
				(localMatrix)|| (localMatrix=this._animationSpritesInitLocalMatrix[i]=new Matrix4x4());
				curSprite.transform.localMatrix.cloneTo(localMatrix);
				curParentSprite=this._owner;
			}
		}

		/**
		*@private
		*/
		__proto._animtionPlay=function(){
			if (this._templet.loaded)
				this._init();
			else
			this._templet.once(/*laya.events.Event.LOADED*/"loaded",this,this._init);
		}

		/**
		*@private
		*/
		__proto._animtionStop=function(){
			this._lastFrameIndex=-1;
			if (this._player.returnToZeroStopped){
				this._curAnimationDatas=null;
				for (var i=0;i < this._animationSprites.length;i++)
				this._animationSprites[i].transform.localMatrix=this._animationSpritesInitLocalMatrix[i];
			}
		}

		/**
		*@private
		*摄像机动画作用函数。
		*/
		__proto._effectAnimation=function(nodes){
			for (var nodeIndex=0,nodeLength=this._animationSprites.length;nodeIndex < nodeLength;nodeIndex++){
				var sprite=this._animationSprites[nodeIndex];
				var matrix=sprite.transform.localMatrix;
				var matrixE=matrix.elements;
				for (var i=0;i < 16;i++)
				matrixE[i]=this._curAnimationDatas[nodeIndex *16+i];
				sprite.transform.localMatrix=matrix;
			}
		}

		/**
		*@private
		*初始化载入摄像机动画组件。
		*@param owner 所属精灵对象。
		*/
		__proto._load=function(owner){
			_super.prototype._load.call(this,owner);
			this._player.on(/*laya.events.Event.STOPPED*/"stopped",this,this._animtionStop);
			this._player.on(/*laya.events.Event.PLAYED*/"played",this,this._animtionPlay);
		}

		/**
		*@private
		*更新摄像机动画组件。
		*@param state 渲染状态。
		*/
		__proto._update=function(state){
			if (this._player.state!==/*laya.ani.AnimationState.playing*/2 || !this._templet || !this._templet.loaded)
				return;
			var rate=this._player.playbackRate *Laya.timer.scale;
			var cachePlayRate=this._player.cachePlayRate;
			var isCache=this._player.isCache && rate >=cachePlayRate;
			var frameIndex=isCache ? this.currentFrameIndex :-1;
			if (frameIndex!==-1 && this._lastFrameIndex===frameIndex)
				return;
			var animationClipIndex=this.currentAnimationClipIndex;
			var nodes=this._templet.getNodes(animationClipIndex);
			var animationDatasCache=this._templet._animationDatasCache;
			if (isCache){
				var cacheData=this._templet.getAnimationDataWithCache(cachePlayRate,animationDatasCache,animationClipIndex,frameIndex);
				if (cacheData){
					this._curAnimationDatas=cacheData;
					this._lastFrameIndex=frameIndex;
					this._effectAnimation(nodes);
					return;
				}
			};
			var nodeFloatCount=nodes.length *16;
			if (isCache){
				this._curAnimationDatas=new Float32Array(nodeFloatCount);
				}else{
				(this._tempCurAnimationData)|| (this._tempCurAnimationData=new Float32Array(nodeFloatCount));
				this._curAnimationDatas=this._tempCurAnimationData;
			}
			this._curOriginalData || (this._curOriginalData=new Float32Array(this._templet.getTotalkeyframesLength(animationClipIndex)));
			if (isCache)
				this._templet.getOriginalData(animationClipIndex,this._curOriginalData,this._player._fullFrames[animationClipIndex],frameIndex,this._player.currentFrameTime);
			else
			this._templet.getOriginalDataUnfixedRate(animationClipIndex,this._curOriginalData,this._player.currentPlayTime);
			Utils3D._computeRootAnimationData(nodes,this._curOriginalData,this._curAnimationDatas);
			if (isCache){
				this._templet.setAnimationDataWithCache(cachePlayRate,animationDatasCache,animationClipIndex,frameIndex,this._curAnimationDatas);
			}
			this._lastFrameIndex=frameIndex;
			this._effectAnimation(nodes);
		}

		/**
		*@private
		*卸载组件时执行。
		*/
		__proto._unload=function(owner){
			_super.prototype._unload.call(this,owner);
			this._animationSprites=null;
			this._animationSpritesInitLocalMatrix=null;
			this._tempCurAnimationData=null;
			this._curOriginalData=null;
			this._curAnimationDatas=null;
		}

		/**
		*设置url地址。
		*@param value 地址。
		*/
		__getset(0,__proto,'url',null,function(value){
			console.log("Warning: discard property,please use templet property instead.");
			var templet=Laya.loader.create(value,null,null,AnimationTemplet);
			if (this._templet!==templet){
				if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
					this._player.stop(true);
				this._templet=templet;
				this._player.templet=templet;
				this._curOriginalData=null;
				this._curAnimationDatas=null;
				this._tempCurAnimationData=null;
				(this._templet._animationDatasCache)|| (this._templet._animationDatasCache=[]);
				this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
			}
		});

		__getset(0,__proto,'templet',_super.prototype._$get_templet,function(value){
			if (this._templet!==value){
				if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
					this._player.stop(true);
				this._templet=value;
				this._player.templet=value;
				this._curOriginalData=null;
				this._curAnimationDatas=null;
				this._tempCurAnimationData=null;
				(this._templet._animationDatasCache)|| (this._templet._animationDatasCache=[]);
				this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
			}
		});

		return RigidAnimations;
	})(KeyframeAnimations)


	/**
	*<code>SkinAnimations</code> 类用于创建蒙皮动画组件。
	*/
	//class laya.d3.component.animation.SkinAnimations extends laya.d3.component.animation.KeyframeAnimations
	var SkinAnimations=(function(_super){
		function SkinAnimations(){
			this._tempCurAnimationData=null;
			this._tempCurBonesData=null;
			this._curOriginalData=null;
			this._extenData=null;
			this._lastFrameIndex=-1;
			this._curMeshAnimationData=null;
			this._curBonesDatas=null;
			this._curAnimationDatas=null;
			this._ownerMesh=null;
			this._boneIndexToMeshList=null;
			this._oldVersion=false;
			SkinAnimations.__super.call(this);
			this._boneIndexToMeshList=[];
		}

		__class(SkinAnimations,'laya.d3.component.animation.SkinAnimations',_super);
		var __proto=SkinAnimations.prototype;
		/**
		*@private
		*/
		__proto._computeBoneIndeToMeshOnTemplet=function(){
			if (this._templet.loaded)
				this._computeBoneIndeToMeshOnMesh();
			else
			this._templet.once(/*laya.events.Event.LOADED*/"loaded",this,this._computeBoneIndeToMeshOnMesh);
		}

		/**
		*@private
		*/
		__proto._computeBoneIndeToMeshOnMesh=function(){
			if (this._templet._aniVersion==="LAYAANIMATION:02")
				this._oldVersion=false;
			else
			this._oldVersion=true;
			var mesh=(this._owner).meshFilter.sharedMesh;
			if (mesh.loaded)
				this._computeBoneIndeToMesh(mesh);
			else
			mesh.on(/*laya.events.Event.LOADED*/"loaded",this,this._computeBoneIndeToMesh);
		}

		/**
		*@private
		*/
		__proto._computeBoneIndeToMesh=function(mesh){
			var meshBoneNames=mesh._boneNames;
			if (meshBoneNames){
				var binPoseCount=meshBoneNames.length;
				var anis=this._templet._anis;
				for (var i=0,n=anis.length;i < n;i++){
					var boneIndexToMesh=this._boneIndexToMeshList[i];
					(boneIndexToMesh)|| (boneIndexToMesh=this._boneIndexToMeshList[i]=[]);
					boneIndexToMesh.length=binPoseCount;
					var ani=anis[i];
					for (var j=0;j < binPoseCount;j++)
					boneIndexToMesh[j]=ani.bone3DMap[meshBoneNames[j]];
				}
			}
		}

		/**@private */
		__proto._getAnimationDatasWithCache=function(rate,mesh,cacheDatas,aniIndex,frameIndex){
			var aniDatas=cacheDatas[aniIndex];
			if (!aniDatas){
				return null;
				}else {
				var rateDatas=aniDatas[rate];
				if (!rateDatas)
					return null;
				else {
					var meshDatas=rateDatas[mesh.id];
					if (!meshDatas)
						return null;
					else
					return meshDatas[frameIndex];
				}
			}
		}

		/**@private */
		__proto._setAnimationDatasWithCache=function(rate,mesh,cacheDatas,aniIndex,frameIndex,animationDatas){
			var aniDatas=(cacheDatas[aniIndex])|| (cacheDatas[aniIndex]={});
			var rateDatas=(aniDatas[rate])|| (aniDatas[rate]={});
			var meshDatas=(rateDatas[mesh.id])|| (rateDatas[mesh.id]=[]);
			meshDatas[frameIndex]=animationDatas;
		}

		/**@private */
		__proto._onMeshLoaded=function(){
			(this.destroyed)|| (this._onAnimationPlayMeshLoaded);
		}

		/**@private */
		__proto._onAnimationPlayMeshLoaded=function(){
			var renderElements=this._ownerMesh.meshRender._renderElements;
			for (var i=0,n=renderElements.length;i < n;i++)
			renderElements[i]._canDynamicBatch=false;
		}

		/**@private */
		__proto._onAnimationPlay=function(){
			this._ownerMesh._addShaderDefine(laya.d3.component.animation.SkinAnimations.SHADERDEFINE_BONE);
			var mesh=this._ownerMesh.meshFilter.sharedMesh;
			if (mesh.loaded)
				this._onAnimationPlayMeshLoaded();
			else
			mesh.on(/*laya.events.Event.LOADED*/"loaded",this,this._onMeshLoaded);
		}

		/**@private */
		__proto._onAnimationStop=function(){
			this._lastFrameIndex=-1;
			if (this._player.returnToZeroStopped){
				this._curBonesDatas=null;
				this._curAnimationDatas=null;
				this._ownerMesh._removeShaderDefine(laya.d3.component.animation.SkinAnimations.SHADERDEFINE_BONE);
			};
			var renderElements=this._ownerMesh.meshRender._renderElements;
			for (var i=0,n=renderElements.length;i < n;i++)
			renderElements[i]._canDynamicBatch=true;
		}

		/**
		*@private
		*初始化载入蒙皮动画组件。
		*@param owner 所属精灵对象。
		*/
		__proto._load=function(owner){
			_super.prototype._load.call(this,owner);
			this._ownerMesh=(owner);
			this._player.on(/*laya.events.Event.PLAYED*/"played",this,this._onAnimationPlay);
			this._player.on(/*laya.events.Event.STOPPED*/"stopped",this,this._onAnimationStop);
			(this._owner).meshFilter.on(/*laya.events.Event.MESH_CHANGED*/"meshchanged",this,this._computeBoneIndeToMeshOnTemplet);
		}

		/**
		*@private
		*更新蒙皮动画组件。
		*@param state 渲染状态参数。
		*/
		__proto._update=function(state){
			var mesh=this._ownerMesh.meshFilter.sharedMesh;
			if (this._player.state!==/*laya.ani.AnimationState.playing*/2 || !this._templet || !this._templet.loaded || !mesh.loaded)
				return;
			var rate=this._player.playbackRate *Laya.timer.scale;
			var cachePlayRate=this._player.cachePlayRate;
			var isCache=this._player.isCache && rate >=cachePlayRate;
			var frameIndex=isCache ? this.currentFrameIndex :-1;
			if (frameIndex!==-1 && this._lastFrameIndex===frameIndex)
				return;
			var animationClipIndex=this.currentAnimationClipIndex;
			var boneDatasCache=this._templet._animationDatasCache[0];
			var animationDatasCache=this._templet._animationDatasCache[1];
			if (isCache){
				var cacheAnimationDatas=this._getAnimationDatasWithCache(cachePlayRate,mesh,animationDatasCache,animationClipIndex,frameIndex);
				if (cacheAnimationDatas){
					this._curAnimationDatas=cacheAnimationDatas;
					this._curBonesDatas=this._templet.getAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex);
					this._lastFrameIndex=frameIndex;
					return;
				}
			};
			var isCacheBonesDatas=false;
			if (isCache){
				this._curBonesDatas=this._templet.getAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex);
				isCacheBonesDatas=this._curBonesDatas ? true :false;
			};
			var bones=this._templet.getNodes(animationClipIndex);
			var boneFloatCount=bones.length *16;
			var inverseAbsoluteBindPoses=mesh.InverseAbsoluteBindPoses;
			if (this._oldVersion)
				(this._curMeshAnimationData)|| (this._curMeshAnimationData=new Float32Array(boneFloatCount *16));
			else
			(this._curMeshAnimationData)|| (this._curMeshAnimationData=new Float32Array(inverseAbsoluteBindPoses.length *16));
			var i=0,n=0,j=0;
			var curSubAnimationDatas,subMesh,boneIndicesCount=0;
			var subMeshCount=mesh.getSubMeshCount();
			if (isCache){
				this._curAnimationDatas=[];
				this._curAnimationDatas.length=subMeshCount;
				for (i=0;i < subMeshCount;i++){
					curSubAnimationDatas=this._curAnimationDatas[i]=[];
					subMesh=mesh.getSubMesh(i);
					boneIndicesCount=subMesh._boneIndicesList.length;
					curSubAnimationDatas.length=boneIndicesCount;
					for (j=0;j < boneIndicesCount;j++)
					curSubAnimationDatas[j]=new Float32Array(subMesh._boneIndicesList[j].length *16);
				}
				(isCacheBonesDatas)|| (this._curBonesDatas=new Float32Array(boneFloatCount));
				}else {
				if (!this._tempCurAnimationData){
					this._tempCurAnimationData=[];
					this._tempCurAnimationData.length=subMeshCount;
					for (i=0;i < subMeshCount;i++){
						curSubAnimationDatas=this._tempCurAnimationData[i]=[];
						subMesh=mesh.getSubMesh(i);
						boneIndicesCount=subMesh._boneIndicesList.length;
						curSubAnimationDatas.length=boneIndicesCount;
						for (j=0;j < boneIndicesCount;j++)
						curSubAnimationDatas[j]=new Float32Array(subMesh._boneIndicesList[j].length *16);
					}
				}
				(this._tempCurBonesData)|| (this._tempCurBonesData=new Float32Array(boneFloatCount));
				this._curAnimationDatas=this._tempCurAnimationData;
				this._curBonesDatas=this._tempCurBonesData;
			}
			this._curOriginalData || (this._curOriginalData=new Float32Array(this._templet.getTotalkeyframesLength(animationClipIndex)));
			if (isCache)
				this._templet.getOriginalData(animationClipIndex,this._curOriginalData,this._player._fullFrames[animationClipIndex],frameIndex,this._player.currentFrameTime);
			else
			this._templet.getOriginalDataUnfixedRate(animationClipIndex,this._curOriginalData,this._player.currentPlayTime);
			if (inverseAbsoluteBindPoses){
				if (this._oldVersion){
					if (isCache && isCacheBonesDatas)
						Utils3D._computeAnimationDatasByArrayAndMatrixFastOld(inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData);
					else
					Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxixOld(bones,this._curOriginalData,inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData);
					}else {
					var boneIndexToMesh=this._boneIndexToMeshList[animationClipIndex];
					if (isCache && isCacheBonesDatas)
						Utils3D._computeAnimationDatasByArrayAndMatrixFast(inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData,boneIndexToMesh);
					else
					Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxix(bones,this._curOriginalData,inverseAbsoluteBindPoses,this._curBonesDatas,this._curMeshAnimationData,boneIndexToMesh);
				}
				}else {
				this._extenData || (this._extenData=new Float32Array(this._templet.getPublicExtData()));
				if (isCache && isCacheBonesDatas)
					Utils3D._computeAnimationDatas(this._extenData,this._curBonesDatas,this._curMeshAnimationData);
				else
				Utils3D._computeBoneAndAnimationDatas(bones,this._curOriginalData,this._extenData,this._curBonesDatas,this._curMeshAnimationData);
			}
			for (i=0;i < subMeshCount;i++){
				var boneIndicesList=mesh.getSubMesh(i)._boneIndicesList;
				boneIndicesCount=boneIndicesList.length;
				curSubAnimationDatas=this._curAnimationDatas[i]
				for (j=0;j < boneIndicesCount;j++)
				SkinAnimations._splitAnimationDatas(boneIndicesList[j],this._curMeshAnimationData,curSubAnimationDatas[j]);
			}
			if (isCache){
				this._setAnimationDatasWithCache(cachePlayRate,mesh,animationDatasCache,animationClipIndex,frameIndex,this._curAnimationDatas);
				(isCacheBonesDatas)|| (this._templet.setAnimationDataWithCache(cachePlayRate,boneDatasCache,animationClipIndex,frameIndex,this._curBonesDatas));
			}
			this._lastFrameIndex=frameIndex;
			if (Render.isConchNode){
				for (i=0,n=mesh.getSubMeshCount();i < n;i++){
					this._ownerMesh.meshRender.sharedMaterials[i]._addShaderDefine(laya.d3.component.animation.SkinAnimations.SHADERDEFINE_BONE);
					this._ownerMesh.meshRender._renderElements[i]._conchSubmesh.setShaderValue(/*CLASS CONST:laya.d3.component.animation.SkinAnimations.BONES*/0,this._curAnimationDatas[i],0);
				}
			}
		}

		/**
		*@private
		*在渲染前更新蒙皮动画组件渲染参数。
		*@param state 渲染状态参数。
		*/
		__proto._preRenderUpdate=function(state){
			var subMesh=state.renderElement.renderObj;
			if (this._curAnimationDatas)
				subMesh._skinAnimationDatas=this._curAnimationDatas[subMesh.indexOfHost];
			else
			subMesh._skinAnimationDatas=null;
		}

		/**
		*@private
		*卸载组件时执行
		*/
		__proto._unload=function(owner){
			(this.player.state==/*laya.ani.AnimationState.playing*/2)&& (this._owner._removeShaderDefine(laya.d3.component.animation.SkinAnimations.SHADERDEFINE_BONE));
			_super.prototype._unload.call(this,owner);
			this._tempCurAnimationData=null;
			this._tempCurBonesData=null;
			this._curOriginalData=null;
			this._extenData=null;
			this._curMeshAnimationData=null;
			this._curBonesDatas=null;
			this._curAnimationDatas=null;
			this._ownerMesh=null;
		}

		/**
		*获取骨骼数据。
		*@return 骨骼数据。
		*/
		__getset(0,__proto,'curBonesDatas',function(){
			return this._curBonesDatas;
		});

		__getset(0,__proto,'templet',_super.prototype._$get_templet,function(value){
			if (this._templet!==value){
				if (this._player.state!==/*laya.ani.AnimationState.stopped*/0)
					this._player.stop(true);
				this._templet=value;
				this._player.templet=value;
				this._computeBoneIndeToMeshOnTemplet();
				this._curOriginalData=this._extenData=null;
				this._curMeshAnimationData=null;
				this._tempCurBonesData=null;
				this._tempCurAnimationData=null;
				(this._templet._animationDatasCache)|| (this._templet._animationDatasCache=[[],[]]);
				this.event(/*laya.events.Event.ANIMATION_CHANGED*/"animationchanged",this);
			}
		});

		SkinAnimations._splitAnimationDatas=function(indices,bonesData,subAnimationDatas){
			for (var i=0,n=indices.length,ii=0;i < n;i++){
				for (var j=0;j < 16;j++,ii++){
					subAnimationDatas[ii]=bonesData[(indices[i] << 4)+j];
				}
			}
		}

		SkinAnimations.BONES=0;
		SkinAnimations.SHADERDEFINE_BONE=0x4;
		return SkinAnimations;
	})(KeyframeAnimations)


	/**
	*<code>UVAnimations</code> 类用于创建UV动画组件。
	*/
	//class laya.d3.component.animation.UVAnimations extends laya.d3.component.animation.KeyframeAnimations
	var UVAnimations=(function(_super){
		function UVAnimations(){
			this._nodes=null;
			this._lasstInitIndex=-1;
			this._materials=null;
			this._mesh=null;
			this._meshDataInited=false;
			this._uvDatasCount=0;
			this._subMeshIndexToNodeIndex=[];
			this._keyframeAges=[];
			this._ages=[];
			this._bufferUsages=[];
			this._originalShaderAttributes=[];
			this._uvShaderValues=[];
			this._uvNextShaderValues=[];
			this._uvAnimationBuffers=[];
			UVAnimations.__super.call(this);
			this._meshDataInited=false;
		}

		__class(UVAnimations,'laya.d3.component.animation.UVAnimations',_super);
		var __proto=UVAnimations.prototype;
		/**
		*@private
		*初始化Mesh相关数据函数。
		*/
		__proto._initMeshData=function(){
			this._materials=this._mesh.meshRender.sharedMaterials;
			this._meshDataInited=true;
		}

		/**
		*@private
		*初始化UV动画相关数据函数。
		*/
		__proto._initAnimationData=function(animationIndex){}
		/**
		*@private
		*初始化载入UV动画组件。
		*@param owner 所属精灵对象。
		*/
		__proto._load=function(owner){
			if ((owner instanceof laya.d3.core.MeshSprite3D ))
				this._mesh=owner;
			else
			throw new Error("该Sprite3D并非Mesh");
			owner.on(/*laya.events.Event.LOADED*/"loaded",this,function(mesh){
			});
			this.on(/*laya.events.Event.LOADED*/"loaded",this,function(){
			});
			this.player.on(/*laya.events.Event.PLAYED*/"played",this,function(){
			});
			this.player.on(/*laya.events.Event.STOPPED*/"stopped",this,function(){
			});
		}

		/**
		*@private
		*更新UV动画组件。
		*@param state 渲染状态参数。
		*/
		__proto._update=function(state){
			this.player._update(state.elapsedTime);
			if (!this._templet || !this._templet.loaded || this.player.state!==/*laya.ani.AnimationState.playing*/2)
				return;
			var animationClipIndex=this.currentAnimationClipIndex;
			var unfixedIndexes=this._templet.getNodesCurrentFrameIndex(animationClipIndex,this.player.currentPlayTime);
			for (var i=0;i < this._nodes.length;i++){
				var index=unfixedIndexes[i];
				this._keyframeAges[i]=(this.player.currentPlayTime-this._nodes[i].keyFrame[index].startTime)/ this._nodes[i].keyFrame[index].duration;
				this._ages[i]=this.player.currentPlayTime / this._nodes[i].playTime;
				var subkeyframeWidth=this._nodes[i].keyframeWidth / this._uvDatasCount;
				(this._uvShaderValues[i])|| (this._uvShaderValues[i]=[]);
				(this._uvNextShaderValues[i])|| (this._uvNextShaderValues[i]=[]);
				for (var c=0;c < this._uvDatasCount;c++){
					var uvShaderValue=[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,0,(index)*subkeyframeWidth *4];
					var uvNextShaderValue=[2,/*laya.webgl.WebGLContext.FLOAT*/0x1406,false,0,(index+1)*subkeyframeWidth *4];
					this._uvShaderValues[i][c]=uvShaderValue;
					this._uvNextShaderValues[i][c]=uvNextShaderValue;
				}
			}
			laya.d3.component.Component3D.prototype._update.call(this,state);
		}

		/**
		*@private
		*在渲染前更新UV动画组件渲染参数。
		*@param state 渲染状态参数。
		*/
		__proto._preRenderUpdate=function(state){}
		return UVAnimations;
	})(KeyframeAnimations)


	/**
	*<code>BoxCollider</code> 类用于创建盒子碰撞器。
	*/
	//class laya.d3.component.physics.BoxCollider extends laya.d3.component.physics.Collider
	var BoxCollider=(function(_super){
		function BoxCollider(){
			this._size=null;
			this._transformOrientedBoundBox=null;
			this.center=null;
			BoxCollider.__super.call(this);
			this._needUpdate=false;
		}

		__class(BoxCollider,'laya.d3.component.physics.BoxCollider',_super);
		var __proto=BoxCollider.prototype;
		/**
		*@private
		*/
		__proto._updateCollider=function(){
			if (this._needUpdate){
				var transform=this._owner.transform;
				var ownerWorldMatrix=transform.worldMatrix;
				ownerWorldMatrix.cloneTo(this._transformOrientedBoundBox.transformation);
				Vector3.multiply(transform.scale,this.center,BoxCollider._deviationV3);
				Vector3.transformQuat(BoxCollider._deviationV3,transform.rotation,BoxCollider._deviationV3);
				this._transformOrientedBoundBox.getCenter(BoxCollider._obbCenterV3);
				Vector3.add(BoxCollider._obbCenterV3,BoxCollider._deviationV3,BoxCollider._deviationV3);
				this._transformOrientedBoundBox.transformation.setTranslationVector(BoxCollider._deviationV3);
				this._needUpdate=false;
			}
		}

		/**
		*@private
		*/
		__proto._onGeometryFilterLoaded=function(){
			(this.destroyed)|| (this._initBoundBox());
		}

		/**
		*@private
		*/
		__proto._onWorldMatrixChanged=function(){
			this._needUpdate=true;
		}

		/**
		*@private
		*/
		__proto._initBoundBox=function(){
			var originalBoundingBox=(this.owner)._geometryFilter._originalBoundingBox;
			OrientedBoundBox.createByBoundBox(originalBoundingBox,this._transformOrientedBoundBox);
			var extents=this._transformOrientedBoundBox.extents;
			this._size=new Vector3(extents.x *2,extents.y *2,extents.z *2);
			this.center=new Vector3();
			Vector3.add(originalBoundingBox.min,originalBoundingBox.max,this.center);
			Vector3.scale(this.center,0.5,this.center);
			this.owner.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
			this._needUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			laya.d3.component.Component3D.prototype._initialize.call(this,owner);
			if ((this._owner instanceof laya.d3.core.RenderableSprite3D )){
				var renderableOwner=owner;
				this._transformOrientedBoundBox=new OrientedBoundBox(new Vector3(),new Matrix4x4());
				if (renderableOwner._geometryFilter._isAsyncLoaded){
					this._initBoundBox();
					}else {
					renderableOwner._geometryFilter.once(/*laya.events.Event.LOADED*/"loaded",this,this._onGeometryFilterLoaded);
				}
				}else {
				this._transformOrientedBoundBox=new OrientedBoundBox(new Vector3(),new Matrix4x4());
				this._size=new Vector3();
				this.center=new Vector3();
				owner.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
				this._needUpdate=true;
			}
		}

		/**
		*在场景中投下可与盒体碰撞器碰撞的一条光线,获取发生碰撞的盒体碰撞器信息。
		*@param ray 射线
		*@param outHitInfo 与该射线发生碰撞盒体碰撞器的碰撞信息
		*@param distance 射线长度,默认为最大值
		*/
		__proto.raycast=function(ray,hitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=Number.MAX_VALUE);
			this._updateCollider();
			var distance=this._transformOrientedBoundBox.intersectsRay(ray,hitInfo.position);
			if (distance!==-1 && distance <=maxDistance){
				hitInfo.distance=distance;
				hitInfo.sprite3D=this._owner;
				return true;
				}else {
				hitInfo.distance=-1;
				hitInfo.sprite3D=null;
				return false;
			}
		}

		/**
		*获取包围盒子。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundBox',function(){
			this._updateCollider();
			return this._transformOrientedBoundBox;
		});

		/**
		*设置盒子碰撞器长宽高的一半。
		*@param 长宽高的一半。
		*/
		/**
		*获取盒子碰撞器长宽高的一半。
		*@return 长宽高的一半。
		*/
		__getset(0,__proto,'size',function(){
			return this._size;
			},function(value){
			this._size=value;
			Vector3.scale(value,0.5,this._transformOrientedBoundBox.extents);
		});

		__static(BoxCollider,
		['_deviationV3',function(){return this._deviationV3=new Vector3();},'_obbCenterV3',function(){return this._obbCenterV3=new Vector3();}
		]);
		return BoxCollider;
	})(Collider)


	/**
	*<code>MeshCollider</code> 类用于创建网格碰撞器。
	*/
	//class laya.d3.component.physics.MeshCollider extends laya.d3.component.physics.Collider
	var MeshCollider=(function(_super){
		function MeshCollider(){
			this._transformBoundSphere=null;
			this._mesh=null;
			MeshCollider.__super.call(this);
			this._transformBoundSphere=new BoundSphere(new Vector3(0,0,0),0);
		}

		__class(MeshCollider,'laya.d3.component.physics.MeshCollider',_super);
		var __proto=MeshCollider.prototype;
		/**
		*@private
		*/
		__proto._raycastMesh=function(ray,sprite3D,outHitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=Number.MAX_VALUE);
			var worldMatrix=sprite3D.transform.worldMatrix;
			var invertWorldMatrix=MeshCollider._tempMatrix4x40;
			worldMatrix.invert(invertWorldMatrix);
			var rayOrigin=ray.origin;
			var rayDirection=ray.direction;
			var transformRay=MeshCollider._tempRay0;
			Vector3.transformCoordinate(rayOrigin,invertWorldMatrix,transformRay.origin);
			Vector3.TransformNormal(rayDirection,invertWorldMatrix,transformRay.direction);
			var curMinDistance=Number.MAX_VALUE;
			for (var i=0,n=this._mesh.getRenderElementsCount();i < n;i++){
				var renderObj=this._mesh.getRenderElement(i);
				var vertexBuffer=renderObj._getVertexBuffer(0);
				var vertexDatas=vertexBuffer.getData();
				var indexDatas=renderObj._getIndexBuffer().getData();
				var elementRaycastHit=MeshCollider._tempRaycastHit;
				var isHit=Picker.rayIntersectsPositionsAndIndices(transformRay,vertexDatas,vertexBuffer.vertexDeclaration,indexDatas,elementRaycastHit);
				if (isHit){
					Vector3.transformCoordinate(elementRaycastHit.position,worldMatrix,elementRaycastHit.position);
					var rayOriToPos=MeshCollider._tempVector30;
					Vector3.subtract(rayOrigin,elementRaycastHit.position,rayOriToPos);
					var distance=Vector3.scalarLength(rayOriToPos);
					if ((distance < maxDistance)&& (distance < curMinDistance)){
						elementRaycastHit.distance=distance;
						elementRaycastHit.sprite3D=sprite3D;
						var trianglePositions=elementRaycastHit.trianglePositions;
						Vector3.transformCoordinate(trianglePositions[0],worldMatrix,trianglePositions[0]);
						Vector3.transformCoordinate(trianglePositions[1],worldMatrix,trianglePositions[1]);
						Vector3.transformCoordinate(trianglePositions[2],worldMatrix,trianglePositions[2]);
						var triangleNormals=elementRaycastHit.triangleNormals;
						Vector3.transformCoordinate(triangleNormals[0],worldMatrix,triangleNormals[0]);
						Vector3.transformCoordinate(triangleNormals[1],worldMatrix,triangleNormals[1]);
						Vector3.transformCoordinate(triangleNormals[2],worldMatrix,triangleNormals[2]);
						curMinDistance=distance;
						elementRaycastHit.cloneTo(outHitInfo);
						return true;
					}
					return false;
				}
			}
			return false;
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			laya.d3.component.Component3D.prototype._initialize.call(this,owner);
			if ((this._owner instanceof laya.d3.core.MeshSprite3D )){
				var meshSprite3D=owner;
				this._mesh=meshSprite3D.meshFilter.sharedMesh;
			}
		}

		/**
		*在场景中投下可与网格碰撞器碰撞的一条光线,获取发生碰撞的网格碰撞器信息。
		*@param ray 射线
		*@param outHitInfo 与该射线发生碰撞网格碰撞器的碰撞信息
		*@param distance 射线长度,默认为最大值
		*/
		__proto.raycast=function(ray,hitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=Number.MAX_VALUE);
			if (this._mesh==null || !this._mesh.loaded)
				return false;
			var maxScale=NaN;
			var transform=this._owner.transform;
			var scale=transform.scale;
			if (scale.x >=scale.y && scale.x >=scale.z)
				maxScale=scale.x;
			else
			maxScale=scale.y >=scale.z ? scale.y :scale.z;
			var originalBoundSphere=this._mesh.boundingSphere;
			Vector3.transformCoordinate(originalBoundSphere.center,transform.worldMatrix,this._transformBoundSphere.center);
			this._transformBoundSphere.radius=originalBoundSphere.radius *maxScale;
			var distance=this._transformBoundSphere.intersectsRayPoint(ray,hitInfo.position);
			if (distance!==-1 && distance <=maxDistance && this._raycastMesh(ray,this._owner,hitInfo,maxDistance)){
				return true;
				}else {
				hitInfo.distance=-1;
				hitInfo.sprite3D=null;
				return false;
			}
		}

		/**
		*设置碰撞器网格。
		*@param value 碰撞其网格。
		*/
		/**
		*获取碰撞器网格。
		*@return 碰撞其网格。
		*/
		__getset(0,__proto,'mesh',function(){
			return this._mesh;
			},function(value){
			this._mesh=value;
		});

		__static(MeshCollider,
		['_tempRay0',function(){return this._tempRay0=new Ray(new Vector3(),new Vector3());},'_tempVector30',function(){return this._tempVector30=new Vector3();},'_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempRaycastHit',function(){return this._tempRaycastHit=new RaycastHit();}
		]);
		return MeshCollider;
	})(Collider)


	/**
	*<code>SphereCollider</code> 类用于创建球碰撞器。
	*/
	//class laya.d3.component.physics.SphereCollider extends laya.d3.component.physics.Collider
	var SphereCollider=(function(_super){
		function SphereCollider(){
			this._originalBoundSphere=null;
			this._transformBoundSphere=null;
			SphereCollider.__super.call(this);
			this._needUpdate=false;
		}

		__class(SphereCollider,'laya.d3.component.physics.SphereCollider',_super);
		var __proto=SphereCollider.prototype;
		/**
		*@private
		*/
		__proto._updateCollider=function(){
			if (this._needUpdate){
				var maxScale=NaN;
				var transform=this._owner.transform;
				var scale=transform.scale;
				if (scale.x >=scale.y && scale.x >=scale.z)
					maxScale=scale.x;
				else
				maxScale=scale.y >=scale.z ? scale.y :scale.z;
				Vector3.transformCoordinate(this._originalBoundSphere.center,transform.worldMatrix,this._transformBoundSphere.center);
				this._transformBoundSphere.radius=this._originalBoundSphere.radius *maxScale;
				this._needUpdate=false;
			}
		}

		/**
		*@private
		*/
		__proto._onGeometryFilterLoaded=function(){
			(this.destroyed)|| (this._initBoundSphere());
		}

		/**
		*@private
		*/
		__proto._onWorldMatrixChanged=function(){
			this._needUpdate=true;
		}

		/**
		*@private
		*/
		__proto._initBoundSphere=function(){
			(this.owner)._geometryFilter._originalBoundingSphere.cloneTo(this._originalBoundSphere);
			this.owner.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
			this._needUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._initialize=function(owner){
			laya.d3.component.Component3D.prototype._initialize.call(this,owner);
			if ((owner instanceof laya.d3.core.RenderableSprite3D )){
				var renderableOwner=owner;
				this._originalBoundSphere=new BoundSphere(new Vector3(0,0,0),0);
				this._transformBoundSphere=new BoundSphere(new Vector3(0,0,0),0);
				if (renderableOwner._geometryFilter._isAsyncLoaded){
					this._initBoundSphere();
					}else {
					renderableOwner._geometryFilter.once(/*laya.events.Event.LOADED*/"loaded",this,this._onGeometryFilterLoaded);
				}
				}else {
				this._originalBoundSphere=new BoundSphere(new Vector3(0,0,0),0.5);
				this._transformBoundSphere=new BoundSphere(new Vector3(0,0,0),0.5);
				owner.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
				this._needUpdate=true;
			}
		}

		/**
		*在场景中投下可与球体碰撞器碰撞的一条光线,获取发生碰撞的球体碰撞器信息。
		*@param ray 射线
		*@param outHitInfo 与该射线发生碰撞球体碰撞器的碰撞信息
		*@param distance 射线长度,默认为最大值
		*/
		__proto.raycast=function(ray,hitInfo,maxDistance){
			(maxDistance===void 0)&& (maxDistance=Number.MAX_VALUE);
			this._updateCollider();
			var distance=this._transformBoundSphere.intersectsRayPoint(ray,hitInfo.position);
			if (distance!==-1 && distance <=maxDistance){
				hitInfo.distance=distance;
				hitInfo.sprite3D=this._owner;
				return true;
				}else {
				hitInfo.distance=-1;
				hitInfo.sprite3D=null;
				return false;
			}
		}

		/**
		*设置中心点。
		*@param value 中心点。
		*/
		/**
		*获取中心点。
		*@return 中心点。
		*/
		__getset(0,__proto,'center',function(){
			return this._originalBoundSphere.center;
			},function(value){
			this._originalBoundSphere.center=value;
		});

		/**
		*设置半径。
		*@param value 半径。
		*/
		/**
		*获取半径。
		*@return 半径。
		*/
		__getset(0,__proto,'radius',function(){
			return this._originalBoundSphere.radius;
			},function(value){
			this._originalBoundSphere.radius=value;
		});

		/**
		*获取包围球。
		*@return 包围球。
		*/
		__getset(0,__proto,'boundSphere',function(){
			this._updateCollider();
			return this._transformBoundSphere;
		});

		return SphereCollider;
	})(Collider)


	//class laya.d3.resource.DataTexture2D extends laya.d3.resource.BaseTexture
	var DataTexture2D=(function(_super){
		function DataTexture2D(){
			this.simLodInfo=null;
			this._src=null;
			this._buffer=null;
			this._mipmaps=null;
			this._recreateLock=false;
			this._needReleaseAgain=false;
			DataTexture2D.__super.call(this);
		}

		__class(DataTexture2D,'laya.d3.resource.DataTexture2D',_super);
		var __proto=DataTexture2D.prototype;
		__proto.genDebugMipmaps=function(){
			var ret=[];
			ret.push(new Uint8Array((new Uint32Array(512 *256)).fill(0xff0000ff).buffer));
			ret.push(new Uint8Array((new Uint32Array(256 *128)).fill(0xff0080ff).buffer));
			ret.push(new Uint8Array((new Uint32Array(128 *64)).fill(0xff00ffff).buffer));
			ret.push(new Uint8Array((new Uint32Array(64 *32)).fill(0xff00ff00).buffer));
			ret.push(new Uint8Array((new Uint32Array(32 *16)).fill(0xff804000).buffer));
			ret.push(new Uint8Array((new Uint32Array(16 *8)).fill(0xffff0000).buffer));
			ret.push(new Uint8Array((new Uint32Array(8 *4)).fill(0xffff0080).buffer));
			ret.push(new Uint8Array((new Uint32Array(4 *2)).fill(0x0).buffer));
			ret.push(new Uint8Array((new Uint32Array(2 *1)).fill(0xff808080).buffer));
			ret.push(new Uint8Array((new Uint32Array(1 *1)).fill(0xffffffff).buffer));
			return ret;
		}

		/**
		*@private
		*/
		__proto._onTextureLoaded=function(buff){}
		/**
		*@private
		*/
		__proto._createWebGlTexture=function(){
			if (!this._buffer && !this._mipmaps)
				throw "create GLTextur err:no data";
			var gl=WebGL.mainContext;
			gl.getExtension("EXT_shader_texture_lod");
			var glTexture=this._source=gl.createTexture();
			var w=this._width;
			var h=this._height;
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,glTexture);
			if (this._mipmaps){
				if (laya.d3.resource.DataTexture2D.lodasatlas){
					var infoi=0;
					gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,this._width,this._height,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,null);
					for (var i=0;i < this._mipmaps.length;i++){
						if (this._mipmaps[i].byteLength !=cw *ch *4){
							throw "mipmap size error  level:"+i;
						}
						gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,
						DataTexture2D.simLodRect[infoi++],
						DataTexture2D.simLodRect[infoi++],
						DataTexture2D.simLodRect[infoi++],
						DataTexture2D.simLodRect[infoi++],
						/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,new Uint8Array(this._mipmaps[i]));
					}
					this.minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601;
					this.magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601;
				}
				else {
					var cw=this._width;
					var ch=this._height;
					infoi=0;
					gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,this._width,this._height,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,null);
					for (i=0;i < this._mipmaps.length;i++){
						if (this._mipmaps[i].byteLength !=cw *ch *4){
							throw "mipmap size error  level:"+i;
						}
						gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,i,/*laya.webgl.WebGLContext.RGBA*/0x1908,cw,ch,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,new Uint8Array(this._mipmaps[i]));
						cw /=2;
						ch /=2;
						if (cw < 1)cw=1;
						if (ch < 1)ch=1;
						this.minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703;
						this.magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601;
					}
				}
				this.mipmap=false;
				}else {
				gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,new Uint8Array(this._buffer));
			};
			var minFifter=this._minFifter;
			var magFifter=this._magFifter;
			var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPot=Arith.isPOT(w,h);
			if (isPot){
				if (this._mipmap || this._mipmaps)
					(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
				if(this._mipmaps)
					gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				else
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
				this._mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
				}else {
				throw "data texture must be POT";
			}
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			if(this.src && this.src.length>0)
				this._buffer=null;
			if (isPot)
				this.memorySize=w *h *4 *(1+1 / 3);
			else
			this.memorySize=w *h *4;
			this._recreateLock=false;
		}

		/**
		*重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。
		*/
		__proto.recreateResource=function(){
			if (!this._buffer && (this._src==null || this._src===""))
				return;
			this._needReleaseAgain=false;
			if (!this._buffer && !this._mipmaps){
				this._recreateLock=true;
				this.startCreate();
				var _this=this;
				}else {
				if (this._recreateLock){
					return;
				}
				this.startCreate();
				this._createWebGlTexture();
				this.completeCreate();
			}
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(url,data,params){
			var imgdata;
			if (params){
				imgdata=params[0].call(this,data);
			}
			if (imgdata){
				this._width=imgdata.width;
				this._height=imgdata.height;
				this._buffer=imgdata.data;
			}
			this._src=url;
			this._size=new Size(this._width,this._height);
			if (this._conchTexture){
				alert('怎么给runtime传递datatexture数据');
			}else
			this.activeResource();
			this._loaded=true;
			this.event(/*laya.events.Event.LOADED*/"loaded",this);
		}

		/**
		*返回图片像素。
		*@return 图片像素。
		*/
		__proto.getPixels=function(){
			return new Uint8Array(this._buffer);
		}

		/**
		*销毁资源。
		*/
		__proto.detoryResource=function(){
			if (this._recreateLock){
				this._needReleaseAgain=true;
			}
			if (this._source){
				WebGL.mainContext.deleteTexture(this._source);
				this._source=null;
				this._buffer=null;
				this.memorySize=0;
			}
		}

		/**
		*获取文件路径全名。
		*/
		__getset(0,__proto,'src',function(){
			return this._src;
		});

		DataTexture2D.create=function(data,w,h,magfilter,minfilter,mipmap){
			(magfilter===void 0)&& (magfilter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(minfilter===void 0)&& (minfilter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(mipmap===void 0)&& (mipmap=true);
			if (!data || data.byteLength < (w *h *4))
				throw 'DataTexture2D create error';
			var ret=new DataTexture2D();
			ret._buffer=data;
			ret._width=w;
			ret._height=h;
			ret._mipmap=mipmap;
			ret._magFifter=magfilter;
			ret._minFifter=minfilter;
			ret._size=new Size(ret._width,ret._height);
			if (ret._conchTexture){
				alert('怎么给runtime传递datatexture数据');
			}else
			ret.activeResource();
			ret._loaded=true;
			return ret;
		}

		DataTexture2D.load=function(url,w,h,magfilter,minfilter){
			(w===void 0)&& (w=0);
			(h===void 0)&& (h=0);
			(magfilter===void 0)&& (magfilter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(minfilter===void 0)&& (minfilter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			var extension=Utils.getFileExtension(url);
			if (extension==='mipmaps'){
				var ret=Laya.loader.create(url,null,null,DataTexture2D,[function(data){
					this._mipmaps=[];
					var szinfo=new Uint32Array(data);
					this._width=szinfo[0];
					var validw=512;
					if (laya.d3.resource.DataTexture2D.lodasatlas){
						this._width *=2;
						validw=1024;
					}
					if (this._width !=validw){
						console.error("现在只支持512x256的环境贴图。当前的是"+szinfo[0]);
						throw "现在只支持512x256的环境贴图。当前的是"+szinfo[0];
					}
					this._height=szinfo[1];
					var curw=laya.d3.resource.DataTexture2D.lodasatlas?this._width/ 2:this._width;
					var curh=this._height;
					var cursz=8;
					while (true){
						var curbufsz=curw *curh *4;
						if (cursz+curbufsz > data.byteLength){
							throw "load mipmaps data size error ";
						};
						var tbuf=new Uint8Array(data,cursz,curbufsz);
						this._mipmaps.push(tbuf);
						cursz+=curbufsz;
						if (curw==1 && curh==1){
							break ;
						}
						curw /=2;
						curh /=2;
						if (curw < 1)curw=1;
						if (curh < 1)curh=1;
					}
					return null;
				}]);
				if(laya.d3.resource.DataTexture2D.lodasatlas){
					ret.simLodInfo=new Float32Array(40);
					for (var i=0;i < ret.simLodInfo.length;){
						ret.simLodInfo[i]=(DataTexture2D.simLodRect[i]+0.5)/ 1024;
						i++;
						ret.simLodInfo[i]=(DataTexture2D.simLodRect[i]+0.5)/ 256;
						i++;
						ret.simLodInfo[i]=Math.max(DataTexture2D.simLodRect[i]-1,0.1)/ 1024;
						i++;
						ret.simLodInfo[i]=Math.max(DataTexture2D.simLodRect[i]-1.5,0.1)/ 256;
						i++;
					}
				}
				return ret;
				}else if (typeof(w)=='number'){
				return Laya.loader.create(url,null,null,DataTexture2D,[function(data){
					this._width=w;
					this._height=h;
					this._buffer=data;
					return null;
				}]);
				}else if (typeof(w)=='function'){
				return Laya.loader.create(url,null,null,DataTexture2D,[w]);
				}else {
				throw new Error("unknown params.");
			}
		}

		DataTexture2D.lodasatlas=false;
		__static(DataTexture2D,
		['simLodRect',function(){return this.simLodRect=new Uint32Array([
			0,0,512,256,
			512,0,256,128,
			512+256,0,128,64,
			512+256+128,0,64,32,
			512+256+128+64,0,32,16,
			512+256+128+64+32,0,16,8,
			512+256+128+64+32+16,0,8,4,
			512+256+128+64+32+16+8,0,4,2,
			512+256+128+64+32+16+8+4,0,2,1,
			512+256+128+64+32+16+8+4+2,0,1,1]);}
		]);
		return DataTexture2D;
	})(BaseTexture)


	/**
	*@private
	*<code>PrimitiveMesh</code> 类用于创建基本网格的父类。
	*/
	//class laya.d3.resource.models.PrimitiveMesh extends laya.d3.resource.models.BaseMesh
	var PrimitiveMesh=(function(_super){
		function PrimitiveMesh(){
			this._numberVertices=0;
			this._numberIndices=0;
			this._vertexBuffer=null;
			this._indexBuffer=null;
			this._indexOfHost=0;
			PrimitiveMesh.__super.call(this);
			this._indexOfHost=0;
		}

		__class(PrimitiveMesh,'laya.d3.resource.models.PrimitiveMesh',_super);
		var __proto=PrimitiveMesh.prototype;
		Laya.imps(__proto,{"laya.d3.core.render.IRenderable":true})
		__proto._getVertexBuffer=function(index){
			(index===void 0)&& (index=0);
			if (index===0)
				return this._vertexBuffer;
			else
			return null;
		}

		__proto._getIndexBuffer=function(){
			return this._indexBuffer;
		}

		__proto.getRenderElement=function(index){
			return this;
		}

		__proto.getRenderElementsCount=function(){
			return 1;
		}

		__proto.detoryResource=function(){
			(this._vertexBuffer)&& (this._vertexBuffer.dispose(),this._vertexBuffer=null);
			(this._indexBuffer)&& (this._indexBuffer.dispose(),this._indexBuffer=null);
			this.memorySize=0;
		}

		__proto._beforeRender=function(state){
			this._vertexBuffer._bind();
			this._indexBuffer._bind();
			return true;
		}

		__proto._render=function(state){
			WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._numberIndices,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
			Stat.drawCall++;
			Stat.trianglesFaces+=this._numberIndices / 3;
		}

		/**NATIVE*/
		__proto._renderRuntime=function(conchGraphics3D,renderElement,state){
			conchGraphics3D.drawSubmesh(renderElement._conchSubmesh,0,/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,0,this._numberIndices);
		}

		__getset(0,__proto,'indexOfHost',function(){
			return this._indexOfHost;
		});

		__getset(0,__proto,'_vertexBufferCount',function(){
			return 1;
		});

		__getset(0,__proto,'triangleCount',function(){
			return this._indexBuffer.indexCount / 3;
		});

		/**
		*获取网格顶点
		*@return 网格顶点。
		*/
		__getset(0,__proto,'positions',function(){
			var vertices=[];
			var positionElement;
			var vertexElements=this._vertexBuffer.vertexDeclaration.getVertexElements();
			var j=0;
			for (j=0;j < vertexElements.length;j++){
				var vertexElement=vertexElements[j];
				if (vertexElement.elementFormat===/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3" && vertexElement.elementUsage===/*laya.d3.graphics.VertexElementUsage.POSITION0*/0){
					positionElement=vertexElement;
					break ;
				}
			};
			var verticesData=this._vertexBuffer.getData();
			for (j=0;j < verticesData.length;j+=this._vertexBuffer.vertexDeclaration.vertexStride / 4){
				var ofset=j+positionElement.offset / 4;
				var position=new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]);
				vertices.push(position);
			}
			return vertices;
		});

		return PrimitiveMesh;
	})(BaseMesh)


	/**
	*<code>Mesh</code> 类用于创建文件网格数据模板。
	*/
	//class laya.d3.resource.models.Mesh extends laya.d3.resource.models.BaseMesh
	var Mesh=(function(_super){
		function Mesh(){
			this._materials=null;
			this._subMeshes=null;
			this._vertexBuffers=null;
			this._indexBuffer=null;
			this._boneNames=null;
			this._bindPoses=null;
			this._inverseBindPoses=null;
			Mesh.__super.call(this);
			this._subMeshes=[];
			this._materials=[];
			this._vertexBuffers=[];
			if (this._loaded)
				this._generateBoundingObject();
			else
			this.once(/*laya.events.Event.LOADED*/"loaded",this,this._generateBoundingObject);
		}

		__class(Mesh,'laya.d3.resource.models.Mesh',_super);
		var __proto=Mesh.prototype;
		/**
		*添加子网格（开发者禁止修改）。
		*@param subMesh 子网格。
		*/
		__proto._add=function(subMesh){
			subMesh._indexInMesh=this._subMeshes.length;
			this._subMeshes.push(subMesh);
			this._subMeshCount++;
		}

		/**
		*移除子网格（开发者禁止修改）。
		*@param subMesh 子网格。
		*@return 是否成功。
		*/
		__proto._remove=function(subMesh){
			var index=this._subMeshes.indexOf(subMesh);
			if (index < 0)return false;
			this._subMeshes.splice(index,1);
			this._subMeshCount--;
			return true;
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(url,data,params){
			var bufferData=data[0];
			var textureMap=data[1];
			MeshReader.read(bufferData,this,this._materials,textureMap);
			this._loaded=true;
			this.event(/*laya.events.Event.LOADED*/"loaded",this);
		}

		/**
		*获得子网格。
		*@param index 子网格索引。
		*@return 子网格。
		*/
		__proto.getSubMesh=function(index){
			return this._subMeshes[index];
		}

		/**
		*获得子网格数量。
		*@return 子网格数量。
		*/
		__proto.getSubMeshCount=function(){
			return this._subMeshes.length;
		}

		__proto.getRenderElementsCount=function(){
			return this._subMeshes.length;
		}

		__proto.getRenderElement=function(index){
			return this._subMeshes[index];
		}

		/**
		*<p>彻底清理资源。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.dispose=function(){
			this._resourceManager.removeResource(this);
			laya.resource.Resource.prototype.dispose.call(this);
			for (var i=0;i < this._subMeshes.length;i++)
			this._subMeshes[i].dispose();
			this._subMeshes=null;
			this._subMeshCount=0;
		}

		/**
		*获取网格顶点
		*@return 网格顶点。
		*/
		__getset(0,__proto,'positions',function(){
			var vertices=[];
			var i=0,j=0,vertexBuffer,positionElement,vertexElements,vertexElement,ofset=0,verticesData;
			if (this._vertexBuffers.length!==0){
				var vertexBufferCount=this._vertexBuffers.length;
				for (i=0;i < vertexBufferCount;i++){
					vertexBuffer=this._vertexBuffers[i];
					vertexElements=vertexBuffer.vertexDeclaration.getVertexElements();
					for (j=0;j < vertexElements.length;j++){
						vertexElement=vertexElements[j];
						if (vertexElement.elementFormat===/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3" && vertexElement.elementUsage===/*laya.d3.graphics.VertexElementUsage.POSITION0*/0){
							positionElement=vertexElement;
							break ;
						}
					}
					verticesData=vertexBuffer.getData();
					for (j=0;j < verticesData.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
						ofset=j+positionElement.offset / 4;
						vertices.push(new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]));
					}
				}
				}else {
				var submesheCount=this._subMeshes.length;
				for (i=0;i < submesheCount;i++){
					var subMesh=this._subMeshes[i];
					vertexBuffer=subMesh._getVertexBuffer();
					vertexElements=vertexBuffer.vertexDeclaration.getVertexElements();
					for (j=0;j < vertexElements.length;j++){
						vertexElement=vertexElements[j];
						if (vertexElement.elementFormat===/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3" && vertexElement.elementUsage===/*laya.d3.graphics.VertexElementUsage.POSITION0*/0){
							positionElement=vertexElement;
							break ;
						}
					}
					verticesData=vertexBuffer.getData();
					for (j=0;j < verticesData.length;j+=vertexBuffer.vertexDeclaration.vertexStride / 4){
						ofset=j+positionElement.offset / 4;
						vertices.push(new Vector3(verticesData[ofset+0],verticesData[ofset+1],verticesData[ofset+2]));
					}
				}
			}
			return vertices;
		});

		/**
		*获取材质队列的浅拷贝。
		*@return 材质队列的浅拷贝。
		*/
		__getset(0,__proto,'materials',function(){
			return this._materials.slice();
		});

		/**
		*获取网格的默认绑定动作矩阵。
		*@return 网格的默认绑定动作矩阵。
		*/
		__getset(0,__proto,'bindPoses',function(){
			return this._bindPoses;
		});

		/**
		*获取网格的全局默认绑定动作逆矩阵。
		*@return 网格的全局默认绑定动作逆矩阵。
		*/
		__getset(0,__proto,'InverseAbsoluteBindPoses',function(){
			return this._inverseBindPoses;
		});

		Mesh.load=function(url){
			return Laya.loader.create(url,null,null,Mesh);
		}

		return Mesh;
	})(BaseMesh)


	/**
	*<code>RenderTarget</code> 类用于创建渲染目标。
	*/
	//class laya.d3.resource.RenderTexture extends laya.d3.resource.BaseTexture
	var RenderTexture=(function(_super){
		function RenderTexture(width,height,surfaceFormat,surfaceType,depthStencilFormat,mipMap,repeat,minFifter,magFifter){
			this._alreadyResolved=false;
			this._surfaceFormat=0;
			this._surfaceType=0;
			this._depthStencilFormat=0;
			this._frameBuffer=null;
			this._depthStencilBuffer=null;
			(surfaceFormat===void 0)&& (surfaceFormat=/*laya.webgl.WebGLContext.RGBA*/0x1908);
			(surfaceType===void 0)&& (surfaceType=/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401);
			(depthStencilFormat===void 0)&& (depthStencilFormat=/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5);
			(mipMap===void 0)&& (mipMap=false);
			(repeat===void 0)&& (repeat=false);
			(minFifter===void 0)&& (minFifter=-1);
			(magFifter===void 0)&& (magFifter=-1);
			RenderTexture.__super.call(this);
			this._width=width;
			this._height=height;
			this._size=new Size(width,height);
			this._surfaceFormat=surfaceFormat;
			this._surfaceType=surfaceType;
			this._depthStencilFormat=depthStencilFormat;
			this._mipmap=mipMap;
			this._repeat=repeat;
			this._minFifter=minFifter;
			this._magFifter=magFifter;
			this.activeResource();
			this._loaded=true;
			this._alreadyResolved=true;
		}

		__class(RenderTexture,'laya.d3.resource.RenderTexture',_super);
		var __proto=RenderTexture.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			var gl=WebGL.mainContext;
			this._frameBuffer=gl.createFramebuffer();
			this._source=gl.createTexture();
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,this._width,this._height,0,this._surfaceFormat,this._surfaceType,null);
			var minFifter=this._minFifter;
			var magFifter=this._magFifter;
			var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPot=Arith.isPOT(this._width,this._height);
			if (isPot){
				if (this._mipmap)
					(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
				this._mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
				}else {
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			}
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._frameBuffer);
			gl.framebufferTexture2D(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.COLOR_ATTACHMENT0*/0x8CE0,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,this._source,0);
			if (this._depthStencilFormat){
				this._depthStencilBuffer=gl.createRenderbuffer();
				gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
				gl.renderbufferStorage(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilFormat,this._width,this._height);
				switch (this._depthStencilFormat){
					case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
						gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_ATTACHMENT*/0x8D00,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
						break ;
					case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
						gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.STENCIL_ATTACHMENT*/0x8D20,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
						break ;
					case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
						gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_STENCIL_ATTACHMENT*/0x821A,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,this._depthStencilBuffer);
						break ;
					}
			}
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41,null);
			this.memorySize=this._width *this._height *4;
			this.completeCreate();
		}

		/**
		*开始绑定。
		*/
		__proto.start=function(){
			WebGL.mainContext.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this.frameBuffer);
			RenderTexture._currentRenderTarget=this;
			this._alreadyResolved=false;
		}

		/**
		*结束绑定。
		*/
		__proto.end=function(){
			WebGL.mainContext.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
			RenderTexture._currentRenderTarget=null;
			this._alreadyResolved=true;
		}

		/**
		*获得像素数据。
		*@param x X像素坐标。
		*@param y Y像素坐标。
		*@param width 宽度。
		*@param height 高度。
		*@return 像素数据。
		*/
		__proto.getData=function(x,y,width,height){
			var gl=WebGL.mainContext;
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,this._frameBuffer);
			var canRead=(gl.checkFramebufferStatus(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40)===/*laya.webgl.WebGLContext.FRAMEBUFFER_COMPLETE*/0x8CD5);
			if (!canRead){
				gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
				return null;
			};
			var pixels=new Uint8Array(this._width *this._height *4);
			gl.readPixels(x,y,width,height,this._surfaceFormat,this._surfaceType,pixels);
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,null);
			return pixels;
		}

		/**
		*销毁资源。
		*/
		__proto.detoryResource=function(){
			if (this._frameBuffer){
				var gl=WebGL.mainContext;
				gl.deleteTexture(this._source);
				gl.deleteFramebuffer(this._frameBuffer);
				gl.deleteRenderbuffer(this._depthStencilBuffer);
				this._source=null;
				this._frameBuffer=null;
				this._depthStencilBuffer=null;
				this.memorySize=0;
			}
		}

		/**
		*获取表面格式。
		*@return 表面格式。
		*/
		__getset(0,__proto,'surfaceFormat',function(){
			return this._surfaceFormat;
		});

		/**
		*获取表面类型。
		*@return 表面类型。
		*/
		__getset(0,__proto,'surfaceType',function(){
			return this._surfaceType;
		});

		/**
		*获取深度格式。
		*@return 深度格式。
		*/
		__getset(0,__proto,'depthStencilFormat',function(){
			return this._depthStencilFormat;
		});

		/**
		*获取RenderTarget数据源,如果alreadyResolved等于false，则返回null。
		*@return RenderTarget数据源。
		*/
		__getset(0,__proto,'source',function(){
			if (this._alreadyResolved)
				return _super.prototype._$get_source.call(this);
			else
			return null;
		});

		__getset(0,__proto,'depthStencilBuffer',function(){
			return this._depthStencilBuffer;
		});

		__getset(0,__proto,'frameBuffer',function(){
			return this._frameBuffer;
		});

		RenderTexture._currentRenderTarget=null
		return RenderTexture;
	})(BaseTexture)


	/**
	*<code>SolidColorTexture2D</code> 二维纯色纹理。
	*/
	//class laya.d3.resource.SolidColorTexture2D extends laya.d3.resource.BaseTexture
	var SolidColorTexture2D=(function(_super){
		function SolidColorTexture2D(color){
			this._color=null;
			this._pixels=null;
			SolidColorTexture2D.__super.call(this);
			this._width=1;
			this._height=1;
			this._size=new Size(this.width,this.height);
			this._color=color;
			this._pixels=new Uint8Array([color.x *255,color.y *255,color.z *255,color.w *255]);
		}

		__class(SolidColorTexture2D,'laya.d3.resource.SolidColorTexture2D',_super);
		var __proto=SolidColorTexture2D.prototype;
		/**
		*@private
		*/
		__proto._createWebGlTexture=function(){
			var gl=WebGL.mainContext;
			var glTex=this._source=gl.createTexture();
			var w=this._width;
			var h=this._height;
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,glTex);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
			var minFifter=this._minFifter;
			var magFifter=this._magFifter;
			var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPot=Arith.isPOT(w,h);
			if (isPot){
				if (this._mipmap)
					(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
				this._mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
				}else {
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			}
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			if (isPot)
				this.memorySize=w *h *4 *(1+1 / 3);
			else
			this.memorySize=w *h *4;
		}

		/**
		*重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。
		*/
		__proto.recreateResource=function(){
			this.startCreate();
			this._createWebGlTexture();
			this.completeCreate();
		}

		/**
		*销毁资源。
		*/
		__proto.detoryResource=function(){
			if (this._source){
				WebGL.mainContext.deleteTexture(this._source);
				this._source=null;
				this.memorySize=0;
			}
		}

		__getset(0,__proto,'source',function(){
			return _super.prototype._$get_source.call(this);
		});

		__static(SolidColorTexture2D,
		['magentaTexture',function(){return this.magentaTexture=new SolidColorTexture2D(new Vector4(1.0,0.0,1.0,1.0));},'grayTexture',function(){return this.grayTexture=new SolidColorTexture2D(new Vector4(0.5,0.5,0.5,1.0));}
		]);
		return SolidColorTexture2D;
	})(BaseTexture)


	//class laya.d3.resource.SolidColorTextureCube extends laya.d3.resource.BaseTexture
	var SolidColorTextureCube=(function(_super){
		function SolidColorTextureCube(color){
			this._color=null;
			this._pixels=null;
			this._texCount=6;
			SolidColorTextureCube.__super.call(this);
			this._width=1;
			this._height=1;
			this._size=new Size(this.width,this.height);
			this._color=color;
			this._pixels=new Uint8Array([color.x *255,color.y *255,color.z *255,color.w *255]);
		}

		__class(SolidColorTextureCube,'laya.d3.resource.SolidColorTextureCube',_super);
		var __proto=SolidColorTextureCube.prototype;
		__proto._createWebGlTexture=function(){
			var gl=WebGL.mainContext;
			var glTex=this._source=gl.createTexture();
			var w=this._width;
			var h=this._height;
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,glTex);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X*/0x8515,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X*/0x8516,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y*/0x8517,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y*/0x8518,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z*/0x8519,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z*/0x851A,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
			var minFifter=this.minFifter;
			var magFifter=this.magFifter;
			var repeat=this.repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPOT=Arith.isPOT(w,h);
			if (isPOT){
				if (this.mipmap)
					(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
				this.mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513);
				}else {
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			}
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			if (isPOT)
				this.memorySize=w *h *4 *(1+1 / 3)*this._texCount;
			else
			this.memorySize=w *h *4 *this._texCount;
		}

		__proto.recreateResource=function(){
			this.startCreate();
			this._createWebGlTexture();
			this.completeCreate();
		}

		//处理创建完成后相关操作
		__proto.detoryResource=function(){
			if (this._source){
				WebGL.mainContext.deleteTexture(this._source);
				this._source=null;
				this.memorySize=0;
			}
		}

		__static(SolidColorTextureCube,
		['magentaTexture',function(){return this.magentaTexture=new SolidColorTextureCube(new Vector4(1.0,0.0,1.0,1.0));},'grayTexture',function(){return this.grayTexture=new SolidColorTextureCube(new Vector4(0.5,0.5,0.5,1.0));}
		]);
		return SolidColorTextureCube;
	})(BaseTexture)


	/**
	*<code>Texture2D</code> 二维纹理。
	*/
	//class laya.d3.resource.Texture2D extends laya.d3.resource.BaseTexture
	var Texture2D=(function(_super){
		function Texture2D(canRead){
			this._canRead=false;
			this._src=null;
			this._image=null;
			this._recreateLock=false;
			this._needReleaseAgain=false;
			this._pixels=null;
			(canRead===void 0)&& (canRead=false);
			Texture2D.__super.call(this);
			this._canRead=canRead;
		}

		__class(Texture2D,'laya.d3.resource.Texture2D',_super);
		var __proto=Texture2D.prototype;
		/**
		*@private
		*/
		__proto._onTextureLoaded=function(img){
			this._image=img;
			var w=img.width;
			var h=img.height;
			this._width=w;
			this._height=h;
			this._size=new Size(w,h);
			if (this._canRead){
				Browser.canvas.size(w,h);
				Browser.canvas.clear();
				Browser.context.drawImage(img,0,0,w,h);
				this._pixels=new Uint8Array(Browser.context.getImageData(0,0,w,h).data.buffer);
			}
		}

		/**
		*@private
		*/
		__proto._createWebGlTexture=function(){
			if (!this._image)
				throw "create GLTextur err:no data:"+this._image;
			var gl=WebGL.mainContext;
			var glTexture=this._source=gl.createTexture();
			var w=this._width;
			var h=this._height;
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,glTexture);
			if (this._canRead)
				gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,w,h,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._pixels);
			else
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._image);
			var minFifter=this._minFifter;
			var magFifter=this._magFifter;
			var repeat=this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPot=Arith.isPOT(w,h);
			if (isPot){
				if (this._mipmap)
					(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
				this._mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
				}else {
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			}
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			this._image.onload=null;
			this._image=null;
			if (isPot)
				this.memorySize=w *h *4 *(1+1 / 3);
			else
			this.memorySize=w *h *4;
			this._recreateLock=false;
		}

		/**
		*重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。
		*/
		__proto.recreateResource=function(){
			if (this._src==null || this._src==="")
				return;
			this._needReleaseAgain=false;
			if (!this._image){
				this._recreateLock=true;
				this.startCreate();
				var _this=this;
				this._image=new Browser.window.Image();
				this._image.crossOrigin="";
				this._image.onload=function (){
					if (_this._needReleaseAgain){
						_this._needReleaseAgain=false;
						_this._image.onload=null;
						_this._image=null;
						return;
					}
					_this._createWebGlTexture();
					_this.completeCreate();
				};
				this._image.src=this._src;
				}else {
				if (this._recreateLock){
					return;
				}
				this.startCreate();
				this._createWebGlTexture();
				this.completeCreate();
			}
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(url,data,params){
			if (params){
				this._canRead=params[0];
			}
			this._src=url;
			this._onTextureLoaded(data);
			if (this._conchTexture)
				this._conchTexture.setTexture2DImage(this._image);
			else
			this.activeResource();
			this._loaded=true;
			this.event(/*laya.events.Event.LOADED*/"loaded",this);
		}

		/**
		*返回图片像素。
		*@return 图片像素。
		*/
		__proto.getPixels=function(){
			if (this._canRead)
				return this._pixels;
			else
			throw new Error("Texture2D: must set texture canRead is true.");
		}

		/**
		*销毁资源。
		*/
		__proto.detoryResource=function(){
			if (this._recreateLock){
				this._needReleaseAgain=true;
			}
			if (this._source){
				WebGL.mainContext.deleteTexture(this._source);
				this._source=null;
				this._image=null;
				this.memorySize=0;
			}
		}

		/**
		*获取文件路径全名。
		*/
		__getset(0,__proto,'src',function(){
			return this._src;
		});

		Texture2D.load=function(url){
			return Laya.loader.create(url,null,null,Texture2D);
		}

		return Texture2D;
	})(BaseTexture)


	//class laya.d3.resource.TextureCube extends laya.d3.resource.BaseTexture
	var TextureCube=(function(_super){
		function TextureCube(){
			this._texCount=6;
			//this._images=null;
			//this._srcs=null;
			this._recreateLock=false;
			this._needReleaseAgain=false;
			TextureCube.__super.call(this);
		}

		__class(TextureCube,'laya.d3.resource.TextureCube',_super);
		var __proto=TextureCube.prototype;
		/**
		*@private
		*/
		__proto._onTextureLoaded=function(images){
			this._images=images;
			var minWidth=2147483647;
			var minHeight=2147483647;
			for (var i=0;i < 6;i++){
				var image=images[i];
				minWidth=Math.min(minWidth,image.width);
				minHeight=Math.min(minHeight,image.height);
			}
			this._width=minWidth;
			this._height=minHeight;
			this._size=new Size(minWidth,minHeight);
		}

		__proto._createWebGlTexture=function(){
			var i=0;
			for (i=0;i < this._texCount;i++){
				if (!this._images[i]){
					throw "create GLTextur err:no data:"+this._images[i];
				}
			};
			var gl=WebGL.mainContext;
			var glTex=this._source=gl.createTexture();
			var w=this._width;
			var h=this._height;
			var preTarget=WebGLContext.curBindTexTarget;
			var preTexture=WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,glTex);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X*/0x8515,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[0]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X*/0x8516,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[1]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y*/0x8517,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[2]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y*/0x8518,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[3]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z*/0x8519,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[4]);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z*/0x851A,0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,this._images[5]);
			var minFifter=this.minFifter;
			var magFifter=this.magFifter;
			var repeat=this.repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPOT=Arith.isPOT(w,h);
			if (isPOT){
				if (this.mipmap)
					(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,repeat);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,repeat);
				this.mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513);
				}else {
				(minFifter!==-1)|| (minFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter!==-1)|| (magFifter=/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			}
			(preTarget && preTexture)&& (WebGLContext.bindTexture(gl,preTarget,preTexture));
			for (i=0;i < 6;i++){
				this._images[i].onload=null;
				this._images[i]=null;
			}
			if (isPOT)
				this.memorySize=w *h *4 *(1+1 / 3)*this._texCount;
			else
			this.memorySize=w *h *4 *this._texCount;
			this._recreateLock=false;
		}

		__proto.recreateResource=function(){
			var _$this=this;
			if (this._srcs==null)
				return;
			this._needReleaseAgain=false;
			if (!this._images[0]){
				this._recreateLock=true;
				this.startCreate();
				var _this=this;
				for (var i=0;i < this._texCount;i++){
					this._images[i]=new Browser.window.Image();
					this._images[i].crossOrigin="";
					var index=i;
					this._images[index].onload=function (){
						var j=0;
						if (_this._needReleaseAgain){
							for (j=0;j < _$this._texCount;j++)
							if (!_this._images[j].complete)
								return;
							_this._needReleaseAgain=false;
							for (j=0;j < _$this._texCount;j++){
								_this._images[j].onload=null;
								_this._images[j]=null;
							}
							return;
						}
						for (j=0;j < _$this._texCount;j++)
						if (!_this._images[j].complete)
							return;
						_this._createWebGlTexture();
						_this.completeCreate();
					};
					this._images[i].src=this._srcs[i];
				}
				}else {
				if (this._recreateLock){
					return;
				}
				this.startCreate();
				this._createWebGlTexture();
				this.completeCreate();
			}
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded=function(url,data,params){
			this._srcs=url;
			this._onTextureLoaded(data);
			if (this._conchTexture)
				this._conchTexture.setTextureCubeImages(this._images);
			else
			this.activeResource();
			this._loaded=true;
			this.event(/*laya.events.Event.LOADED*/"loaded",this);
		}

		__proto.detoryResource=function(){
			if (this._recreateLock){
				this._needReleaseAgain=true;
			}
			if (this._source){
				WebGL.mainContext.deleteTexture(this._source);
				this._source=null;
				this.memorySize=0;
			}
		}

		/**
		*文件路径全名。
		*/
		__getset(0,__proto,'srcs',function(){
			return this._srcs;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'defaulteTexture',function(){
			return TextureCube.grayTexture;
		});

		TextureCube.load=function(url){
			return Laya.loader.create(url,null,null,TextureCube);
		}

		__static(TextureCube,
		['grayTexture',function(){return this.grayTexture=new SolidColorTextureCube(new Vector4(0.5,0.5,0.5,1.0));}
		]);
		return TextureCube;
	})(BaseTexture)


	/**
	*<code>Sky</code> 类用于创建天空盒。
	*/
	//class laya.d3.resource.models.SkyBox extends laya.d3.resource.models.Sky
	var SkyBox=(function(_super){
		function SkyBox(){
			this._numberVertices=0;
			this._numberIndices=0;
			this._textureCube=null;
			SkyBox.__super.call(this);
			this.name="Skybox-"+SkyBox._nameNumber;
			SkyBox._nameNumber++;
			this.loadShaderParams();
			this.recreateResource();
			this.alphaBlending=1;
			this.colorIntensity=1;
		}

		__class(SkyBox,'laya.d3.resource.models.SkyBox',_super);
		var __proto=SkyBox.prototype;
		/**
		*@private
		*/
		__proto._getShader=function(state){
			var shaderDefineValue=state.scene._shaderDefineValue;
			this._shader=this._shaderCompile.withCompile(this._sharderNameID,shaderDefineValue,0,0);
			return this._shader;
		}

		/**
		*@private
		*/
		__proto.recreateResource=function(){
			this.startCreate();
			this._numberVertices=36;
			this._numberIndices=36;
			var indices=new Uint16Array(this._numberIndices);
			var vertexFloatStride=SkyBox._vertexDeclaration.vertexStride / 4;
			var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
			var width=1.0;
			var height=1.0;
			var depth=1.0;
			var halfWidth=width / 2.0;
			var halfHeight=height / 2.0;
			var halfDepth=depth / 2.0;
			var topLeftFront=new Vector3(-halfWidth,halfHeight,halfDepth);
			var bottomLeftFront=new Vector3(-halfWidth,-halfHeight,halfDepth);
			var topRightFront=new Vector3(halfWidth,halfHeight,halfDepth);
			var bottomRightFront=new Vector3(halfWidth,-halfHeight,halfDepth);
			var topLeftBack=new Vector3(-halfWidth,halfHeight,-halfDepth);
			var topRightBack=new Vector3(halfWidth,halfHeight,-halfDepth);
			var bottomLeftBack=new Vector3(-halfWidth,-halfHeight,-halfDepth);
			var bottomRightBack=new Vector3(halfWidth,-halfHeight,-halfDepth);
			var vertexCount=0;
			vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomRightFront);
			vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
			vertexCount=this._addVertex(vertices,vertexCount,topLeftBack);
			vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
			vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,topLeftBack);
			vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
			vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomRightFront);
			vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,topLeftBack);
			vertexCount=this._addVertex(vertices,vertexCount,bottomLeftBack);
			vertexCount=this._addVertex(vertices,vertexCount,topLeftFront);
			vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomRightFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,topRightBack);
			vertexCount=this._addVertex(vertices,vertexCount,topRightFront);
			vertexCount=this._addVertex(vertices,vertexCount,bottomRightBack);
			for (var i=0;i < 36;i++)
			indices[i]=i;
			this._vertexBuffer=new VertexBuffer3D(SkyBox._vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(indices);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.completeCreate();
			if (this._conchSky){
				this._conchSky.setVBIB(SkyBox._vertexDeclaration._conchVertexDeclaration,vertices,indices);
				this._sharderNameID=Shader3D.nameKey.getID("SkyBox");
				var shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
				this._conchSky.setShader(shaderCompile._conchShader);
			}
		}

		/**
		*@private
		*/
		__proto._addVertex=function(vertices,index,position){
			var posE=position.elements;
			vertices[index+0]=posE[0];
			vertices[index+1]=posE[1];
			vertices[index+2]=posE[2];
			return index+3;
		}

		/**
		*@private
		*/
		__proto.loadShaderParams=function(){
			this._sharderNameID=Shader3D.nameKey.getID("SkyBox");
			this._shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
		}

		__proto._render=function(state){
			if (this._textureCube && this._textureCube.loaded){
				this._vertexBuffer._bind();
				this._indexBuffer._bind();
				this._shader=this._getShader(state);
				this._shader.bind();
				state.camera.transform.worldMatrix.cloneTo(SkyBox._tempMatrix4x40);
				SkyBox._tempMatrix4x40.transpose();
				Matrix4x4.multiply(state._projectionMatrix,SkyBox._tempMatrix4x40,SkyBox._tempMatrix4x41);
				state.camera._shaderValues.setValue(/*laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE*/4,SkyBox._tempMatrix4x41.elements);
				this._shader.uploadCameraUniforms(state.camera._shaderValues.data);
				this._shaderValue.setValue(1,this._colorIntensity);
				this._shaderValue.setValue(2,this._alphaBlending);
				this._shaderValue.setValue(3,this.textureCube.source);
				this._shader.uploadAttributes(SkyBox._vertexDeclaration.shaderValues.data,null);
				this._shader.uploadMaterialUniforms(this._shaderValue.data);
				WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,36,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
				Stat.trianglesFaces+=12;
				Stat.drawCall++;
			}
		}

		/**
		*设置天空立方体纹理。
		*@param value 天空立方体纹理。
		*/
		/**
		*获取天空立方体纹理。
		*@return 天空立方体纹理。
		*/
		__getset(0,__proto,'textureCube',function(){
			return this._textureCube;
			},function(value){
			this._textureCube=value;
			if (this._conchSky){
				this._conchSky.setTextureCube(this._textureCube._conchTexture,0,/*laya.d3.resource.models.Sky.DIFFUSETEXTURE*/3);
			}
		});

		SkyBox._nameNumber=1;
		__static(SkyBox,
		['_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempMatrix4x41',function(){return this._tempMatrix4x41=new Matrix4x4();},'_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(12,[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0)]);}
		]);
		return SkyBox;
	})(Sky)


	/**
	*<code>Sky</code> 类用于创建天空盒。
	*/
	//class laya.d3.resource.models.SkyDome extends laya.d3.resource.models.Sky
	var SkyDome=(function(_super){
		function SkyDome(){
			this._numberVertices=0;
			this._numberIndices=0;
			this._texture=null;
			this._stacks=16;
			this._slices=16;
			this._radius=1;
			SkyDome.__super.call(this);
			this.name="SkyDome-"+SkyDome._nameNumber;
			SkyDome._nameNumber++;
			this.loadShaderParams();
			this.recreateResource();
			this.alphaBlending=1;
			this.colorIntensity=1;
		}

		__class(SkyDome,'laya.d3.resource.models.SkyDome',_super);
		var __proto=SkyDome.prototype;
		/**
		*@private
		*/
		__proto._getShader=function(state){
			var shaderDefineValue=state.scene._shaderDefineValue;
			this._shader=this._shaderCompile.withCompile(this._sharderNameID,shaderDefineValue,0,0);
			return this._shader;
		}

		/**
		*@private
		*/
		__proto.recreateResource=function(){
			this.startCreate();
			this._numberVertices=(this._stacks+1)*(this._slices+1);
			this._numberIndices=(3 *this._stacks *(this._slices+1))*2;
			var indices=new Uint16Array(this._numberIndices);
			var vertexFloatStride=SkyDome._vertexDeclaration.vertexStride / 4;
			var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
			var stackAngle=Math.PI / this._stacks;
			var sliceAngle=(Math.PI *2.0)/ this._slices;
			var vertexIndex=0;
			var vertexCount=0;
			var indexCount=0;
			for (var stack=0;stack < (this._stacks+1);stack++){
				var r=Math.sin(stack *stackAngle);
				var y=Math.cos(stack *stackAngle);
				for (var slice=0;slice < (this._slices+1);slice++){
					var x=r *Math.sin(slice *sliceAngle);
					var z=r *Math.cos(slice *sliceAngle);
					vertices[vertexCount+0]=x *this._radius;
					vertices[vertexCount+1]=y *this._radius;
					vertices[vertexCount+2]=z *this._radius;
					vertices[vertexCount+3]=-(slice / this._slices)+0.75;
					vertices[vertexCount+4]=stack / this._stacks;
					vertexCount+=vertexFloatStride;
					if (stack !=(this._stacks-1)){
						indices[indexCount++]=vertexIndex+1;
						indices[indexCount++]=vertexIndex;
						indices[indexCount++]=vertexIndex+(this._slices+1);
						indices[indexCount++]=vertexIndex+(this._slices+1);
						indices[indexCount++]=vertexIndex;
						indices[indexCount++]=vertexIndex+(this._slices);
						vertexIndex++;
					}
				}
			}
			this._vertexBuffer=new VertexBuffer3D(SkyDome._vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(indices);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.completeCreate();
			if (this._conchSky){
				this._conchSky.setVBIB(SkyDome._vertexDeclaration._conchVertexDeclaration,vertices,indices);
				this._sharderNameID=Shader3D.nameKey.getID("SkyDome");
				var shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
				this._conchSky.setShader(shaderCompile._conchShader);
			}
		}

		/**
		*@private
		*/
		__proto.loadShaderParams=function(){
			this._sharderNameID=Shader3D.nameKey.getID("SkyDome");
			this._shaderCompile=ShaderCompile3D._preCompileShader[this._sharderNameID];
		}

		__proto._render=function(state){
			if (this._texture && this._texture.loaded){
				this._vertexBuffer._bind();
				this._indexBuffer._bind();
				this._shader=this._getShader(state);
				this._shader.bind();
				state.camera.transform.worldMatrix.cloneTo(SkyDome._tempMatrix4x40);
				SkyDome._tempMatrix4x40.transpose();
				Matrix4x4.multiply(state._projectionMatrix,SkyDome._tempMatrix4x40,SkyDome._tempMatrix4x41);
				state.camera._shaderValues.setValue(/*laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE*/4,SkyDome._tempMatrix4x41.elements);
				this._shader.uploadCameraUniforms(state.camera._shaderValues.data);
				this._shaderValue.setValue(1,this._colorIntensity);
				this._shaderValue.setValue(2,this._alphaBlending);
				this._shaderValue.setValue(3,this.texture.source);
				this._shader.uploadAttributes(SkyDome._vertexDeclaration.shaderValues.data,null);
				this._shader.uploadMaterialUniforms(this._shaderValue.data);
				WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004,this._indexBuffer.indexCount,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403,0);
				Stat.trianglesFaces+=this._numberIndices / 3;
				Stat.drawCall++;
			}
		}

		/**
		*设置天空立方体纹理。
		*@param value 天空立方体纹理。
		*/
		/**
		*获取天空立方体纹理。
		*@return 天空立方体纹理。
		*/
		__getset(0,__proto,'texture',function(){
			return this._texture;
			},function(value){
			this._texture=value;
			if (this._conchSky){
				this._conchSky.setTexture(this._texture._conchTexture,0,/*laya.d3.resource.models.Sky.DIFFUSETEXTURE*/3);
			}
		});

		SkyDome._nameNumber=1;
		__static(SkyDome,
		['_tempMatrix4x40',function(){return this._tempMatrix4x40=new Matrix4x4();},'_tempMatrix4x41',function(){return this._tempMatrix4x41=new Matrix4x4();},'_vertexDeclaration',function(){return this._vertexDeclaration=new VertexDeclaration(20,[new VertexElement(0,/*laya.d3.graphics.VertexElementFormat.Vector3*/"vector3",/*laya.d3.graphics.VertexElementUsage.POSITION0*/0),new VertexElement(12,/*laya.d3.graphics.VertexElementFormat.Vector2*/"vector2",/*laya.d3.graphics.VertexElementUsage.TEXTURECOORDINATE0*/2)]);}
		]);
		return SkyDome;
	})(Sky)


	/**
	*<code>Scene</code> 类用于实现普通场景。
	*/
	//class laya.d3.core.scene.Scene extends laya.d3.core.scene.BaseScene
	var Scene=(function(_super){
		function Scene(){
			this._tempBoundBoxCorners=[];
			Scene.__super.call(this);
		}

		__class(Scene,'laya.d3.core.scene.Scene',_super);
		var __proto=Scene.prototype;
		//}
		__proto._renderCamera=function(gl,state,baseCamera){
			var camera=baseCamera;
			(this.parallelSplitShadowMaps[0])&& (this._renderShadowMap(gl,state,camera));
			state.camera=camera;
			camera._prepareCameraToRender();
			this.beforeRender(state);
			var viewMatrix=camera.viewMatrix;
			var projectMatrix;
			state._viewMatrix=viewMatrix;
			var renderTarget=camera.renderTarget;
			if (renderTarget){
				renderTarget.start();
				Matrix4x4.multiply(this._invertYScaleMatrix,camera.projectionMatrix,this._invertYProjectionMatrix);
				Matrix4x4.multiply(this._invertYScaleMatrix,camera.projectionViewMatrix,this._invertYProjectionViewMatrix);
				projectMatrix=state._projectionMatrix=this._invertYProjectionMatrix;
				state._projectionViewMatrix=this._invertYProjectionViewMatrix;
				}else {
				projectMatrix=state._projectionMatrix=camera.projectionMatrix;
				state._projectionViewMatrix=camera.projectionViewMatrix;
			}
			camera._prepareCameraViewProject(viewMatrix,projectMatrix);
			state._boundFrustum=camera.boundFrustum;
			state._viewport=camera.viewport;
			this._preRenderScene(gl,state);
			this._clear(gl,state);
			this._renderScene(gl,state);
			this.lateRender(state);
			(renderTarget)&& (renderTarget.end());
		}

		return Scene;
	})(BaseScene)


	/**
	*<code>VRScene</code> 类用于实现VR场景。
	*/
	//class laya.d3.core.scene.VRScene extends laya.d3.core.scene.BaseScene
	var VRScene=(function(_super){
		/**
		*创建一个 <code>VRScene</code> 实例。
		*/
		function VRScene(){
			VRScene.__super.call(this);
		}

		__class(VRScene,'laya.d3.core.scene.VRScene',_super);
		var __proto=VRScene.prototype;
		__proto._renderCamera=function(gl,state,baseCamera){
			var vrCamera=baseCamera;
			state.camera=vrCamera;
			vrCamera._prepareCameraToRender();
			state.scene.addShaderDefine(ShaderCompile3D.SHADERDEFINE_VR);
			this.beforeRender(state);
			var leftViewMatrix=vrCamera.leftViewMatrix;
			var leftProjectMatrix;
			state._viewMatrix=leftViewMatrix;
			var renderTarget=vrCamera.renderTarget;
			if (renderTarget){
				renderTarget.start();
				Matrix4x4.multiply(this._invertYScaleMatrix,vrCamera.leftProjectionMatrix,this._invertYProjectionMatrix);
				Matrix4x4.multiply(this._invertYScaleMatrix,vrCamera.leftProjectionViewMatrix,this._invertYProjectionViewMatrix);
				leftProjectMatrix=state._projectionMatrix=this._invertYProjectionMatrix;
				state._projectionViewMatrix=this._invertYProjectionViewMatrix;
				}else {
				leftProjectMatrix=state._projectionMatrix=vrCamera.leftProjectionMatrix;
				state._projectionViewMatrix=vrCamera.leftProjectionViewMatrix;
			}
			vrCamera._prepareCameraViewProject(leftViewMatrix,leftProjectMatrix);
			state._boundFrustum=vrCamera.leftBoundFrustum;
			state._viewport=vrCamera.leftViewport;
			this._preRenderScene(gl,state);
			this._clear(gl,state);
			this._renderScene(gl,state);
			var rightViewMatrix=vrCamera.rightViewMatrix;
			var rightProjectMatrix;
			state._viewMatrix=rightViewMatrix;
			if (renderTarget){
				renderTarget.start();
				Matrix4x4.multiply(this._invertYScaleMatrix,vrCamera.rightProjectionMatrix,this._invertYProjectionMatrix);
				Matrix4x4.multiply(this._invertYScaleMatrix,vrCamera.rightProjectionViewMatrix,this._invertYProjectionViewMatrix);
				state._projectionMatrix=this._invertYProjectionMatrix;
				rightProjectMatrix=state._projectionViewMatrix=this._invertYProjectionViewMatrix;
				}else {
				state._projectionMatrix=vrCamera.rightProjectionMatrix;
				rightProjectMatrix=state._projectionViewMatrix=vrCamera.rightProjectionViewMatrix;
			}
			vrCamera._prepareCameraViewProject(rightViewMatrix,rightProjectMatrix);
			state._boundFrustum=vrCamera.rightBoundFrustum;
			state._viewport=vrCamera.rightViewport;
			this._preRenderScene(gl,state);
			this._clear(gl,state);
			this._renderScene(gl,state);
			this.lateRender(state);
			(renderTarget)&& (renderTarget.end());
		}

		return VRScene;
	})(BaseScene)


	/**
	*<code>Camera</code> 类用于创建摄像机。
	*/
	//class laya.d3.core.Camera extends laya.d3.core.BaseCamera
	var Camera=(function(_super){
		function Camera(aspectRatio,nearPlane,farPlane){
			//this._aspectRatio=NaN;
			//this._viewport=null;
			//this._normalizedViewport=null;
			//this._viewMatrix=null;
			//this._projectionMatrix=null;
			//this._projectionViewMatrix=null;
			//this._boundFrustumUpdate=false;
			//this._boundFrustum=null;
			(aspectRatio===void 0)&& (aspectRatio=0);
			(nearPlane===void 0)&& (nearPlane=0.3);
			(farPlane===void 0)&& (farPlane=1000);
			this._viewMatrix=new Matrix4x4();
			this._projectionMatrix=new Matrix4x4();
			this._projectionViewMatrix=new Matrix4x4();
			this._viewport=new Viewport(0,0,0,0);
			this._normalizedViewport=new Viewport(0,0,1,1);
			this._aspectRatio=aspectRatio;
			this._boundFrustumUpdate=true;
			this._boundFrustum=new BoundFrustum(Matrix4x4.DEFAULT);
			Camera.__super.call(this,nearPlane,farPlane);
			this.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
		}

		__class(Camera,'laya.d3.core.Camera',_super);
		var __proto=Camera.prototype;
		/**
		*@private
		*/
		__proto._onWorldMatrixChanged=function(){
			this._boundFrustumUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateProjectionMatrix=function(){
			if (!this._useUserProjectionMatrix){
				if (this.orthographicProjection){
					var halfWidth=this.orthographicVerticalSize *this.aspectRatio *0.5;
					var halfHeight=this.orthographicVerticalSize *0.5;
					Matrix4x4.createOrthogonal(-halfWidth,halfWidth,-halfHeight,halfHeight,this.nearPlane,this.farPlane,this._projectionMatrix);
					}else {
					Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.aspectRatio,this.nearPlane,this.farPlane,this._projectionMatrix);
				}
			}
			this._boundFrustumUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._update=function(state){
			if (this.conchModel){
				this.conchModel.setViewMatrix(this.viewMatrix.elements);
				this.conchModel.setProjectMatrix(this.projectionMatrix.elements);
			}
			laya.d3.core.Sprite3D.prototype._update.call(this,state);
		}

		/**
		*计算从屏幕空间生成的射线。
		*@param point 屏幕空间的位置位置。
		*@return out 输出射线。
		*/
		__proto.viewportPointToRay=function(point,out){
			Picker.calculateCursorRay(point,this.viewport,this._projectionMatrix,this.viewMatrix,null,out);
		}

		/**
		*计算从裁切空间生成的射线。
		*@param point 裁切空间的位置。。
		*@return out 输出射线。
		*/
		__proto.normalizedViewportPointToRay=function(point,out){
			var finalPoint=Camera._tempVector20;
			var vp=this.viewport;
			var nVpPosE=point.elements;
			var vpPosE=finalPoint.elements;
			vpPosE[0]=nVpPosE[0] *vp.width;
			vpPosE[1]=nVpPosE[1] *vp.height;
			Picker.calculateCursorRay(finalPoint,this.viewport,this._projectionMatrix,this.viewMatrix,null,out);
		}

		/**
		*计算从世界空间准换三维坐标到屏幕空间。
		*@param position 世界空间的位置。
		*@return out 输出位置。
		*/
		__proto.worldToViewportPoint=function(position,out){
			Matrix4x4.multiply(this._projectionMatrix,this._viewMatrix,this._projectionViewMatrix);
			this.viewport.project(position,this._projectionViewMatrix,out);
			if (out.z < 0.0 || out.z > 1.0){
				var outE=out.elements;
				outE[0]=outE[1]=outE[2]=NaN;
			}
		}

		/**
		*计算从世界空间准换三维坐标到裁切空间。
		*@param position 世界空间的位置。
		*@return out 输出位置。
		*/
		__proto.worldToNormalizedViewportPoint=function(position,out){
			Matrix4x4.multiply(this._projectionMatrix,this._viewMatrix,this._projectionViewMatrix);
			this.normalizedViewport.project(position,this._projectionViewMatrix,out);
			if (out.z < 0.0 || out.z > 1.0){
				var outE=out.elements;
				outE[0]=outE[1]=outE[2]=NaN;
			}
		}

		/**
		*获取视图投影矩阵。
		*@return 视图投影矩阵。
		*/
		__getset(0,__proto,'projectionViewMatrix',function(){
			Matrix4x4.multiply(this.projectionMatrix,this.viewMatrix,this._projectionViewMatrix);
			return this._projectionViewMatrix;
		});

		/**
		*设置横纵比。
		*@param value 横纵比。
		*/
		/**
		*获取横纵比。
		*@return 横纵比。
		*/
		__getset(0,__proto,'aspectRatio',function(){
			if (this._aspectRatio===0){
				var vp=this.viewport;
				return vp.width / vp.height;
			}
			return this._aspectRatio;
			},function(value){
			if (value < 0)
				throw new Error("Camera: the aspect ratio has to be a positive real number.");
			this._aspectRatio=value;
			this._calculateProjectionMatrix();
		});

		/**
		*获取摄像机视锥。
		*/
		__getset(0,__proto,'boundFrustum',function(){
			if (this._boundFrustumUpdate)
				this._boundFrustum.matrix=this.projectionViewMatrix;
			return this._boundFrustum;
		});

		__getset(0,__proto,'needViewport',function(){
			var nVp=this.normalizedViewport;
			return nVp.x===0 && nVp.y===0 && nVp.width===1 && nVp.height===1;
		});

		/**
		*设置屏幕空间的视口。
		*@param 屏幕空间的视口。
		*/
		/**
		*获取屏幕空间的视口。
		*@return 屏幕空间的视口。
		*/
		__getset(0,__proto,'viewport',function(){
			if (this._viewportExpressedInClipSpace){
				var nVp=this._normalizedViewport;
				var size=this.renderTargetSize;
				var sizeW=size.width;
				var sizeH=size.height;
				this._viewport.x=nVp.x *sizeW;
				this._viewport.y=nVp.y *sizeH;
				this._viewport.width=nVp.width *sizeW;
				this._viewport.height=nVp.height *sizeH;
			}
			return this._viewport;
			},function(value){
			if (this.renderTarget !=null && (value.x < 0 || value.y < 0 || value.width==0 || value.height==0))
				throw new Error("Camera: viewport size invalid.","value");
			this._viewportExpressedInClipSpace=false;
			this._viewport=value;
			this._calculateProjectionMatrix();
		});

		/**
		*设置裁剪空间的视口。
		*@return 裁剪空间的视口。
		*/
		/**
		*获取裁剪空间的视口。
		*@return 裁剪空间的视口。
		*/
		__getset(0,__proto,'normalizedViewport',function(){
			if (!this._viewportExpressedInClipSpace){
				var vp=this._viewport;
				var size=this.renderTargetSize;
				var sizeW=size.width;
				var sizeH=size.height;
				this._normalizedViewport.x=vp.x / sizeW;
				this._normalizedViewport.y=vp.y / sizeH;
				this._normalizedViewport.width=vp.width / sizeW;
				this._normalizedViewport.height=vp.height / sizeH;
			}
			return this._normalizedViewport;
			},function(value){
			if (value.x < 0 || value.y < 0 || (value.x+value.width)> 1 || (value.y+value.height)> 1)
				throw new Error("Camera: viewport size invalid.","value");
			this._viewportExpressedInClipSpace=true;
			this._normalizedViewport=value;
			this._calculateProjectionMatrix();
		});

		/**设置投影矩阵。*/
		/**获取投影矩阵。*/
		__getset(0,__proto,'projectionMatrix',function(){
			return this._projectionMatrix;
			},function(value){
			this._projectionMatrix=value;
			this._useUserProjectionMatrix=true;
		});

		/**
		*获取视图矩阵。
		*@return 视图矩阵。
		*/
		__getset(0,__proto,'viewMatrix',function(){
			this.transform.worldMatrix.invert(this._viewMatrix);
			return this._viewMatrix;
		});

		__static(Camera,
		['_tempVector20',function(){return this._tempVector20=new Vector2();}
		]);
		return Camera;
	})(BaseCamera)


	/**
	*<code>Glitter</code> 类用于创建闪光。
	*/
	//class laya.d3.core.glitter.Glitter extends laya.d3.core.RenderableSprite3D
	var Glitter=(function(_super){
		/**
		*创建一个 <code>Glitter</code> 实例。
		*@param settings 配置信息。
		*/
		function Glitter(){
			Glitter.__super.call(this);
			this._render=new GlitterRender(this);
			this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._onMaterialChanged);
			var material=new GlitterMaterial();
			this._render.sharedMaterial=material;
			this._geometryFilter=new GlitterTemplet(this);
			material.renderMode=/*laya.d3.core.material.GlitterMaterial.RENDERMODE_DEPTHREAD_ADDTIVEDOUBLEFACE*/8;
			this._changeRenderObject(0);
		}

		__class(Glitter,'laya.d3.core.glitter.Glitter',_super);
		var __proto=Glitter.prototype;
		/**@private */
		__proto._changeRenderObject=function(index){
			var renderObjects=this._render._renderElements;
			var renderElement=renderObjects[index];
			(renderElement)|| (renderElement=renderObjects[index]=new RenderElement());
			renderElement._render=this._render;
			var material=this._render.sharedMaterials[index];
			(material)|| (material=GlitterMaterial.defaultMaterial);
			var element=this._geometryFilter;
			renderElement._mainSortID=0;
			renderElement._sprite3D=this;
			renderElement.renderObj=element;
			renderElement._material=material;
			return renderElement;
		}

		/**@private */
		__proto._onMaterialChanged=function(_glitterRender,index,material){
			var renderElementCount=_glitterRender._renderElements.length;
			(index < renderElementCount)&& this._changeRenderObject(index);
		}

		/**@private */
		__proto._clearSelfRenderObjects=function(){
			this.scene.removeFrustumCullingObject(this._render);
		}

		/**@private */
		__proto._addSelfRenderObjects=function(){
			this.scene.addFrustumCullingObject(this._render);
		}

		__proto._update=function(state){
			(this._geometryFilter)._update(state.elapsedTime);
			_super.prototype._update.call(this,state);
		}

		/**
		*@private
		*/
		__proto._renderUpdate=function(projectionView){
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.WORLDMATRIX*/0,this.transform.worldMatrix);
			var projViewWorld=this.getProjectionViewWorldMatrix(projectionView);
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,projViewWorld);
		}

		/**
		*通过位置添加刀光。
		*@param position0 位置0。
		*@param position1 位置1。
		*/
		__proto.addGlitterByPositions=function(position0,position1){
			(this._geometryFilter).addVertexPosition(position0,position1);
		}

		/**
		*通过位置和速度添加刀光。
		*@param position0 位置0。
		*@param velocity0 速度0。
		*@param position1 位置1。
		*@param velocity1 速度1。
		*/
		__proto.addGlitterByPositionsVelocitys=function(position0,velocity0,position1,velocity1){
			(this._geometryFilter).addVertexPositionVelocity(position0,velocity0,position1,velocity1);
		}

		__proto.cloneTo=function(destObject){
			laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
			var destGlitter=destObject;
			var destTemplet=destGlitter.templet;
			var templet=this._geometryFilter;
			destTemplet.lifeTime=templet.lifeTime;
			destTemplet.minSegmentDistance=templet.minSegmentDistance;
			destTemplet.minInterpDistance=templet.minInterpDistance;
			destTemplet.maxSlerpCount=templet.maxSlerpCount;
			templet.color.cloneTo(destTemplet.color);
			destTemplet._maxSegments=templet._maxSegments;
			var destGlitterRender=destGlitter._render;
			var glitterRender=this._render;
			destGlitterRender.sharedMaterials=glitterRender.sharedMaterials;
			destGlitterRender.enable=glitterRender.enable;
		}

		/**
		*<p>销毁此对象。</p>
		*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._geometryFilter._destroy();
			this._geometryFilter=null;
		}

		/**
		*获取闪光模板。
		*@return 闪光模板。
		*/
		__getset(0,__proto,'templet',function(){
			return this._geometryFilter;
		});

		/**
		*获取刀光渲染器。
		*@return 刀光渲染器。
		*/
		__getset(0,__proto,'glitterRender',function(){
			return this._render;
		});

		return Glitter;
	})(RenderableSprite3D)


	/**
	*<code>DirectionLight</code> 类用于创建平行光。
	*/
	//class laya.d3.core.light.DirectionLight extends laya.d3.core.light.LightSprite
	var DirectionLight=(function(_super){
		function DirectionLight(){
			this._updateDirection=false;
			this._direction=null;
			DirectionLight.__super.call(this);
			this._diffuseColor=new Vector3(1.0,1.0,1.0);
			this._ambientColor=new Vector3(0.6,0.6,0.6);
			this._specularColor=new Vector3(1.0,1.0,1.0);
			this._reflectColor=new Vector3(1.0,1.0,1.0);
			this._updateDirection=false;
			this.direction=new Vector3(0.0,-0.5,-1.0);
			this.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChange);
		}

		__class(DirectionLight,'laya.d3.core.light.DirectionLight',_super);
		var __proto=DirectionLight.prototype;
		/**
		*@private
		*/
		__proto._initShadow=function(){
			if (this._shadow){
				this._parallelSplitShadowMap=new ParallelSplitShadowMap();
				this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap);
				this._parallelSplitShadowMap.setInfo(this.scene,this._shadowFarPlane,this.direction,this._shadowMapSize,this._shadowMapCount,this._shadowMapPCFType);
				}else {
				var parallelSplitShadowMaps=this.scene.parallelSplitShadowMaps;
				parallelSplitShadowMaps.splice(parallelSplitShadowMaps.indexOf(this._parallelSplitShadowMap),1);
				this._parallelSplitShadowMap.disposeAllRenderTarget();
				this._parallelSplitShadowMap=null;
				this.scene.removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM1);
				this.scene.removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM2);
				this.scene.removeShaderDefine(ParallelSplitShadowMap.SHADERDEFINE_SHADOW_PSSM3);
			}
		}

		/**
		*@private
		*/
		__proto._onWorldMatrixChange=function(){
			this._updateDirection=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._addSelfRenderObjects=function(){
			_super.prototype._addSelfRenderObjects.call(this);
			this._shadow && (this._initShadow());
		}

		/**
		*@inheritDoc
		*/
		__proto._clearSelfRenderObjects=function(){
			var scene=this.scene;
			var shaderValue=scene._shaderValues;
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.LIGHTDIRDIFFUSE*/4,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.LIGHTDIRAMBIENT*/5,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.LIGHTDIRSPECULAR*/6,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.LIGHTDIRECTION*/3,null);
			(this._activeInHierarchy)&& (scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT));
		}

		/**
		*更新平行光相关渲染状态参数。
		*@param state 渲染状态参数。
		*/
		__proto.updateToWorldState=function(state){
			var scene=state.scene;
			if (scene.enableLight && this.active){
				var shaderValue=scene._shaderValues;
				scene.addShaderDefine(ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.LIGHTDIRDIFFUSE*/4,this.diffuseColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.LIGHTDIRAMBIENT*/5,this.ambientColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.LIGHTDIRSPECULAR*/6,this.specularColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.LIGHTDIRECTION*/3,this.direction.elements);
				return true;
				}else {
				scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_DIRECTIONLIGHT);
				return false;
			}
		}

		/**
		*设置平行光的方向。
		*@param value 平行光的方向。
		*/
		/**
		*获取平行光的方向。
		*@return 平行光的方向。
		*/
		__getset(0,__proto,'direction',function(){
			if (this._updateDirection){
				this.transform.worldMatrix.getForward(this._direction);
				Vector3.normalize(this._direction,this._direction);
				this._updateDirection=false;
			}
			return this._direction;
			},function(value){
			var worldMatrix=this.transform.worldMatrix;
			worldMatrix.setForward(value);
			this.transform.worldMatrix=worldMatrix;
			Vector3.normalize(value,value);
			this._direction=value;
			(this.shadow&&this._parallelSplitShadowMap)&& (this._parallelSplitShadowMap._setGlobalParallelLightDir(this._direction));
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'lightType',function(){
			return 1;
		});

		/**
		*@inheritDoc
		*/
		__getset(0,__proto,'shadow',_super.prototype._$get_shadow,function(value){
			if (this._shadow!==value){
				this._shadow=value;
				(this.scene)&& (this._initShadow());
			}
		});

		return DirectionLight;
	})(LightSprite)


	/**
	*<code>PointLight</code> 类用于创建点光。
	*/
	//class laya.d3.core.light.PointLight extends laya.d3.core.light.LightSprite
	var PointLight=(function(_super){
		function PointLight(){
			this._attenuation=null;
			this._range=NaN;
			PointLight.__super.call(this);
			this._diffuseColor=new Vector3(1.0,1.0,1.0);
			this._ambientColor=new Vector3(0.2,0.2,0.2);
			this._specularColor=new Vector3(1.0,0.0,0.0);
			this._reflectColor=new Vector3(1.0,1.0,1.0);
			this.transform.position=new Vector3(0.0,0.0,0.0);
			this._range=6.0;
			this._attenuation=new Vector3(0.6,0.6,0.6);
		}

		__class(PointLight,'laya.d3.core.light.PointLight',_super);
		var __proto=PointLight.prototype;
		/**
		*@inheritDoc
		*/
		__proto._clearSelfRenderObjects=function(){
			var scene=this.scene;
			var shaderValue=scene._shaderValues;
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTDIFFUSE*/10,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTAMBIENT*/11,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTSPECULAR*/12,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTPOS*/7,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTRANGE*/8,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTATTENUATION*/9,null);
			(this._activeInHierarchy)&& (scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT));
		}

		/**
		*更新点光相关渲染状态参数。
		*@param state 渲染状态参数。
		*/
		__proto.updateToWorldState=function(state){
			var scene=state.scene;
			if (scene.enableLight && this.active){
				var shaderValue=scene._shaderValues;
				scene.addShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTDIFFUSE*/10,this.diffuseColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTAMBIENT*/11,this.ambientColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTSPECULAR*/12,this.specularColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTPOS*/7,this.transform.position.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTRANGE*/8,this.range);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.POINTLIGHTATTENUATION*/9,this.attenuation.elements);
				return true;
				}else {
				scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_POINTLIGHT);
				return false;
			}
		}

		/**
		*设置点光的范围。
		*@param value 点光的范围。
		*/
		/**
		*获取点光的范围。
		*@return 点光的范围。
		*/
		__getset(0,__proto,'range',function(){
			return this._range;
			},function(value){
			this._range=value;
		});

		/**
		*获取点光的类型。
		*@return 点光的类型。
		*/
		__getset(0,__proto,'lightType',function(){
			return 2;
		});

		/**
		*设置点光的衰减。
		*@param value 点光的衰减。
		*/
		/**
		*获取点光的衰减。
		*@return 点光的衰减。
		*/
		__getset(0,__proto,'attenuation',function(){
			return this._attenuation;
			},function(value){
			this._attenuation=value;
		});

		return PointLight;
	})(LightSprite)


	/**
	*<code>SpotLight</code> 类用于创建聚光。
	*/
	//class laya.d3.core.light.SpotLight extends laya.d3.core.light.LightSprite
	var SpotLight=(function(_super){
		function SpotLight(){
			this._updateDirection=false;
			this._direction=null;
			this._attenuation=null;
			this._spot=NaN;
			this._range=NaN;
			SpotLight.__super.call(this);
			this._diffuseColor=new Vector3(1.0,1.0,1.0);
			this._ambientColor=new Vector3(0.2,0.2,0.2);
			this._specularColor=new Vector3(1.0,1.0,1.0);
			this._reflectColor=new Vector3(1.0,1.0,1.0);
			this.transform.position=new Vector3(0.0,1.0,1.0);
			this._updateDirection=false;
			this.direction=new Vector3(0.0,-1.0,-1.0);
			this._attenuation=new Vector3(0.6,0.6,0.6);
			this._spot=96.0;
			this._range=6.0;
			this.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChange);
		}

		__class(SpotLight,'laya.d3.core.light.SpotLight',_super);
		var __proto=SpotLight.prototype;
		/**
		*@private
		*/
		__proto._onWorldMatrixChange=function(){
			this._updateDirection=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._clearSelfRenderObjects=function(){
			var scene=this.scene;
			var shaderValue=scene._shaderValues;
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTDIFFUSE*/18,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTAMBIENT*/19,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTSPECULAR*/20,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTPOS*/13,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTDIRECTION*/14,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTRANGE*/16,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTSPOT*/15,null);
			shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTATTENUATION*/17,null);
			(this._activeInHierarchy)&& (scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_SPOTLIGHT));
		}

		/**
		*更新聚光相关渲染状态参数。
		*@param state 渲染状态参数。
		*/
		__proto.updateToWorldState=function(state){
			var scene=state.scene;
			if (scene.enableLight && this.active){
				var shaderValue=scene._shaderValues;
				scene.addShaderDefine(ShaderCompile3D.SHADERDEFINE_SPOTLIGHT);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTDIFFUSE*/18,this.diffuseColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTAMBIENT*/19,this.ambientColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTSPECULAR*/20,this.specularColor.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTPOS*/13,this.transform.position.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTDIRECTION*/14,this.direction.elements);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTRANGE*/16,this.range);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTSPOT*/15,this.spot);
				shaderValue.setValue(/*laya.d3.core.scene.BaseScene.SPOTLIGHTATTENUATION*/17,this.attenuation.elements);
				return true;
				}else {
				scene.removeShaderDefine(ShaderCompile3D.SHADERDEFINE_SPOTLIGHT);
				return false;
			}
		}

		/**
		*设置聚光的范围。
		*@param value 聚光的范围值。
		*/
		/**
		*获取聚光的范围。
		*@return 聚光的范围值。
		*/
		__getset(0,__proto,'range',function(){
			return this._range;
			},function(value){
			this._range=value;
		});

		/**
		*设置平行光的方向。
		*@param value 平行光的方向。
		*/
		/**
		*获取平行光的方向。
		*@return 平行光的方向。
		*/
		__getset(0,__proto,'direction',function(){
			if (this._updateDirection){
				this.transform.worldMatrix.getForward(this._direction);
				this._updateDirection=false;
			}
			return this._direction;
			},function(value){
			var worldMatrix=this.transform.worldMatrix;
			worldMatrix.setForward(value);
			this.transform.worldMatrix=worldMatrix;
			this._direction=value;
		});

		/**
		*获取聚光的类型。
		*@return 聚光的类型。
		*/
		__getset(0,__proto,'lightType',function(){
			return 3;
		});

		/**
		*设置聚光的衰减。
		*@param value 聚光的衰减。
		*/
		/**
		*获取聚光的衰减。
		*@return 聚光的衰减。
		*/
		__getset(0,__proto,'attenuation',function(){
			return this._attenuation;
			},function(value){
			this._attenuation=value;
		});

		/**
		*设置聚光的聚光值。
		*@param value 聚光的聚光值。
		*/
		/**
		*获取聚光的聚光值。
		*@return 聚光的聚光值。
		*/
		__getset(0,__proto,'spot',function(){
			return this._spot;
			},function(value){
			this._spot=value;
		});

		return SpotLight;
	})(LightSprite)


	/**
	*<code>MeshSprite3D</code> 类用于创建网格。
	*/
	//class laya.d3.core.MeshSprite3D extends laya.d3.core.RenderableSprite3D
	var MeshSprite3D=(function(_super){
		/**
		*创建一个 <code>MeshSprite3D</code> 实例。
		*@param mesh 网格,同时会加载网格所用默认材质。
		*@param name 名字。
		*/
		function MeshSprite3D(mesh,name){
			MeshSprite3D.__super.call(this,name);
			this._geometryFilter=new MeshFilter(this);
			this._render=new MeshRender(this);
			this._geometryFilter.on(/*laya.events.Event.MESH_CHANGED*/"meshchanged",this,this._onMeshChanged);
			this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._onMaterialChanged);
			if (mesh){
				(this._geometryFilter).sharedMesh=mesh;
				if ((mesh instanceof laya.d3.resource.models.Mesh ))
					if (mesh.loaded)
				this._render.sharedMaterials=(mesh).materials;
				else
				mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._applyMeshMaterials);
			}
		}

		__class(MeshSprite3D,'laya.d3.core.MeshSprite3D',_super);
		var __proto=MeshSprite3D.prototype;
		/**
		*@private
		*/
		__proto.createConchModel=function(){
			return null;
		}

		/**
		*@private
		*/
		__proto._changeRenderObjectByMesh=function(index){
			var renderObjects=this._render._renderElements;
			var renderElement=renderObjects[index];
			(renderElement)|| (renderElement=renderObjects[index]=new RenderElement());
			renderElement._render=this._render;
			var material=this._render.sharedMaterials[index];
			(material)|| (material=StandardMaterial.defaultMaterial);
			var element=(this._geometryFilter).sharedMesh.getRenderElement(index);
			renderElement._mainSortID=this._getSortID(element,material);
			renderElement._sprite3D=this;
			renderElement.renderObj=element;
			renderElement._material=material;
			if (Render.isConchNode){
				var vertexBuffer=element._getVertexBuffer();
				renderElement._conchSubmesh.setVBIB(vertexBuffer.vertexDeclaration._conchVertexDeclaration,vertexBuffer.getData(),element._getIndexBuffer().getData());
			}
			return renderElement;
		}

		/**
		*@private
		*/
		__proto._changeRenderObjectByMaterial=function(index,material){
			var renderElement=this._render._renderElements[index];
			var element=(this._geometryFilter).sharedMesh.getRenderElement(index);
			renderElement._mainSortID=this._getSortID(element,material);
			renderElement._sprite3D=this;
			renderElement.renderObj=element;
			renderElement._material=material;
			if (Render.isConchNode){
				renderElement._conchSubmesh.setMaterial(material._conchMaterial);
			}
			return renderElement;
		}

		/**
		*@private
		*/
		__proto._changeRenderObjectsByMesh=function(){
			if (Render.isConchNode){
			};
			var renderElementsCount=(this._geometryFilter).sharedMesh.getRenderElementsCount();
			this._render._renderElements.length=renderElementsCount;
			for (var i=0;i < renderElementsCount;i++)
			this._changeRenderObjectByMesh(i);
		}

		/**
		*@private
		*/
		__proto._onMeshChanged=function(meshFilter){
			var mesh=meshFilter.sharedMesh;
			if (mesh.loaded)
				this._changeRenderObjectsByMesh();
			else
			mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._onMeshLoaded);
		}

		/**
		*@private
		*/
		__proto._onMeshLoaded=function(sender){
			(sender===this.meshFilter.sharedMesh)&& (this._changeRenderObjectsByMesh());
		}

		/**
		*@private
		*/
		__proto._onMaterialChanged=function(meshRender,index,material){
			var renderElementCount=this._render._renderElements.length;
			(index < renderElementCount)&& this._changeRenderObjectByMaterial(index,material);
		}

		/**
		*@private
		*/
		__proto._clearSelfRenderObjects=function(){
			this.scene.removeFrustumCullingObject(this._render);
			if (this.scene.conchModel){}
				}
		/**
		*@private
		*/
		__proto._addSelfRenderObjects=function(){
			this.scene.addFrustumCullingObject(this._render);
			if (this.scene.conchModel){}
				}
		/**
		*@private
		*/
		__proto._applyMeshMaterials=function(mesh){
			var shaderMaterials=this._render.sharedMaterials;
			var meshMaterials=mesh.materials;
			for (var i=0,n=meshMaterials.length;i < n;i++)
			(shaderMaterials[i])|| (shaderMaterials[i]=meshMaterials[i]);
			this._render.sharedMaterials=shaderMaterials;
		}

		/**
		*@private
		*/
		__proto._renderUpdate=function(projectionView){
			laya.d3.core.Sprite3D.prototype._renderUpdate.call(this,projectionView);
		}

		__proto.cloneTo=function(destObject){
			laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
			var meshSprite3D=destObject;
			(meshSprite3D._geometryFilter).sharedMesh=(this._geometryFilter).sharedMesh;
			var meshRender=this._render;
			var destMeshRender=meshSprite3D._render;
			destMeshRender.enable=meshRender.enable;
			destMeshRender.sharedMaterials=meshRender.sharedMaterials;
			destMeshRender.castShadow=meshRender.castShadow;
			var lightmapScaleOffset=meshRender.lightmapScaleOffset;
			lightmapScaleOffset && (destMeshRender.lightmapScaleOffset=lightmapScaleOffset.clone());
			destMeshRender.receiveShadow=meshRender.receiveShadow;
			destMeshRender.sortingFudge=meshRender.sortingFudge;
		}

		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			(this._geometryFilter)._destroy();
		}

		/**
		*获取网格过滤器。
		*@return 网格过滤器。
		*/
		__getset(0,__proto,'meshFilter',function(){
			return this._geometryFilter;
		});

		/**
		*获取网格渲染器。
		*@return 网格渲染器。
		*/
		__getset(0,__proto,'meshRender',function(){
			return this._render;
		});

		MeshSprite3D.load=function(url){
			return Laya.loader.create(url,null,null,MeshSprite3D,null,1,false);
		}

		MeshSprite3D.LIGHTMAPSCALEOFFSET=2;
		return MeshSprite3D;
	})(RenderableSprite3D)


	/**
	*<code>Particle3D</code> 3D粒子。
	*/
	//class laya.d3.core.particle.Particle3D extends laya.d3.core.RenderableSprite3D
	var Particle3D=(function(_super){
		function Particle3D(setting){
			this._setting=null;
			this._templet=null;
			Particle3D.__super.call(this);
			this._setting=setting;
			this._render=new ParticleRender(this);
			this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._onMaterialChanged);
			var material=new ParticleMaterial();
			if (setting.textureName)
				material.diffuseTexture=Texture2D.load(setting.textureName);
			this._render.sharedMaterial=material;
			this._templet=new ParticleTemplet3D(this,setting);
			if (setting.blendState===0)
				material.renderMode=/*laya.d3.core.material.ParticleMaterial.RENDERMODE_DEPTHREAD_TRANSPARENT*/5;
			else if (setting.blendState===1)
			material.renderMode=/*laya.d3.core.material.ParticleMaterial.RENDERMODE_DEPTHREAD_ADDTIVE*/7;
			this._changeRenderObject(0);
		}

		__class(Particle3D,'laya.d3.core.particle.Particle3D',_super);
		var __proto=Particle3D.prototype;
		/**@private */
		__proto._changeRenderObject=function(index){
			var renderObjects=this._render._renderElements;
			var renderElement=renderObjects[index];
			(renderElement)|| (renderElement=renderObjects[index]=new RenderElement());
			renderElement._render=this._render;
			var material=this._render.sharedMaterials[index];
			(material)|| (material=ParticleMaterial.defaultMaterial);
			var element=this._templet;
			renderElement._mainSortID=0;
			renderElement._sprite3D=this;
			renderElement.renderObj=element;
			renderElement._material=material;
			return renderElement;
		}

		/**@private */
		__proto._onMaterialChanged=function(particleRender,index,material){
			var renderElementCount=particleRender._renderElements.length;
			(index < renderElementCount)&& this._changeRenderObject(index);
		}

		/**@private */
		__proto._clearSelfRenderObjects=function(){
			this.scene.removeFrustumCullingObject(this._render);
		}

		/**@private */
		__proto._addSelfRenderObjects=function(){
			this.scene.addFrustumCullingObject(this._render);
		}

		/**
		*@private
		*/
		__proto._renderUpdate=function(projectionView){
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.WORLDMATRIX*/0,this.transform.worldMatrix);
			var projViewWorld=this.getProjectionViewWorldMatrix(projectionView);
			this._setShaderValueMatrix4x4(/*laya.d3.core.Sprite3D.MVPMATRIX*/1,projViewWorld);
		}

		__proto._update=function(state){
			this._templet.update(state.elapsedTime);
			_super.prototype._update.call(this,state);
		}

		/**
		*添加粒子。
		*@param position 粒子位置。
		*@param velocity 粒子速度。
		*/
		__proto.addParticle=function(position,velocity){
			Vector3.add(this.transform.localPosition,position,position);
			this._templet.addParticle(position,velocity);
		}

		__proto.cloneTo=function(destObject){
			laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
			var destParticle3D=destObject;
			destParticle3D._templet=this._templet;
			var destParticleRender=destParticle3D._render;
			var particleRender=this._render;
			destParticleRender.sharedMaterials=particleRender.sharedMaterials;
			destParticleRender.enable=particleRender.enable;
		}

		/**
		*<p>销毁此对象。</p>
		*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			this._templet=null;
		}

		/**
		*获取粒子模板。
		*@return 粒子模板。
		*/
		__getset(0,__proto,'templet',function(){
			return this._templet;
		});

		/**
		*获取粒子渲染器。
		*@return 粒子渲染器。
		*/
		__getset(0,__proto,'particleRender',function(){
			return this._render;
		});

		return Particle3D;
	})(RenderableSprite3D)


	/**
	*<code>ShuriKenParticle3D</code> 3D粒子。
	*/
	//class laya.d3.core.particleShuriKen.ShuriKenParticle3D extends laya.d3.core.RenderableSprite3D
	var ShuriKenParticle3D=(function(_super){
		function ShuriKenParticle3D(material){
			ShuriKenParticle3D.__super.call(this);
			this._tempRotationMatrix=new Matrix4x4();
			this._render=new ShurikenParticleRender(this);
			this._render.on(/*laya.events.Event.MATERIAL_CHANGED*/"materialchanged",this,this._onMaterialChanged);
			this._geometryFilter=new ShurikenParticleSystem(this);
			this._changeRenderObject(0);
			(material)&& (this._render.sharedMaterial=material);
		}

		__class(ShuriKenParticle3D,'laya.d3.core.particleShuriKen.ShuriKenParticle3D',_super);
		var __proto=ShuriKenParticle3D.prototype;
		/**@private */
		__proto._changeRenderObject=function(index){
			var renderObjects=this._render._renderElements;
			var renderElement=renderObjects[index];
			(renderElement)|| (renderElement=renderObjects[index]=new RenderElement());
			renderElement._render=this._render;
			var material=this._render.sharedMaterials[index];
			(material)|| (material=ShurikenParticleMaterial.defaultMaterial);
			var element=this._geometryFilter;
			renderElement._mainSortID=0;
			renderElement._sprite3D=this;
			renderElement.renderObj=element;
			renderElement._material=material;
			return renderElement;
		}

		/**@private */
		__proto._onMaterialChanged=function(_particleRender,index,material){
			var renderElementCount=_particleRender._renderElements.length;
			(index < renderElementCount)&& this._changeRenderObject(index);
		}

		/**@private */
		__proto._clearSelfRenderObjects=function(){
			this.scene.removeFrustumCullingObject(this._render);
		}

		/**@private */
		__proto._addSelfRenderObjects=function(){
			this.scene.addFrustumCullingObject(this._render);
		}

		/**
		*@inheritDoc
		*/
		__proto._renderUpdate=function(projectionView){
			switch (this.particleSystem.simulationSpace){
				case 0:
					this._setShaderValueColor(0,Vector3.ZERO);
					break ;
				case 1:
					this._setShaderValueColor(0,this.transform.position);
					break ;
				default :
					throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
				}
			Matrix4x4.createFromQuaternion(this.transform.rotation,this._tempRotationMatrix);
			this._setShaderValueMatrix4x4(1,this._tempRotationMatrix);
			switch (this.particleSystem.scaleMode){
				case 0:;
					var scale=this.transform.scale;
					this._setShaderValueColor(4,scale);
					this._setShaderValueColor(5,scale);
					break ;
				case 1:;
					var localScale=this.transform.localScale;
					this._setShaderValueColor(4,localScale);
					this._setShaderValueColor(5,localScale);
					break ;
				case 2:
					this._setShaderValueColor(4,this.transform.scale);
					this._setShaderValueColor(5,Vector3.ONE);
					break ;
				}
			if (Laya3D.debugMode)
				this._renderRenderableBoundBox();
		}

		/**
		*@private
		*/
		__proto.cloneTo=function(destObject){
			laya.d3.core.Sprite3D.prototype.cloneTo.call(this,destObject);
			var destShuriKenParticle3D=destObject;
			var destParticleSystem=destShuriKenParticle3D._geometryFilter;
			(this._geometryFilter).cloneTo(destParticleSystem);
			var destParticleRender=destShuriKenParticle3D._render;
			var particleRender=this._render;
			destParticleRender.sharedMaterials=particleRender.sharedMaterials;
			destParticleRender.enable=particleRender.enable;
			destParticleRender.renderMode=particleRender.renderMode;
			destParticleRender.stretchedBillboardCameraSpeedScale=particleRender.stretchedBillboardCameraSpeedScale;
			destParticleRender.stretchedBillboardSpeedScale=particleRender.stretchedBillboardSpeedScale;
			destParticleRender.stretchedBillboardLengthScale=particleRender.stretchedBillboardLengthScale;
			destParticleRender.sortingFudge=particleRender.sortingFudge;
		}

		/**
		*<p>销毁此对象。</p>
		*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			(this._geometryFilter)._destroy();
			this._geometryFilter=null;
		}

		/**
		*获取粒子系统。
		*@return 粒子系统。
		*/
		__getset(0,__proto,'particleSystem',function(){
			return this._geometryFilter;
		});

		/**
		*获取粒子渲染器。
		*@return 粒子渲染器。
		*/
		__getset(0,__proto,'particleRender',function(){
			return this._render;
		});

		ShuriKenParticle3D.SHADERDEFINE_SPHERHBILLBOARD=0x2;
		ShuriKenParticle3D.SHADERDEFINE_STRETCHEDBILLBOARD=0x4;
		ShuriKenParticle3D.SHADERDEFINE_HORIZONTALBILLBOARD=0x8;
		ShuriKenParticle3D.SHADERDEFINE_VERTICALBILLBOARD=0x10;
		ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME=0x20;
		ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME=0x40;
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT=0x80;
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE=0x100;
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT=0x200;
		ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE=0x400;
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE=0x800;
		ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE=0x1000;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME=0x2000;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE=0x4000;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT=0x8000;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE=0x10000;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS=0x20000;
		ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES=0x40000;
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE=0x80000;
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE=0x100000;
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES=0x200000;
		ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE=0x400000;
		ShuriKenParticle3D.WORLDPOSITION=0;
		ShuriKenParticle3D.WORLDROTATIONMATRIX=1;
		ShuriKenParticle3D.POSITIONSCALE=4;
		ShuriKenParticle3D.SIZESCALE=5;
		ShuriKenParticle3D.VOLVELOCITYCONST=6;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTX=7;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTY=8;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTZ=9;
		ShuriKenParticle3D.VOLVELOCITYCONSTMAX=10;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTXMAX=11;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTYMAX=12;
		ShuriKenParticle3D.VOLVELOCITYGRADIENTZMAX=13;
		ShuriKenParticle3D.VOLSPACETYPE=14;
		ShuriKenParticle3D.COLOROVERLIFEGRADIENTALPHAS=15;
		ShuriKenParticle3D.COLOROVERLIFEGRADIENTCOLORS=16;
		ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTALPHAS=17;
		ShuriKenParticle3D.MAXCOLOROVERLIFEGRADIENTCOLORS=18;
		ShuriKenParticle3D.SOLSIZEGRADIENT=19;
		ShuriKenParticle3D.SOLSIZEGRADIENTX=20;
		ShuriKenParticle3D.SOLSIZEGRADIENTY=21;
		ShuriKenParticle3D.SOLSizeGradientZ=22;
		ShuriKenParticle3D.SOLSizeGradientMax=23;
		ShuriKenParticle3D.SOLSIZEGRADIENTXMAX=24;
		ShuriKenParticle3D.SOLSIZEGRADIENTYMAX=25;
		ShuriKenParticle3D.SOLSizeGradientZMAX=26;
		ShuriKenParticle3D.ROLANGULARVELOCITYCONST=27;
		ShuriKenParticle3D.ROLANGULARVELOCITYCONSTSEPRARATE=28;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENT=29;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTX=30;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTY=31;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZ=32;
		ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAX=33;
		ShuriKenParticle3D.ROLANGULARVELOCITYCONSTMAXSEPRARATE=34;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTMAX=35;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTXMAX=36;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTYMAX=37;
		ShuriKenParticle3D.ROLANGULARVELOCITYGRADIENTZMAX=38;
		ShuriKenParticle3D.TEXTURESHEETANIMATIONCYCLES=39;
		ShuriKenParticle3D.TEXTURESHEETANIMATIONSUBUVLENGTH=40;
		ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTUVS=41;
		ShuriKenParticle3D.TEXTURESHEETANIMATIONGRADIENTMAXUVS=42;
		return ShuriKenParticle3D;
	})(RenderableSprite3D)


	/**
	*<code>Camera</code> 类用于创建VR摄像机。
	*/
	//class laya.d3.core.VRCamera extends laya.d3.core.BaseCamera
	var VRCamera=(function(_super){
		function VRCamera(pupilDistande,leftAspectRatio,rightAspectRatio,nearPlane,farPlane){
			//this._tempMatrix=null;
			//this._leftAspectRatio=NaN;
			//this._leftViewport=null;
			//this._leftNormalizedViewport=null;
			//this._leftViewMatrix=null;
			//this._leftProjectionMatrix=null;
			//this._leftProjectionViewMatrix=null;
			//this._rightAspectRatio=NaN;
			//this._rightViewport=null;
			//this._rightNormalizedViewport=null;
			//this._rightViewMatrix=null;
			//this._rightProjectionMatrix=null;
			//this._rightProjectionViewMatrix=null;
			//this._pupilDistande=0;
			//this._leftBoundFrustumUpdate=false;
			//this._rightBoundFrustumUpdate=false;
			//this._leftBoundFrustum=null;
			//this._rightBoundFrustum=null;
			(pupilDistande===void 0)&& (pupilDistande=0.1);
			(leftAspectRatio===void 0)&& (leftAspectRatio=0);
			(rightAspectRatio===void 0)&& (rightAspectRatio=0);
			(nearPlane===void 0)&& (nearPlane=0.3);
			(farPlane===void 0)&& (farPlane=1000);
			this._tempMatrix=new Matrix4x4();
			this._leftViewMatrix=new Matrix4x4();
			this._leftProjectionMatrix=new Matrix4x4();
			this._leftProjectionViewMatrix=new Matrix4x4();
			this._leftViewport=new Viewport(0,0,0,0);
			this._leftNormalizedViewport=new Viewport(0,0,0.5,1);
			this._leftAspectRatio=leftAspectRatio;
			this._rightViewMatrix=new Matrix4x4();
			this._rightProjectionMatrix=new Matrix4x4();
			this._rightProjectionViewMatrix=new Matrix4x4();
			this._rightViewport=new Viewport(0,0,0,0);
			this._rightNormalizedViewport=new Viewport(0.5,0,0.5,1);
			this._rightAspectRatio=rightAspectRatio;
			this._pupilDistande=pupilDistande;
			this._leftBoundFrustumUpdate=true;
			this._leftBoundFrustum=new BoundFrustum(Matrix4x4.DEFAULT);
			this._rightBoundFrustumUpdate=true;
			this._rightBoundFrustum=new BoundFrustum(Matrix4x4.DEFAULT);
			VRCamera.__super.call(this,nearPlane,farPlane);
			this.transform.on(/*laya.events.Event.WORLDMATRIX_NEEDCHANGE*/"worldmatrixneedchanged",this,this._onWorldMatrixChanged);
		}

		__class(VRCamera,'laya.d3.core.VRCamera',_super);
		var __proto=VRCamera.prototype;
		/**
		*@private
		*/
		__proto._onWorldMatrixChanged=function(){
			this._leftBoundFrustumUpdate=this._rightBoundFrustumUpdate=true;
		}

		/**
		*@private
		*计算瞳距。
		*/
		__proto._calculatePupilOffset=function(){
			var offset=this._tempVector3;
			Vector3.scale(this.right,this._pupilDistande / 2,offset);
			return offset.elements;
		}

		/**
		*@private
		*计算左投影矩阵。
		*/
		__proto._calculateLeftProjectionMatrix=function(){
			if (!this._useUserProjectionMatrix){
				if (this.orthographicProjection){
					var leftHalfWidth=this.orthographicVerticalSize *this.leftAspectRatio *0.5;
					var leftHalfHeight=this.orthographicVerticalSize *0.5;
					Matrix4x4.createOrthogonal(-leftHalfWidth,leftHalfWidth,-leftHalfHeight,leftHalfHeight,this.nearPlane,this.farPlane,this._leftProjectionMatrix);
					}else {
					Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.leftAspectRatio,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
				}
			}
			this._leftBoundFrustumUpdate=true;
		}

		/**
		*@private
		*计算右投影矩阵。
		*/
		__proto._calculateRightProjectionMatrix=function(){
			if (!this._useUserProjectionMatrix){
				if (this.orthographicProjection){
					var rightHalfWidth=this.orthographicVerticalSize *this.rightAspectRatio *0.5;
					var rightHalfHeight=this.orthographicVerticalSize *0.5;
					Matrix4x4.createOrthogonal(-rightHalfWidth,rightHalfWidth,rightHalfHeight,rightHalfHeight,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
					}else {
					Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.rightAspectRatio,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
				}
			}
			this._rightBoundFrustumUpdate=true;
		}

		/**
		*@inheritDoc
		*/
		__proto._calculateProjectionMatrix=function(){
			if (!this._useUserProjectionMatrix){
				if (this.orthographicProjection){
					var leftHalfWidth=this.orthographicVerticalSize *this.leftAspectRatio *0.5;
					var leftHalfHeight=this.orthographicVerticalSize *0.5;
					var rightHalfWidth=this.orthographicVerticalSize *this.rightAspectRatio *0.5;
					var rightHalfHeight=this.orthographicVerticalSize *0.5;
					Matrix4x4.createOrthogonal(-leftHalfWidth,leftHalfWidth,-leftHalfHeight,leftHalfHeight,this.nearPlane,this.farPlane,this._leftProjectionMatrix);
					Matrix4x4.createOrthogonal(-rightHalfWidth,rightHalfWidth,rightHalfHeight,rightHalfHeight,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
					}else {
					Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.leftAspectRatio,this.nearPlane,this.farPlane,this._leftProjectionMatrix);
					Matrix4x4.createPerspective(3.1416 *this.fieldOfView / 180.0,this.rightAspectRatio,this.nearPlane,this.farPlane,this._rightProjectionMatrix);
				}
			}
			this._leftBoundFrustumUpdate=this._rightBoundFrustumUpdate=true;
		}

		/**
		*获取摄像机右视锥。
		*/
		__getset(0,__proto,'rightBoundFrustum',function(){
			if (this._rightBoundFrustumUpdate)
				this._rightBoundFrustum.matrix=this.rightProjectionViewMatrix;
			return this._rightBoundFrustum;
		});

		/**
		*获取裁剪空间的左视口。
		*@return 裁剪空间的左视口。
		*/
		__getset(0,__proto,'leftNormalizedViewport',function(){
			if (!this._viewportExpressedInClipSpace){
				var vp=this._leftViewport;
				var size=this.renderTargetSize;
				var sizeW=size.width;
				var sizeH=size.height;
				this._leftNormalizedViewport.x=vp.x / sizeW;
				this._leftNormalizedViewport.y=vp.y / sizeH;
				this._leftNormalizedViewport.width=vp.width / sizeW;
				this._leftNormalizedViewport.height=vp.height / sizeH;
			}
			return this._leftNormalizedViewport;
		});

		/**
		*获取屏幕空间的右视口。
		*@return 屏幕空间的右视口。
		*/
		__getset(0,__proto,'rightViewport',function(){
			if (this._viewportExpressedInClipSpace){
				var nVp=this._rightNormalizedViewport;
				var size=this.renderTargetSize;
				var sizeW=size.width;
				var sizeH=size.height;
				this._rightViewport.x=nVp.x *sizeW;
				this._rightViewport.y=nVp.y *sizeH;
				this._rightViewport.width=nVp.width *sizeW;
				this._rightViewport.height=nVp.height *sizeH;
			}
			return this._rightViewport;
		});

		/**
		*设置屏幕空间的视口。
		*@param 屏幕空间的视口。
		*/
		__getset(0,__proto,'viewport',null,function(value){
			if (this.renderTarget !=null && (value.x < 0 || value.y < 0 || value.width==0 || value.height==0))
				throw new Error("VRCamera: viewport size invalid.","value");
			this._viewportExpressedInClipSpace=false;
			this._leftViewport=new Viewport(0,0,value.width / 2,value.height);
			this._rightViewport=new Viewport(value.width / 2,0,value.width / 2,value.height);
			this._calculateProjectionMatrix();
		});

		/**
		*获取左横纵比。
		*@return 左横纵比。
		*/
		__getset(0,__proto,'leftAspectRatio',function(){
			if (this._leftAspectRatio===0){
				var lVp=this.leftViewport;
				return lVp.width / lVp.height;
			}
			return this._leftAspectRatio;
		});

		/**
		*获取右横纵比。
		*@return 右横纵比。
		*/
		__getset(0,__proto,'rightAspectRatio',function(){
			if (this._rightAspectRatio===0){
				var rVp=this.rightViewport;
				return rVp.width / rVp.height;
			}
			return this._rightAspectRatio;
		});

		/**
		*设置横纵比。
		*@param value 横纵比。
		*/
		__getset(0,__proto,'aspectRatio',null,function(value){
			if (value < 0)
				throw new Error("VRCamera: the aspect ratio has to be a positive real number.");
			this._leftAspectRatio=value;
			this._rightAspectRatio=value;
			this._calculateRightProjectionMatrix();
		});

		/**
		*获取裁剪空间的右视口。
		*@return 裁剪空间的右视口。
		*/
		__getset(0,__proto,'rightNormalizedViewport',function(){
			if (!this._viewportExpressedInClipSpace){
				var vp=this._rightViewport;
				var size=this.renderTargetSize;
				var sizeW=size.width;
				var sizeH=size.height;
				this._rightNormalizedViewport.x=vp.x / sizeW;
				this._rightNormalizedViewport.y=vp.y / sizeH;
				this._rightNormalizedViewport.width=vp.width / sizeW;
				this._rightNormalizedViewport.height=vp.height / sizeH;
			}
			return this._rightNormalizedViewport;
		});

		/**
		*设置裁剪空间的视口。
		*@return 裁剪空间的视口。
		*/
		__getset(0,__proto,'normalizedViewport',null,function(value){
			if (value.x < 0 || value.y < 0 || (value.x+value.width)> 1 || (value.x+value.height)> 1)
				throw new Error("VRCamera: viewport size invalid.","value");
			this._viewportExpressedInClipSpace=true;
			this._leftNormalizedViewport=new Viewport(0,0,value.width / 2,value.height);
			this._rightNormalizedViewport=new Viewport(value.width / 2,0,value.width / 2,value.height);
			this._calculateProjectionMatrix();
		});

		/**
		*获取屏幕空间的左视口。
		*@return 屏幕空间的左视口。
		*/
		__getset(0,__proto,'leftViewport',function(){
			if (this._viewportExpressedInClipSpace){
				var nVp=this._leftNormalizedViewport;
				var size=this.renderTargetSize;
				var sizeW=size.width;
				var sizeH=size.height;
				this._leftViewport.x=nVp.x *sizeW;
				this._leftViewport.y=nVp.y *sizeH;
				this._leftViewport.width=nVp.width *sizeW;
				this._leftViewport.height=nVp.height *sizeH;
			}
			return this._leftViewport;
		});

		__getset(0,__proto,'needLeftViewport',function(){
			var nVp=this.leftNormalizedViewport;
			return nVp.x===0 && nVp.y===0 && nVp.width===1 && nVp.height===1;
		});

		__getset(0,__proto,'needRightViewport',function(){
			var nVp=this.rightNormalizedViewport;
			return nVp.x===0 && nVp.y===0 && nVp.width===1 && nVp.height===1;
		});

		/**
		*获取左视图矩阵。
		*@return 左视图矩阵。
		*/
		__getset(0,__proto,'leftViewMatrix',function(){
			var offsetE=this._calculatePupilOffset();
			var tempWorldMat=this._tempMatrix;
			this.transform.worldMatrix.cloneTo(tempWorldMat);
			var worldMatE=tempWorldMat.elements;
			worldMatE[12]-=offsetE[0];
			worldMatE[13]-=offsetE[1];
			worldMatE[14]-=offsetE[2];
			tempWorldMat.invert(this._leftViewMatrix);
			return this._leftViewMatrix;
		});

		/**
		*获取右视图矩阵。
		*@return 右视图矩阵。
		*/
		__getset(0,__proto,'rightViewMatrix',function(){
			var offsetE=this._calculatePupilOffset();
			var tempWorldMat=this._tempMatrix;
			this.transform.worldMatrix.cloneTo(tempWorldMat);
			var worldMatE=tempWorldMat.elements;
			worldMatE[12]+=offsetE[0];
			worldMatE[13]+=offsetE[1];
			worldMatE[14]+=offsetE[2];
			tempWorldMat.invert(this._rightViewMatrix);
			return this._rightViewMatrix;
		});

		/**
		*获取左投影矩阵。
		*@return 左投影矩阵。
		*/
		__getset(0,__proto,'leftProjectionMatrix',function(){
			return this._leftProjectionMatrix;
		});

		/**
		*获取左投影视图矩阵。
		*@return 左投影视图矩阵。
		*/
		__getset(0,__proto,'leftProjectionViewMatrix',function(){
			Matrix4x4.multiply(this.leftProjectionMatrix,this.leftViewMatrix,this._leftProjectionViewMatrix);
			return this._leftProjectionViewMatrix;
		});

		/**
		*获取右投影矩阵。
		*@return 右投影矩阵。
		*/
		__getset(0,__proto,'rightProjectionMatrix',function(){
			return this._rightProjectionMatrix;
		});

		/**
		*获取右投影视图矩阵。
		*@return 右投影视图矩阵。
		*/
		__getset(0,__proto,'rightProjectionViewMatrix',function(){
			Matrix4x4.multiply(this.rightProjectionMatrix,this.rightViewMatrix,this._rightProjectionViewMatrix);
			return this._rightProjectionViewMatrix;
		});

		/**
		*获取摄像机左视锥。
		*/
		__getset(0,__proto,'leftBoundFrustum',function(){
			if (this._leftBoundFrustumUpdate)
				this._leftBoundFrustum.matrix=this.leftProjectionViewMatrix;
			return this._leftBoundFrustum;
		});

		return VRCamera;
	})(BaseCamera)


	/**
	*<code>TerrainChunk</code> 类用于创建地块。
	*/
	//class laya.d3.terrain.TerrainChunk extends laya.d3.core.RenderableSprite3D
	var TerrainChunk=(function(_super){
		/**
		*创建一个 <code>MeshSprite3D</code> 实例。
		*@param mesh 网格,同时会加载网格所用默认材质。
		*@param name 名字。
		*/
		function TerrainChunk(chunkOffsetX,chunkOffsetZ,girdSize,terrainHeightData,heightDataWidth,heightDataHeight,name){
			TerrainChunk.__super.call(this,name);
			this._geometryFilter=new TerrainFilter(this,chunkOffsetX,chunkOffsetZ,girdSize,terrainHeightData,heightDataWidth,heightDataHeight);
			this._render=new TerrainRender(this);
		}

		__class(TerrainChunk,'laya.d3.terrain.TerrainChunk',_super);
		var __proto=TerrainChunk.prototype;
		__proto.buildRenderElementAndMaterial=function(detailNum,normalMap,alphaMapUrl,detailUrl1,detailUrl2,detailUrl3,detailUrl4,sx1,sy1,sx2,sy2,sx3,sy3,sx4,sy4){
			(sx1===void 0)&& (sx1=1);
			(sy1===void 0)&& (sy1=1);
			(sx2===void 0)&& (sx2=1);
			(sy2===void 0)&& (sy2=1);
			(sx3===void 0)&& (sx3=1);
			(sy3===void 0)&& (sy3=1);
			(sx4===void 0)&& (sx4=1);
			(sy4===void 0)&& (sy4=1);
			var terrainMaterial=new TerrainMaterial();
			terrainMaterial.splatAlphaTexture=Texture2D.load(alphaMapUrl);
			terrainMaterial.splatAlphaTexture.repeat=false;
			terrainMaterial.normalTexture=normalMap ? Texture2D.load(normalMap):null;
			terrainMaterial.diffuseTexture1=detailUrl1 ? Texture2D.load(detailUrl1):null;
			terrainMaterial.diffuseTexture2=detailUrl2 ? Texture2D.load(detailUrl2):null;
			terrainMaterial.diffuseTexture3=detailUrl3 ? Texture2D.load(detailUrl3):null;
			terrainMaterial.diffuseTexture4=detailUrl4 ? Texture2D.load(detailUrl4):null;
			terrainMaterial.setDiffuseScale1(sx1,sy1);
			terrainMaterial.setDiffuseScale2(sx2,sy2);
			terrainMaterial.setDiffuseScale3(sx3,sy3);
			terrainMaterial.setDiffuseScale4(sx4,sy4);
			terrainMaterial.setDetailNum(detailNum);
			if (this._render._renderElements.length !=0){
				terrainMaterial.renderMode=/*laya.d3.core.material.TerrainMaterial.RENDERMODE_TRANSPARENT*/2;
			};
			var renderElement=new RenderElement();
			renderElement._mainSortID=0;
			renderElement._sprite3D=this;
			renderElement.renderObj=this._geometryFilter;
			renderElement._material=terrainMaterial;
			this._render._materials.push(terrainMaterial);
			this._render._renderElements.push(renderElement);
		}

		/**
		*@private
		*/
		__proto.createConchModel=function(){
			return null;
		}

		/**
		*@private
		*/
		__proto._clearSelfRenderObjects=function(){
			this.scene.removeFrustumCullingObject(this._render);
		}

		/**
		*@private
		*/
		__proto._addSelfRenderObjects=function(){
			this.scene.addFrustumCullingObject(this._render);
		}

		/**
		*@private
		*/
		__proto._applyMeshMaterials=function(mesh){
			var shaderMaterials=this._render.sharedMaterials;
			var meshMaterials=mesh.materials;
			for (var i=0,n=meshMaterials.length;i < n;i++)
			(shaderMaterials[i])|| (shaderMaterials[i]=meshMaterials[i]);
			this._render.sharedMaterials=shaderMaterials;
		}

		/**
		*@private
		*/
		__proto._renderUpdate=function(projectionView){
			laya.d3.core.Sprite3D.prototype._renderUpdate.call(this,projectionView);
		}

		__proto.cloneTo=function(destObject){
			console.log("Terrain Chunk can't clone");
		}

		__proto.destroy=function(destroyChild){
			(destroyChild===void 0)&& (destroyChild=true);
			_super.prototype.destroy.call(this,destroyChild);
			(this._geometryFilter)._destroy();
		}

		/**
		*获取地形过滤器。
		*@return 地形过滤器。
		*/
		__getset(0,__proto,'terrainFilter',function(){
			return this._geometryFilter;
		});

		/**
		*获取地形渲染器。
		*@return 地形渲染器。
		*/
		__getset(0,__proto,'terrainRender',function(){
			return this._render;
		});

		TerrainChunk.load=function(url){
			return Laya.loader.create(url,null,null,TerrainChunk,null,1,false);
		}

		return TerrainChunk;
	})(RenderableSprite3D)


	/**
	*<code>Sphere</code> 类用于创建方体。
	*/
	//class laya.d3.resource.models.BoxMesh extends laya.d3.resource.models.PrimitiveMesh
	var BoxMesh=(function(_super){
		function BoxMesh(long,width,height){
			this._long=NaN;
			this._width=NaN;
			this._height=NaN;
			(long===void 0)&& (long=1);
			(width===void 0)&& (width=1);
			(height===void 0)&& (height=1);
			BoxMesh.__super.call(this);
			this._long=long;
			this._width=width;
			this._height=height;
			this.activeResource();
			this._loaded=true;
			this._generateBoundingObject();
		}

		__class(BoxMesh,'laya.d3.resource.models.BoxMesh',_super);
		var __proto=BoxMesh.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			this._numberVertices=24;
			this._numberIndices=36;
			var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			var vertexFloatStride=vertexDeclaration.vertexStride / 4;
			var halfLong=this._long / 2;
			var halfHeight=this._height / 2;
			var halfWidth=this._width / 2;
			var vertices=new Float32Array([
			-halfLong,halfHeight,-halfWidth,0,1,0,0,0,
			halfLong,halfHeight,-halfWidth,0,1,0,1,0,
			halfLong,halfHeight,halfWidth,0,1,0,1,1,
			-halfLong,halfHeight,halfWidth,0,1,0,0,1,
			-halfLong,-halfHeight,-halfWidth,0,-1,0,0,1,
			halfLong,-halfHeight,-halfWidth,0,-1,0,1,1,
			halfLong,-halfHeight,halfWidth,0,-1,0,1,0,
			-halfLong,-halfHeight,halfWidth,0,-1,0,0,0,
			-halfLong,halfHeight,-halfWidth,-1,0,0,0,0,
			-halfLong,halfHeight,halfWidth,-1,0,0,1,0,
			-halfLong,-halfHeight,halfWidth,-1,0,0,1,1,
			-halfLong,-halfHeight,-halfWidth,-1,0,0,0,1,
			halfLong,halfHeight,-halfWidth,1,0,0,1,0,
			halfLong,halfHeight,halfWidth,1,0,0,0,0,
			halfLong,-halfHeight,halfWidth,1,0,0,0,1,
			halfLong,-halfHeight,-halfWidth,1,0,0,1,1,
			-halfLong,halfHeight,halfWidth,0,0,1,0,0,
			halfLong,halfHeight,halfWidth,0,0,1,1,0,
			halfLong,-halfHeight,halfWidth,0,0,1,1,1,
			-halfLong,-halfHeight,halfWidth,0,0,1,0,1,
			-halfLong,halfHeight,-halfWidth,0,0,-1,1,0,
			halfLong,halfHeight,-halfWidth,0,0,-1,0,0,
			halfLong,-halfHeight,-halfWidth,0,0,-1,0,1,
			-halfLong,-halfHeight,-halfWidth,0,0,-1,1,1]);
			var indices=new Uint16Array([
			0,1,2,
			2,3,0,
			4,7,6,
			6,5,4,
			8,9,10,
			10,11,8,
			12,15,14,
			14,13,12,
			16,17,18,
			18,19,16,
			20,23,22,
			22,21,20]);
			this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(indices);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.completeCreate();
		}

		/**
		*设置长度（改变此属性会重新生成顶点和索引）
		*@param value 长度
		*/
		/**
		*返回长度
		*@return 长
		*/
		__getset(0,__proto,'long',function(){
			return this._long;
			},function(value){
			if (this._long!==value){
				this._long=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置宽度（改变此属性会重新生成顶点和索引）
		*@param value 宽度
		*/
		/**
		*返回宽度
		*@return 宽
		*/
		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			if (this._width!==value){
				this._width=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置高度（改变此属性会重新生成顶点和索引）
		*@param value 高度
		*/
		/**
		*返回高度
		*@return 高
		*/
		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			if (this._height!==value){
				this._height=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		return BoxMesh;
	})(PrimitiveMesh)


	/**
	*<code>CapsuleMesh</code> 类用于创建胶囊体。
	*/
	//class laya.d3.resource.models.CapsuleMesh extends laya.d3.resource.models.PrimitiveMesh
	var CapsuleMesh=(function(_super){
		function CapsuleMesh(radius,height,stacks,slices){
			this._radius=NaN;
			this._height=NaN;
			this._slices=0;
			this._stacks=0;
			(radius===void 0)&& (radius=0.5);
			(height===void 0)&& (height=2);
			(stacks===void 0)&& (stacks=16);
			(slices===void 0)&& (slices=32);
			CapsuleMesh.__super.call(this);
			this._radius=radius;
			this._height=height < radius *2 ? radius *2 :height;
			this._stacks=stacks;
			this._slices=slices;
			this.recreateResource();
			this._loaded=true;
			this._generateBoundingObject();
		}

		__class(CapsuleMesh,'laya.d3.resource.models.CapsuleMesh',_super);
		var __proto=CapsuleMesh.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			this._numberVertices=(this._stacks+1)*(this.slices+1)*2+(this._slices+1)*2;
			this._numberIndices=(3 *this._stacks *(this._slices+1))*2 *2+2 *this._slices *3;
			var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			var vertexFloatStride=vertexDeclaration.vertexStride / 4;
			var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
			var indices=new Uint16Array(this._numberIndices);
			var stackAngle=(Math.PI / 2.0)/ this._stacks;
			var sliceAngle=(Math.PI *2.0)/ this._slices;
			var hcHeight=this._height / 2-this._radius;
			var posX=0;
			var posY=0;
			var posZ=0;
			var vc=0;
			var ic=0;
			var verticeCount=0;
			var stack=0,slice=0;
			for (stack=0;stack <=this._stacks;stack++){
				for (slice=0;slice <=this._slices;slice++){
					posX=this._radius *Math.cos(stack *stackAngle)*Math.cos(slice *sliceAngle+Math.PI);
					posY=this._radius *Math.sin(stack *stackAngle);
					posZ=this._radius *Math.cos(stack *stackAngle)*Math.sin(slice *sliceAngle+Math.PI);
					vertices[vc++]=posX;
					vertices[vc++]=posY+hcHeight;
					vertices[vc++]=posZ;
					vertices[vc++]=posX;
					vertices[vc++]=posY;
					vertices[vc++]=posZ;
					vertices[vc++]=1-slice / this._slices;
					vertices[vc++]=(1-stack / this._stacks)*((Math.PI *this._radius / 2)/ (this._height+Math.PI *this._radius));
					if (stack < this._stacks){
						indices[ic++]=(stack *(this._slices+1))+slice+(this._slices+1);
						indices[ic++]=(stack *(this._slices+1))+slice;
						indices[ic++]=(stack *(this._slices+1))+slice+1;
						indices[ic++]=(stack *(this._slices+1))+slice+(this._slices);
						indices[ic++]=(stack *(this._slices+1))+slice;
						indices[ic++]=(stack *(this._slices+1))+slice+(this._slices+1);
					}
				}
			}
			verticeCount+=(this._stacks+1)*(this._slices+1);
			for (stack=0;stack <=this._stacks;stack++){
				for (slice=0;slice <=this._slices;slice++){
					posX=this._radius *Math.cos(stack *stackAngle)*Math.cos(slice *sliceAngle+Math.PI);
					posY=this._radius *Math.sin(-stack *stackAngle);
					posZ=this._radius *Math.cos(stack *stackAngle)*Math.sin(slice *sliceAngle+Math.PI);
					vertices[vc++]=posX;
					vertices[vc++]=posY-hcHeight;
					vertices[vc++]=posZ;
					vertices[vc++]=posX;
					vertices[vc++]=posY;
					vertices[vc++]=posZ;
					vertices[vc++]=1-slice / this._slices;
					vertices[vc++]=((stack / this._stacks)*(Math.PI *this._radius / 2)+(this._height+Math.PI *this._radius / 2))/ (this._height+Math.PI *this._radius);
					if (stack < this._stacks){
						indices[ic++]=verticeCount+(stack *(this._slices+1))+slice;
						indices[ic++]=verticeCount+(stack *(this._slices+1))+slice+(this._slices+1);
						indices[ic++]=verticeCount+(stack *(this._slices+1))+slice+1;
						indices[ic++]=verticeCount+(stack *(this._slices+1))+slice;
						indices[ic++]=verticeCount+(stack *(this._slices+1))+slice+(this._slices);
						indices[ic++]=verticeCount+(stack *(this._slices+1))+slice+(this._slices+1);
					}
				}
			}
			verticeCount+=(this._stacks+1)*(this._slices+1);
			for (slice=0;slice <=this._slices;slice++){
				posX=this._radius *Math.cos(slice *sliceAngle+Math.PI);
				posY=hcHeight;
				posZ=this._radius *Math.sin(slice *sliceAngle+Math.PI);
				vertices[vc++]=posX;
				vertices[vc+(this._slices+1)*8-1]=posX;
				vertices[vc++]=posY;
				vertices[vc+(this._slices+1)*8-1]=-posY;
				vertices[vc++]=posZ;
				vertices[vc+(this._slices+1)*8-1]=posZ;
				vertices[vc++]=posX;
				vertices[vc+(this._slices+1)*8-1]=posX;
				vertices[vc++]=0;
				vertices[vc+(this._slices+1)*8-1]=0;
				vertices[vc++]=posZ;
				vertices[vc+(this._slices+1)*8-1]=posZ;
				vertices[vc++]=1-slice *1 / this._slices;
				vertices[vc+(this._slices+1)*8-1]=1-slice *1 / this._slices;
				vertices[vc++]=(Math.PI *this._radius / 2)/ (this._height+Math.PI *this._radius);
				vertices[vc+(this._slices+1)*8-1]=(Math.PI *this._radius / 2+this._height)/ (this._height+Math.PI *this._radius);
			}
			for (slice=0;slice < this._slices;slice++){
				indices[ic++]=slice+verticeCount+(this._slices+1);
				indices[ic++]=slice+verticeCount+1;
				indices[ic++]=slice+verticeCount;
				indices[ic++]=slice+verticeCount+(this._slices+1);
				indices[ic++]=slice+verticeCount+(this._slices+1)+1;
				indices[ic++]=slice+verticeCount+1;
			}
			verticeCount+=2 *(this._slices+1);
			this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(indices);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.completeCreate();
		}

		/**
		*设置半径（改变此属性会重新生成顶点和索引）
		*@param value 半径
		*/
		/**
		*返回半径
		*@return 半径
		*/
		__getset(0,__proto,'radius',function(){
			return this._radius;
			},function(value){
			if (this._radius!==value){
				this._radius=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置高度（改变此属性会重新生成顶点和索引）
		*@param value 高度
		*/
		/**
		*返回高度
		*@return 高度
		*/
		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			if (this._height!==value){
				this._height=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置高度分段（改变此属性会重新生成顶点和索引）
		*@param value高度分段
		*/
		/**
		*获取高度分段
		*@return 高度分段
		*/
		__getset(0,__proto,'stacks',function(){
			return this._stacks;
			},function(value){
			if (this._stacks!==value){
				this._stacks=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置宽度分段（改变此属性会重新生成顶点和索引）
		*@param value 宽度分段
		*/
		/**
		*获取宽度分段
		*@return 宽度分段
		*/
		__getset(0,__proto,'slices',function(){
			return this._slices;
			},function(value){
			if (this._slices!==value){
				this._slices=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		return CapsuleMesh;
	})(PrimitiveMesh)


	/**
	*<code>CylinderMesh</code> 类用于创建圆柱体。
	*/
	//class laya.d3.resource.models.CylinderMesh extends laya.d3.resource.models.PrimitiveMesh
	var CylinderMesh=(function(_super){
		function CylinderMesh(radius,height,slices){
			this._radius=NaN;
			this._height=NaN;
			this._slices=0;
			(radius===void 0)&& (radius=0.5);
			(height===void 0)&& (height=2);
			(slices===void 0)&& (slices=32);
			CylinderMesh.__super.call(this);
			this._radius=radius;
			this._height=height;
			this._slices=slices;
			this.recreateResource();
			this._loaded=true;
			this._generateBoundingObject();
		}

		__class(CylinderMesh,'laya.d3.resource.models.CylinderMesh',_super);
		var __proto=CylinderMesh.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			this._numberVertices=(this._slices+1+1)+(this._slices+1)*2+(this._slices+1+1);
			this._numberIndices=3 *this._slices+6 *this._slices+3 *this._slices;
			var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			var vertexFloatStride=vertexDeclaration.vertexStride / 4;
			var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
			var indices=new Uint16Array(this._numberIndices);
			var sliceAngle=(Math.PI *2.0)/ this._slices;
			var halfHeight=this._height / 2;
			var curAngle=0;
			var verticeCount=0;
			var posX=0;
			var posY=0;
			var posZ=0;
			var vc=0;
			var ic=0;
			for (var tv=0;tv <=this._slices;tv++){
				if (tv===0){
					vertices[vc++]=0;
					vertices[vc++]=halfHeight;
					vertices[vc++]=0;
					vertices[vc++]=0;
					vertices[vc++]=1;
					vertices[vc++]=0;
					vertices[vc++]=0.5;
					vertices[vc++]=0.5;
				}
				curAngle=tv *sliceAngle;
				posX=Math.cos(curAngle)*this._radius;
				posY=halfHeight;
				posZ=Math.sin(curAngle)*this._radius;
				vertices[vc++]=posX;
				vertices[vc++]=posY;
				vertices[vc++]=posZ;
				vertices[vc++]=0;
				vertices[vc++]=1;
				vertices[vc++]=0;
				vertices[vc++]=0.5+Math.cos(curAngle)*0.5;
				vertices[vc++]=0.5+Math.sin(curAngle)*0.5;
			}
			for (var ti=0;ti < this._slices;ti++){
				indices[ic++]=0;
				indices[ic++]=ti+1;
				indices[ic++]=ti+2;
			}
			verticeCount+=this._slices+1+1;
			for (var rv=0;rv <=this._slices;rv++){
				curAngle=rv *sliceAngle;
				posX=Math.cos(curAngle+Math.PI)*this._radius;
				posY=halfHeight;
				posZ=Math.sin(curAngle+Math.PI)*this._radius;
				vertices[vc++]=posX;
				vertices[vc+(this._slices+1)*8-1]=posX;
				vertices[vc++]=posY;
				vertices[vc+(this._slices+1)*8-1]=-posY;
				vertices[vc++]=posZ;
				vertices[vc+(this._slices+1)*8-1]=posZ;
				vertices[vc++]=posX;
				vertices[vc+(this._slices+1)*8-1]=posX;
				vertices[vc++]=0;
				vertices[vc+(this._slices+1)*8-1]=0;
				vertices[vc++]=posZ;
				vertices[vc+(this._slices+1)*8-1]=posZ;
				vertices[vc++]=1-rv *1 / this._slices;
				vertices[vc+(this._slices+1)*8-1]=1-rv *1 / this._slices;
				vertices[vc++]=0;
				vertices[vc+(this._slices+1)*8-1]=1;
			}
			vc+=(this._slices+1)*8;
			for (var ri=0;ri < this._slices;ri++){
				indices[ic++]=ri+verticeCount+(this._slices+1);
				indices[ic++]=ri+verticeCount+1;
				indices[ic++]=ri+verticeCount;
				indices[ic++]=ri+verticeCount+(this._slices+1);
				indices[ic++]=ri+verticeCount+(this._slices+1)+1;
				indices[ic++]=ri+verticeCount+1;
			}
			verticeCount+=2 *(this._slices+1);
			for (var bv=0;bv <=this._slices;bv++){
				if (bv===0){
					vertices[vc++]=0;
					vertices[vc++]=-halfHeight;
					vertices[vc++]=0;
					vertices[vc++]=0;
					vertices[vc++]=-1;
					vertices[vc++]=0;
					vertices[vc++]=0.5;
					vertices[vc++]=0.5;
				}
				curAngle=bv *sliceAngle;
				posX=Math.cos(curAngle+Math.PI)*this._radius;
				posY=-halfHeight;
				posZ=Math.sin(curAngle+Math.PI)*this._radius;
				vertices[vc++]=posX;
				vertices[vc++]=posY;
				vertices[vc++]=posZ;
				vertices[vc++]=0;
				vertices[vc++]=-1;
				vertices[vc++]=0;
				vertices[vc++]=0.5+Math.cos(curAngle)*0.5;
				vertices[vc++]=0.5+Math.sin(curAngle)*0.5;
			}
			for (var bi=0;bi < this._slices;bi++){
				indices[ic++]=0+verticeCount;
				indices[ic++]=bi+2+verticeCount;
				indices[ic++]=bi+1+verticeCount;
			}
			verticeCount+=this._slices+1+1;
			debugger;
			this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(indices);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.completeCreate();
		}

		/**
		*设置半径（改变此属性会重新生成顶点和索引）
		*@param value 半径
		*/
		/**
		*返回半径
		*@return 半径
		*/
		__getset(0,__proto,'radius',function(){
			return this._radius;
			},function(value){
			if (this._radius!==value){
				this._radius=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置高度（改变此属性会重新生成顶点和索引）
		*@param value 高度
		*/
		/**
		*返回高度
		*@return 高度
		*/
		__getset(0,__proto,'height',function(){
			return this._height;
			},function(value){
			if (this._height!==value){
				this._height=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置宽度分段（改变此属性会重新生成顶点和索引）
		*@param value 宽度分段
		*/
		/**
		*获取宽度分段
		*@return 宽度分段
		*/
		__getset(0,__proto,'slices',function(){
			return this._slices;
			},function(value){
			if (this._slices!==value){
				this._slices=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		return CylinderMesh;
	})(PrimitiveMesh)


	/**
	*<code>QuadMesh</code> 类用于创建平面。
	*/
	//class laya.d3.resource.models.PlaneMesh extends laya.d3.resource.models.PrimitiveMesh
	var PlaneMesh=(function(_super){
		function PlaneMesh(long,width,stacks,slices){
			this._long=NaN;
			this._width=NaN;
			this._stacks=0;
			this._slices=0;
			(long===void 0)&& (long=10);
			(width===void 0)&& (width=10);
			(stacks===void 0)&& (stacks=10);
			(slices===void 0)&& (slices=10);
			PlaneMesh.__super.call(this);
			this._long=long;
			this._width=width;
			this._stacks=stacks;
			this._slices=slices;
			this.activeResource();
			this._loaded=true;
			this._generateBoundingObject();
		}

		__class(PlaneMesh,'laya.d3.resource.models.PlaneMesh',_super);
		var __proto=PlaneMesh.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			this._numberVertices=(this._stacks+1)*(this._slices+1);
			this._numberIndices=this._stacks *this._slices *2 *3;
			var indices=new Uint16Array(this._numberIndices);
			var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			var vertexFloatStride=vertexDeclaration.vertexStride / 4;
			var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
			var halfLong=this._long / 2;
			var halfWidth=this._width / 2;
			var stacksLong=this._long / this._stacks;
			var slicesWidth=this._width / this._slices;
			var verticeCount=0;
			for (var i=0;i <=this._slices;i++){
				for (var j=0;j <=this._stacks;j++){
					vertices[verticeCount++]=j *stacksLong-halfLong;
					vertices[verticeCount++]=0;
					vertices[verticeCount++]=i *slicesWidth-halfWidth;
					vertices[verticeCount++]=0;
					vertices[verticeCount++]=1;
					vertices[verticeCount++]=0;
					vertices[verticeCount++]=j *1 / this._stacks;
					vertices[verticeCount++]=i *1 / this._slices;
				}
			};
			var indiceIndex=0;
			for (i=0;i < this._slices;i++){
				for (j=0;j < this._stacks;j++){
					indices[indiceIndex++]=(i+1)*(this._stacks+1)+j;
					indices[indiceIndex++]=i *(this._stacks+1)+j;
					indices[indiceIndex++]=(i+1)*(this._stacks+1)+j+1;
					indices[indiceIndex++]=i *(this._stacks+1)+j;
					indices[indiceIndex++]=i *(this._stacks+1)+j+1;
					indices[indiceIndex++]=(i+1)*(this._stacks+1)+j+1;
				}
			}
			this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(indices);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.completeCreate();
		}

		/**
		*设置长度（改变此属性会重新生成顶点和索引）
		*@param value 长度
		*/
		/**
		*返回长度
		*@return 长
		*/
		__getset(0,__proto,'long',function(){
			return this._long;
			},function(value){
			if (this._long!==value){
				this._long=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置宽度（改变此属性会重新生成顶点和索引）
		*@param value 宽度
		*/
		/**
		*返回宽度
		*@return 宽
		*/
		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			if (this._width!==value){
				this._width=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置长度分段（改变此属性会重新生成顶点和索引）
		*@param value长度分段
		*/
		/**
		*获取长度分段
		*@return 长度分段
		*/
		__getset(0,__proto,'stacks',function(){
			return this._stacks;
			},function(value){
			if (this._stacks!==value){
				this._stacks=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置宽度分段（改变此属性会重新生成顶点和索引）
		*@param value 宽度分段
		*/
		/**
		*获取宽度分段
		*@return 宽度分段
		*/
		__getset(0,__proto,'slices',function(){
			return this._slices;
			},function(value){
			if (this._slices!==value){
				this._slices=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		return PlaneMesh;
	})(PrimitiveMesh)


	/**
	*<code>QuadMesh</code> 类用于创建四边形。
	*/
	//class laya.d3.resource.models.QuadMesh extends laya.d3.resource.models.PrimitiveMesh
	var QuadMesh=(function(_super){
		function QuadMesh(long,width){
			this._long=NaN;
			this._width=NaN;
			(long===void 0)&& (long=1);
			(width===void 0)&& (width=1);
			QuadMesh.__super.call(this);
			this._long=long;
			this._width=width;
			this.activeResource();
			this._loaded=true;
			this._generateBoundingObject();
		}

		__class(QuadMesh,'laya.d3.resource.models.QuadMesh',_super);
		var __proto=QuadMesh.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			this._numberVertices=4;
			this._numberIndices=6;
			var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			var vertexFloatStride=vertexDeclaration.vertexStride / 4;
			var halfLong=this._long / 2;
			var halfWidth=this._width / 2;
			var vertices=new Float32Array([
			-halfLong,halfWidth,0,0,0,1,0,0,
			halfLong,halfWidth,0,0,0,1,1,0,
			-halfLong,-halfWidth,0,0,0,1,0,1,
			halfLong,-halfWidth,0,0,0,1,1,1,]);
			var indices=new Uint16Array([
			0,1,2,
			3,2,1,]);
			this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(indices);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.completeCreate();
		}

		/**
		*设置长度（改变此属性会重新生成顶点和索引）
		*@param value 长度
		*/
		/**
		*返回长度
		*@return 长
		*/
		__getset(0,__proto,'long',function(){
			return this._long;
			},function(value){
			if (this._long!==value){
				this._long=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置宽度（改变此属性会重新生成顶点和索引）
		*@param value 宽度
		*/
		/**
		*返回宽度
		*@return 宽
		*/
		__getset(0,__proto,'width',function(){
			return this._width;
			},function(value){
			if (this._width!==value){
				this._width=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		return QuadMesh;
	})(PrimitiveMesh)


	/**
	*<code>Sphere</code> 类用于创建球体。
	*/
	//class laya.d3.resource.models.SphereMesh extends laya.d3.resource.models.PrimitiveMesh
	var SphereMesh=(function(_super){
		function SphereMesh(radius,stacks,slices){
			this._radius=NaN;
			this._slices=0;
			this._stacks=0;
			(radius===void 0)&& (radius=0.5);
			(stacks===void 0)&& (stacks=32);
			(slices===void 0)&& (slices=32);
			SphereMesh.__super.call(this);
			this._radius=radius;
			this._stacks=stacks;
			this._slices=slices;
			this.activeResource();
			this._loaded=true;
			this._generateBoundingObject();
		}

		__class(SphereMesh,'laya.d3.resource.models.SphereMesh',_super);
		var __proto=SphereMesh.prototype;
		__proto.recreateResource=function(){
			this.startCreate();
			this._numberVertices=(this._stacks+1)*(this._slices+1);
			this._numberIndices=(3 *this._stacks *(this._slices+1))*2;
			var indices=new Uint16Array(this._numberIndices);
			var vertexDeclaration=VertexPositionNormalTexture.vertexDeclaration;
			var vertexFloatStride=vertexDeclaration.vertexStride / 4;
			var vertices=new Float32Array(this._numberVertices *vertexFloatStride);
			var stackAngle=Math.PI / this._stacks;
			var sliceAngle=(Math.PI *2.0)/ this._slices;
			var vertexIndex=0;
			var vertexCount=0;
			var indexCount=0;
			for (var stack=0;stack < (this._stacks+1);stack++){
				var r=Math.sin(stack *stackAngle);
				var y=Math.cos(stack *stackAngle);
				for (var slice=0;slice < (this._slices+1);slice++){
					var x=r *Math.sin(slice *sliceAngle+Math.PI *1/2);
					var z=r *Math.cos(slice *sliceAngle+Math.PI *1/2);
					vertices[vertexCount+0]=x *this._radius;
					vertices[vertexCount+1]=y *this._radius;
					vertices[vertexCount+2]=z *this._radius;
					vertices[vertexCount+3]=x;
					vertices[vertexCount+4]=y;
					vertices[vertexCount+5]=z;
					vertices[vertexCount+6]=slice / this._slices;
					vertices[vertexCount+7]=stack / this._stacks;
					vertexCount+=vertexFloatStride;
					if (stack !=(this._stacks-1)){
						indices[indexCount++]=vertexIndex+(this._slices+1);
						indices[indexCount++]=vertexIndex;
						indices[indexCount++]=vertexIndex+1;
						indices[indexCount++]=vertexIndex+(this._slices);
						indices[indexCount++]=vertexIndex;
						indices[indexCount++]=vertexIndex+(this._slices+1);
						vertexIndex++;
					}
				}
			}
			this._vertexBuffer=new VertexBuffer3D(vertexDeclaration,this._numberVertices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._indexBuffer=new IndexBuffer3D(/*laya.d3.graphics.IndexBuffer3D.INDEXTYPE_USHORT*/"ushort",this._numberIndices,/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4,true);
			this._vertexBuffer.setData(vertices);
			this._indexBuffer.setData(indices);
			this.memorySize=(this._vertexBuffer.byteLength+this._indexBuffer.byteLength)*2;
			this.completeCreate();
		}

		/**
		*设置半径（改变此属性会重新生成顶点和索引）
		*@param value 半径
		*/
		/**
		*返回半径
		*@return 半径
		*/
		__getset(0,__proto,'radius',function(){
			return this._radius;
			},function(value){
			if (this._radius!==value){
				this._radius=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置宽度分段（改变此属性会重新生成顶点和索引）
		*@param value 宽度分段
		*/
		/**
		*获取宽度分段
		*@return 宽度分段
		*/
		__getset(0,__proto,'slices',function(){
			return this._slices;
			},function(value){
			if (this._slices!==value){
				this._slices=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		/**
		*设置高度分段（改变此属性会重新生成顶点和索引）
		*@param value高度分段
		*/
		/**
		*获取高度分段
		*@return 高度分段
		*/
		__getset(0,__proto,'stacks',function(){
			return this._stacks;
			},function(value){
			if (this._stacks!==value){
				this._stacks=value;
				this.releaseResource();
				this.activeResource();
			}
		});

		return SphereMesh;
	})(PrimitiveMesh)


	/**
	*<code>TerrainMeshSprite3D</code> 类用于创建网格。
	*/
	//class laya.d3.core.MeshTerrainSprite3D extends laya.d3.core.MeshSprite3D
	var MeshTerrainSprite3D=(function(_super){
		function MeshTerrainSprite3D(mesh,heightMap,name){
			this._minX=NaN;
			this._minZ=NaN;
			this._cellSize=null;
			this._heightMap=null;
			MeshTerrainSprite3D.__super.call(this,mesh,name);
			this._heightMap=heightMap;
			this._cellSize=new Vector2();
		}

		__class(MeshTerrainSprite3D,'laya.d3.core.MeshTerrainSprite3D',_super);
		var __proto=MeshTerrainSprite3D.prototype;
		/**
		*@private
		*/
		__proto._disableRotation=function(){
			var rotation=this.transform.rotation;
			rotation.elements[0]=0;
			rotation.elements[1]=0;
			rotation.elements[2]=0;
			rotation.elements[3]=1;
			this.transform.rotation=rotation;
		}

		/**
		*@private
		*/
		__proto._getScaleX=function(){
			var worldMat=this.transform.worldMatrix;
			var worldMatE=worldMat.elements;
			var m11=worldMatE[0];
			var m12=worldMatE[1];
			var m13=worldMatE[2];
			return Math.sqrt((m11 *m11)+(m12 *m12)+(m13 *m13));
		}

		/**
		*@private
		*/
		__proto._getScaleZ=function(){
			var worldMat=this.transform.worldMatrix;
			var worldMatE=worldMat.elements;
			var m31=worldMatE[8];
			var m32=worldMatE[9];
			var m33=worldMatE[10];
			return Math.sqrt((m31 *m31)+(m32 *m32)+(m33 *m33));
		}

		/**
		*@private
		*/
		__proto._initCreateFromMesh=function(heightMapWidth,heightMapHeight){
			this._heightMap=HeightMap.creatFromMesh(this.meshFilter.sharedMesh,heightMapWidth,heightMapHeight,this._cellSize);
			var boundingBox=this.meshFilter.sharedMesh.boundingBox;
			var min=boundingBox.min;
			var max=boundingBox.max;
			this._minX=min.x;
			this._minZ=min.z;
		}

		/**
		*@private
		*/
		__proto._initCreateFromMeshHeightMap=function(texture,minHeight,maxHeight){
			var _$this=this;
			var boundingBox=this.meshFilter.sharedMesh.boundingBox;
			if (texture.loaded){
				this._heightMap=HeightMap.createFromImage(texture,minHeight,maxHeight);
				this._computeCellSize(boundingBox);
				}else {
				texture.once(/*laya.events.Event.LOADED*/"loaded",null,function(){
					_$this._heightMap=HeightMap.createFromImage(texture,minHeight,maxHeight);
					_$this._computeCellSize(boundingBox);
				});
			};
			var min=boundingBox.min;
			var max=boundingBox.max;
			this._minX=min.x;
			this._minZ=min.z;
		}

		/**
		*@private
		*/
		__proto._computeCellSize=function(boundingBox){
			var min=boundingBox.min;
			var max=boundingBox.max;
			var minX=min.x;
			var minZ=min.z;
			var maxX=max.x;
			var maxZ=max.z;
			var widthSize=maxX-minX;
			var heightSize=maxZ-minZ;
			this._cellSize.elements[0]=widthSize / (this._heightMap.width-1);
			this._cellSize.elements[1]=heightSize / (this._heightMap.height-1);
		}

		/**
		*@private
		*/
		__proto._update=function(state){
			this._disableRotation();
			laya.d3.core.RenderableSprite3D.prototype._update.call(this,state);
		}

		/**
		*获取地形高度。
		*@param x X轴坐标。
		*@param z Z轴坐标。
		*/
		__proto.getHeight=function(x,z){
			MeshTerrainSprite3D._tempVector3.elements[0]=x;
			MeshTerrainSprite3D._tempVector3.elements[1]=0;
			MeshTerrainSprite3D._tempVector3.elements[2]=z;
			this._disableRotation();
			var worldMat=this.transform.worldMatrix;
			worldMat.invert(MeshTerrainSprite3D._tempMatrix4x4);
			Vector3.transformCoordinate(MeshTerrainSprite3D._tempVector3,MeshTerrainSprite3D._tempMatrix4x4,MeshTerrainSprite3D._tempVector3);
			x=MeshTerrainSprite3D._tempVector3.elements[0];
			z=MeshTerrainSprite3D._tempVector3.elements[2];
			var c=(x-this._minX)/ this._cellSize.x;
			var d=(z-this._minZ)/ this._cellSize.y;
			var row=Math.floor(d);
			var col=Math.floor(c);
			var s=c-col;
			var t=d-row;
			var uy=NaN;
			var vy=NaN;
			var worldMatE=worldMat.elements;
			var m21=worldMatE[4];
			var m22=worldMatE[5];
			var m23=worldMatE[6];
			var scaleY=Math.sqrt((m21 *m21)+(m22 *m22)+(m23 *m23));
			var translateY=worldMatE[13];
			var h01=this._heightMap.getHeight(row,col+1);
			var h10=this._heightMap.getHeight((row+1),col);
			if (isNaN(h01)|| isNaN(h10))
				return NaN;
			if (s+t <=1.0){
				var h00=this._heightMap.getHeight(row,col);
				if (isNaN(h00))
					return NaN;
				uy=h01-h00;
				vy=h10-h00;
				return (h00+s *uy+t *vy)*scaleY+translateY;
				}else {
				var h11=this._heightMap.getHeight((row+1),col+1);
				if (isNaN(h11))
					return NaN;
				uy=h10-h11;
				vy=h01-h11;
				return (h11+(1.0-s)*uy+(1.0-t)*vy)*scaleY+translateY;
			}
		}

		/**
		*获取地形X轴最小位置。
		*@return 地形X轴最小位置。
		*/
		__getset(0,__proto,'minX',function(){
			var worldMat=this.transform.worldMatrix;
			var worldMatE=worldMat.elements;
			return this._minX *this._getScaleX()+worldMatE[12];
		});

		/**
		*获取地形X轴长度。
		*@return 地形X轴长度。
		*/
		__getset(0,__proto,'width',function(){
			return (this._heightMap.width-1)*this._cellSize.x *this._getScaleX();
		});

		/**
		*获取地形Z轴最小位置。
		*@return 地形X轴最小位置。
		*/
		__getset(0,__proto,'minZ',function(){
			var worldMat=this.transform.worldMatrix;
			var worldMatE=worldMat.elements;
			return this._minZ *this._getScaleZ()+worldMatE[14];
		});

		/**
		*获取地形Z轴长度。
		*@return 地形Z轴长度。
		*/
		__getset(0,__proto,'depth',function(){
			return (this._heightMap.height-1)*this._cellSize.y *this._getScaleZ();
		});

		MeshTerrainSprite3D.createFromMesh=function(mesh,heightMapWidth,heightMapHeight,name){
			var meshTerrainSprite3D=new MeshTerrainSprite3D(mesh,null,name);
			if (mesh.loaded)
				meshTerrainSprite3D._initCreateFromMesh(heightMapWidth,heightMapHeight);
			else
			mesh.once(/*laya.events.Event.LOADED*/"loaded",meshTerrainSprite3D,meshTerrainSprite3D._initCreateFromMesh,[heightMapWidth,heightMapHeight]);
			return meshTerrainSprite3D;
		}

		MeshTerrainSprite3D.createFromMeshAndHeightMap=function(mesh,texture,minHeight,maxHeight,name){
			var meshTerrainSprite3D=new MeshTerrainSprite3D(mesh,null,name);
			if (mesh.loaded)
				meshTerrainSprite3D._initCreateFromMeshHeightMap(texture,minHeight,maxHeight);
			else
			mesh.once(/*laya.events.Event.LOADED*/"loaded",meshTerrainSprite3D,meshTerrainSprite3D._initCreateFromMeshHeightMap,[texture,minHeight,maxHeight]);
			return meshTerrainSprite3D;
		}

		__static(MeshTerrainSprite3D,
		['_tempVector3',function(){return this._tempVector3=new Vector3();},'_tempMatrix4x4',function(){return this._tempMatrix4x4=new Matrix4x4();}
		]);
		return MeshTerrainSprite3D;
	})(MeshSprite3D)


	/**
	*...
	*@author ...
	*/
	//class laya.d3.water.WaterSprite extends laya.d3.core.MeshSprite3D
	var WaterSprite=(function(_super){
		function WaterSprite(mesh,name){
			this.mtl=null;
			this.detailMtl=null;
			this.mesh=null;
			this._stop=false;
			this._texWave=null;
			this._texRefract=null;
			this._detailMesh=null;
			this._texWaveDegTest=0;
			this._shownormal=false;
			this._refractQueue=null;
			this._loaded=false;
			this._scene=null;
			this._waterFogStart=0;
			this._waterFogRange=20;
			this._geoWaveInfo=new Float32Array(WaterSprite._waveInfoEleNum *4);
			this._geoWaveInfoDir=new Float32Array(2 *4);
			this._texWaveInfo=new Float32Array(WaterSprite._waveInfoEleNum *15);
			this._texWaveInfoDir=new Float32Array(2 *15);
			this._texWaveTrans=new Float32Array(9);
			this._refractObjStack=[];
			this._refractObjecs=[];
			this._scrSizeInfo=new Float32Array(2);
			this._waterColor=new Vector3();
			WaterSprite.__super.call(this,mesh,name);
			this.mtl=new WaterMaterial();
		}

		__class(WaterSprite,'laya.d3.water.WaterSprite',_super);
		var __proto=WaterSprite.prototype;
		__proto._getWaveInfo=function(out,outdir,i,deg,L,Q,A){
			var st=i *WaterSprite._waveInfoEleNum;
			var dirst=i *2;
			var r=deg *WaterSprite.deg2rad;
			outdir[dirst++]=Math.cos(r);
			outdir[dirst++]=Math.sin(r);
			out[st++]=Q;
			out[st++]=A;
			out[st++]=WaterSprite._2pi / L;
			out[st++]=7.846987702957 / Math.sqrt(L);
		}

		__proto.onDescLoaded=function(desc){
			var _$this=this;
			var mesh=Mesh.load(desc.mesh);
			this._texWave=new RenderTexture(desc.detailTexSize[0],desc.detailTexSize[1],/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401,/*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5,false,false);
			this._texRefract=new RenderTexture(desc.refracTexSize[0],desc.refracTexSize[1]);
			this._texRefract.repeat=false;
			this._texRefract.mipmap=true;
			(this._geometryFilter).sharedMesh=mesh;
			mesh.once(/*laya.events.Event.LOADED*/"loaded",this,this._applyMeshMaterials);
			mesh.on(/*laya.events.Event.LOADED*/"loaded",this,this.onMeshLoaded);
			if (desc.skyTexture.substr(desc.skyTexture.length-4).toLowerCase()==='.ltc'){
				this.mtl.skyTexture=TextureCube.load(desc.skyTexture);
				this.mtl._addShaderDefine(WaterMaterial.SHADERDEFINE_CUBE_ENV);
				}else {
				this.mtl.skyTexture=Texture2D.load(desc.skyTexture);
				this.mtl._removeShaderDefine(WaterMaterial.SHADERDEFINE_CUBE_ENV);
			}
			if (desc.hdrsky){
				this.mtl._addShaderDefine(WaterMaterial.SHADERDEFINE_HDR_ENV);
			}
			this.mtl.skyTexture.repeat=true;
			var infotex=Texture2D.load(desc.infoTexture);
			infotex.repeat=false;
			this.mtl.waterInfoTexture=infotex;
			var foamTex=Texture2D.load(desc.foamTexture);
			foamTex.repeat=true;
			this.mtl.foamTexture=foamTex;
			this.mtl.renderMode=/*laya.d3.core.material.WaterMaterial.RENDERMODE_TRANSPARENT*/13;
			this.mtl.waveMainDir=desc.geoWaveData[0].dir;
			this.mtl.geoWaveUVScale=desc.geoWaveUVScale;
			this._detailMesh=new QuadMesh(2,2);
			this.detailMtl=new WaterDetailMaterial();
			this.detailMtl.texWaveUVScale=desc.detailWaveUVScale;
			if (desc.geoWaveData.length !=4)throw "error 3";
			if (desc.detailData.length !=4)throw "error 4";
			(desc.geoWaveData).forEach(function(v,i){
				_$this._getWaveInfo(_$this._geoWaveInfo,_$this._geoWaveInfoDir,i,v.dir,v.L,v.Q,v.A);
			});
			var kAmp_over_L=0.01;
			(desc.detailData).forEach(function(v,i){
				_$this._getWaveInfo(_$this._texWaveInfo,_$this._texWaveInfoDir,i,v.dir,v.L,1.5,v.L *kAmp_over_L);
			});
			this._waterColor.x=desc.color[0];this._waterColor.y=desc.color[1];this._waterColor.z=desc.color[2];
			this.mtl.seaColor=new Float32Array(desc.color);
			this._waterFogStart=desc.fogStart;
			this._waterFogRange=desc.fogRange;
		}

		__proto.onMeshLoaded=function(){
			this._refractQueue=new RenderQueue(this._scene);
			this._scrSizeInfo[0]=Laya.stage.width;
			this._scrSizeInfo[1]=Laya.stage.height;
			this.mtl.scrsize=this._scrSizeInfo;
			this.meshRender.sharedMaterial=this.mtl;
			if (this._render._renderElements.length > 0){
				this._render._renderElements[0]._onPreRenderFunction=this.onPreRender;
				}else {
				throw "error2";
			}
			this._loaded=true;
		}

		__proto.stop=function(){
			this._stop=!this._stop;
		}

		__proto.addRefractObj=function(obj){
			this._refractObjStack.push(obj);
			this._refractObjecs.push(obj);
		}

		/**
		*渲染之前，生成必要的数据。
		*@param state
		*/
		__proto.onPreRender=function(state){
			var _$this=this;
			if (!this._loaded)
				return;
			if (this._refractObjStack.length){
				for (var i=0;i < this._refractObjStack.length;i++){
					var obj=this._refractObjStack[i];
					if (obj._render._renderElements.length){
						obj._render._renderElements.forEach(function(v){_$this._refractQueue._addRenderElement(v);});
						this._refractObjStack.splice(i,1);
						i--;
					}
				}
			};
			var gl=WebGL.mainContext;
			var olddf=gl.getParameter(/*laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71);
			var oldcf=gl.getParameter(/*laya.webgl.WebGLContext.CULL_FACE*/0x0B44);
			var oldvp=gl.getParameter(/*laya.webgl.WebGLContext.VIEWPORT*/0x0BA2);
			this._texRefract.start();
			gl.viewport(0,0,this._texRefract.width,this._texRefract.height);
			gl.clearColor(this._waterColor.x,this._waterColor.y,this._waterColor.z,1.);
			gl.clear(/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100 | /*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000);
			this._refractObjecs.forEach(function(v){
				v._renderUpdate(state._projectionViewMatrix);
			});
			this._refractQueue._preRender(state);
			var old_fog=this.scene.enableDepthFog;
			var old_fogcol=this.scene.fogColor;
			var old_fogstart=this.scene.fogStart;
			var old_fogrange=this.scene.fogRange;
			this.scene.enableDepthFog=true;
			this.scene.fogColor=this._waterColor;
			this.scene.fogStart=this._waterFogStart;
			this.scene.fogRange=this._waterFogRange;
			this._refractQueue._render(state,false);
			this._texRefract.end();
			this._texRefract.repeat=true;
			this.scene.enableDepthFog=old_fog;
			this.scene.fogColor=old_fogcol;
			this.scene.fogStart=old_fogstart;
			this.scene.fogRange=old_fogrange;
			this._texWave.start();
			gl.disable(/*laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71);
			gl.disable(/*laya.webgl.WebGLContext.CULL_FACE*/0x0B44);
			gl.viewport(0,0,WaterSprite.detailTexWidth,WaterSprite.detailTexHeight);
			var re=this._detailMesh.getRenderElement(0);
			re._beforeRender(state);
			this.detailMtl.currentTm=Laya.timer.currTimer;
			this.detailMtl.waveInfo=this._texWaveInfo;
			this.detailMtl.waveInfoD=this._texWaveInfoDir;
			var detailShader=this.detailMtl._getShader(0,0,0);
			detailShader.bind();
			var vb=this._detailMesh._getVertexBuffer(0);
			detailShader.uploadAttributes(vb.vertexDeclaration.shaderValues.data,null);
			this.detailMtl._upload();
			re._render(state);
			this._texWave.end();
			olddf && gl.enable(/*laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71);
			oldcf && gl.enable(/*laya.webgl.WebGLContext.CULL_FACE*/0x0B44);
			gl.viewport(oldvp[0],oldvp[1],oldvp[2],oldvp[3]);
			this.mtl.detailTexture=this._texWave;
			this.mtl.waveInfo=this._geoWaveInfo;
			this.mtl.waveInfoD=this._geoWaveInfoDir;
			this.mtl.underWaterTexture=this._texRefract;
			if(!this._stop){
				this.mtl.currentTm=Laya.timer.currTimer;
				}else {
				this._texWaveDegTest+=0.02;
				this.mtl.waveMainDir=this._texWaveDegTest;
			}
			if (/*__JS__ */window.shownormal && !this._shownormal){
				this._shownormal=true;
				this.mtl._addShaderDefine(WaterMaterial.SHADERDEFINE_SHOW_NORMAL);
			}
			if(/*__JS__ */window.shownormal && this._shownormal){
				this._shownormal=false;
				this.mtl._removeShaderDefine(WaterMaterial.SHADERDEFINE_SHOW_NORMAL);
			}
		}

		__proto._update=function(state){
			laya.d3.core.RenderableSprite3D.prototype._update.call(this,state);
		}

		__getset(0,__proto,'src',null,function(v){
			var ld=new Loader();
			ld.on(/*laya.events.Event.COMPLETE*/"complete",this,this.onDescLoaded);
			ld.load(v);
		});

		WaterSprite._waveInfoEleNum=4;
		WaterSprite.detailTexWidth=256;
		WaterSprite.detailTexHeight=256;
		__static(WaterSprite,
		['deg2rad',function(){return this.deg2rad=Math.PI / 180;},'_2pi',function(){return this._2pi=2 *Math.PI;}
		]);
		return WaterSprite;
	})(MeshSprite3D)


	Laya.__init([ShaderCompile3D]);
})(window,document,Laya);
