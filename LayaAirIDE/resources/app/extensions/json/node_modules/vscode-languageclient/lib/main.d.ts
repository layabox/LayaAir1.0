import * as cp from 'child_process';
import ChildProcess = cp.ChildProcess;
import { TextDocument, Disposable, FileSystemWatcher } from 'vscode';
import { IRequestHandler, INotificationHandler, RequestType, NotificationType } from 'vscode-jsonrpc';
import { Position, Range, Location, TextDocumentIdentifier, TextDocumentPosition, FileEvent } from './protocol';
export { RequestType, NotificationType, INotificationHandler, Position, Range, Location, TextDocumentIdentifier, TextDocumentPosition };
export interface StreamInfo {
    writer: NodeJS.WritableStream;
    reader: NodeJS.ReadableStream;
}
export interface ExecutableOptions {
    cwd?: string;
    stdio?: string | string[];
    env?: any;
    detached?: boolean;
}
export interface Executable {
    command: string;
    args?: string[];
    options?: ExecutableOptions;
}
export interface ForkOptions {
    cwd?: string;
    env?: any;
    encoding?: string;
    execArgv?: string[];
}
export declare enum TransportKind {
    stdio = 0,
    ipc = 1,
}
export interface NodeModule {
    module: string;
    transport?: TransportKind;
    args?: string[];
    options?: ForkOptions;
}
export declare type ServerOptions = Executable | {
    run: Executable;
    debug: Executable;
} | {
    run: NodeModule;
    debug: NodeModule;
} | NodeModule | (() => Thenable<ChildProcess | StreamInfo>);
export interface SynchronizeOptions {
    configurationSection?: string | string[];
    fileEvents?: FileSystemWatcher | FileSystemWatcher[];
    textDocumentFilter?: (textDocument: TextDocument) => boolean;
}
export interface LanguageClientOptions {
    documentSelector?: string | string[];
    synchronize?: SynchronizeOptions;
    diagnosticCollectionName?: string;
    initializationOptions?: any;
}
export declare class LanguageClient {
    private _name;
    private _serverOptions;
    private _languageOptions;
    private _forceDebug;
    private _state;
    private _onReady;
    private _onReadyCallbacks;
    private _connection;
    private _childProcess;
    private _outputChannel;
    private _capabilites;
    private _listeners;
    private _providers;
    private _diagnostics;
    private _syncExpression;
    private _documentSyncDelayer;
    private _fileEvents;
    private _fileEventDelayer;
    constructor(name: string, serverOptions: ServerOptions, languageOptions: LanguageClientOptions, forceDebug?: boolean);
    private computeSyncExpression();
    sendRequest<P, R, E>(type: RequestType<P, R, E>, params?: P): Thenable<R>;
    private doSendRequest<P, R, E>(connection, type, params?);
    sendNotification<P>(type: NotificationType<P>, params?: P): void;
    onNotification<P>(type: NotificationType<P>, handler: INotificationHandler<P>): void;
    onRequest<P, R, E>(type: RequestType<P, R, E>, handler: IRequestHandler<P, R, E>): void;
    needsStart(): boolean;
    needsStop(): boolean;
    onReady(): Promise<void>;
    private isConnectionActive();
    start(): Disposable;
    private resolveConnection();
    private initialize(connection);
    stop(): void;
    notifyConfigurationChanged(settings: any): void;
    notifyFileEvent(event: FileEvent): void;
    private onDidOpenTextDoument(connection, textDocument);
    private onDidChangeTextDocument(connection, event);
    private onDidCloseTextDoument(connection, textDocument);
    private forceDocumentSync();
    private handleDiagnostics(params);
    private createConnection();
    private checkProcessDied(childProcess);
    private hookConfigurationChanged(connection);
    private onDidChangeConfiguration(connection);
    private extractSettingsInformation(keys);
    private hookFileEvents(connection);
    private hookCapabilities(connection);
    private hookCompletionProvider(documentSelector, connection);
    private hookHoverProvider(documentSelector, connection);
    private hookSignatureHelpProvider(documentSelector, connection);
    private hookDefinitionProvider(documentSelector, connection);
    private hookReferencesProvider(documentSelector, connection);
    private hookDocumentHighlightProvider(documentSelector, connection);
    private hookDocumentSymbolProvider(documentSelector, connection);
    private hookWorkspaceSymbolProvider(connection);
    private hookCodeActionsProvider(documentSelector, connection);
    private hookCodeLensProvider(documentSelector, connection);
    private hookDocumentFormattingProvider(documentSelector, connection);
    private hookDocumentRangeFormattingProvider(documentSelector, connection);
    private hookDocumentOnTypeFormattingProvider(documentSelector, connection);
    private hookRenameProvider(documentSelector, connection);
}
export declare class SettingMonitor {
    private _client;
    private _setting;
    private _listeners;
    constructor(_client: LanguageClient, _setting: string);
    start(): Disposable;
    private onDidChangeConfiguration();
}
