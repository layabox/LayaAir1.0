/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var vscode_jsonrpc_1 = require('vscode-jsonrpc');
exports.ResponseError = vscode_jsonrpc_1.ResponseError;
exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
exports.StreamMessageReader = vscode_jsonrpc_1.StreamMessageReader;
exports.IPCMessageReader = vscode_jsonrpc_1.IPCMessageReader;
exports.StreamMessageWriter = vscode_jsonrpc_1.StreamMessageWriter;
exports.IPCMessageWriter = vscode_jsonrpc_1.IPCMessageWriter;
var protocol_1 = require('./protocol');
exports.FileChangeType = protocol_1.FileChangeType;
exports.Diagnostic = protocol_1.Diagnostic;
exports.DiagnosticSeverity = protocol_1.DiagnosticSeverity;
exports.Range = protocol_1.Range;
exports.Position = protocol_1.Position;
exports.Location = protocol_1.Location;
exports.TextDocumentIdentifier = protocol_1.TextDocumentIdentifier;
exports.TextDocumentPosition = protocol_1.TextDocumentPosition;
exports.TextDocumentSyncKind = protocol_1.TextDocumentSyncKind;
exports.CompletionItemKind = protocol_1.CompletionItemKind;
exports.CompletionItem = protocol_1.CompletionItem;
exports.CompletionList = protocol_1.CompletionList;
exports.TextEdit = protocol_1.TextEdit;
exports.WorkspaceChange = protocol_1.WorkspaceChange;
exports.SignatureInformation = protocol_1.SignatureInformation;
exports.ParameterInformation = protocol_1.ParameterInformation;
exports.DocumentHighlight = protocol_1.DocumentHighlight;
exports.DocumentHighlightKind = protocol_1.DocumentHighlightKind;
exports.SymbolInformation = protocol_1.SymbolInformation;
exports.SymbolKind = protocol_1.SymbolKind;
exports.CodeActionContext = protocol_1.CodeActionContext;
exports.Command = protocol_1.Command;
exports.CodeLensRequest = protocol_1.CodeLensRequest;
exports.CodeLensResolveRequest = protocol_1.CodeLensResolveRequest;
exports.CodeLens = protocol_1.CodeLens;
exports.DocumentFormattingRequest = protocol_1.DocumentFormattingRequest;
exports.DocumentRangeFormattingRequest = protocol_1.DocumentRangeFormattingRequest;
exports.DocumentOnTypeFormattingRequest = protocol_1.DocumentOnTypeFormattingRequest;
exports.FormattingOptions = protocol_1.FormattingOptions;
exports.RenameRequest = protocol_1.RenameRequest;
var events_1 = require('./utils/events');
var Is = require('./utils/is');
// ------------- Reexport the API surface of the language worker API ----------------------
var fm = require('./files');
var Files;
(function (Files) {
    Files.uriToFilePath = fm.uriToFilePath;
    Files.resolveModule = fm.resolveModule;
})(Files = exports.Files || (exports.Files = {}));
var ITextDocument;
(function (ITextDocument) {
    function create(uri, arg2, arg3) {
        var languageId;
        var content;
        if (Is.string(arg3)) {
            languageId = arg2;
            content = arg3;
        }
        else {
            languageId = undefined;
            content = arg2;
        }
        return new TextDocument(uri, languageId, content);
    }
    ITextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    ITextDocument.is = is;
})(ITextDocument = exports.ITextDocument || (exports.ITextDocument = {}));
var TextDocument = (function () {
    function TextDocument(uri, languageId, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._content = content;
        this._lineOffsets = null;
    }
    Object.defineProperty(TextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    TextDocument.prototype.getText = function () {
        return this._content;
    };
    TextDocument.prototype.update = function (event) {
        this._content = event.text;
        this._lineOffsets = null;
    };
    TextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === null) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    TextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return protocol_1.Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return protocol_1.Position.create(line, offset - lineOffsets[line]);
    };
    TextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(TextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    return TextDocument;
})();
/**
 * A manager for simple text documents
 */
var TextDocuments = (function () {
    /**
     * Create a new text document manager.
     */
    function TextDocuments() {
        this._documents = Object.create(null);
        this._onDidChangeContent = new events_1.Emitter();
        this._onDidOpen = new events_1.Emitter();
        this._onDidClose = new events_1.Emitter();
    }
    Object.defineProperty(TextDocuments.prototype, "syncKind", {
        /**
         * Returns the [TextDocumentSyncKind](#TextDocumentSyncKind) used by
         * this text document manager.
         */
        get: function () {
            return protocol_1.TextDocumentSyncKind.Full;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDocuments.prototype, "onDidChangeContent", {
        /**
         * An event that fires when a text document managed by this manager
         * has been opened or the content changes.
         */
        get: function () {
            return this._onDidChangeContent.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDocuments.prototype, "onDidOpen", {
        /**
         * An event that fires when a text document managed by this manager
         * has been opened.
         */
        get: function () {
            return this._onDidOpen.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextDocuments.prototype, "onDidClose", {
        /**
         * An event that fires when a text document managed by this manager
         * has been closed.
         */
        get: function () {
            return this._onDidClose.event;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not mananged by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    TextDocuments.prototype.get = function (uri) {
        return this._documents[uri];
    };
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    TextDocuments.prototype.all = function () {
        var _this = this;
        return Object.keys(this._documents).map(function (key) { return _this._documents[key]; });
    };
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    TextDocuments.prototype.keys = function () {
        return Object.keys(this._documents);
    };
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * @param connection The connection to listen on.
     */
    TextDocuments.prototype.listen = function (connection) {
        var _this = this;
        connection.__textDocumentSync = protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument(function (event) {
            var document = new TextDocument(event.uri, event.languageId, event.text);
            _this._documents[event.uri] = document;
            _this._onDidOpen.fire({ document: document });
            _this._onDidChangeContent.fire({ document: document });
        });
        connection.onDidChangeTextDocument(function (event) {
            var changes = event.contentChanges;
            var last = changes.length > 0 ? changes[changes.length - 1] : null;
            if (last) {
                var document_1 = _this._documents[event.uri];
                if (document_1) {
                    document_1.update(last);
                    _this._onDidChangeContent.fire({ document: document_1 });
                }
            }
        });
        connection.onDidCloseTextDocument(function (event) {
            var document = _this._documents[event.uri];
            if (document) {
                delete _this._documents[event.uri];
                _this._onDidClose.fire({ document: document });
            }
        });
    };
    return TextDocuments;
})();
exports.TextDocuments = TextDocuments;
// ------------------------- implementation of the language server protocol ---------------------------------------------
/**
 * Helps tracking error message. Equal occurences of the same
 * message are only stored once. This class is for example
 * usefull if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
var ErrorMessageTracker = (function () {
    function ErrorMessageTracker() {
        this.messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    ErrorMessageTracker.prototype.add = function (message) {
        var count = this.messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this.messages[message] = count;
    };
    /**
     * Send all tracked messages to the conenction's window.
     *
     * @param connection The connection establised between client and server.
     */
    ErrorMessageTracker.prototype.sendErrors = function (connection) {
        Object.keys(this.messages).forEach(function (message) {
            connection.window.showErrorMessage(message);
        });
    };
    return ErrorMessageTracker;
})();
exports.ErrorMessageTracker = ErrorMessageTracker;
var Logger = (function () {
    function Logger() {
    }
    Logger.prototype.attach = function (connection) {
        this.connection = connection;
    };
    Logger.prototype.error = function (message) {
        this.send(protocol_1.MessageType.Error, message);
    };
    Logger.prototype.warn = function (message) {
        this.send(protocol_1.MessageType.Warning, message);
    };
    Logger.prototype.info = function (message) {
        this.send(protocol_1.MessageType.Info, message);
    };
    Logger.prototype.log = function (message) {
        this.send(protocol_1.MessageType.Log, message);
    };
    Logger.prototype.send = function (type, message) {
        if (this.connection) {
            this.connection.sendNotification(protocol_1.LogMessageNotification.type, { type: type, message: message });
        }
    };
    return Logger;
})();
var RemoteWindowImpl = (function () {
    function RemoteWindowImpl(connection) {
        this.connection = connection;
    }
    RemoteWindowImpl.prototype.showErrorMessage = function (message) {
        this.connection.sendNotification(protocol_1.ShowMessageNotification.type, { type: protocol_1.MessageType.Error, message: message });
    };
    RemoteWindowImpl.prototype.showWarningMessage = function (message) {
        this.connection.sendNotification(protocol_1.ShowMessageNotification.type, { type: protocol_1.MessageType.Warning, message: message });
    };
    RemoteWindowImpl.prototype.showInformationMessage = function (message) {
        this.connection.sendNotification(protocol_1.ShowMessageNotification.type, { type: protocol_1.MessageType.Info, message: message });
    };
    return RemoteWindowImpl;
})();
function createConnection(input, output) {
    var shutdownReceived;
    // Backwards compatibility
    if (Is.func(input.read) && Is.func(input.on)) {
        var inputStream = input;
        inputStream.on('end', function () {
            process.exit(shutdownReceived ? 0 : 1);
        });
        inputStream.on('close', function () {
            process.exit(shutdownReceived ? 0 : 1);
        });
    }
    var logger = new Logger();
    var connection = vscode_jsonrpc_1.createServerMessageConnection(input, output, logger);
    logger.attach(connection);
    var remoteWindow = new RemoteWindowImpl(connection);
    function asThenable(value) {
        if (Is.thenable(value)) {
            return value;
        }
        else {
            return Promise.resolve(value);
        }
    }
    var shutdownHandler = null;
    var initializeHandler = null;
    var exitHandler = null;
    var protocolConnection = {
        listen: function () { return connection.listen(); },
        sendRequest: function (type, params) { return connection.sendRequest(type, params); },
        onRequest: function (type, handler) { return connection.onRequest(type, handler); },
        sendNotification: function (type, params) { return connection.sendNotification(type, params); },
        onNotification: function (type, handler) { return connection.onNotification(type, handler); },
        onInitialize: function (handler) { return initializeHandler = handler; },
        onShutdown: function (handler) { return shutdownHandler = handler; },
        onExit: function (handler) { return exitHandler = handler; },
        get console() { return logger; },
        get window() { return remoteWindow; },
        onDidChangeConfiguration: function (handler) { return connection.onNotification(protocol_1.DidChangeConfigurationNotification.type, handler); },
        onDidChangeWatchedFiles: function (handler) { return connection.onNotification(protocol_1.DidChangeWatchedFilesNotification.type, handler); },
        __textDocumentSync: undefined,
        onDidOpenTextDocument: function (handler) { return connection.onNotification(protocol_1.DidOpenTextDocumentNotification.type, handler); },
        onDidChangeTextDocument: function (handler) { return connection.onNotification(protocol_1.DidChangeTextDocumentNotification.type, handler); },
        onDidCloseTextDocument: function (handler) { return connection.onNotification(protocol_1.DidCloseTextDocumentNotification.type, handler); },
        sendDiagnostics: function (params) { return connection.sendNotification(protocol_1.PublishDiagnosticsNotification.type, params); },
        onHover: function (handler) { return connection.onRequest(protocol_1.HoverRequest.type, handler); },
        onCompletion: function (handler) { return connection.onRequest(protocol_1.CompletionRequest.type, handler); },
        onCompletionResolve: function (handler) { return connection.onRequest(protocol_1.CompletionResolveRequest.type, handler); },
        onSignatureHelp: function (handler) { return connection.onRequest(protocol_1.SignatureHelpRequest.type, handler); },
        onDefinition: function (handler) { return connection.onRequest(protocol_1.DefinitionRequest.type, handler); },
        onReferences: function (handler) { return connection.onRequest(protocol_1.ReferencesRequest.type, handler); },
        onDocumentHighlight: function (handler) { return connection.onRequest(protocol_1.DocumentHighlightRequest.type, handler); },
        onDocumentSymbol: function (handler) { return connection.onRequest(protocol_1.DocumentSymbolRequest.type, handler); },
        onWorkspaceSymbol: function (handler) { return connection.onRequest(protocol_1.WorkspaceSymbolRequest.type, handler); },
        onCodeAction: function (handler) { return connection.onRequest(protocol_1.CodeActionRequest.type, handler); },
        onCodeLens: function (handler) { return connection.onRequest(protocol_1.CodeLensRequest.type, handler); },
        onCodeLensResolve: function (handler) { return connection.onRequest(protocol_1.CodeLensResolveRequest.type, handler); },
        onDocumentFormatting: function (handler) { return connection.onRequest(protocol_1.DocumentFormattingRequest.type, handler); },
        onDocumentRangeFormatting: function (handler) { return connection.onRequest(protocol_1.DocumentRangeFormattingRequest.type, handler); },
        onDocumentOnTypeFormatting: function (handler) { return connection.onRequest(protocol_1.DocumentOnTypeFormattingRequest.type, handler); },
        onRenameRequest: function (handler) { return connection.onRequest(protocol_1.RenameRequest.type, handler); },
        dispose: function () { return connection.dispose(); }
    };
    connection.onRequest(protocol_1.InitializeRequest.type, function (params) {
        if (Is.number(params.processId)) {
            // We received a parent process id. Set up a timer to periodically check
            // if the parent is still alive.
            setInterval(function () {
                try {
                    process.kill(params.processId, 0);
                }
                catch (ex) {
                    // Parent process doesn't exist anymore. Exit the server.
                    process.exit(shutdownReceived ? 0 : 1);
                }
            }, 3000);
        }
        if (initializeHandler) {
            var result = initializeHandler(params);
            return asThenable(result).then(function (value) {
                if (value instanceof vscode_jsonrpc_1.ResponseError) {
                    return value;
                }
                var result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                var capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = {};
                }
                if (!Is.number(capabilities.textDocumentSync)) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : protocol_1.TextDocumentSyncKind.None;
                }
                return result;
            });
        }
        else {
            var result = { capabilities: { textDocumentSync: protocol_1.TextDocumentSyncKind.None } };
            return result;
        }
    });
    connection.onRequest(protocol_1.ShutdownRequest.type, function (params) {
        shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(params);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(protocol_1.ExitNotification.type, function (params) {
        try {
            if (exitHandler) {
                exitHandler(params);
            }
        }
        finally {
            if (shutdownReceived) {
                process.exit(0);
            }
            else {
                process.exit(1);
            }
        }
    });
    return protocolConnection;
}
exports.createConnection = createConnection;
