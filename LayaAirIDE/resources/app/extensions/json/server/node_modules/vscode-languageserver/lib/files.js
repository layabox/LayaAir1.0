/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var url = require('url');
var path = require('path');
var child_process_1 = require('child_process');
function uriToFilePath(uri) {
    var parsed = url.parse(uri);
    if (parsed.protocol !== 'file:' || !parsed.path) {
        return null;
    }
    var segments = parsed.path.split('/');
    for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === 'win32' && segments.length > 1) {
        var first = segments[0];
        var second = segments[1];
        // Do we have a drive letter and we started with a / which is the
        // case if the first segement is empty (see split above)
        if (first.length === 0 && second.length > 1 && second[1] === ':') {
            // Remove first slash
            segments.shift();
        }
    }
    return path.normalize(segments.join('/'));
}
exports.uriToFilePath = uriToFilePath;
function isWindows() {
    return process.platform === 'win32';
}
function resolveModule(workspaceRoot, moduleName) {
    var nodePathKey = 'NODE_PATH';
    return new Promise(function (c, e) {
        var result = Object.create(null);
        var nodePath = [];
        if (workspaceRoot) {
            nodePath.push(path.join(workspaceRoot, 'node_modules'));
        }
        child_process_1.exec('npm config get prefix', function (error, stdout, stderr) {
            if (!error) {
                var globalPath = stdout.toString().replace(/[\s\r\n]+$/, '');
                if (globalPath.length > 0) {
                    if (isWindows()) {
                        nodePath.push(path.join(globalPath, 'node_modules'));
                    }
                    else {
                        nodePath.push(path.join(globalPath, 'lib', 'node_modules'));
                    }
                }
            }
            var separator = isWindows() ? ';' : ':';
            var env = process.env;
            var newEnv = Object.create(null);
            Object.keys(env).forEach(function (key) { return newEnv[key] = env[key]; });
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath.join(separator) + separator + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath.join(separator);
            }
            try {
                var cp = child_process_1.fork(path.join(__dirname, 'resolve.js'), [], { env: newEnv, execArgv: [] });
                cp.on('message', function (message) {
                    if (message.command === 'resolve') {
                        var toRequire = moduleName;
                        if (message.success) {
                            toRequire = message.result;
                        }
                        cp.send({ command: 'exit' });
                        try {
                            c(require(toRequire));
                        }
                        catch (err) {
                            e(undefined);
                        }
                    }
                });
                var message = {
                    command: 'resolve',
                    args: moduleName
                };
                cp.send(message);
            }
            catch (error) {
                e(undefined);
            }
        });
    });
}
exports.resolveModule = resolveModule;
