/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var is = require('./is');
var messages_1 = require('./messages');
exports.ResponseError = messages_1.ResponseError;
exports.ErrorCodes = messages_1.ErrorCodes;
var messageReader_1 = require('./messageReader');
exports.StreamMessageReader = messageReader_1.StreamMessageReader;
exports.IPCMessageReader = messageReader_1.IPCMessageReader;
var messageWriter_1 = require('./messageWriter');
exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
function createMessageConnection(messageReader, messageWriter, logger, client) {
    if (client === void 0) { client = false; }
    var sequenceNumber = 0;
    var version = '2.0';
    var requestHandlers = Object.create(null);
    var responseHandlers = Object.create(null);
    var eventHandlers = Object.create(null);
    function handleRequest(requestMessage) {
        function reply(resultOrError) {
            var message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = is.undefined(resultOrError) ? null : resultOrError;
            }
            messageWriter.write(message);
        }
        function replyError(error) {
            var message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            messageWriter.write(message);
        }
        function replySuccess(result) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (is.undefined(result)) {
                result = null;
            }
            var message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            messageWriter.write(message);
        }
        var requestHandler = requestHandlers[requestMessage.method];
        if (requestHandler) {
            try {
                var handlerResult = requestHandler(requestMessage.params);
                var promise = handlerResult;
                if (!handlerResult) {
                    replySuccess(handlerResult);
                }
                else if (promise.then) {
                    promise.then(function (resultOrError) {
                        reply(resultOrError);
                    }, function (error) {
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error);
                        }
                        else if (error && is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed with message: " + error.message));
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed unexpectedly without providing any details."));
                        }
                    });
                }
                else {
                    reply(handlerResult);
                }
            }
            catch (error) {
                if (error instanceof messages_1.ResponseError) {
                    reply(error);
                }
                else if (error && is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed with message: " + error.message));
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed unexpectedly without providing any details."));
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, "Unhandled method " + requestMessage.method));
        }
    }
    function handleResponse(responseMessage) {
        var key = String(responseMessage.id);
        var responseHandler = responseHandlers[key];
        if (responseHandler) {
            try {
                if (is.defined(responseMessage.error)) {
                    responseHandler.reject(responseMessage.error);
                }
                else if (is.defined(responseMessage.result)) {
                    responseHandler.resolve(responseMessage.result);
                }
                else {
                    throw new Error('Should never happen.');
                }
                delete responseHandlers[key];
            }
            catch (error) {
                if (error.message) {
                    logger.error("Response handler '" + responseHandler.method + "' failed with message: " + error.message);
                }
                else {
                    logger.error("Response handler '" + responseHandler.method + "' failed unexpectedly.");
                }
            }
        }
    }
    function handleNotification(message) {
        var eventHandler = eventHandlers[message.method];
        if (eventHandler) {
            try {
                eventHandler(message.params);
            }
            catch (error) {
                if (error.message) {
                    logger.error("Notification handler '" + message.method + "' failed with message: " + error.message);
                }
                else {
                    logger.error("Notification handler '" + message.method + "' failed unexpectedly.");
                }
            }
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error("Recevied message which is neither a response nor a notification message:\n" + JSON.stringify(message, null, 4));
        // Test whether we find an id to reject the promise
        var responseMessage = message;
        if (is.string(responseMessage.id) || is.number(responseMessage.id)) {
            var key = String(responseMessage.id);
            var responseHandler = responseHandlers[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    var callback = function (message) {
        if (messages_1.isRequestMessage(message)) {
            handleRequest(message);
        }
        else if (messages_1.isReponseMessage(message)) {
            handleResponse(message);
        }
        else if (messages_1.isNotificationMessage(message)) {
            handleNotification(message);
        }
        else {
            handleInvalidMessage(message);
        }
    };
    var connection = {
        sendNotification: function (type, params) {
            var notificatioMessage = {
                jsonrpc: version,
                method: type.method,
                params: params
            };
            messageWriter.write(notificatioMessage);
        },
        onNotification: function (type, handler) {
            eventHandlers[type.method] = handler;
        },
        sendRequest: function (type, params) {
            return new Promise(function (resolve, reject) {
                var id = sequenceNumber++;
                var requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: type.method,
                    params: params
                };
                responseHandlers[String(id)] = { method: type.method, resolve: resolve, reject: reject };
                messageWriter.write(requestMessage);
            });
        },
        onRequest: function (type, handler) {
            requestHandlers[type.method] = handler;
        },
        dispose: function () {
        },
        listen: function () {
            messageReader.listen(callback);
        }
    };
    return connection;
}
function isMessageReader(value) {
    return is.defined(value.listen) && is.undefined(value.read);
}
function isMessageWriter(value) {
    return is.defined(value.write) && is.undefined(value.end);
}
function createServerMessageConnection(input, output, logger) {
    var reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    var writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return createMessageConnection(reader, writer, logger);
}
exports.createServerMessageConnection = createServerMessageConnection;
function createClientMessageConnection(input, output, logger) {
    var reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
    var writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
    return createMessageConnection(reader, writer, logger, true);
}
exports.createClientMessageConnection = createClientMessageConnection;
